<?xml version="1.0" encoding="UTF-8"?>
<robot rpa="false" generated="20190402 05:34:55.920" generator="Robot 3.1.1 (Python 2.7.15 on linux2)">
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Provision-Containers.robot" id="s1" name="Provision-Containers">
<kw type="setup" name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Utils.Stx Suite Setup</arg>
<arg>provisioning.Assign Data Interfaces</arg>
</arguments>
<kw name="Stx Suite Setup" library="Utils">
<doc>Wrapper to setup the environment needed for exercise
StarlingX features</doc>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190402 05:34:56.062" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 05:34:56.062" starttime="20190402 05:34:56.061"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190402 05:34:56.062" level="INFO">Length is 10</msg>
<msg timestamp="20190402 05:34:56.062" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190402 05:34:56.062" starttime="20190402 05:34:56.062"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190402 05:34:56.063" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190402 05:34:57.180" level="INFO">Read output: Last login: Tue Apr  2 10:03:40 2019
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<msg timestamp="20190402 05:34:57.181" level="INFO">/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:39: CryptographyDeprecationWarning: encode_point has been deprecated on EllipticCurvePublicNumbers and will be removed in a future version. Please use EllipticCurvePublicKey.public_bytes to obtain both compressed and uncompressed point encoding.
  m.add_string(self.Q_C.public_numbers().encode_point())
/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:96: CryptographyDeprecationWarning: Support for unsafe construction of public numbers from encoded data will be removed in a future version. Please use EllipticCurvePublicKey.from_encoded_point
  self.curve, Q_S_bytes
/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:111: CryptographyDeprecationWarning: encode_point has been deprecated on EllipticCurvePublicNumbers and will be removed in a future version. Please use EllipticCurvePublicKey.public_bytes to obtain both compressed and uncompressed point encoding.
  hm.add_string(self.Q_C.public_numbers().encode_point())</msg>
<status status="PASS" endtime="20190402 05:34:57.181" starttime="20190402 05:34:56.063"></status>
</kw>
<msg timestamp="20190402 05:34:57.182" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190402 05:34:57.182" starttime="20190402 05:34:56.063"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:57.182" starttime="20190402 05:34:56.062"></status>
</kw>
<msg timestamp="20190402 05:34:57.183" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 05:34:57.183" starttime="20190402 05:34:56.061"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190402 05:34:57.185" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 05:34:57.185" starttime="20190402 05:34:57.184"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190402 05:34:57.186" level="INFO">1</msg>
<status status="PASS" endtime="20190402 05:34:57.186" starttime="20190402 05:34:57.185"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:57.186" starttime="20190402 05:34:56.061"></status>
</kw>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:57.190" starttime="20190402 05:34:57.189"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:34:57.193" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:34:57.193" starttime="20190402 05:34:57.191"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:57.194" starttime="20190402 05:34:57.193"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:57.195" starttime="20190402 05:34:57.195"></status>
</kw>
<msg timestamp="20190402 05:34:57.196" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:34:57.196" starttime="20190402 05:34:57.190"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190402 05:34:57.197" starttime="20190402 05:34:57.196"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:34:57.203" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:34:57.203" starttime="20190402 05:34:57.197"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:34:57.598" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:34:57.598" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:34:57.598" starttime="20190402 05:34:57.203"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:34:57.599" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:34:57.599" starttime="20190402 05:34:57.599"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:34:57.599" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190402 05:34:57.599" starttime="20190402 05:34:57.599"></status>
</kw>
<msg timestamp="20190402 05:34:57.600" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190402 05:34:57.600" starttime="20190402 05:34:57.598"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:34:57.601" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:34:57.602" starttime="20190402 05:34:57.600"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:34:57.602" level="INFO">0</msg>
<msg timestamp="20190402 05:34:57.602" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:34:57.602" starttime="20190402 05:34:57.602"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:34:57.603" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:34:57.603" starttime="20190402 05:34:57.602"></status>
</kw>
<msg timestamp="20190402 05:34:57.603" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:34:57.603" starttime="20190402 05:34:57.600"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:57.604" starttime="20190402 05:34:57.603"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:57.604" starttime="20190402 05:34:57.603"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:57.604" starttime="20190402 05:34:57.604"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:34:57.604" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190402 05:34:57.604" starttime="20190402 05:34:57.604"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:57.604" starttime="20190402 05:34:57.187"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:57.604" starttime="20190402 05:34:57.187"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:57.605" starttime="20190402 05:34:56.060"></status>
</kw>
<kw name="Assign Data Interfaces" library="provisioning">
<doc>Set variables for Data interfaces according to the
configuration selected</doc>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${ENVIRONMENT}'=='virtual'</arg>
<arg>Create List</arg>
<arg>eth1000</arg>
<arg>eth1001</arg>
<arg>ELSE</arg>
<arg>Create List</arg>
<arg>enp24s0f0</arg>
<arg>enp24s0f1</arg>
</arguments>
<assign>
<var>@{data_interfaces}</var>
</assign>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<arguments>
<arg>enp24s0f0</arg>
<arg>enp24s0f1</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:57.605" starttime="20190402 05:34:57.605"></status>
</kw>
<msg timestamp="20190402 05:34:57.605" level="INFO">@{data_interfaces} = [ enp24s0f0 | enp24s0f1 ]</msg>
<status status="PASS" endtime="20190402 05:34:57.605" starttime="20190402 05:34:57.605"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${data_interfaces}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data0if}</var>
</assign>
<msg timestamp="20190402 05:34:57.606" level="INFO">${data0if} = enp24s0f0</msg>
<status status="PASS" endtime="20190402 05:34:57.606" starttime="20190402 05:34:57.606"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${data_interfaces}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data1if}</var>
</assign>
<msg timestamp="20190402 05:34:57.606" level="INFO">${data1if} = enp24s0f1</msg>
<status status="PASS" endtime="20190402 05:34:57.606" starttime="20190402 05:34:57.606"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${data0if}</arg>
</arguments>
<msg timestamp="20190402 05:34:57.607" level="INFO">${data0if} = enp24s0f0</msg>
<status status="PASS" endtime="20190402 05:34:57.607" starttime="20190402 05:34:57.606"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${data1if}</arg>
</arguments>
<msg timestamp="20190402 05:34:57.607" level="INFO">${data1if} = enp24s0f1</msg>
<status status="PASS" endtime="20190402 05:34:57.607" starttime="20190402 05:34:57.607"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:57.607" starttime="20190402 05:34:57.605"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:57.607" starttime="20190402 05:34:56.060"></status>
</kw>
<test id="s1-t1" name="Provisioning Duplex System">
<kw name="Set NTP Server" library="Utils">
<doc>Setup the NTP servers for the system.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>0.pool.ntp.org,1.pool.ntp.org</arg>
</arguments>
<assign>
<var>${ntp_servers}</var>
</assign>
<msg timestamp="20190402 05:34:57.608" level="INFO">${ntp_servers} = 0.pool.ntp.org,1.pool.ntp.org</msg>
<status status="PASS" endtime="20190402 05:34:57.608" starttime="20190402 05:34:57.608"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system ntp-modify ntpservers=${ntp_servers}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:57.609" starttime="20190402 05:34:57.609"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:34:57.610" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:34:57.610" starttime="20190402 05:34:57.609"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:57.610" starttime="20190402 05:34:57.610"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:57.610" starttime="20190402 05:34:57.610"></status>
</kw>
<msg timestamp="20190402 05:34:57.610" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:34:57.610" starttime="20190402 05:34:57.609"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:34:57.611" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:34:57.611" starttime="20190402 05:34:57.611"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:34:57.620" level="INFO">system ntp-modify ntpservers=0.pool.nt p.org,1.pool.ntp.org</msg>
<status status="PASS" endtime="20190402 05:34:57.620" starttime="20190402 05:34:57.611"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:34:58.834" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| uuid         | 75981062-d688-4d6d-b1b2-32887c1200db |
| enabled      | True                                 |
| ntpservers   | 0.pool.ntp.org,1.pool.ntp.org        |
| isystem_uuid | 76ce9d91-d770-4f94-85b0-7eebb135973e |
| created_at   | 2019-04-02T10:06:08.063839+00:00     |
| updated_at   | None                                 |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:34:58.834" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| uuid         | 75981062-d68...</msg>
<status status="PASS" endtime="20190402 05:34:58.834" starttime="20190402 05:34:57.620"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:34:58.835" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:34:58.835" starttime="20190402 05:34:58.834"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:34:58.835" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| uuid         | 75981062-d68...</msg>
<status status="PASS" endtime="20190402 05:34:58.835" starttime="20190402 05:34:58.835"></status>
</kw>
<msg timestamp="20190402 05:34:58.835" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| uuid         | 75981062-d68...</msg>
<status status="PASS" endtime="20190402 05:34:58.835" starttime="20190402 05:34:58.834"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:34:58.837" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:34:58.837" starttime="20190402 05:34:58.835"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:34:58.838" level="INFO">0</msg>
<msg timestamp="20190402 05:34:58.838" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:34:58.838" starttime="20190402 05:34:58.837"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:34:58.838" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:34:58.838" starttime="20190402 05:34:58.838"></status>
</kw>
<msg timestamp="20190402 05:34:58.838" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:34:58.838" starttime="20190402 05:34:58.835"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:58.839" starttime="20190402 05:34:58.839"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:58.839" starttime="20190402 05:34:58.838"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:58.839" starttime="20190402 05:34:58.839"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:34:58.840" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| uuid         | 75981062-d688-4d6d-b1b2-32887c1200db |
| enabled      | True                                 |
| ntpservers   | 0.pool.ntp.org,1.pool.ntp.org        |
| isystem_uuid | 76ce9d91-d770-4f94-85b0-7eebb135973e |
| created_at   | 2019-04-02T10:06:08.063839+00:00     |
| updated_at   | None                                 |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:34:58.840" starttime="20190402 05:34:58.840"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:58.840" starttime="20190402 05:34:57.608"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:58.840" starttime="20190402 05:34:57.608"></status>
</kw>
<kw name="Configure Data Interfaces" library="Utils">
<doc>Configure data interfaces with proper values.</doc>
<arguments>
<arg>${master_controller}</arg>
<arg>${data0if}</arg>
<arg>${data1if}</arg>
<arg>${physnet0}</arg>
<arg>${physnet1}</arg>
<arg>${mtu}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>Run Keywords</arg>
<arg>Provide OAM Network Interface</arg>
<arg>${host}</arg>
<arg>AND</arg>
<arg>Setup Cluster-host Interfaces</arg>
<arg>${host}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:58.841" starttime="20190402 05:34:58.841"></status>
</kw>
<kw name="Get Interface Information" library="Utils">
<doc>Returns a dictionary with the values of the spcecified
interface.</doc>
<arguments>
<arg>${host}</arg>
<arg>${data0if}</arg>
</arguments>
<assign>
<var>${iface_info}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-port-list ${host} --nowrap</arg>
<arg>grep ${interface}</arg>
<arg>awk '{ print $2,$4,$8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 05:34:58.842" level="INFO">${cmd} = system host-port-list controller-0 --nowrap|grep enp24s0f0|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190402 05:34:58.842" starttime="20190402 05:34:58.841"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:58.842" starttime="20190402 05:34:58.842"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:34:58.843" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:34:58.843" starttime="20190402 05:34:58.843"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:58.843" starttime="20190402 05:34:58.843"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:58.844" starttime="20190402 05:34:58.844"></status>
</kw>
<msg timestamp="20190402 05:34:58.844" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:34:58.844" starttime="20190402 05:34:58.842"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:34:58.844" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:34:58.844" starttime="20190402 05:34:58.844"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:34:58.855" level="INFO">system host-port-list controller-0 --n owrap|grep enp24s0f0|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190402 05:34:58.856" starttime="20190402 05:34:58.844"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:34:59.934" level="INFO">6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6 enp24s0f0 0000:18:00.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:34:59.934" level="INFO">${output} = 6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6 enp24s0f0 0000:18:00.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:34:59.934" starttime="20190402 05:34:58.856"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:34:59.935" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:34:59.935" starttime="20190402 05:34:59.934"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:34:59.935" level="INFO">${clean_out} = 6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6 enp24s0f0 0000:18:00.0
</msg>
<status status="PASS" endtime="20190402 05:34:59.935" starttime="20190402 05:34:59.935"></status>
</kw>
<msg timestamp="20190402 05:34:59.935" level="INFO">${output} = 6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6 enp24s0f0 0000:18:00.0
</msg>
<status status="PASS" endtime="20190402 05:34:59.935" starttime="20190402 05:34:59.934"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:34:59.937" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:34:59.937" starttime="20190402 05:34:59.936"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:34:59.937" level="INFO">0</msg>
<msg timestamp="20190402 05:34:59.937" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:34:59.938" starttime="20190402 05:34:59.937"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:34:59.938" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:34:59.938" starttime="20190402 05:34:59.938"></status>
</kw>
<msg timestamp="20190402 05:34:59.938" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:34:59.938" starttime="20190402 05:34:59.935"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:59.939" starttime="20190402 05:34:59.939"></status>
</kw>
<status status="PASS" endtime="20190402 05:34:59.939" starttime="20190402 05:34:59.938"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:59.939" starttime="20190402 05:34:59.939"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:34:59.939" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6 enp24s0f0 0000:18:00.0</msg>
<status status="PASS" endtime="20190402 05:34:59.940" starttime="20190402 05:34:59.939"></status>
</kw>
<msg timestamp="20190402 05:34:59.940" level="INFO">${info} = {u'stdout': u'6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6 enp24s0f0 0000:18:00.0', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:34:59.940" starttime="20190402 05:34:58.842"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${info}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190402 05:34:59.940" level="INFO">${response} = 6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6 enp24s0f0 0000:18:00.0</msg>
<status status="PASS" endtime="20190402 05:34:59.940" starttime="20190402 05:34:59.940"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190402 05:34:59.941" level="INFO">@{res_in_list} = [ 6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6 | enp24s0f0 | 0000:18:00.0 ]</msg>
<status status="PASS" endtime="20190402 05:34:59.941" starttime="20190402 05:34:59.940"></status>
</kw>
<msg timestamp="20190402 05:34:59.941" level="INFO">${info} = [u'6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6', u'enp24s0f0', u'0000:18:00.0']</msg>
<status status="PASS" endtime="20190402 05:34:59.941" starttime="20190402 05:34:59.940"></status>
</kw>
<msg timestamp="20190402 05:34:59.941" level="INFO">${iface_info} = [u'6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6', u'enp24s0f0', u'0000:18:00.0']</msg>
<status status="PASS" endtime="20190402 05:34:59.941" starttime="20190402 05:34:58.841"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data0portuuid}</var>
</assign>
<msg timestamp="20190402 05:34:59.941" level="INFO">${data0portuuid} = 6ef9bf2a-1a6f-4d1e-8890-3f621879b8f6</msg>
<status status="PASS" endtime="20190402 05:34:59.941" starttime="20190402 05:34:59.941"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data0portname}</var>
</assign>
<msg timestamp="20190402 05:34:59.942" level="INFO">${data0portname} = enp24s0f0</msg>
<status status="PASS" endtime="20190402 05:34:59.942" starttime="20190402 05:34:59.941"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>2</arg>
</arguments>
<assign>
<var>${data0pciaddr}</var>
</assign>
<msg timestamp="20190402 05:34:59.942" level="INFO">${data0pciaddr} = 0000:18:00.0</msg>
<status status="PASS" endtime="20190402 05:34:59.942" starttime="20190402 05:34:59.942"></status>
</kw>
<kw name="Get Interface Information" library="Utils">
<doc>Returns a dictionary with the values of the spcecified
interface.</doc>
<arguments>
<arg>${host}</arg>
<arg>${data1if}</arg>
</arguments>
<assign>
<var>${iface_info}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-port-list ${host} --nowrap</arg>
<arg>grep ${interface}</arg>
<arg>awk '{ print $2,$4,$8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 05:34:59.943" level="INFO">${cmd} = system host-port-list controller-0 --nowrap|grep enp24s0f1|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190402 05:34:59.943" starttime="20190402 05:34:59.943"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:59.944" starttime="20190402 05:34:59.943"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:34:59.944" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:34:59.944" starttime="20190402 05:34:59.944"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:59.945" starttime="20190402 05:34:59.944"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:34:59.945" starttime="20190402 05:34:59.945"></status>
</kw>
<msg timestamp="20190402 05:34:59.945" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:34:59.945" starttime="20190402 05:34:59.944"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:34:59.945" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:34:59.946" starttime="20190402 05:34:59.945"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:34:59.958" level="INFO">system host-port-list controller-0 --n owrap|grep enp24s0f1|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190402 05:34:59.958" starttime="20190402 05:34:59.946"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:01.099" level="INFO">8f070dfb-c440-470d-82d3-8f5f52d7c2a4 enp24s0f1 0000:18:00.1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:01.099" level="INFO">${output} = 8f070dfb-c440-470d-82d3-8f5f52d7c2a4 enp24s0f1 0000:18:00.1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:01.099" starttime="20190402 05:34:59.958"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:01.100" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:01.100" starttime="20190402 05:35:01.099"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:01.100" level="INFO">${clean_out} = 8f070dfb-c440-470d-82d3-8f5f52d7c2a4 enp24s0f1 0000:18:00.1
</msg>
<status status="PASS" endtime="20190402 05:35:01.100" starttime="20190402 05:35:01.100"></status>
</kw>
<msg timestamp="20190402 05:35:01.100" level="INFO">${output} = 8f070dfb-c440-470d-82d3-8f5f52d7c2a4 enp24s0f1 0000:18:00.1
</msg>
<status status="PASS" endtime="20190402 05:35:01.100" starttime="20190402 05:35:01.099"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:01.102" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:01.102" starttime="20190402 05:35:01.100"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:01.103" level="INFO">0</msg>
<msg timestamp="20190402 05:35:01.103" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:01.103" starttime="20190402 05:35:01.102"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:01.103" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:01.103" starttime="20190402 05:35:01.103"></status>
</kw>
<msg timestamp="20190402 05:35:01.104" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:01.104" starttime="20190402 05:35:01.100"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:01.104" starttime="20190402 05:35:01.104"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:01.104" starttime="20190402 05:35:01.104"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:01.105" starttime="20190402 05:35:01.104"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:01.105" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 8f070dfb-c440-470d-82d3-8f5f52d7c2a4 enp24s0f1 0000:18:00.1</msg>
<status status="PASS" endtime="20190402 05:35:01.105" starttime="20190402 05:35:01.105"></status>
</kw>
<msg timestamp="20190402 05:35:01.105" level="INFO">${info} = {u'stdout': u'8f070dfb-c440-470d-82d3-8f5f52d7c2a4 enp24s0f1 0000:18:00.1', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:35:01.105" starttime="20190402 05:34:59.943"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${info}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190402 05:35:01.106" level="INFO">${response} = 8f070dfb-c440-470d-82d3-8f5f52d7c2a4 enp24s0f1 0000:18:00.1</msg>
<status status="PASS" endtime="20190402 05:35:01.106" starttime="20190402 05:35:01.106"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190402 05:35:01.106" level="INFO">@{res_in_list} = [ 8f070dfb-c440-470d-82d3-8f5f52d7c2a4 | enp24s0f1 | 0000:18:00.1 ]</msg>
<status status="PASS" endtime="20190402 05:35:01.106" starttime="20190402 05:35:01.106"></status>
</kw>
<msg timestamp="20190402 05:35:01.106" level="INFO">${info} = [u'8f070dfb-c440-470d-82d3-8f5f52d7c2a4', u'enp24s0f1', u'0000:18:00.1']</msg>
<status status="PASS" endtime="20190402 05:35:01.106" starttime="20190402 05:35:01.105"></status>
</kw>
<msg timestamp="20190402 05:35:01.106" level="INFO">${iface_info} = [u'8f070dfb-c440-470d-82d3-8f5f52d7c2a4', u'enp24s0f1', u'0000:18:00.1']</msg>
<status status="PASS" endtime="20190402 05:35:01.106" starttime="20190402 05:34:59.942"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data1portuuid}</var>
</assign>
<msg timestamp="20190402 05:35:01.107" level="INFO">${data1portuuid} = 8f070dfb-c440-470d-82d3-8f5f52d7c2a4</msg>
<status status="PASS" endtime="20190402 05:35:01.107" starttime="20190402 05:35:01.107"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data1portname}</var>
</assign>
<msg timestamp="20190402 05:35:01.107" level="INFO">${data1portname} = enp24s0f1</msg>
<status status="PASS" endtime="20190402 05:35:01.107" starttime="20190402 05:35:01.107"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>2</arg>
</arguments>
<assign>
<var>${data1pciaddr}</var>
</assign>
<msg timestamp="20190402 05:35:01.108" level="INFO">${data1pciaddr} = 0000:18:00.1</msg>
<status status="PASS" endtime="20190402 05:35:01.108" starttime="20190402 05:35:01.107"></status>
</kw>
<kw name="Get Interface UUID" library="Utils">
<doc>Get Interface id of the specified host and port</doc>
<arguments>
<arg>${host}</arg>
<arg>${data0portname}</arg>
</arguments>
<assign>
<var>${data0ifuuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-if-list -a ${host}</arg>
<arg>grep ${port_name}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 05:35:01.108" level="INFO">${cmd} = system host-if-list -a controller-0|grep enp24s0f0|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 05:35:01.108" starttime="20190402 05:35:01.108"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${uuid}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:01.109" starttime="20190402 05:35:01.109"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:01.110" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:01.110" starttime="20190402 05:35:01.109"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:01.110" starttime="20190402 05:35:01.110"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:01.110" starttime="20190402 05:35:01.110"></status>
</kw>
<msg timestamp="20190402 05:35:01.111" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:01.111" starttime="20190402 05:35:01.109"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:01.111" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:01.111" starttime="20190402 05:35:01.111"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:01.120" level="INFO">system host-if-list -a controller-0|gr ep enp24s0f0|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 05:35:01.120" starttime="20190402 05:35:01.111"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:02.283" level="INFO">c22463b6-2fe0-479e-b810-8ece7e444a4f
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:02.284" level="INFO">${output} = c22463b6-2fe0-479e-b810-8ece7e444a4f
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:02.284" starttime="20190402 05:35:01.120"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:02.284" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:02.284" starttime="20190402 05:35:02.284"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:02.285" level="INFO">${clean_out} = c22463b6-2fe0-479e-b810-8ece7e444a4f
</msg>
<status status="PASS" endtime="20190402 05:35:02.285" starttime="20190402 05:35:02.285"></status>
</kw>
<msg timestamp="20190402 05:35:02.285" level="INFO">${output} = c22463b6-2fe0-479e-b810-8ece7e444a4f
</msg>
<status status="PASS" endtime="20190402 05:35:02.285" starttime="20190402 05:35:02.284"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:02.287" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:02.287" starttime="20190402 05:35:02.285"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:02.287" level="INFO">0</msg>
<msg timestamp="20190402 05:35:02.287" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:02.287" starttime="20190402 05:35:02.287"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:02.288" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:02.288" starttime="20190402 05:35:02.288"></status>
</kw>
<msg timestamp="20190402 05:35:02.288" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:02.288" starttime="20190402 05:35:02.285"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:02.289" starttime="20190402 05:35:02.288"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:02.289" starttime="20190402 05:35:02.288"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:02.289" starttime="20190402 05:35:02.289"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:02.289" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: c22463b6-2fe0-479e-b810-8ece7e444a4f</msg>
<status status="PASS" endtime="20190402 05:35:02.289" starttime="20190402 05:35:02.289"></status>
</kw>
<msg timestamp="20190402 05:35:02.289" level="INFO">${uuid} = {u'stdout': u'c22463b6-2fe0-479e-b810-8ece7e444a4f', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:35:02.289" starttime="20190402 05:35:01.108"></status>
</kw>
<msg timestamp="20190402 05:35:02.290" level="INFO">${data0ifuuid} = c22463b6-2fe0-479e-b810-8ece7e444a4f</msg>
<status status="PASS" endtime="20190402 05:35:02.290" starttime="20190402 05:35:01.108"></status>
</kw>
<kw name="Get Interface UUID" library="Utils">
<doc>Get Interface id of the specified host and port</doc>
<arguments>
<arg>${host}</arg>
<arg>${data1portname}</arg>
</arguments>
<assign>
<var>${data1ifuuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-if-list -a ${host}</arg>
<arg>grep ${port_name}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 05:35:02.290" level="INFO">${cmd} = system host-if-list -a controller-0|grep enp24s0f1|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 05:35:02.290" starttime="20190402 05:35:02.290"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${uuid}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:02.292" starttime="20190402 05:35:02.292"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:02.293" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:02.293" starttime="20190402 05:35:02.292"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:02.293" starttime="20190402 05:35:02.293"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:02.293" starttime="20190402 05:35:02.293"></status>
</kw>
<msg timestamp="20190402 05:35:02.293" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:02.294" starttime="20190402 05:35:02.292"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:02.294" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:02.294" starttime="20190402 05:35:02.294"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:02.304" level="INFO">system host-if-list -a controller-0|gr ep enp24s0f1|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 05:35:02.304" starttime="20190402 05:35:02.294"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:03.464" level="INFO">f623786d-bcad-4598-90c5-723841b5f6c9
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:03.464" level="INFO">${output} = f623786d-bcad-4598-90c5-723841b5f6c9
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:03.464" starttime="20190402 05:35:02.304"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:03.465" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:03.465" starttime="20190402 05:35:03.464"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:03.465" level="INFO">${clean_out} = f623786d-bcad-4598-90c5-723841b5f6c9
</msg>
<status status="PASS" endtime="20190402 05:35:03.465" starttime="20190402 05:35:03.465"></status>
</kw>
<msg timestamp="20190402 05:35:03.465" level="INFO">${output} = f623786d-bcad-4598-90c5-723841b5f6c9
</msg>
<status status="PASS" endtime="20190402 05:35:03.465" starttime="20190402 05:35:03.464"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:03.467" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:03.467" starttime="20190402 05:35:03.466"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:03.468" level="INFO">0</msg>
<msg timestamp="20190402 05:35:03.468" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:03.468" starttime="20190402 05:35:03.468"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:03.468" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:03.468" starttime="20190402 05:35:03.468"></status>
</kw>
<msg timestamp="20190402 05:35:03.469" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:03.469" starttime="20190402 05:35:03.465"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:03.469" starttime="20190402 05:35:03.469"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:03.469" starttime="20190402 05:35:03.469"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:03.470" starttime="20190402 05:35:03.469"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:03.470" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: f623786d-bcad-4598-90c5-723841b5f6c9</msg>
<status status="PASS" endtime="20190402 05:35:03.470" starttime="20190402 05:35:03.470"></status>
</kw>
<msg timestamp="20190402 05:35:03.470" level="INFO">${uuid} = {u'stdout': u'f623786d-bcad-4598-90c5-723841b5f6c9', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:35:03.470" starttime="20190402 05:35:02.291"></status>
</kw>
<msg timestamp="20190402 05:35:03.470" level="INFO">${data1ifuuid} = f623786d-bcad-4598-90c5-723841b5f6c9</msg>
<status status="PASS" endtime="20190402 05:35:03.470" starttime="20190402 05:35:02.290"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-0' or '${host}'=='compute-0'</arg>
<arg>Run Keywords</arg>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet0} vlan</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet1} vlan</arg>
<arg>True</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet0} vlan</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet1} vlan</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system datanetwork-add ${physnet0} vlan</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:03.472" starttime="20190402 05:35:03.471"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:03.472" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:03.472" starttime="20190402 05:35:03.472"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:03.473" starttime="20190402 05:35:03.472"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:03.473" starttime="20190402 05:35:03.473"></status>
</kw>
<msg timestamp="20190402 05:35:03.473" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:03.473" starttime="20190402 05:35:03.472"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:03.474" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:03.474" starttime="20190402 05:35:03.473"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:03.479" level="INFO">system datanetwork-add physnet0 vlan</msg>
<status status="PASS" endtime="20190402 05:35:03.479" starttime="20190402 05:35:03.474"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:04.500" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 1                                    |
| uuid         | 2e5088f2-a40d-4bce-a4d4-c567ba883e45 |
| name         | physnet0                             |
| network_type | vlan                                 |
| mtu          | 1500                                 |
| description  | None                                 |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:04.501" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 1           ...</msg>
<status status="PASS" endtime="20190402 05:35:04.501" starttime="20190402 05:35:03.480"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:04.501" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:04.502" starttime="20190402 05:35:04.501"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:04.502" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 1           ...</msg>
<status status="PASS" endtime="20190402 05:35:04.502" starttime="20190402 05:35:04.502"></status>
</kw>
<msg timestamp="20190402 05:35:04.502" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 1           ...</msg>
<status status="PASS" endtime="20190402 05:35:04.502" starttime="20190402 05:35:04.501"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:04.504" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:04.504" starttime="20190402 05:35:04.502"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:04.505" level="INFO">0</msg>
<msg timestamp="20190402 05:35:04.505" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:04.505" starttime="20190402 05:35:04.504"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:04.505" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:04.505" starttime="20190402 05:35:04.505"></status>
</kw>
<msg timestamp="20190402 05:35:04.505" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:04.505" starttime="20190402 05:35:04.502"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:04.506" starttime="20190402 05:35:04.506"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:04.506" starttime="20190402 05:35:04.505"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:04.506" starttime="20190402 05:35:04.506"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:04.507" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 1                                    |
| uuid         | 2e5088f2-a40d-4bce-a4d4-c567ba883e45 |
| name         | physnet0                             |
| network_type | vlan                                 |
| mtu          | 1500                                 |
| description  | None                                 |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:04.507" starttime="20190402 05:35:04.507"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:04.507" starttime="20190402 05:35:03.471"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system datanetwork-add ${physnet1} vlan</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:04.508" starttime="20190402 05:35:04.507"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:04.508" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:04.508" starttime="20190402 05:35:04.508"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:04.509" starttime="20190402 05:35:04.508"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:04.509" starttime="20190402 05:35:04.509"></status>
</kw>
<msg timestamp="20190402 05:35:04.509" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:04.509" starttime="20190402 05:35:04.508"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:04.509" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:04.510" starttime="20190402 05:35:04.509"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:04.515" level="INFO">system datanetwork-add physnet1 vlan</msg>
<status status="PASS" endtime="20190402 05:35:04.515" starttime="20190402 05:35:04.510"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:05.535" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 2                                    |
| uuid         | 7fac0e9e-15e4-4fc1-a050-56c6a42ebc6c |
| name         | physnet1                             |
| network_type | vlan                                 |
| mtu          | 1500                                 |
| description  | None                                 |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:05.536" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 2           ...</msg>
<status status="PASS" endtime="20190402 05:35:05.536" starttime="20190402 05:35:04.515"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:05.536" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:05.536" starttime="20190402 05:35:05.536"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:05.537" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 2           ...</msg>
<status status="PASS" endtime="20190402 05:35:05.537" starttime="20190402 05:35:05.536"></status>
</kw>
<msg timestamp="20190402 05:35:05.537" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 2           ...</msg>
<status status="PASS" endtime="20190402 05:35:05.537" starttime="20190402 05:35:05.536"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:05.539" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:05.539" starttime="20190402 05:35:05.537"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:05.540" level="INFO">0</msg>
<msg timestamp="20190402 05:35:05.540" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:05.540" starttime="20190402 05:35:05.539"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:05.540" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:05.540" starttime="20190402 05:35:05.540"></status>
</kw>
<msg timestamp="20190402 05:35:05.540" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:05.540" starttime="20190402 05:35:05.537"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:05.541" starttime="20190402 05:35:05.541"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:05.541" starttime="20190402 05:35:05.541"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:05.542" starttime="20190402 05:35:05.541"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:05.542" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 2                                    |
| uuid         | 7fac0e9e-15e4-4fc1-a050-56c6a42ebc6c |
| name         | physnet1                             |
| network_type | vlan                                 |
| mtu          | 1500                                 |
| description  | None                                 |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:05.542" starttime="20190402 05:35:05.542"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:05.542" starttime="20190402 05:35:04.507"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:05.542" starttime="20190402 05:35:03.471"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:05.542" starttime="20190402 05:35:03.471"></status>
</kw>
<kw name="Add Interface To Data Network" library="Utils">
<doc>Adds an interface to the specified data network.</doc>
<arguments>
<arg>${mtu}</arg>
<arg>data0</arg>
<arg>${physnet0}</arg>
<arg>${host}</arg>
<arg>${data0ifuuid}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controler-0'</arg>
<arg>-d</arg>
<arg>-p</arg>
</arguments>
<assign>
<var>${option}</var>
</assign>
<msg timestamp="20190402 05:35:05.543" level="INFO">${option} = -p</msg>
<status status="PASS" endtime="20190402 05:35:05.543" starttime="20190402 05:35:05.543"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system host-if-modify</arg>
<arg>-m ${mtu}</arg>
<arg>-n ${if_name}</arg>
<arg>${option} ${datanetwork}</arg>
<arg>-c data</arg>
<arg>${host}</arg>
<arg>${uuid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 05:35:05.543" level="INFO">${cmd} = system host-if-modify -m 1500 -n data0 -p physnet0 -c data controller-0 c22463b6-2fe0-479e-b810-8ece7e444a4f</msg>
<status status="PASS" endtime="20190402 05:35:05.543" starttime="20190402 05:35:05.543"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:05.544" starttime="20190402 05:35:05.544"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:05.545" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:05.545" starttime="20190402 05:35:05.544"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:05.545" starttime="20190402 05:35:05.545"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:05.545" starttime="20190402 05:35:05.545"></status>
</kw>
<msg timestamp="20190402 05:35:05.546" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:05.546" starttime="20190402 05:35:05.544"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:05.546" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:05.546" starttime="20190402 05:35:05.546"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:05.561" level="INFO">system host-if-modify -m 1500 -n data0  -p physnet0 -c data controller-0 c22463b6-2fe0-479e-b810-8ece7e444a4f</msg>
<status status="PASS" endtime="20190402 05:35:05.561" starttime="20190402 05:35:05.546"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:07.132" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f0']                       |
| datanetworks | [u'physnet0']                        |
| imac         | 3c:fd:fe:be:e0:cc                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | c22463b6-2fe0-479e-b810-8ece7e444a4f |
| ihost_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T10:06:57.909474+00:00     |
| updated_at   | 2019-04-02T11:23:50.874925+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:07.132" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190402 05:35:07.132" starttime="20190402 05:35:05.561"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:07.133" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:07.133" starttime="20190402 05:35:07.133"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:07.134" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190402 05:35:07.134" starttime="20190402 05:35:07.133"></status>
</kw>
<msg timestamp="20190402 05:35:07.134" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190402 05:35:07.134" starttime="20190402 05:35:07.133"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:07.136" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:07.136" starttime="20190402 05:35:07.134"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:07.136" level="INFO">0</msg>
<msg timestamp="20190402 05:35:07.136" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:07.136" starttime="20190402 05:35:07.136"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:07.137" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:07.137" starttime="20190402 05:35:07.136"></status>
</kw>
<msg timestamp="20190402 05:35:07.137" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:07.137" starttime="20190402 05:35:07.134"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:07.138" starttime="20190402 05:35:07.137"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:07.138" starttime="20190402 05:35:07.137"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:07.138" starttime="20190402 05:35:07.138"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:07.138" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f0']                       |
| datanetworks | [u'physnet0']                        |
| imac         | 3c:fd:fe:be:e0:cc                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | c22463b6-2fe0-479e-b810-8ece7e444a4f |
| ihost_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T10:06:57.909474+00:00     |
| updated_at   | 2019-04-02T11:23:50.874925+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:07.138" starttime="20190402 05:35:07.138"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:07.139" starttime="20190402 05:35:05.543"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:07.139" starttime="20190402 05:35:05.542"></status>
</kw>
<kw name="Add Interface To Data Network" library="Utils">
<doc>Adds an interface to the specified data network.</doc>
<arguments>
<arg>${mtu}</arg>
<arg>data1</arg>
<arg>${physnet1}</arg>
<arg>${host}</arg>
<arg>${data1ifuuid}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controler-0'</arg>
<arg>-d</arg>
<arg>-p</arg>
</arguments>
<assign>
<var>${option}</var>
</assign>
<msg timestamp="20190402 05:35:07.139" level="INFO">${option} = -p</msg>
<status status="PASS" endtime="20190402 05:35:07.139" starttime="20190402 05:35:07.139"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system host-if-modify</arg>
<arg>-m ${mtu}</arg>
<arg>-n ${if_name}</arg>
<arg>${option} ${datanetwork}</arg>
<arg>-c data</arg>
<arg>${host}</arg>
<arg>${uuid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 05:35:07.140" level="INFO">${cmd} = system host-if-modify -m 1500 -n data1 -p physnet1 -c data controller-0 f623786d-bcad-4598-90c5-723841b5f6c9</msg>
<status status="PASS" endtime="20190402 05:35:07.140" starttime="20190402 05:35:07.139"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:07.141" starttime="20190402 05:35:07.140"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:07.141" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:07.141" starttime="20190402 05:35:07.141"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:07.142" starttime="20190402 05:35:07.141"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:07.142" starttime="20190402 05:35:07.142"></status>
</kw>
<msg timestamp="20190402 05:35:07.142" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:07.142" starttime="20190402 05:35:07.141"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:07.142" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:07.142" starttime="20190402 05:35:07.142"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:07.158" level="INFO">system host-if-modify -m 1500 -n data1  -p physnet1 -c data controller-0 f623786d-bcad-4598-90c5-723841b5f6c9</msg>
<status status="PASS" endtime="20190402 05:35:07.158" starttime="20190402 05:35:07.142"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:08.725" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f1']                       |
| datanetworks | [u'physnet1']                        |
| imac         | 3c:fd:fe:be:e0:cd                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | f623786d-bcad-4598-90c5-723841b5f6c9 |
| ihost_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T10:06:58.001956+00:00     |
| updated_at   | 2019-04-02T11:23:52.456743+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:08.725" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190402 05:35:08.725" starttime="20190402 05:35:07.158"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:08.726" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:08.726" starttime="20190402 05:35:08.726"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:08.726" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190402 05:35:08.727" starttime="20190402 05:35:08.726"></status>
</kw>
<msg timestamp="20190402 05:35:08.727" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190402 05:35:08.727" starttime="20190402 05:35:08.726"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:08.729" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:08.729" starttime="20190402 05:35:08.727"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:08.729" level="INFO">0</msg>
<msg timestamp="20190402 05:35:08.729" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:08.729" starttime="20190402 05:35:08.729"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:08.730" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:08.730" starttime="20190402 05:35:08.730"></status>
</kw>
<msg timestamp="20190402 05:35:08.730" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:08.730" starttime="20190402 05:35:08.727"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:08.731" starttime="20190402 05:35:08.730"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:08.731" starttime="20190402 05:35:08.730"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:08.731" starttime="20190402 05:35:08.731"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:08.731" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f1']                       |
| datanetworks | [u'physnet1']                        |
| imac         | 3c:fd:fe:be:e0:cd                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | f623786d-bcad-4598-90c5-723841b5f6c9 |
| ihost_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T10:06:58.001956+00:00     |
| updated_at   | 2019-04-02T11:23:52.456743+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:08.731" starttime="20190402 05:35:08.731"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:08.732" starttime="20190402 05:35:07.140"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:08.732" starttime="20190402 05:35:07.139"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:08.732" starttime="20190402 05:34:58.840"></status>
</kw>
<kw name="Enable Containerized Services" library="Utils">
<doc>apply all the node labels for each controller
and compute functions.</doc>
<arguments>
<arg>${master_controller}</arg>
</arguments>
<kw name="Evaluate" library="BuiltIn">
<doc>Evaluates the given expression in Python and returns the results.</doc>
<arguments>
<arg>"controller" in """${host}"""</arg>
</arguments>
<assign>
<var>${is_controller}</var>
</assign>
<msg timestamp="20190402 05:35:08.732" level="INFO">${is_controller} = True</msg>
<status status="PASS" endtime="20190402 05:35:08.732" starttime="20190402 05:35:08.732"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-control-plane=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openstack-control-plane=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:08.734" starttime="20190402 05:35:08.733"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:08.734" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:08.734" starttime="20190402 05:35:08.734"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:08.735" starttime="20190402 05:35:08.734"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:08.735" starttime="20190402 05:35:08.735"></status>
</kw>
<msg timestamp="20190402 05:35:08.735" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:08.735" starttime="20190402 05:35:08.734"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:08.735" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:08.735" starttime="20190402 05:35:08.735"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:08.747" level="INFO">system host-label-assign controller-0  openstack-control-plane=enabled</msg>
<status status="PASS" endtime="20190402 05:35:08.747" starttime="20190402 05:35:08.736"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:09.839" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 8bd90126-04f1-437e-ad77-37e81fc2baf6 |
| host_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| label_key   | openstack-control-plane              |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:09.840" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 8bd90126-04f1-43...</msg>
<status status="PASS" endtime="20190402 05:35:09.840" starttime="20190402 05:35:08.747"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:09.840" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:09.840" starttime="20190402 05:35:09.840"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:09.841" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 8bd90126-04f1-43...</msg>
<status status="PASS" endtime="20190402 05:35:09.841" starttime="20190402 05:35:09.841"></status>
</kw>
<msg timestamp="20190402 05:35:09.841" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 8bd90126-04f1-43...</msg>
<status status="PASS" endtime="20190402 05:35:09.841" starttime="20190402 05:35:09.840"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:09.843" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:09.843" starttime="20190402 05:35:09.841"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:09.843" level="INFO">0</msg>
<msg timestamp="20190402 05:35:09.844" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:09.844" starttime="20190402 05:35:09.843"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:09.844" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:09.844" starttime="20190402 05:35:09.844"></status>
</kw>
<msg timestamp="20190402 05:35:09.844" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:09.844" starttime="20190402 05:35:09.841"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:09.845" starttime="20190402 05:35:09.845"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:09.845" starttime="20190402 05:35:09.844"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:09.845" starttime="20190402 05:35:09.845"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:09.846" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 8bd90126-04f1-437e-ad77-37e81fc2baf6 |
| host_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| label_key   | openstack-control-plane              |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:09.846" starttime="20190402 05:35:09.845"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:09.846" starttime="20190402 05:35:08.733"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:09.846" starttime="20190402 05:35:08.733"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}'=='Simplex' or '${CONFIGURATION_TYPE}'=='Duplex' or ${is_controller}==False</arg>
<arg>Run Keywords</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:09.847" starttime="20190402 05:35:09.847"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:09.848" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:09.848" starttime="20190402 05:35:09.848"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:09.848" starttime="20190402 05:35:09.848"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:09.849" starttime="20190402 05:35:09.849"></status>
</kw>
<msg timestamp="20190402 05:35:09.849" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:09.849" starttime="20190402 05:35:09.847"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:09.849" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:09.849" starttime="20190402 05:35:09.849"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:09.860" level="INFO">system host-label-assign controller-0  openstack-compute-node=enabled</msg>
<status status="PASS" endtime="20190402 05:35:09.860" starttime="20190402 05:35:09.849"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:10.957" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | cd5d7c87-20a2-4d5e-b7fb-ab221f4a0bd2 |
| host_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| label_key   | openstack-compute-node               |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:10.957" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | cd5d7c87-20a2-4d...</msg>
<status status="PASS" endtime="20190402 05:35:10.957" starttime="20190402 05:35:09.860"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:10.958" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:10.958" starttime="20190402 05:35:10.958"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:10.958" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | cd5d7c87-20a2-4d...</msg>
<status status="PASS" endtime="20190402 05:35:10.959" starttime="20190402 05:35:10.958"></status>
</kw>
<msg timestamp="20190402 05:35:10.959" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | cd5d7c87-20a2-4d...</msg>
<status status="PASS" endtime="20190402 05:35:10.959" starttime="20190402 05:35:10.958"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:10.960" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:10.960" starttime="20190402 05:35:10.959"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:10.961" level="INFO">0</msg>
<msg timestamp="20190402 05:35:10.961" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:10.961" starttime="20190402 05:35:10.961"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:10.961" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:10.962" starttime="20190402 05:35:10.961"></status>
</kw>
<msg timestamp="20190402 05:35:10.962" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:10.962" starttime="20190402 05:35:10.959"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:10.962" starttime="20190402 05:35:10.962"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:10.962" starttime="20190402 05:35:10.962"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:10.963" starttime="20190402 05:35:10.963"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:10.963" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | cd5d7c87-20a2-4d5e-b7fb-ab221f4a0bd2 |
| host_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| label_key   | openstack-compute-node               |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:10.963" starttime="20190402 05:35:10.963"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:10.963" starttime="20190402 05:35:09.847"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:10.964" starttime="20190402 05:35:10.964"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:10.965" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:10.965" starttime="20190402 05:35:10.964"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:10.965" starttime="20190402 05:35:10.965"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:10.965" starttime="20190402 05:35:10.965"></status>
</kw>
<msg timestamp="20190402 05:35:10.966" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:10.966" starttime="20190402 05:35:10.964"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:10.966" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:10.966" starttime="20190402 05:35:10.966"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:10.974" level="INFO">system host-label-assign controller-0  openvswitch=enabled</msg>
<status status="PASS" endtime="20190402 05:35:10.974" starttime="20190402 05:35:10.966"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:12.073" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | d5ee1c84-03e2-48bf-9034-18c9d35a3c41 |
| host_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| label_key   | openvswitch                          |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:12.073" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | d5ee1c84-03e2-48...</msg>
<status status="PASS" endtime="20190402 05:35:12.073" starttime="20190402 05:35:10.975"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:12.074" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:12.074" starttime="20190402 05:35:12.074"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:12.075" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | d5ee1c84-03e2-48...</msg>
<status status="PASS" endtime="20190402 05:35:12.075" starttime="20190402 05:35:12.074"></status>
</kw>
<msg timestamp="20190402 05:35:12.075" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | d5ee1c84-03e2-48...</msg>
<status status="PASS" endtime="20190402 05:35:12.075" starttime="20190402 05:35:12.073"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:12.077" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:12.077" starttime="20190402 05:35:12.075"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:12.077" level="INFO">0</msg>
<msg timestamp="20190402 05:35:12.077" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:12.077" starttime="20190402 05:35:12.077"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:12.078" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:12.078" starttime="20190402 05:35:12.077"></status>
</kw>
<msg timestamp="20190402 05:35:12.078" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:12.078" starttime="20190402 05:35:12.075"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:12.079" starttime="20190402 05:35:12.078"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:12.079" starttime="20190402 05:35:12.078"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:12.079" starttime="20190402 05:35:12.079"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:12.079" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | d5ee1c84-03e2-48bf-9034-18c9d35a3c41 |
| host_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| label_key   | openvswitch                          |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:12.079" starttime="20190402 05:35:12.079"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:12.079" starttime="20190402 05:35:10.963"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:12.080" starttime="20190402 05:35:12.080"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:12.081" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:12.081" starttime="20190402 05:35:12.081"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:12.081" starttime="20190402 05:35:12.081"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:12.082" starttime="20190402 05:35:12.081"></status>
</kw>
<msg timestamp="20190402 05:35:12.082" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:12.082" starttime="20190402 05:35:12.080"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:12.082" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:12.082" starttime="20190402 05:35:12.082"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:12.090" level="INFO">system host-label-assign controller-0  sriov=enabled</msg>
<status status="PASS" endtime="20190402 05:35:12.090" starttime="20190402 05:35:12.082"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:13.190" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 1fb09885-cf78-4e4f-9154-6bbbcc4391d6 |
| host_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| label_key   | sriov                                |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:13.190" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 1fb09885-cf78-4e...</msg>
<status status="PASS" endtime="20190402 05:35:13.190" starttime="20190402 05:35:12.090"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:13.191" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:13.191" starttime="20190402 05:35:13.191"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:13.192" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 1fb09885-cf78-4e...</msg>
<status status="PASS" endtime="20190402 05:35:13.192" starttime="20190402 05:35:13.191"></status>
</kw>
<msg timestamp="20190402 05:35:13.192" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 1fb09885-cf78-4e...</msg>
<status status="PASS" endtime="20190402 05:35:13.192" starttime="20190402 05:35:13.191"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:13.194" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:13.194" starttime="20190402 05:35:13.192"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:13.194" level="INFO">0</msg>
<msg timestamp="20190402 05:35:13.194" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:13.194" starttime="20190402 05:35:13.194"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:13.195" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:13.195" starttime="20190402 05:35:13.194"></status>
</kw>
<msg timestamp="20190402 05:35:13.195" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:13.195" starttime="20190402 05:35:13.192"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:13.196" starttime="20190402 05:35:13.195"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:13.196" starttime="20190402 05:35:13.195"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:13.196" starttime="20190402 05:35:13.196"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:13.196" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 1fb09885-cf78-4e4f-9154-6bbbcc4391d6 |
| host_uuid   | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd |
| label_key   | sriov                                |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:13.196" starttime="20190402 05:35:13.196"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:13.196" starttime="20190402 05:35:12.080"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:13.197" starttime="20190402 05:35:09.846"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:13.197" starttime="20190402 05:35:09.846"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:13.197" starttime="20190402 05:35:08.732"></status>
</kw>
<kw name="Setup Partitions" library="Utils">
<doc>Setup required partition on specified host.</doc>
<arguments>
<arg>${master_controller}</arg>
<arg>${lgv_name}</arg>
<arg>${nova_size}</arg>
<arg>${cgts_part_size}</arg>
</arguments>
<kw name="Get Root Disk Device" library="Utils">
<doc>Get the root disk partition assigned to the specified
node</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<assign>
<var>${root_disk_device}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${host}</arg>
<arg>grep rootfs</arg>
<arg>awk '{print $4}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 05:35:13.198" level="INFO">${cmd} = system host-show controller-0|grep rootfs|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:35:13.198" starttime="20190402 05:35:13.198"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:13.199" starttime="20190402 05:35:13.198"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:13.199" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:13.199" starttime="20190402 05:35:13.199"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:13.200" starttime="20190402 05:35:13.199"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:13.200" starttime="20190402 05:35:13.200"></status>
</kw>
<msg timestamp="20190402 05:35:13.200" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:13.200" starttime="20190402 05:35:13.199"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:13.201" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:13.201" starttime="20190402 05:35:13.200"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:13.210" level="INFO">system host-show controller-0|grep roo tfs|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:35:13.210" starttime="20190402 05:35:13.201"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:14.238" level="INFO">/dev/disk/by-path/pci-0000:00:17.0-ata-1.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:14.239" level="INFO">${output} = /dev/disk/by-path/pci-0000:00:17.0-ata-1.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:14.239" starttime="20190402 05:35:13.210"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:14.239" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:14.239" starttime="20190402 05:35:14.239"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:14.240" level="INFO">${clean_out} = /dev/disk/by-path/pci-0000:00:17.0-ata-1.0
</msg>
<status status="PASS" endtime="20190402 05:35:14.240" starttime="20190402 05:35:14.240"></status>
</kw>
<msg timestamp="20190402 05:35:14.240" level="INFO">${output} = /dev/disk/by-path/pci-0000:00:17.0-ata-1.0
</msg>
<status status="PASS" endtime="20190402 05:35:14.240" starttime="20190402 05:35:14.239"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:14.242" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:14.242" starttime="20190402 05:35:14.240"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:14.242" level="INFO">0</msg>
<msg timestamp="20190402 05:35:14.242" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:14.242" starttime="20190402 05:35:14.242"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:14.243" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:14.243" starttime="20190402 05:35:14.243"></status>
</kw>
<msg timestamp="20190402 05:35:14.243" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:14.243" starttime="20190402 05:35:14.240"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:14.244" starttime="20190402 05:35:14.243"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:14.244" starttime="20190402 05:35:14.243"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:14.244" starttime="20190402 05:35:14.244"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:14.244" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: /dev/disk/by-path/pci-0000:00:17.0-ata-1.0</msg>
<status status="PASS" endtime="20190402 05:35:14.244" starttime="20190402 05:35:14.244"></status>
</kw>
<msg timestamp="20190402 05:35:14.245" level="INFO">${result} = {u'stdout': u'/dev/disk/by-path/pci-0000:00:17.0-ata-1.0', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:35:14.245" starttime="20190402 05:35:13.198"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${result.stdout.strip()}</arg>
</arguments>
<assign>
<var>${root_disk}</var>
</assign>
<msg timestamp="20190402 05:35:14.245" level="INFO">${root_disk} = /dev/disk/by-path/pci-0000:00:17.0-ata-1.0</msg>
<status status="PASS" endtime="20190402 05:35:14.245" starttime="20190402 05:35:14.245"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host} --nowrap</arg>
<arg>grep ${root_disk}</arg>
<arg>awk '{print $4}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 05:35:14.245" level="INFO">${cmd} = system host-disk-list controller-0 --nowrap|grep /dev/disk/by-path/pci-0000:00:17.0-ata-1.0|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:35:14.245" starttime="20190402 05:35:14.245"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${root_disk_device}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:14.246" starttime="20190402 05:35:14.246"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:14.247" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:14.247" starttime="20190402 05:35:14.246"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:14.247" starttime="20190402 05:35:14.247"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:14.248" starttime="20190402 05:35:14.247"></status>
</kw>
<msg timestamp="20190402 05:35:14.248" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:14.248" starttime="20190402 05:35:14.246"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:14.248" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:14.248" starttime="20190402 05:35:14.248"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:14.262" level="INFO">system host-disk-list controller-0 --n owrap|grep /dev/disk/by-path/pci-0000:00:17.0-ata-1.0|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:35:14.262" starttime="20190402 05:35:14.248"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:15.391" level="INFO">/dev/sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:15.391" level="INFO">${output} = /dev/sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:15.391" starttime="20190402 05:35:14.262"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:15.392" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:15.392" starttime="20190402 05:35:15.392"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:15.392" level="INFO">${clean_out} = /dev/sda
</msg>
<status status="PASS" endtime="20190402 05:35:15.392" starttime="20190402 05:35:15.392"></status>
</kw>
<msg timestamp="20190402 05:35:15.392" level="INFO">${output} = /dev/sda
</msg>
<status status="PASS" endtime="20190402 05:35:15.392" starttime="20190402 05:35:15.391"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:15.394" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:15.394" starttime="20190402 05:35:15.393"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:15.395" level="INFO">0</msg>
<msg timestamp="20190402 05:35:15.395" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:15.395" starttime="20190402 05:35:15.395"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:15.395" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:15.395" starttime="20190402 05:35:15.395"></status>
</kw>
<msg timestamp="20190402 05:35:15.395" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:15.396" starttime="20190402 05:35:15.392"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:15.396" starttime="20190402 05:35:15.396"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:15.396" starttime="20190402 05:35:15.396"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:15.397" starttime="20190402 05:35:15.396"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:15.397" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: /dev/sda</msg>
<status status="PASS" endtime="20190402 05:35:15.397" starttime="20190402 05:35:15.397"></status>
</kw>
<msg timestamp="20190402 05:35:15.397" level="INFO">${root_disk_device} = {u'stdout': u'/dev/sda', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:35:15.397" starttime="20190402 05:35:14.245"></status>
</kw>
<msg timestamp="20190402 05:35:15.397" level="INFO">${root_disk_device} = /dev/sda</msg>
<status status="PASS" endtime="20190402 05:35:15.397" starttime="20190402 05:35:13.197"></status>
</kw>
<kw name="Get Disk List UID" library="Utils">
<doc>Returns the UID of the disk given the device node and
host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_device}</arg>
</arguments>
<assign>
<var>${root_disk_uuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host}</arg>
<arg>grep ${device_node}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:35:15.398" level="INFO">${system_cmd} = system host-disk-list controller-0|grep /dev/sda|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 05:35:15.398" starttime="20190402 05:35:15.398"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:15.399" starttime="20190402 05:35:15.399"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:15.399" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:15.400" starttime="20190402 05:35:15.399"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:15.400" starttime="20190402 05:35:15.400"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:15.400" starttime="20190402 05:35:15.400"></status>
</kw>
<msg timestamp="20190402 05:35:15.400" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:15.400" starttime="20190402 05:35:15.399"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:15.401" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:15.401" starttime="20190402 05:35:15.401"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:15.411" level="INFO">system host-disk-list controller-0|gre p /dev/sda|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 05:35:15.411" starttime="20190402 05:35:15.401"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:16.482" level="INFO">59c21ecb-ddc2-4855-9798-ada28b56ee4d
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:16.482" level="INFO">${output} = 59c21ecb-ddc2-4855-9798-ada28b56ee4d
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:16.483" starttime="20190402 05:35:15.411"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:16.483" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:16.484" starttime="20190402 05:35:16.483"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:16.484" level="INFO">${clean_out} = 59c21ecb-ddc2-4855-9798-ada28b56ee4d
</msg>
<status status="PASS" endtime="20190402 05:35:16.484" starttime="20190402 05:35:16.484"></status>
</kw>
<msg timestamp="20190402 05:35:16.484" level="INFO">${output} = 59c21ecb-ddc2-4855-9798-ada28b56ee4d
</msg>
<status status="PASS" endtime="20190402 05:35:16.484" starttime="20190402 05:35:16.483"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:16.486" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:16.486" starttime="20190402 05:35:16.484"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:16.487" level="INFO">0</msg>
<msg timestamp="20190402 05:35:16.487" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:16.487" starttime="20190402 05:35:16.486"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:16.487" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:16.487" starttime="20190402 05:35:16.487"></status>
</kw>
<msg timestamp="20190402 05:35:16.487" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:16.487" starttime="20190402 05:35:16.484"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:16.488" starttime="20190402 05:35:16.488"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:16.488" starttime="20190402 05:35:16.487"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:16.488" starttime="20190402 05:35:16.488"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:16.489" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 59c21ecb-ddc2-4855-9798-ada28b56ee4d</msg>
<status status="PASS" endtime="20190402 05:35:16.489" starttime="20190402 05:35:16.488"></status>
</kw>
<msg timestamp="20190402 05:35:16.489" level="INFO">&amp;{result} = { stdout=59c21ecb-ddc2-4855-9798-ada28b56ee4d | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 05:35:16.489" starttime="20190402 05:35:15.398"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${uid}</var>
</assign>
<msg timestamp="20190402 05:35:16.489" level="INFO">${uid} = 59c21ecb-ddc2-4855-9798-ada28b56ee4d</msg>
<status status="PASS" endtime="20190402 05:35:16.489" starttime="20190402 05:35:16.489"></status>
</kw>
<msg timestamp="20190402 05:35:16.489" level="INFO">${root_disk_uuid} = 59c21ecb-ddc2-4855-9798-ada28b56ee4d</msg>
<status status="PASS" endtime="20190402 05:35:16.489" starttime="20190402 05:35:15.397"></status>
</kw>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controller-0'</arg>
<arg>Ready</arg>
<arg>Creating</arg>
</arguments>
<assign>
<var>${part_status}</var>
</assign>
<msg timestamp="20190402 05:35:16.490" level="INFO">${part_status} = Ready</msg>
<status status="PASS" endtime="20190402 05:35:16.490" starttime="20190402 05:35:16.490"></status>
</kw>
<kw name="Evaluate" library="BuiltIn">
<doc>Evaluates the given expression in Python and returns the results.</doc>
<arguments>
<arg>"controller" in """${host}"""</arg>
</arguments>
<assign>
<var>${is_controller}</var>
</assign>
<msg timestamp="20190402 05:35:16.490" level="INFO">${is_controller} = True</msg>
<status status="PASS" endtime="20190402 05:35:16.490" starttime="20190402 05:35:16.490"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${nova_size}==True</arg>
<arg>Calcultae Nova Partition Size For Computes</arg>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>ELSE</arg>
<arg>Set Variable</arg>
<arg>${nova_size}</arg>
</arguments>
<assign>
<var>${nova_size}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${nova_size}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:16.491" starttime="20190402 05:35:16.491"></status>
</kw>
<msg timestamp="20190402 05:35:16.491" level="INFO">${nova_size} = 100</msg>
<status status="PASS" endtime="20190402 05:35:16.491" starttime="20190402 05:35:16.490"></status>
</kw>
<kw name="Add Disk Partition" library="Utils">
<doc>Add a partition for specified disk on the specified host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${nova_size}</arg>
<arg>${part_status}</arg>
</arguments>
<assign>
<var>${nova_partition_uuid}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-disk-partition-add ${host} ${uid} ${size} -t lvm_phys_vol</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:16.492" starttime="20190402 05:35:16.492"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:16.493" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:16.493" starttime="20190402 05:35:16.492"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:16.493" starttime="20190402 05:35:16.493"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:16.493" starttime="20190402 05:35:16.493"></status>
</kw>
<msg timestamp="20190402 05:35:16.493" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:16.494" starttime="20190402 05:35:16.492"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:16.494" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:16.494" starttime="20190402 05:35:16.494"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:16.507" level="INFO">system host-disk-partition-add control ler-0 59c21ecb-ddc2-4855-9798-ada28b56ee4d 100 -t lvm_phys_vol</msg>
<status status="PASS" endtime="20190402 05:35:16.507" starttime="20190402 05:35:16.494"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:17.737" level="INFO">+-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| device_node | /dev/sda5                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 102400                                           |
| uuid        | 41e205bc-b2ec-467b-8971-c9a060ab2b02             |
| ihost_uuid  | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd             |
| idisk_uuid  | 59c21ecb-ddc2-4855-9798-ada28b56ee4d             |
| ipv_uuid    | None                                             |
| status      | Creating                                         |
| created_at  | 2019-04-02T11:24:01.519303+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:17.737" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 05:35:17.737" starttime="20190402 05:35:16.508"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:17.738" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:17.738" starttime="20190402 05:35:17.738"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:17.738" level="INFO">${clean_out} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 05:35:17.739" starttime="20190402 05:35:17.738"></status>
</kw>
<msg timestamp="20190402 05:35:17.739" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 05:35:17.739" starttime="20190402 05:35:17.737"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:17.741" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:17.741" starttime="20190402 05:35:17.739"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:17.741" level="INFO">0</msg>
<msg timestamp="20190402 05:35:17.741" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:17.741" starttime="20190402 05:35:17.741"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:17.742" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:17.742" starttime="20190402 05:35:17.742"></status>
</kw>
<msg timestamp="20190402 05:35:17.742" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:17.742" starttime="20190402 05:35:17.739"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:17.743" starttime="20190402 05:35:17.742"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:17.743" starttime="20190402 05:35:17.742"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:17.743" starttime="20190402 05:35:17.743"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:17.743" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| device_node | /dev/sda5                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 102400                                           |
| uuid        | 41e205bc-b2ec-467b-8971-c9a060ab2b02             |
| ihost_uuid  | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd             |
| idisk_uuid  | 59c21ecb-ddc2-4855-9798-ada28b56ee4d             |
| ipv_uuid    | None                                             |
| status      | Creating                                         |
| created_at  | 2019-04-02T11:24:01.519303+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:17.743" starttime="20190402 05:35:17.743"></status>
</kw>
<msg timestamp="20190402 05:35:17.744" level="INFO">${result} = {u'stdout': u'+-------------+--------------------------------------------------+\r\n| Property    | Value                                            |\r\n+-------------+-------------------------------...</msg>
<status status="PASS" endtime="20190402 05:35:17.744" starttime="20190402 05:35:16.491"></status>
</kw>
<kw name="Get Property From Result" library="Utils">
<arguments>
<arg>${result}</arg>
<arg>uuid</arg>
</arguments>
<assign>
<var>${new_uid}</var>
</assign>
<kw name="String To Dict" library="common">
<doc>Convert string table to dictionary</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 05:35:17.744" level="INFO">${dict} = {'Property': {'status': {'Value': 'Creating'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '41e205bc-b2ec-467b-8971-...</msg>
<status status="PASS" endtime="20190402 05:35:17.744" starttime="20190402 05:35:17.744"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Property</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 05:35:17.745" level="INFO">${dict} = {'status': {'Value': 'Creating'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '41e205bc-b2ec-467b-8971-c9a060ab2b02'...</msg>
<status status="PASS" endtime="20190402 05:35:17.745" starttime="20190402 05:35:17.744"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 05:35:17.745" level="INFO">${dict} = {'Value': '41e205bc-b2ec-467b-8971-c9a060ab2b02'}</msg>
<status status="PASS" endtime="20190402 05:35:17.745" starttime="20190402 05:35:17.745"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Value</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 05:35:17.745" level="INFO">${dict} = 41e205bc-b2ec-467b-8971-c9a060ab2b02</msg>
<status status="PASS" endtime="20190402 05:35:17.745" starttime="20190402 05:35:17.745"></status>
</kw>
<msg timestamp="20190402 05:35:17.745" level="INFO">${new_uid} = 41e205bc-b2ec-467b-8971-c9a060ab2b02</msg>
<status status="PASS" endtime="20190402 05:35:17.745" starttime="20190402 05:35:17.744"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>30 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value Of Command</arg>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:17.747" starttime="20190402 05:35:17.747"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:17.748" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:17.748" starttime="20190402 05:35:17.747"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:17.748" starttime="20190402 05:35:17.748"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:17.748" starttime="20190402 05:35:17.748"></status>
</kw>
<msg timestamp="20190402 05:35:17.749" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:17.749" starttime="20190402 05:35:17.747"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:17.749" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:17.749" starttime="20190402 05:35:17.749"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:17.767" level="INFO">system host-disk-partition-show contro ller-0 41e205bc-b2ec-467b-8971-c9a060ab2b02 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:35:17.767" starttime="20190402 05:35:17.749"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:18.788" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:18.789" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:18.789" starttime="20190402 05:35:17.767"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:18.789" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:18.789" starttime="20190402 05:35:18.789"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:18.790" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190402 05:35:18.790" starttime="20190402 05:35:18.789"></status>
</kw>
<msg timestamp="20190402 05:35:18.790" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190402 05:35:18.790" starttime="20190402 05:35:18.789"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:18.792" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:18.792" starttime="20190402 05:35:18.790"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:18.792" level="INFO">0</msg>
<msg timestamp="20190402 05:35:18.793" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:18.793" starttime="20190402 05:35:18.792"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:18.793" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:18.793" starttime="20190402 05:35:18.793"></status>
</kw>
<msg timestamp="20190402 05:35:18.793" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:18.793" starttime="20190402 05:35:18.790"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:18.794" starttime="20190402 05:35:18.794"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:18.794" starttime="20190402 05:35:18.793"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:18.794" starttime="20190402 05:35:18.794"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:18.795" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190402 05:35:18.795" starttime="20190402 05:35:18.794"></status>
</kw>
<msg timestamp="20190402 05:35:18.795" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:35:18.795" starttime="20190402 05:35:17.746"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:35:18.795" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190402 05:35:18.795" starttime="20190402 05:35:18.795"></status>
</kw>
<msg timestamp="20190402 05:35:18.795" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190402 05:35:18.795" starttime="20190402 05:35:17.746"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:35:18.796" level="FAIL">Creating != Ready</msg>
<status status="FAIL" endtime="20190402 05:35:18.796" starttime="20190402 05:35:18.795"></status>
</kw>
<status status="FAIL" endtime="20190402 05:35:18.796" starttime="20190402 05:35:17.746"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:28.805" starttime="20190402 05:35:28.804"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:28.807" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:28.808" starttime="20190402 05:35:28.806"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:28.809" starttime="20190402 05:35:28.808"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:28.810" starttime="20190402 05:35:28.809"></status>
</kw>
<msg timestamp="20190402 05:35:28.811" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:28.811" starttime="20190402 05:35:28.805"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:28.812" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:28.812" starttime="20190402 05:35:28.811"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:28.849" level="INFO">system host-disk-partition-show contro ller-0 41e205bc-b2ec-467b-8971-c9a060ab2b02 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:35:28.849" starttime="20190402 05:35:28.812"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:29.869" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:29.869" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:29.869" starttime="20190402 05:35:28.849"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:29.870" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:29.870" starttime="20190402 05:35:29.870"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:29.870" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190402 05:35:29.870" starttime="20190402 05:35:29.870"></status>
</kw>
<msg timestamp="20190402 05:35:29.871" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190402 05:35:29.871" starttime="20190402 05:35:29.870"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:29.872" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:29.872" starttime="20190402 05:35:29.871"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:29.873" level="INFO">0</msg>
<msg timestamp="20190402 05:35:29.873" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:29.873" starttime="20190402 05:35:29.873"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:29.873" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:29.873" starttime="20190402 05:35:29.873"></status>
</kw>
<msg timestamp="20190402 05:35:29.873" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:29.873" starttime="20190402 05:35:29.871"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:29.874" starttime="20190402 05:35:29.874"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:29.874" starttime="20190402 05:35:29.874"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:29.875" starttime="20190402 05:35:29.874"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:29.875" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190402 05:35:29.875" starttime="20190402 05:35:29.875"></status>
</kw>
<msg timestamp="20190402 05:35:29.875" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:35:29.875" starttime="20190402 05:35:28.802"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:35:29.875" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190402 05:35:29.875" starttime="20190402 05:35:29.875"></status>
</kw>
<msg timestamp="20190402 05:35:29.876" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190402 05:35:29.876" starttime="20190402 05:35:28.800"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:35:29.876" level="FAIL">Creating != Ready</msg>
<status status="FAIL" endtime="20190402 05:35:29.876" starttime="20190402 05:35:29.876"></status>
</kw>
<status status="FAIL" endtime="20190402 05:35:29.876" starttime="20190402 05:35:28.797"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:39.885" starttime="20190402 05:35:39.884"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:39.887" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:39.887" starttime="20190402 05:35:39.886"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:39.889" starttime="20190402 05:35:39.888"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:39.890" starttime="20190402 05:35:39.889"></status>
</kw>
<msg timestamp="20190402 05:35:39.891" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:39.891" starttime="20190402 05:35:39.885"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:39.891" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:39.892" starttime="20190402 05:35:39.891"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:39.931" level="INFO">system host-disk-partition-show contro ller-0 41e205bc-b2ec-467b-8971-c9a060ab2b02 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:35:39.931" starttime="20190402 05:35:39.892"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:41.016" level="INFO">Ready
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:41.016" level="INFO">${output} = Ready
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:41.016" starttime="20190402 05:35:39.931"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:41.017" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:41.017" starttime="20190402 05:35:41.017"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:41.017" level="INFO">${clean_out} = Ready
</msg>
<status status="PASS" endtime="20190402 05:35:41.017" starttime="20190402 05:35:41.017"></status>
</kw>
<msg timestamp="20190402 05:35:41.018" level="INFO">${output} = Ready
</msg>
<status status="PASS" endtime="20190402 05:35:41.018" starttime="20190402 05:35:41.016"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:41.019" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:41.019" starttime="20190402 05:35:41.018"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:41.020" level="INFO">0</msg>
<msg timestamp="20190402 05:35:41.020" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:41.020" starttime="20190402 05:35:41.019"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:41.021" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:41.021" starttime="20190402 05:35:41.020"></status>
</kw>
<msg timestamp="20190402 05:35:41.021" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:41.021" starttime="20190402 05:35:41.018"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:41.022" starttime="20190402 05:35:41.021"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:41.022" starttime="20190402 05:35:41.021"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:41.022" starttime="20190402 05:35:41.022"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:41.022" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Ready</msg>
<status status="PASS" endtime="20190402 05:35:41.022" starttime="20190402 05:35:41.022"></status>
</kw>
<msg timestamp="20190402 05:35:41.022" level="INFO">${result} = {u'stdout': u'Ready', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:35:41.022" starttime="20190402 05:35:39.882"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:35:41.023" level="INFO">${value} = Ready</msg>
<status status="PASS" endtime="20190402 05:35:41.023" starttime="20190402 05:35:41.023"></status>
</kw>
<msg timestamp="20190402 05:35:41.023" level="INFO">${current_value} = Ready</msg>
<status status="PASS" endtime="20190402 05:35:41.023" starttime="20190402 05:35:39.880"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:41.023" starttime="20190402 05:35:41.023"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:41.023" starttime="20190402 05:35:39.877"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:41.023" starttime="20190402 05:35:17.746"></status>
</kw>
<msg timestamp="20190402 05:35:41.024" level="INFO">${nova_partition_uuid} = 41e205bc-b2ec-467b-8971-c9a060ab2b02</msg>
<status status="PASS" endtime="20190402 05:35:41.024" starttime="20190402 05:35:16.491"></status>
</kw>
<kw name="Add Local Volume Group" library="Utils">
<doc>Adds a local volume group according to given options.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-lvg-add ${host} ${lvg_name}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:41.025" starttime="20190402 05:35:41.024"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:41.025" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:41.025" starttime="20190402 05:35:41.025"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:41.026" starttime="20190402 05:35:41.025"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:41.026" starttime="20190402 05:35:41.026"></status>
</kw>
<msg timestamp="20190402 05:35:41.026" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:41.026" starttime="20190402 05:35:41.025"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:41.026" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:41.027" starttime="20190402 05:35:41.026"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:41.033" level="INFO">system host-lvg-add controller-0 nova- local</msg>
<status status="PASS" endtime="20190402 05:35:41.033" starttime="20190402 05:35:41.027"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:42.109" level="INFO">+-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+-----------------------+-------------------------------------------------------------------+
| lvm_vg_name           | nova-local                                                        |
| vg_state              | adding                                                            |
| uuid                  | 53262803-e3b3-435c-b3e8-1355487417d8                              |
| ihost_uuid            | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd                              |
| lvm_vg_access         | None                                                              |
| lvm_max_lv            | 0                                                                 |
| lvm_cur_lv            | 0                                                                 |
| lvm_max_pv            | 0                                                                 |
| lvm_cur_pv            | 0                                                                 |
| lvm_vg_size_gib       | 0.0                                                               |
| lvm_vg_avail_size_gib | 0.0                                                               |
| lvm_vg_total_pe       | 0                                                                 |
| lvm_vg_free_pe        | 0                                                                 |
| created_at            | 2019-04-02T11:24:25.895886+00:00                                  |
| updated_at            | None                                                              |
| parameters            | {u'concurrent_disk_operations': 2, u'instance_backing': u'image'} |
+-----------------------+-------------------------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:42.110" level="INFO">${output} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190402 05:35:42.110" starttime="20190402 05:35:41.033"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:42.110" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:42.110" starttime="20190402 05:35:42.110"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:42.111" level="INFO">${clean_out} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190402 05:35:42.111" starttime="20190402 05:35:42.111"></status>
</kw>
<msg timestamp="20190402 05:35:42.111" level="INFO">${output} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190402 05:35:42.111" starttime="20190402 05:35:42.110"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:42.113" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:42.113" starttime="20190402 05:35:42.111"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:42.113" level="INFO">0</msg>
<msg timestamp="20190402 05:35:42.113" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:42.113" starttime="20190402 05:35:42.113"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:42.114" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:42.114" starttime="20190402 05:35:42.113"></status>
</kw>
<msg timestamp="20190402 05:35:42.114" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:42.114" starttime="20190402 05:35:42.111"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:42.115" starttime="20190402 05:35:42.114"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:42.115" starttime="20190402 05:35:42.114"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:42.115" starttime="20190402 05:35:42.115"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:42.115" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+-----------------------+-------------------------------------------------------------------+
| lvm_vg_name           | nova-local                                                        |
| vg_state              | adding                                                            |
| uuid                  | 53262803-e3b3-435c-b3e8-1355487417d8                              |
| ihost_uuid            | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd                              |
| lvm_vg_access         | None                                                              |
| lvm_max_lv            | 0                                                                 |
| lvm_cur_lv            | 0                                                                 |
| lvm_max_pv            | 0                                                                 |
| lvm_cur_pv            | 0                                                                 |
| lvm_vg_size_gib       | 0.0                                                               |
| lvm_vg_avail_size_gib | 0.0                                                               |
| lvm_vg_total_pe       | 0                                                                 |
| lvm_vg_free_pe        | 0                                                                 |
| created_at            | 2019-04-02T11:24:25.895886+00:00                                  |
| updated_at            | None                                                              |
| parameters            | {u'concurrent_disk_operations': 2, u'instance_backing': u'image'} |
+-----------------------+-------------------------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:42.115" starttime="20190402 05:35:42.115"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:42.115" starttime="20190402 05:35:41.024"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:42.116" starttime="20190402 05:35:41.024"></status>
</kw>
<kw name="Add Physical Volume" library="Utils">
<doc>Adds a physical volume to the specified host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${nova_partition_uuid}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-pv-add ${host} ${lvg name} ${uid}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:42.117" starttime="20190402 05:35:42.117"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:42.118" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:42.118" starttime="20190402 05:35:42.117"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:42.118" starttime="20190402 05:35:42.118"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:42.118" starttime="20190402 05:35:42.118"></status>
</kw>
<msg timestamp="20190402 05:35:42.118" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:42.118" starttime="20190402 05:35:42.117"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:42.119" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:42.119" starttime="20190402 05:35:42.119"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:42.131" level="INFO">system host-pv-add controller-0 nova-l ocal 41e205bc-b2ec-467b-8971-c9a060ab2b02</msg>
<status status="PASS" endtime="20190402 05:35:42.132" starttime="20190402 05:35:42.119"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:43.379" level="INFO">+--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | da0b981a-b00c-48f3-89d7-e3b547b9fe52             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 41e205bc-b2ec-467b-8971-c9a060ab2b02             |
| disk_or_part_device_node | /dev/sda5                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| lvm_pv_name              | /dev/sda5                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd             |
| created_at               | 2019-04-02T11:24:27.166027+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:43.379" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 05:35:43.380" starttime="20190402 05:35:42.132"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:43.380" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:43.380" starttime="20190402 05:35:43.380"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:43.381" level="INFO">${clean_out} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 05:35:43.381" starttime="20190402 05:35:43.380"></status>
</kw>
<msg timestamp="20190402 05:35:43.381" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 05:35:43.381" starttime="20190402 05:35:43.380"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:43.383" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:43.383" starttime="20190402 05:35:43.381"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:43.383" level="INFO">0</msg>
<msg timestamp="20190402 05:35:43.383" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:43.383" starttime="20190402 05:35:43.383"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:43.384" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:43.384" starttime="20190402 05:35:43.384"></status>
</kw>
<msg timestamp="20190402 05:35:43.384" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:43.384" starttime="20190402 05:35:43.381"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:43.385" starttime="20190402 05:35:43.384"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:43.385" starttime="20190402 05:35:43.384"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:43.385" starttime="20190402 05:35:43.385"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:43.385" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | da0b981a-b00c-48f3-89d7-e3b547b9fe52             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 41e205bc-b2ec-467b-8971-c9a060ab2b02             |
| disk_or_part_device_node | /dev/sda5                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| lvm_pv_name              | /dev/sda5                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd             |
| created_at               | 2019-04-02T11:24:27.166027+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:43.385" starttime="20190402 05:35:43.385"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:43.385" starttime="20190402 05:35:42.116"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:43.386" starttime="20190402 05:35:42.116"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==False</arg>
<arg>Modify LVG Attributes</arg>
<arg>-b image</arg>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:43.386" starttime="20190402 05:35:43.386"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True or ${setup_cgts}==True</arg>
<arg>Add Disk Partition</arg>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>${part_status}</arg>
</arguments>
<assign>
<var>${cgts_partition_uuid}</var>
</assign>
<kw name="Add Disk Partition" library="Utils">
<doc>Add a partition for specified disk on the specified host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>${part_status}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-disk-partition-add ${host} ${uid} ${size} -t lvm_phys_vol</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:43.387" starttime="20190402 05:35:43.387"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:43.388" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:43.388" starttime="20190402 05:35:43.388"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:43.389" starttime="20190402 05:35:43.388"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:43.389" starttime="20190402 05:35:43.389"></status>
</kw>
<msg timestamp="20190402 05:35:43.389" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:43.389" starttime="20190402 05:35:43.387"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:43.389" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:43.389" starttime="20190402 05:35:43.389"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:43.404" level="INFO">system host-disk-partition-add control ler-0 59c21ecb-ddc2-4855-9798-ada28b56ee4d 20 -t lvm_phys_vol</msg>
<status status="PASS" endtime="20190402 05:35:43.404" starttime="20190402 05:35:43.390"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:44.523" level="INFO">+-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| device_node | /dev/sda6                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 20480                                            |
| uuid        | 37bf735d-2aa0-4c66-96fa-ec12d5420656             |
| ihost_uuid  | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd             |
| idisk_uuid  | 59c21ecb-ddc2-4855-9798-ada28b56ee4d             |
| ipv_uuid    | None                                             |
| status      | Creating                                         |
| created_at  | 2019-04-02T11:24:28.311921+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:44.523" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 05:35:44.523" starttime="20190402 05:35:43.404"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:44.524" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:44.524" starttime="20190402 05:35:44.524"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:44.524" level="INFO">${clean_out} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 05:35:44.524" starttime="20190402 05:35:44.524"></status>
</kw>
<msg timestamp="20190402 05:35:44.524" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 05:35:44.524" starttime="20190402 05:35:44.523"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:44.526" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:44.526" starttime="20190402 05:35:44.525"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:44.527" level="INFO">0</msg>
<msg timestamp="20190402 05:35:44.527" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:44.527" starttime="20190402 05:35:44.526"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:44.527" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:44.527" starttime="20190402 05:35:44.527"></status>
</kw>
<msg timestamp="20190402 05:35:44.527" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:44.527" starttime="20190402 05:35:44.524"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:44.528" starttime="20190402 05:35:44.528"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:44.528" starttime="20190402 05:35:44.527"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:44.528" starttime="20190402 05:35:44.528"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:44.529" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| device_node | /dev/sda6                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 20480                                            |
| uuid        | 37bf735d-2aa0-4c66-96fa-ec12d5420656             |
| ihost_uuid  | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd             |
| idisk_uuid  | 59c21ecb-ddc2-4855-9798-ada28b56ee4d             |
| ipv_uuid    | None                                             |
| status      | Creating                                         |
| created_at  | 2019-04-02T11:24:28.311921+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:35:44.529" starttime="20190402 05:35:44.528"></status>
</kw>
<msg timestamp="20190402 05:35:44.529" level="INFO">${result} = {u'stdout': u'+-------------+--------------------------------------------------+\r\n| Property    | Value                                            |\r\n+-------------+-------------------------------...</msg>
<status status="PASS" endtime="20190402 05:35:44.529" starttime="20190402 05:35:43.387"></status>
</kw>
<kw name="Get Property From Result" library="Utils">
<arguments>
<arg>${result}</arg>
<arg>uuid</arg>
</arguments>
<assign>
<var>${new_uid}</var>
</assign>
<kw name="String To Dict" library="common">
<doc>Convert string table to dictionary</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 05:35:44.530" level="INFO">${dict} = {'Property': {'status': {'Value': 'Creating'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '37bf735d-2aa0-4c66-96fa-...</msg>
<status status="PASS" endtime="20190402 05:35:44.530" starttime="20190402 05:35:44.529"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Property</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 05:35:44.530" level="INFO">${dict} = {'status': {'Value': 'Creating'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '37bf735d-2aa0-4c66-96fa-ec12d5420656'...</msg>
<status status="PASS" endtime="20190402 05:35:44.530" starttime="20190402 05:35:44.530"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 05:35:44.530" level="INFO">${dict} = {'Value': '37bf735d-2aa0-4c66-96fa-ec12d5420656'}</msg>
<status status="PASS" endtime="20190402 05:35:44.530" starttime="20190402 05:35:44.530"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Value</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 05:35:44.531" level="INFO">${dict} = 37bf735d-2aa0-4c66-96fa-ec12d5420656</msg>
<status status="PASS" endtime="20190402 05:35:44.531" starttime="20190402 05:35:44.530"></status>
</kw>
<msg timestamp="20190402 05:35:44.531" level="INFO">${new_uid} = 37bf735d-2aa0-4c66-96fa-ec12d5420656</msg>
<status status="PASS" endtime="20190402 05:35:44.531" starttime="20190402 05:35:44.529"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>30 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value Of Command</arg>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:44.533" starttime="20190402 05:35:44.532"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:44.533" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:44.533" starttime="20190402 05:35:44.533"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:44.534" starttime="20190402 05:35:44.534"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:44.534" starttime="20190402 05:35:44.534"></status>
</kw>
<msg timestamp="20190402 05:35:44.534" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:44.534" starttime="20190402 05:35:44.533"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:44.535" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:44.535" starttime="20190402 05:35:44.534"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:44.552" level="INFO">system host-disk-partition-show contro ller-0 37bf735d-2aa0-4c66-96fa-ec12d5420656 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:35:44.552" starttime="20190402 05:35:44.535"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:45.595" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:45.596" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:45.596" starttime="20190402 05:35:44.552"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:45.596" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:45.596" starttime="20190402 05:35:45.596"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:45.597" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190402 05:35:45.597" starttime="20190402 05:35:45.596"></status>
</kw>
<msg timestamp="20190402 05:35:45.597" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190402 05:35:45.597" starttime="20190402 05:35:45.596"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:45.598" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:45.598" starttime="20190402 05:35:45.597"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:45.599" level="INFO">0</msg>
<msg timestamp="20190402 05:35:45.599" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:45.599" starttime="20190402 05:35:45.598"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:45.600" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:45.600" starttime="20190402 05:35:45.599"></status>
</kw>
<msg timestamp="20190402 05:35:45.600" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:45.600" starttime="20190402 05:35:45.597"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:45.601" starttime="20190402 05:35:45.600"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:45.601" starttime="20190402 05:35:45.600"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:45.601" starttime="20190402 05:35:45.601"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:45.601" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190402 05:35:45.601" starttime="20190402 05:35:45.601"></status>
</kw>
<msg timestamp="20190402 05:35:45.601" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:35:45.602" starttime="20190402 05:35:44.532"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:35:45.602" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190402 05:35:45.602" starttime="20190402 05:35:45.602"></status>
</kw>
<msg timestamp="20190402 05:35:45.602" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190402 05:35:45.602" starttime="20190402 05:35:44.532"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:35:45.602" level="FAIL">Creating != Ready</msg>
<status status="FAIL" endtime="20190402 05:35:45.603" starttime="20190402 05:35:45.602"></status>
</kw>
<status status="FAIL" endtime="20190402 05:35:45.603" starttime="20190402 05:35:44.531"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:55.608" starttime="20190402 05:35:55.608"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:35:55.609" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:35:55.609" starttime="20190402 05:35:55.608"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:55.609" starttime="20190402 05:35:55.609"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:55.610" starttime="20190402 05:35:55.610"></status>
</kw>
<msg timestamp="20190402 05:35:55.610" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:35:55.610" starttime="20190402 05:35:55.608"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:35:55.610" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:55.610" starttime="20190402 05:35:55.610"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:35:55.629" level="INFO">system host-disk-partition-show contro ller-0 37bf735d-2aa0-4c66-96fa-ec12d5420656 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:35:55.629" starttime="20190402 05:35:55.610"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:35:56.660" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:35:56.661" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:56.661" starttime="20190402 05:35:55.629"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:35:56.661" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:35:56.661" starttime="20190402 05:35:56.661"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:35:56.662" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190402 05:35:56.662" starttime="20190402 05:35:56.662"></status>
</kw>
<msg timestamp="20190402 05:35:56.662" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190402 05:35:56.662" starttime="20190402 05:35:56.661"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:35:56.664" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:35:56.664" starttime="20190402 05:35:56.662"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:35:56.664" level="INFO">0</msg>
<msg timestamp="20190402 05:35:56.664" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:56.664" starttime="20190402 05:35:56.664"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:35:56.665" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:35:56.665" starttime="20190402 05:35:56.665"></status>
</kw>
<msg timestamp="20190402 05:35:56.665" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:35:56.665" starttime="20190402 05:35:56.662"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:56.666" starttime="20190402 05:35:56.665"></status>
</kw>
<status status="PASS" endtime="20190402 05:35:56.666" starttime="20190402 05:35:56.665"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:35:56.666" starttime="20190402 05:35:56.666"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:35:56.666" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190402 05:35:56.666" starttime="20190402 05:35:56.666"></status>
</kw>
<msg timestamp="20190402 05:35:56.667" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:35:56.667" starttime="20190402 05:35:55.606"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:35:56.667" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190402 05:35:56.667" starttime="20190402 05:35:56.667"></status>
</kw>
<msg timestamp="20190402 05:35:56.667" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190402 05:35:56.667" starttime="20190402 05:35:55.605"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:35:56.668" level="FAIL">Creating != Ready</msg>
<status status="FAIL" endtime="20190402 05:35:56.668" starttime="20190402 05:35:56.667"></status>
</kw>
<status status="FAIL" endtime="20190402 05:35:56.668" starttime="20190402 05:35:55.603"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:06.673" starttime="20190402 05:36:06.673"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:36:06.674" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:36:06.674" starttime="20190402 05:36:06.673"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:06.674" starttime="20190402 05:36:06.674"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:06.675" starttime="20190402 05:36:06.674"></status>
</kw>
<msg timestamp="20190402 05:36:06.675" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:36:06.675" starttime="20190402 05:36:06.673"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:36:06.675" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:06.675" starttime="20190402 05:36:06.675"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:36:06.693" level="INFO">system host-disk-partition-show contro ller-0 37bf735d-2aa0-4c66-96fa-ec12d5420656 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:36:06.693" starttime="20190402 05:36:06.675"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:36:07.732" level="INFO">Ready
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:36:07.732" level="INFO">${output} = Ready
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:07.732" starttime="20190402 05:36:06.693"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:36:07.733" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:07.733" starttime="20190402 05:36:07.733"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:36:07.733" level="INFO">${clean_out} = Ready
</msg>
<status status="PASS" endtime="20190402 05:36:07.733" starttime="20190402 05:36:07.733"></status>
</kw>
<msg timestamp="20190402 05:36:07.733" level="INFO">${output} = Ready
</msg>
<status status="PASS" endtime="20190402 05:36:07.734" starttime="20190402 05:36:07.732"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:36:07.735" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:36:07.735" starttime="20190402 05:36:07.734"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:36:07.736" level="INFO">0</msg>
<msg timestamp="20190402 05:36:07.736" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:07.736" starttime="20190402 05:36:07.735"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:36:07.736" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:36:07.736" starttime="20190402 05:36:07.736"></status>
</kw>
<msg timestamp="20190402 05:36:07.736" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:07.736" starttime="20190402 05:36:07.734"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:07.737" starttime="20190402 05:36:07.737"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:07.737" starttime="20190402 05:36:07.736"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:07.737" starttime="20190402 05:36:07.737"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:36:07.738" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Ready</msg>
<status status="PASS" endtime="20190402 05:36:07.738" starttime="20190402 05:36:07.738"></status>
</kw>
<msg timestamp="20190402 05:36:07.738" level="INFO">${result} = {u'stdout': u'Ready', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:36:07.738" starttime="20190402 05:36:06.671"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:36:07.738" level="INFO">${value} = Ready</msg>
<status status="PASS" endtime="20190402 05:36:07.738" starttime="20190402 05:36:07.738"></status>
</kw>
<msg timestamp="20190402 05:36:07.738" level="INFO">${current_value} = Ready</msg>
<status status="PASS" endtime="20190402 05:36:07.738" starttime="20190402 05:36:06.670"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:07.739" starttime="20190402 05:36:07.739"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:07.739" starttime="20190402 05:36:06.668"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:07.739" starttime="20190402 05:35:44.531"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:07.739" starttime="20190402 05:35:43.386"></status>
</kw>
<msg timestamp="20190402 05:36:07.739" level="INFO">${cgts_partition_uuid} = 37bf735d-2aa0-4c66-96fa-ec12d5420656</msg>
<status status="PASS" endtime="20190402 05:36:07.739" starttime="20190402 05:35:43.386"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True or ${setup_cgts}==True</arg>
<arg>Add Physical Volume</arg>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${cgts_partition_uuid}</arg>
</arguments>
<kw name="Add Physical Volume" library="Utils">
<doc>Adds a physical volume to the specified host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${cgts_partition_uuid}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-pv-add ${host} ${lvg name} ${uid}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:07.741" starttime="20190402 05:36:07.740"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:36:07.741" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:36:07.741" starttime="20190402 05:36:07.741"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:07.742" starttime="20190402 05:36:07.741"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:07.742" starttime="20190402 05:36:07.742"></status>
</kw>
<msg timestamp="20190402 05:36:07.742" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:36:07.742" starttime="20190402 05:36:07.741"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:36:07.742" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:07.742" starttime="20190402 05:36:07.742"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:36:07.753" level="INFO">system host-pv-add controller-0 nova-l ocal 37bf735d-2aa0-4c66-96fa-ec12d5420656</msg>
<status status="PASS" endtime="20190402 05:36:07.754" starttime="20190402 05:36:07.743"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:36:08.898" level="INFO">+--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | 3654b23d-951a-4f02-82a5-ac9700e16979             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 37bf735d-2aa0-4c66-96fa-ec12d5420656             |
| disk_or_part_device_node | /dev/sda6                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| lvm_pv_name              | /dev/sda6                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd             |
| created_at               | 2019-04-02T11:24:52.683184+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:36:08.899" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 05:36:08.899" starttime="20190402 05:36:07.754"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:36:08.899" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:08.900" starttime="20190402 05:36:08.899"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:36:08.900" level="INFO">${clean_out} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 05:36:08.900" starttime="20190402 05:36:08.900"></status>
</kw>
<msg timestamp="20190402 05:36:08.900" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 05:36:08.900" starttime="20190402 05:36:08.899"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:36:08.902" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:36:08.902" starttime="20190402 05:36:08.901"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:36:08.902" level="INFO">0</msg>
<msg timestamp="20190402 05:36:08.903" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:08.903" starttime="20190402 05:36:08.902"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:36:08.903" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:36:08.903" starttime="20190402 05:36:08.903"></status>
</kw>
<msg timestamp="20190402 05:36:08.903" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:08.903" starttime="20190402 05:36:08.900"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:08.904" starttime="20190402 05:36:08.904"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:08.904" starttime="20190402 05:36:08.903"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:08.904" starttime="20190402 05:36:08.904"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:36:08.905" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | 3654b23d-951a-4f02-82a5-ac9700e16979             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 37bf735d-2aa0-4c66-96fa-ec12d5420656             |
| disk_or_part_device_node | /dev/sda6                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| lvm_pv_name              | /dev/sda6                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd             |
| created_at               | 2019-04-02T11:24:52.683184+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:36:08.905" starttime="20190402 05:36:08.904"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:08.905" starttime="20190402 05:36:07.740"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:08.905" starttime="20190402 05:36:07.740"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:08.905" starttime="20190402 05:36:07.739"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:08.905" starttime="20190402 05:35:13.197"></status>
</kw>
<kw name="Configure Ceph" library="Utils">
<doc>Enable CEPH partition on the specified node</doc>
<arguments>
<arg>${master_controller}</arg>
<arg>${backend_type}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-0'</arg>
<arg>Run Keywords</arg>
<arg>Add LVM Storage Backend</arg>
<arg>${backend_type}</arg>
<arg>--confirmed</arg>
<arg>AND</arg>
<arg>Check Ceph Status</arg>
<arg>HEALTH_ERR</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Add LVM Storage Backend</arg>
<arg>${backend_type}</arg>
<arg>--confirmed</arg>
<arg>AND</arg>
<arg>Check Ceph Status</arg>
<arg>HEALTH_ERR</arg>
</arguments>
<kw name="Add LVM Storage Backend" library="Utils">
<doc>Adds the LVM storage backend with specified arguments</doc>
<arguments>
<arg>${backend_type}</arg>
<arg>--confirmed</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system storage-backend-add ${backend} ${args}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:08.907" starttime="20190402 05:36:08.907"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:36:08.907" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:36:08.907" starttime="20190402 05:36:08.907"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:08.908" starttime="20190402 05:36:08.908"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:08.908" starttime="20190402 05:36:08.908"></status>
</kw>
<msg timestamp="20190402 05:36:08.908" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:36:08.908" starttime="20190402 05:36:08.907"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:36:08.909" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:08.909" starttime="20190402 05:36:08.908"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:36:08.915" level="INFO">system storage-backend-add ceph --conf irmed</msg>
<status status="PASS" endtime="20190402 05:36:08.915" starttime="20190402 05:36:08.909"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:36:12.745" level="INFO">System configuration has changed.
Please follow the administrator guide to complete configuring the system.

+--------------------------------------+------------+---------+-------------+------+----------+--------------------+
| uuid                                 | name       | backend | state       | task | services | capabilities       |
+--------------------------------------+------------+---------+-------------+------+----------+--------------------+
| 75981062-d688-4d6d-b1b2-32887c1200db | file-store | file    | configured  | None | glance   |                    |
| e38d5d2f-3433-43e4-aaf3-4e4d3a634acd | ceph-store | ceph    | configuring | {}   | None     | min_replication: 1 |
|                                      |            |         |             |      |          | replication: 2     |
+--------------------------------------+------------+---------+-------------+------+----------+--------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:36:12.746" level="INFO">${output} = 
System configuration has changed.
Please follow the administrator guide to complete configuring the system.

+--------------------------------------+------------+---------+-------------+------+--...</msg>
<status status="PASS" endtime="20190402 05:36:12.746" starttime="20190402 05:36:08.916"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:36:12.747" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:12.747" starttime="20190402 05:36:12.746"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:36:12.747" level="INFO">${clean_out} = 
System configuration has changed.
Please follow the administrator guide to complete configuring the system.

+--------------------------------------+------------+---------+-------------+------+--...</msg>
<status status="PASS" endtime="20190402 05:36:12.747" starttime="20190402 05:36:12.747"></status>
</kw>
<msg timestamp="20190402 05:36:12.747" level="INFO">${output} = 
System configuration has changed.
Please follow the administrator guide to complete configuring the system.

+--------------------------------------+------------+---------+-------------+------+--...</msg>
<status status="PASS" endtime="20190402 05:36:12.747" starttime="20190402 05:36:12.746"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:36:12.749" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:36:12.749" starttime="20190402 05:36:12.748"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:36:12.750" level="INFO">0</msg>
<msg timestamp="20190402 05:36:12.750" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:12.750" starttime="20190402 05:36:12.749"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:36:12.751" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:36:12.751" starttime="20190402 05:36:12.750"></status>
</kw>
<msg timestamp="20190402 05:36:12.751" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:12.751" starttime="20190402 05:36:12.747"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:12.752" starttime="20190402 05:36:12.751"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:12.752" starttime="20190402 05:36:12.751"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:12.752" starttime="20190402 05:36:12.752"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:36:12.752" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: System configuration has changed.
Please follow the administrator guide to complete configuring the system.

+--------------------------------------+------------+---------+-------------+------+----------+--------------------+
| uuid                                 | name       | backend | state       | task | services | capabilities       |
+--------------------------------------+------------+---------+-------------+------+----------+--------------------+
| 75981062-d688-4d6d-b1b2-32887c1200db | file-store | file    | configured  | None | glance   |                    |
| e38d5d2f-3433-43e4-aaf3-4e4d3a634acd | ceph-store | ceph    | configuring | {}   | None     | min_replication: 1 |
|                                      |            |         |             |      |          | replication: 2     |
+--------------------------------------+------------+---------+-------------+------+----------+--------------------+</msg>
<status status="PASS" endtime="20190402 05:36:12.752" starttime="20190402 05:36:12.752"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:12.753" starttime="20190402 05:36:08.906"></status>
</kw>
<kw name="Get LVM Storage Backend UID" library="Utils">
<doc>Returns the UID of the specified Backend.</doc>
<arguments>
<arg>${backend}</arg>
</arguments>
<assign>
<var>${name}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system storage-backend-list | grep ${backend} | awk '{print $2}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:12.754" starttime="20190402 05:36:12.754"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:36:12.754" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:36:12.755" starttime="20190402 05:36:12.754"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:12.755" starttime="20190402 05:36:12.755"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:12.755" starttime="20190402 05:36:12.755"></status>
</kw>
<msg timestamp="20190402 05:36:12.755" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:36:12.755" starttime="20190402 05:36:12.754"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:36:12.756" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:12.756" starttime="20190402 05:36:12.756"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:36:12.765" level="INFO">system storage-backend-list | grep cep h | awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 05:36:12.765" starttime="20190402 05:36:12.756"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:36:13.897" level="INFO">e38d5d2f-3433-43e4-aaf3-4e4d3a634acd
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:36:13.897" level="INFO">${output} = e38d5d2f-3433-43e4-aaf3-4e4d3a634acd
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:13.898" starttime="20190402 05:36:12.765"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:36:13.898" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:13.898" starttime="20190402 05:36:13.898"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:36:13.899" level="INFO">${clean_out} = e38d5d2f-3433-43e4-aaf3-4e4d3a634acd
</msg>
<status status="PASS" endtime="20190402 05:36:13.899" starttime="20190402 05:36:13.898"></status>
</kw>
<msg timestamp="20190402 05:36:13.899" level="INFO">${output} = e38d5d2f-3433-43e4-aaf3-4e4d3a634acd
</msg>
<status status="PASS" endtime="20190402 05:36:13.899" starttime="20190402 05:36:13.898"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:36:13.901" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:36:13.901" starttime="20190402 05:36:13.899"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:36:13.902" level="INFO">0</msg>
<msg timestamp="20190402 05:36:13.902" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:13.902" starttime="20190402 05:36:13.901"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:36:13.902" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:36:13.902" starttime="20190402 05:36:13.902"></status>
</kw>
<msg timestamp="20190402 05:36:13.902" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:13.902" starttime="20190402 05:36:13.899"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:13.903" starttime="20190402 05:36:13.903"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:13.903" starttime="20190402 05:36:13.902"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:13.903" starttime="20190402 05:36:13.903"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:36:13.904" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: e38d5d2f-3433-43e4-aaf3-4e4d3a634acd</msg>
<status status="PASS" endtime="20190402 05:36:13.904" starttime="20190402 05:36:13.903"></status>
</kw>
<msg timestamp="20190402 05:36:13.904" level="INFO">${result} = {u'stdout': u'e38d5d2f-3433-43e4-aaf3-4e4d3a634acd', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:36:13.904" starttime="20190402 05:36:12.753"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:36:13.904" level="INFO">${value} = e38d5d2f-3433-43e4-aaf3-4e4d3a634acd</msg>
<status status="PASS" endtime="20190402 05:36:13.904" starttime="20190402 05:36:13.904"></status>
</kw>
<msg timestamp="20190402 05:36:13.904" level="INFO">${name} = e38d5d2f-3433-43e4-aaf3-4e4d3a634acd</msg>
<status status="PASS" endtime="20190402 05:36:13.904" starttime="20190402 05:36:12.753"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>30 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value Of Command</arg>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:13.906" starttime="20190402 05:36:13.906"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:36:13.907" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:36:13.907" starttime="20190402 05:36:13.906"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:13.907" starttime="20190402 05:36:13.907"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:13.908" starttime="20190402 05:36:13.907"></status>
</kw>
<msg timestamp="20190402 05:36:13.908" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:36:13.908" starttime="20190402 05:36:13.906"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:36:13.908" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:13.908" starttime="20190402 05:36:13.908"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:36:13.922" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:36:13.922" starttime="20190402 05:36:13.908"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:36:15.018" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:36:15.018" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:15.018" starttime="20190402 05:36:13.922"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:36:15.019" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:15.019" starttime="20190402 05:36:15.019"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:36:15.019" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:36:15.020" starttime="20190402 05:36:15.019"></status>
</kw>
<msg timestamp="20190402 05:36:15.020" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:36:15.020" starttime="20190402 05:36:15.019"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:36:15.021" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:36:15.021" starttime="20190402 05:36:15.020"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:36:15.022" level="INFO">0</msg>
<msg timestamp="20190402 05:36:15.022" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:15.022" starttime="20190402 05:36:15.021"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:36:15.022" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:36:15.022" starttime="20190402 05:36:15.022"></status>
</kw>
<msg timestamp="20190402 05:36:15.023" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:15.023" starttime="20190402 05:36:15.020"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:15.023" starttime="20190402 05:36:15.023"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:15.023" starttime="20190402 05:36:15.023"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:15.024" starttime="20190402 05:36:15.024"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:36:15.024" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:36:15.024" starttime="20190402 05:36:15.024"></status>
</kw>
<msg timestamp="20190402 05:36:15.024" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:36:15.024" starttime="20190402 05:36:13.906"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:36:15.025" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:36:15.025" starttime="20190402 05:36:15.024"></status>
</kw>
<msg timestamp="20190402 05:36:15.025" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:36:15.025" starttime="20190402 05:36:13.905"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:36:15.025" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:36:15.025" starttime="20190402 05:36:15.025"></status>
</kw>
<status status="FAIL" endtime="20190402 05:36:15.025" starttime="20190402 05:36:13.905"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:25.031" starttime="20190402 05:36:25.031"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:36:25.032" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:36:25.032" starttime="20190402 05:36:25.032"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:25.032" starttime="20190402 05:36:25.032"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:25.033" starttime="20190402 05:36:25.032"></status>
</kw>
<msg timestamp="20190402 05:36:25.033" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:36:25.033" starttime="20190402 05:36:25.031"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:36:25.033" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:25.033" starttime="20190402 05:36:25.033"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:36:25.047" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:36:25.047" starttime="20190402 05:36:25.033"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:36:26.122" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:36:26.122" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:26.122" starttime="20190402 05:36:25.047"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:36:26.123" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:26.123" starttime="20190402 05:36:26.122"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:36:26.123" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:36:26.123" starttime="20190402 05:36:26.123"></status>
</kw>
<msg timestamp="20190402 05:36:26.123" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:36:26.123" starttime="20190402 05:36:26.122"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:36:26.125" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:36:26.125" starttime="20190402 05:36:26.123"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:36:26.126" level="INFO">0</msg>
<msg timestamp="20190402 05:36:26.126" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:26.126" starttime="20190402 05:36:26.125"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:36:26.126" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:36:26.126" starttime="20190402 05:36:26.126"></status>
</kw>
<msg timestamp="20190402 05:36:26.126" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:26.126" starttime="20190402 05:36:26.123"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:26.127" starttime="20190402 05:36:26.127"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:26.127" starttime="20190402 05:36:26.126"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:26.127" starttime="20190402 05:36:26.127"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:36:26.128" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:36:26.128" starttime="20190402 05:36:26.127"></status>
</kw>
<msg timestamp="20190402 05:36:26.128" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:36:26.128" starttime="20190402 05:36:25.029"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:36:26.128" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:36:26.128" starttime="20190402 05:36:26.128"></status>
</kw>
<msg timestamp="20190402 05:36:26.128" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:36:26.128" starttime="20190402 05:36:25.028"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:36:26.129" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:36:26.129" starttime="20190402 05:36:26.128"></status>
</kw>
<status status="FAIL" endtime="20190402 05:36:26.129" starttime="20190402 05:36:25.026"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:36.135" starttime="20190402 05:36:36.134"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:36:36.139" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:36:36.140" starttime="20190402 05:36:36.137"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:36.142" starttime="20190402 05:36:36.140"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:36.144" starttime="20190402 05:36:36.142"></status>
</kw>
<msg timestamp="20190402 05:36:36.144" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:36:36.145" starttime="20190402 05:36:36.135"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:36:36.145" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:36.146" starttime="20190402 05:36:36.145"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:36:36.183" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:36:36.183" starttime="20190402 05:36:36.146"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:36:37.230" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:36:37.231" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:37.231" starttime="20190402 05:36:36.183"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:36:37.231" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:37.231" starttime="20190402 05:36:37.231"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:36:37.232" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:36:37.232" starttime="20190402 05:36:37.231"></status>
</kw>
<msg timestamp="20190402 05:36:37.232" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:36:37.232" starttime="20190402 05:36:37.231"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:36:37.234" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:36:37.234" starttime="20190402 05:36:37.232"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:36:37.234" level="INFO">0</msg>
<msg timestamp="20190402 05:36:37.234" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:37.234" starttime="20190402 05:36:37.234"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:36:37.234" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:36:37.235" starttime="20190402 05:36:37.234"></status>
</kw>
<msg timestamp="20190402 05:36:37.235" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:37.235" starttime="20190402 05:36:37.232"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:37.235" starttime="20190402 05:36:37.235"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:37.236" starttime="20190402 05:36:37.235"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:37.236" starttime="20190402 05:36:37.236"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:36:37.236" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:36:37.236" starttime="20190402 05:36:37.236"></status>
</kw>
<msg timestamp="20190402 05:36:37.236" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:36:37.236" starttime="20190402 05:36:36.132"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:36:37.237" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:36:37.237" starttime="20190402 05:36:37.236"></status>
</kw>
<msg timestamp="20190402 05:36:37.237" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:36:37.237" starttime="20190402 05:36:36.131"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:36:37.237" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:36:37.237" starttime="20190402 05:36:37.237"></status>
</kw>
<status status="FAIL" endtime="20190402 05:36:37.237" starttime="20190402 05:36:36.130"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:47.246" starttime="20190402 05:36:47.245"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:36:47.249" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:36:47.249" starttime="20190402 05:36:47.248"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:47.252" starttime="20190402 05:36:47.250"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:47.254" starttime="20190402 05:36:47.253"></status>
</kw>
<msg timestamp="20190402 05:36:47.254" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:36:47.255" starttime="20190402 05:36:47.247"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:36:47.255" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:47.256" starttime="20190402 05:36:47.255"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:36:47.295" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:36:47.295" starttime="20190402 05:36:47.256"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:36:48.336" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:36:48.336" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:48.336" starttime="20190402 05:36:47.296"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:36:48.337" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:48.337" starttime="20190402 05:36:48.337"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:36:48.337" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:36:48.337" starttime="20190402 05:36:48.337"></status>
</kw>
<msg timestamp="20190402 05:36:48.337" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:36:48.337" starttime="20190402 05:36:48.336"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:36:48.339" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:36:48.340" starttime="20190402 05:36:48.338"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:36:48.340" level="INFO">0</msg>
<msg timestamp="20190402 05:36:48.340" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:48.340" starttime="20190402 05:36:48.340"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:36:48.340" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:36:48.341" starttime="20190402 05:36:48.340"></status>
</kw>
<msg timestamp="20190402 05:36:48.341" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:48.341" starttime="20190402 05:36:48.338"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:48.341" starttime="20190402 05:36:48.341"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:48.341" starttime="20190402 05:36:48.341"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:48.342" starttime="20190402 05:36:48.342"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:36:48.342" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:36:48.342" starttime="20190402 05:36:48.342"></status>
</kw>
<msg timestamp="20190402 05:36:48.342" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:36:48.342" starttime="20190402 05:36:47.243"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:36:48.343" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:36:48.343" starttime="20190402 05:36:48.342"></status>
</kw>
<msg timestamp="20190402 05:36:48.343" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:36:48.343" starttime="20190402 05:36:47.241"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:36:48.343" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:36:48.343" starttime="20190402 05:36:48.343"></status>
</kw>
<status status="FAIL" endtime="20190402 05:36:48.343" starttime="20190402 05:36:47.238"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:58.349" starttime="20190402 05:36:58.349"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:36:58.350" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:36:58.350" starttime="20190402 05:36:58.349"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:58.350" starttime="20190402 05:36:58.350"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:58.351" starttime="20190402 05:36:58.350"></status>
</kw>
<msg timestamp="20190402 05:36:58.351" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:36:58.351" starttime="20190402 05:36:58.349"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:36:58.351" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:58.351" starttime="20190402 05:36:58.351"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:36:58.369" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:36:58.369" starttime="20190402 05:36:58.351"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:36:59.429" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:36:59.430" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:59.430" starttime="20190402 05:36:58.369"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:36:59.430" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:36:59.430" starttime="20190402 05:36:59.430"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:36:59.431" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:36:59.431" starttime="20190402 05:36:59.431"></status>
</kw>
<msg timestamp="20190402 05:36:59.431" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:36:59.431" starttime="20190402 05:36:59.430"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:36:59.433" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:36:59.433" starttime="20190402 05:36:59.431"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:36:59.434" level="INFO">0</msg>
<msg timestamp="20190402 05:36:59.434" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:59.434" starttime="20190402 05:36:59.434"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:36:59.434" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:36:59.434" starttime="20190402 05:36:59.434"></status>
</kw>
<msg timestamp="20190402 05:36:59.435" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:36:59.435" starttime="20190402 05:36:59.431"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:59.435" starttime="20190402 05:36:59.435"></status>
</kw>
<status status="PASS" endtime="20190402 05:36:59.435" starttime="20190402 05:36:59.435"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:36:59.436" starttime="20190402 05:36:59.435"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:36:59.436" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:36:59.436" starttime="20190402 05:36:59.436"></status>
</kw>
<msg timestamp="20190402 05:36:59.436" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:36:59.436" starttime="20190402 05:36:58.347"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:36:59.436" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:36:59.437" starttime="20190402 05:36:59.436"></status>
</kw>
<msg timestamp="20190402 05:36:59.437" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:36:59.437" starttime="20190402 05:36:58.346"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:36:59.437" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:36:59.437" starttime="20190402 05:36:59.437"></status>
</kw>
<status status="FAIL" endtime="20190402 05:36:59.437" starttime="20190402 05:36:58.344"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:09.443" starttime="20190402 05:37:09.443"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:37:09.444" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:37:09.444" starttime="20190402 05:37:09.443"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:09.444" starttime="20190402 05:37:09.444"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:09.444" starttime="20190402 05:37:09.444"></status>
</kw>
<msg timestamp="20190402 05:37:09.445" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:37:09.445" starttime="20190402 05:37:09.443"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:37:09.445" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:09.445" starttime="20190402 05:37:09.445"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:37:09.460" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:37:09.460" starttime="20190402 05:37:09.445"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:37:10.539" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:37:10.539" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:10.539" starttime="20190402 05:37:09.460"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:37:10.540" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:10.540" starttime="20190402 05:37:10.540"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:37:10.540" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:37:10.540" starttime="20190402 05:37:10.540"></status>
</kw>
<msg timestamp="20190402 05:37:10.541" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:37:10.541" starttime="20190402 05:37:10.539"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:37:10.542" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:37:10.543" starttime="20190402 05:37:10.541"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:37:10.543" level="INFO">0</msg>
<msg timestamp="20190402 05:37:10.543" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:37:10.543" starttime="20190402 05:37:10.543"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:37:10.543" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:37:10.543" starttime="20190402 05:37:10.543"></status>
</kw>
<msg timestamp="20190402 05:37:10.544" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:37:10.544" starttime="20190402 05:37:10.541"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:10.544" starttime="20190402 05:37:10.544"></status>
</kw>
<status status="PASS" endtime="20190402 05:37:10.544" starttime="20190402 05:37:10.544"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:10.545" starttime="20190402 05:37:10.545"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:37:10.545" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:37:10.545" starttime="20190402 05:37:10.545"></status>
</kw>
<msg timestamp="20190402 05:37:10.545" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:37:10.545" starttime="20190402 05:37:09.441"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:37:10.546" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:37:10.546" starttime="20190402 05:37:10.545"></status>
</kw>
<msg timestamp="20190402 05:37:10.546" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:37:10.546" starttime="20190402 05:37:09.440"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:37:10.546" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:37:10.546" starttime="20190402 05:37:10.546"></status>
</kw>
<status status="FAIL" endtime="20190402 05:37:10.546" starttime="20190402 05:37:09.438"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:20.552" starttime="20190402 05:37:20.552"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:37:20.553" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:37:20.553" starttime="20190402 05:37:20.553"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:20.553" starttime="20190402 05:37:20.553"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:20.554" starttime="20190402 05:37:20.553"></status>
</kw>
<msg timestamp="20190402 05:37:20.554" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:37:20.554" starttime="20190402 05:37:20.552"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:37:20.554" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:20.554" starttime="20190402 05:37:20.554"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:37:20.569" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:37:20.569" starttime="20190402 05:37:20.554"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:37:21.680" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:37:21.680" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:21.680" starttime="20190402 05:37:20.569"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:37:21.681" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:21.681" starttime="20190402 05:37:21.681"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:37:21.682" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:37:21.682" starttime="20190402 05:37:21.681"></status>
</kw>
<msg timestamp="20190402 05:37:21.682" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:37:21.682" starttime="20190402 05:37:21.681"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:37:21.683" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:37:21.683" starttime="20190402 05:37:21.682"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:37:21.684" level="INFO">0</msg>
<msg timestamp="20190402 05:37:21.684" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:37:21.685" starttime="20190402 05:37:21.684"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:37:21.685" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:37:21.685" starttime="20190402 05:37:21.685"></status>
</kw>
<msg timestamp="20190402 05:37:21.685" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:37:21.685" starttime="20190402 05:37:21.682"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:21.686" starttime="20190402 05:37:21.686"></status>
</kw>
<status status="PASS" endtime="20190402 05:37:21.686" starttime="20190402 05:37:21.685"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:21.686" starttime="20190402 05:37:21.686"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:37:21.686" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:37:21.686" starttime="20190402 05:37:21.686"></status>
</kw>
<msg timestamp="20190402 05:37:21.687" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:37:21.687" starttime="20190402 05:37:20.550"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:37:21.687" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:37:21.687" starttime="20190402 05:37:21.687"></status>
</kw>
<msg timestamp="20190402 05:37:21.687" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:37:21.687" starttime="20190402 05:37:20.549"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:37:21.688" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:37:21.688" starttime="20190402 05:37:21.687"></status>
</kw>
<status status="FAIL" endtime="20190402 05:37:21.688" starttime="20190402 05:37:20.547"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:31.693" starttime="20190402 05:37:31.693"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:37:31.694" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:37:31.694" starttime="20190402 05:37:31.694"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:31.694" starttime="20190402 05:37:31.694"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:31.695" starttime="20190402 05:37:31.695"></status>
</kw>
<msg timestamp="20190402 05:37:31.695" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:37:31.695" starttime="20190402 05:37:31.693"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:37:31.695" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:31.695" starttime="20190402 05:37:31.695"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:37:31.714" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:37:31.714" starttime="20190402 05:37:31.695"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:37:32.789" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:37:32.790" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:32.790" starttime="20190402 05:37:31.714"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:37:32.790" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:32.790" starttime="20190402 05:37:32.790"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:37:32.791" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:37:32.791" starttime="20190402 05:37:32.791"></status>
</kw>
<msg timestamp="20190402 05:37:32.791" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:37:32.791" starttime="20190402 05:37:32.790"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:37:32.793" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:37:32.793" starttime="20190402 05:37:32.791"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:37:32.793" level="INFO">0</msg>
<msg timestamp="20190402 05:37:32.794" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:37:32.794" starttime="20190402 05:37:32.793"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:37:32.794" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:37:32.794" starttime="20190402 05:37:32.794"></status>
</kw>
<msg timestamp="20190402 05:37:32.794" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:37:32.794" starttime="20190402 05:37:32.791"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:32.795" starttime="20190402 05:37:32.795"></status>
</kw>
<status status="PASS" endtime="20190402 05:37:32.795" starttime="20190402 05:37:32.794"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:32.796" starttime="20190402 05:37:32.795"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:37:32.796" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:37:32.796" starttime="20190402 05:37:32.796"></status>
</kw>
<msg timestamp="20190402 05:37:32.796" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:37:32.796" starttime="20190402 05:37:31.691"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:37:32.796" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:37:32.796" starttime="20190402 05:37:32.796"></status>
</kw>
<msg timestamp="20190402 05:37:32.797" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:37:32.797" starttime="20190402 05:37:31.690"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:37:32.797" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:37:32.797" starttime="20190402 05:37:32.797"></status>
</kw>
<status status="FAIL" endtime="20190402 05:37:32.797" starttime="20190402 05:37:31.689"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:42.803" starttime="20190402 05:37:42.802"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:37:42.804" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:37:42.804" starttime="20190402 05:37:42.803"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:42.804" starttime="20190402 05:37:42.804"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:42.804" starttime="20190402 05:37:42.804"></status>
</kw>
<msg timestamp="20190402 05:37:42.805" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:37:42.805" starttime="20190402 05:37:42.803"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:37:42.805" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:42.805" starttime="20190402 05:37:42.805"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:37:42.821" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:37:42.821" starttime="20190402 05:37:42.805"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:37:43.902" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:37:43.902" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:43.902" starttime="20190402 05:37:42.821"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:37:43.903" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:43.903" starttime="20190402 05:37:43.902"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:37:43.903" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:37:43.903" starttime="20190402 05:37:43.903"></status>
</kw>
<msg timestamp="20190402 05:37:43.903" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:37:43.903" starttime="20190402 05:37:43.902"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:37:43.905" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:37:43.905" starttime="20190402 05:37:43.904"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:37:43.906" level="INFO">0</msg>
<msg timestamp="20190402 05:37:43.906" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:37:43.906" starttime="20190402 05:37:43.906"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:37:43.906" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:37:43.906" starttime="20190402 05:37:43.906"></status>
</kw>
<msg timestamp="20190402 05:37:43.906" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:37:43.906" starttime="20190402 05:37:43.903"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:43.907" starttime="20190402 05:37:43.907"></status>
</kw>
<status status="PASS" endtime="20190402 05:37:43.907" starttime="20190402 05:37:43.907"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:43.908" starttime="20190402 05:37:43.907"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:37:43.908" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:37:43.908" starttime="20190402 05:37:43.908"></status>
</kw>
<msg timestamp="20190402 05:37:43.908" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:37:43.908" starttime="20190402 05:37:42.801"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:37:43.908" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:37:43.908" starttime="20190402 05:37:43.908"></status>
</kw>
<msg timestamp="20190402 05:37:43.909" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:37:43.909" starttime="20190402 05:37:42.799"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:37:43.909" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:37:43.909" starttime="20190402 05:37:43.909"></status>
</kw>
<status status="FAIL" endtime="20190402 05:37:43.909" starttime="20190402 05:37:42.798"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:53.915" starttime="20190402 05:37:53.915"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:37:53.916" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:37:53.916" starttime="20190402 05:37:53.916"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:53.916" starttime="20190402 05:37:53.916"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:53.917" starttime="20190402 05:37:53.917"></status>
</kw>
<msg timestamp="20190402 05:37:53.917" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:37:53.917" starttime="20190402 05:37:53.915"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:37:53.917" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:53.917" starttime="20190402 05:37:53.917"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:37:53.933" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:37:53.933" starttime="20190402 05:37:53.917"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:37:55.002" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:37:55.002" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:55.002" starttime="20190402 05:37:53.933"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:37:55.003" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:37:55.003" starttime="20190402 05:37:55.003"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:37:55.004" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:37:55.004" starttime="20190402 05:37:55.003"></status>
</kw>
<msg timestamp="20190402 05:37:55.004" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:37:55.004" starttime="20190402 05:37:55.003"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:37:55.006" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:37:55.006" starttime="20190402 05:37:55.004"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:37:55.006" level="INFO">0</msg>
<msg timestamp="20190402 05:37:55.006" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:37:55.006" starttime="20190402 05:37:55.006"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:37:55.006" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:37:55.007" starttime="20190402 05:37:55.006"></status>
</kw>
<msg timestamp="20190402 05:37:55.007" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:37:55.007" starttime="20190402 05:37:55.004"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:55.007" starttime="20190402 05:37:55.007"></status>
</kw>
<status status="PASS" endtime="20190402 05:37:55.008" starttime="20190402 05:37:55.007"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:37:55.008" starttime="20190402 05:37:55.008"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:37:55.008" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:37:55.008" starttime="20190402 05:37:55.008"></status>
</kw>
<msg timestamp="20190402 05:37:55.008" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:37:55.008" starttime="20190402 05:37:53.913"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:37:55.009" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:37:55.009" starttime="20190402 05:37:55.008"></status>
</kw>
<msg timestamp="20190402 05:37:55.009" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:37:55.009" starttime="20190402 05:37:53.912"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:37:55.009" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:37:55.009" starttime="20190402 05:37:55.009"></status>
</kw>
<status status="FAIL" endtime="20190402 05:37:55.010" starttime="20190402 05:37:53.910"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:05.015" starttime="20190402 05:38:05.015"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:05.016" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:05.016" starttime="20190402 05:38:05.016"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:05.016" starttime="20190402 05:38:05.016"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:05.017" starttime="20190402 05:38:05.016"></status>
</kw>
<msg timestamp="20190402 05:38:05.017" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:05.017" starttime="20190402 05:38:05.015"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:05.017" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:05.017" starttime="20190402 05:38:05.017"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:05.036" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:38:05.037" starttime="20190402 05:38:05.017"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:06.193" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:06.193" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:06.193" starttime="20190402 05:38:05.037"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:06.194" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:06.194" starttime="20190402 05:38:06.194"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:06.195" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:38:06.195" starttime="20190402 05:38:06.194"></status>
</kw>
<msg timestamp="20190402 05:38:06.195" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:38:06.195" starttime="20190402 05:38:06.193"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:06.198" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:06.198" starttime="20190402 05:38:06.195"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:06.198" level="INFO">0</msg>
<msg timestamp="20190402 05:38:06.199" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:06.199" starttime="20190402 05:38:06.198"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:06.199" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:06.199" starttime="20190402 05:38:06.199"></status>
</kw>
<msg timestamp="20190402 05:38:06.200" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:06.200" starttime="20190402 05:38:06.195"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:06.201" starttime="20190402 05:38:06.200"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:06.201" starttime="20190402 05:38:06.200"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:06.201" starttime="20190402 05:38:06.201"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:06.202" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:38:06.202" starttime="20190402 05:38:06.202"></status>
</kw>
<msg timestamp="20190402 05:38:06.202" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:38:06.202" starttime="20190402 05:38:05.013"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:38:06.203" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:38:06.203" starttime="20190402 05:38:06.202"></status>
</kw>
<msg timestamp="20190402 05:38:06.203" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:38:06.203" starttime="20190402 05:38:05.012"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:38:06.204" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:38:06.204" starttime="20190402 05:38:06.204"></status>
</kw>
<status status="FAIL" endtime="20190402 05:38:06.204" starttime="20190402 05:38:05.010"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:16.207" starttime="20190402 05:38:16.206"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:16.208" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:16.208" starttime="20190402 05:38:16.207"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:16.208" starttime="20190402 05:38:16.208"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:16.209" starttime="20190402 05:38:16.208"></status>
</kw>
<msg timestamp="20190402 05:38:16.209" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:16.209" starttime="20190402 05:38:16.207"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:16.209" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:16.209" starttime="20190402 05:38:16.209"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:16.229" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:38:16.229" starttime="20190402 05:38:16.209"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:17.302" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:17.302" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:17.302" starttime="20190402 05:38:16.229"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:17.303" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:17.303" starttime="20190402 05:38:17.303"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:17.303" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190402 05:38:17.303" starttime="20190402 05:38:17.303"></status>
</kw>
<msg timestamp="20190402 05:38:17.304" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190402 05:38:17.304" starttime="20190402 05:38:17.302"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:17.306" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:17.306" starttime="20190402 05:38:17.304"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:17.306" level="INFO">0</msg>
<msg timestamp="20190402 05:38:17.307" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:17.307" starttime="20190402 05:38:17.306"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:17.307" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:17.307" starttime="20190402 05:38:17.307"></status>
</kw>
<msg timestamp="20190402 05:38:17.307" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:17.307" starttime="20190402 05:38:17.304"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:17.308" starttime="20190402 05:38:17.308"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:17.308" starttime="20190402 05:38:17.307"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:17.308" starttime="20190402 05:38:17.308"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:17.309" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190402 05:38:17.309" starttime="20190402 05:38:17.308"></status>
</kw>
<msg timestamp="20190402 05:38:17.309" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:38:17.309" starttime="20190402 05:38:16.206"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:38:17.309" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190402 05:38:17.309" starttime="20190402 05:38:17.309"></status>
</kw>
<msg timestamp="20190402 05:38:17.309" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190402 05:38:17.309" starttime="20190402 05:38:16.205"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:38:17.310" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190402 05:38:17.310" starttime="20190402 05:38:17.310"></status>
</kw>
<status status="FAIL" endtime="20190402 05:38:17.310" starttime="20190402 05:38:16.205"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:27.312" starttime="20190402 05:38:27.312"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:27.313" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:27.313" starttime="20190402 05:38:27.312"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:27.314" starttime="20190402 05:38:27.313"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:27.314" starttime="20190402 05:38:27.314"></status>
</kw>
<msg timestamp="20190402 05:38:27.314" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:27.314" starttime="20190402 05:38:27.312"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:27.315" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:27.315" starttime="20190402 05:38:27.315"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:27.332" level="INFO">system storage-backend-show e38d5d2f-3 433-43e4-aaf3-4e4d3a634acd | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:38:27.332" starttime="20190402 05:38:27.315"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:28.471" level="INFO">configured
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:28.472" level="INFO">${output} = configured
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:28.472" starttime="20190402 05:38:27.332"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:28.472" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:28.473" starttime="20190402 05:38:28.472"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:28.473" level="INFO">${clean_out} = configured
</msg>
<status status="PASS" endtime="20190402 05:38:28.473" starttime="20190402 05:38:28.473"></status>
</kw>
<msg timestamp="20190402 05:38:28.473" level="INFO">${output} = configured
</msg>
<status status="PASS" endtime="20190402 05:38:28.473" starttime="20190402 05:38:28.472"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:28.478" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:28.478" starttime="20190402 05:38:28.474"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:28.478" level="INFO">0</msg>
<msg timestamp="20190402 05:38:28.478" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:28.478" starttime="20190402 05:38:28.478"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:28.478" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:28.478" starttime="20190402 05:38:28.478"></status>
</kw>
<msg timestamp="20190402 05:38:28.479" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:28.479" starttime="20190402 05:38:28.473"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.480" starttime="20190402 05:38:28.479"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:28.480" starttime="20190402 05:38:28.479"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.480" starttime="20190402 05:38:28.480"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:28.480" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configured</msg>
<status status="PASS" endtime="20190402 05:38:28.480" starttime="20190402 05:38:28.480"></status>
</kw>
<msg timestamp="20190402 05:38:28.481" level="INFO">${result} = {u'stdout': u'configured', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:38:28.481" starttime="20190402 05:38:27.311"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:38:28.481" level="INFO">${value} = configured</msg>
<status status="PASS" endtime="20190402 05:38:28.481" starttime="20190402 05:38:28.481"></status>
</kw>
<msg timestamp="20190402 05:38:28.481" level="INFO">${current_value} = configured</msg>
<status status="PASS" endtime="20190402 05:38:28.481" starttime="20190402 05:38:27.311"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.482" starttime="20190402 05:38:28.481"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:28.482" starttime="20190402 05:38:27.310"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:28.482" starttime="20190402 05:36:13.904"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:28.482" starttime="20190402 05:36:08.906"></status>
</kw>
<kw name="Check Ceph Status" library="Utils">
<doc>Verifies the status of the CEPH feature.</doc>
<arguments>
<arg>HEALTH_ERR</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph -s</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.483" starttime="20190402 05:38:28.482"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:28.483" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:28.483" starttime="20190402 05:38:28.483"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.484" starttime="20190402 05:38:28.484"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.484" starttime="20190402 05:38:28.484"></status>
</kw>
<msg timestamp="20190402 05:38:28.484" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:28.484" starttime="20190402 05:38:28.483"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:28.485" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:28.485" starttime="20190402 05:38:28.484"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:28.486" level="INFO">ceph -s</msg>
<status status="PASS" endtime="20190402 05:38:28.486" starttime="20190402 05:38:28.485"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:28.632" level="INFO">cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_ERR
            no osds
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 3, quorum 0 controller
     osdmap e2: 0 osds: 0 up, 0 in
            flags sortbitwise,require_jewel_osds
      pgmap v3: 64 pgs, 1 pools, 0 bytes data, 0 objects
            0 kB used, 0 kB / 0 kB avail
                  64 creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:28.632" level="INFO">${output} =     cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_ERR
            no osds
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 3, quorum 0 controll...</msg>
<status status="PASS" endtime="20190402 05:38:28.632" starttime="20190402 05:38:28.487"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:28.633" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:28.633" starttime="20190402 05:38:28.632"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:28.633" level="INFO">${clean_out} =     cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_ERR
            no osds
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 3, quorum 0 controll...</msg>
<status status="PASS" endtime="20190402 05:38:28.633" starttime="20190402 05:38:28.633"></status>
</kw>
<msg timestamp="20190402 05:38:28.633" level="INFO">${output} =     cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_ERR
            no osds
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 3, quorum 0 controll...</msg>
<status status="PASS" endtime="20190402 05:38:28.633" starttime="20190402 05:38:28.632"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:28.635" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:28.635" starttime="20190402 05:38:28.633"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:28.636" level="INFO">0</msg>
<msg timestamp="20190402 05:38:28.636" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:28.636" starttime="20190402 05:38:28.635"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:28.636" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:28.636" starttime="20190402 05:38:28.636"></status>
</kw>
<msg timestamp="20190402 05:38:28.636" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:28.636" starttime="20190402 05:38:28.633"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.637" starttime="20190402 05:38:28.637"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:28.637" starttime="20190402 05:38:28.636"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.637" starttime="20190402 05:38:28.637"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:28.638" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_ERR
            no osds
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 3, quorum 0 controller
     osdmap e2: 0 osds: 0 up, 0 in
            flags sortbitwise,require_jewel_osds
      pgmap v3: 64 pgs, 1 pools, 0 bytes data, 0 objects
            0 kB used, 0 kB / 0 kB avail
                  64 creating</msg>
<status status="PASS" endtime="20190402 05:38:28.638" starttime="20190402 05:38:28.638"></status>
</kw>
<msg timestamp="20190402 05:38:28.638" level="INFO">${result} = {u'stdout': u'cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7\r\n     health HEALTH_ERR\r\n            no osds\r\n     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}\r\n            election epoch 3,...</msg>
<status status="PASS" endtime="20190402 05:38:28.638" starttime="20190402 05:38:28.482"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${result.stdout}</arg>
<arg>${status}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.638" starttime="20190402 05:38:28.638"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd tree</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.639" starttime="20190402 05:38:28.639"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:28.640" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:28.640" starttime="20190402 05:38:28.639"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.640" starttime="20190402 05:38:28.640"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.640" starttime="20190402 05:38:28.640"></status>
</kw>
<msg timestamp="20190402 05:38:28.641" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:28.641" starttime="20190402 05:38:28.639"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:28.641" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:28.641" starttime="20190402 05:38:28.641"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:28.643" level="INFO">ceph osd tree</msg>
<status status="PASS" endtime="20190402 05:38:28.643" starttime="20190402 05:38:28.641"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:28.783" level="INFO">ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                                         
-4      0         host controller-0                                   
-3      0         host controller-1                                   
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:28.783" level="INFO">${output} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190402 05:38:28.783" starttime="20190402 05:38:28.643"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:28.784" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:28.784" starttime="20190402 05:38:28.784"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:28.785" level="INFO">${clean_out} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190402 05:38:28.785" starttime="20190402 05:38:28.784"></status>
</kw>
<msg timestamp="20190402 05:38:28.785" level="INFO">${output} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190402 05:38:28.785" starttime="20190402 05:38:28.784"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:28.787" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:28.787" starttime="20190402 05:38:28.785"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:28.787" level="INFO">0</msg>
<msg timestamp="20190402 05:38:28.787" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:28.787" starttime="20190402 05:38:28.787"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:28.788" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:28.788" starttime="20190402 05:38:28.788"></status>
</kw>
<msg timestamp="20190402 05:38:28.788" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:28.788" starttime="20190402 05:38:28.785"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.789" starttime="20190402 05:38:28.788"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:28.789" starttime="20190402 05:38:28.788"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.789" starttime="20190402 05:38:28.789"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:28.789" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                                         
-4      0         host controller-0                                   
-3      0         host controller-1</msg>
<status status="PASS" endtime="20190402 05:38:28.789" starttime="20190402 05:38:28.789"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:28.790" starttime="20190402 05:38:28.638"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:28.790" starttime="20190402 05:38:28.482"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:28.790" starttime="20190402 05:36:08.906"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:28.790" starttime="20190402 05:36:08.905"></status>
</kw>
<kw name="Add ODS To Tier" library="Utils">
<doc>Enable the ODS on the specified node.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>/dev/sdb</arg>
</arguments>
<assign>
<var>${device}</var>
</assign>
<msg timestamp="20190402 05:38:28.790" level="INFO">${device} = /dev/sdb</msg>
<status status="PASS" endtime="20190402 05:38:28.790" starttime="20190402 05:38:28.790"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>ceph_cluster</arg>
</arguments>
<assign>
<var>${tier_name}</var>
</assign>
<msg timestamp="20190402 05:38:28.791" level="INFO">${tier_name} = ceph_cluster</msg>
<status status="PASS" endtime="20190402 05:38:28.791" starttime="20190402 05:38:28.790"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${SPACE}</arg>
</arguments>
<assign>
<var>${tier_opt}</var>
</assign>
<msg timestamp="20190402 05:38:28.791" level="INFO">${tier_opt} =  </msg>
<status status="PASS" endtime="20190402 05:38:28.791" starttime="20190402 05:38:28.791"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host}</arg>
<arg>grep ${device}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 05:38:28.791" level="INFO">${cmd} = system host-disk-list controller-0|grep /dev/sdb|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 05:38:28.792" starttime="20190402 05:38:28.791"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.793" starttime="20190402 05:38:28.793"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:28.794" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:28.794" starttime="20190402 05:38:28.793"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.794" starttime="20190402 05:38:28.794"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:28.795" starttime="20190402 05:38:28.794"></status>
</kw>
<msg timestamp="20190402 05:38:28.795" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:28.795" starttime="20190402 05:38:28.793"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:28.795" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:28.795" starttime="20190402 05:38:28.795"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:28.811" level="INFO">system host-disk-list controller-0|gre p /dev/sdb|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 05:38:28.811" starttime="20190402 05:38:28.795"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:29.864" level="INFO">949488d0-0531-4095-9cdd-66c95802bd0d
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:29.864" level="INFO">${output} = 949488d0-0531-4095-9cdd-66c95802bd0d
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:29.864" starttime="20190402 05:38:28.811"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:29.865" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:29.865" starttime="20190402 05:38:29.864"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:29.865" level="INFO">${clean_out} = 949488d0-0531-4095-9cdd-66c95802bd0d
</msg>
<status status="PASS" endtime="20190402 05:38:29.865" starttime="20190402 05:38:29.865"></status>
</kw>
<msg timestamp="20190402 05:38:29.865" level="INFO">${output} = 949488d0-0531-4095-9cdd-66c95802bd0d
</msg>
<status status="PASS" endtime="20190402 05:38:29.865" starttime="20190402 05:38:29.864"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:29.867" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:29.867" starttime="20190402 05:38:29.866"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:29.868" level="INFO">0</msg>
<msg timestamp="20190402 05:38:29.868" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:29.868" starttime="20190402 05:38:29.867"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:29.868" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:29.868" starttime="20190402 05:38:29.868"></status>
</kw>
<msg timestamp="20190402 05:38:29.868" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:29.868" starttime="20190402 05:38:29.865"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:29.869" starttime="20190402 05:38:29.869"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:29.869" starttime="20190402 05:38:29.868"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:29.869" starttime="20190402 05:38:29.869"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:29.870" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 949488d0-0531-4095-9cdd-66c95802bd0d</msg>
<status status="PASS" endtime="20190402 05:38:29.870" starttime="20190402 05:38:29.869"></status>
</kw>
<msg timestamp="20190402 05:38:29.870" level="INFO">${result} = {u'stdout': u'949488d0-0531-4095-9cdd-66c95802bd0d', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:38:29.870" starttime="20190402 05:38:28.792"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>Get Tier UUID</arg>
<arg>${tier_name}</arg>
</arguments>
<assign>
<var>${tier_uuid}</var>
</assign>
<msg timestamp="20190402 05:38:29.870" level="INFO">${tier_uuid} = None</msg>
<status status="PASS" endtime="20190402 05:38:29.870" starttime="20190402 05:38:29.870"></status>
</kw>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>--tier-uuid ${tier_uuid}</arg>
<arg>${EMPTY}</arg>
</arguments>
<assign>
<var>${tier_opt}</var>
</assign>
<msg timestamp="20190402 05:38:29.871" level="INFO">${tier_opt} = </msg>
<status status="PASS" endtime="20190402 05:38:29.871" starttime="20190402 05:38:29.870"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-stor-add ${host} ${result.stdout.strip()} ${tier_opt}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:29.872" starttime="20190402 05:38:29.871"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:29.872" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:29.872" starttime="20190402 05:38:29.872"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:29.873" starttime="20190402 05:38:29.872"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:29.873" starttime="20190402 05:38:29.873"></status>
</kw>
<msg timestamp="20190402 05:38:29.873" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:29.873" starttime="20190402 05:38:29.872"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:29.874" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:29.874" starttime="20190402 05:38:29.873"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:29.885" level="INFO">system host-stor-add controller-0 9494 88d0-0531-4095-9cdd-66c95802bd0d</msg>
<status status="PASS" endtime="20190402 05:38:29.885" starttime="20190402 05:38:29.874"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:31.299" level="INFO">+------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+--------------------------------------------------+
| osdid            | 0                                                |
| function         | osd                                              |
| state            | configuring-on-unlock                            |
| journal_location | f826b655-ce64-4844-a873-58fbb5451b1f             |
| journal_size_gib | 1024                                             |
| journal_path     | /dev/disk/by-path/pci-0000:00:17.0-ata-2.0-part2 |
| journal_node     | /dev/sdb2                                        |
| uuid             | f826b655-ce64-4844-a873-58fbb5451b1f             |
| ihost_uuid       | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd             |
| idisk_uuid       | 949488d0-0531-4095-9cdd-66c95802bd0d             |
| tier_uuid        | 02919f4d-97d2-40f4-a470-5beb3b7558c1             |
| tier_name        | storage                                          |
| created_at       | 2019-04-02T11:27:14.792558+00:00                 |
| updated_at       | 2019-04-02T11:27:14.919947+00:00                 |
+------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:31.299" level="INFO">${output} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190402 05:38:31.299" starttime="20190402 05:38:29.885"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:31.300" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:31.300" starttime="20190402 05:38:31.300"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:31.301" level="INFO">${clean_out} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190402 05:38:31.301" starttime="20190402 05:38:31.300"></status>
</kw>
<msg timestamp="20190402 05:38:31.301" level="INFO">${output} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190402 05:38:31.301" starttime="20190402 05:38:31.300"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:31.303" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:31.303" starttime="20190402 05:38:31.301"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:31.303" level="INFO">0</msg>
<msg timestamp="20190402 05:38:31.303" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:31.303" starttime="20190402 05:38:31.303"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:31.304" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:31.304" starttime="20190402 05:38:31.303"></status>
</kw>
<msg timestamp="20190402 05:38:31.304" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:31.304" starttime="20190402 05:38:31.301"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.305" starttime="20190402 05:38:31.304"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:31.305" starttime="20190402 05:38:31.304"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.305" starttime="20190402 05:38:31.305"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:31.305" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+--------------------------------------------------+
| osdid            | 0                                                |
| function         | osd                                              |
| state            | configuring-on-unlock                            |
| journal_location | f826b655-ce64-4844-a873-58fbb5451b1f             |
| journal_size_gib | 1024                                             |
| journal_path     | /dev/disk/by-path/pci-0000:00:17.0-ata-2.0-part2 |
| journal_node     | /dev/sdb2                                        |
| uuid             | f826b655-ce64-4844-a873-58fbb5451b1f             |
| ihost_uuid       | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd             |
| idisk_uuid       | 949488d0-0531-4095-9cdd-66c95802bd0d             |
| tier_uuid        | 02919f4d-97d2-40f4-a470-5beb3b7558c1             |
| tier_name        | storage                                          |
| created_at       | 2019-04-02T11:27:14.792558+00:00                 |
| updated_at       | 2019-04-02T11:27:14.919947+00:00                 |
+------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:38:31.305" starttime="20190402 05:38:31.305"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:31.305" starttime="20190402 05:38:29.871"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd tree</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.306" starttime="20190402 05:38:31.306"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:31.307" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:31.307" starttime="20190402 05:38:31.307"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.307" starttime="20190402 05:38:31.307"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.308" starttime="20190402 05:38:31.308"></status>
</kw>
<msg timestamp="20190402 05:38:31.308" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:31.308" starttime="20190402 05:38:31.306"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:31.308" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:31.309" starttime="20190402 05:38:31.308"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:31.314" level="INFO">ceph osd tree</msg>
<status status="PASS" endtime="20190402 05:38:31.314" starttime="20190402 05:38:31.309"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:31.456" level="INFO">ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                                         
-4      0         host controller-0                                   
-3      0         host controller-1                                   
 0      0 osd.0                        down        0          1.00000 
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:31.456" level="INFO">${output} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190402 05:38:31.456" starttime="20190402 05:38:31.314"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:31.457" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:31.457" starttime="20190402 05:38:31.457"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:31.457" level="INFO">${clean_out} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190402 05:38:31.457" starttime="20190402 05:38:31.457"></status>
</kw>
<msg timestamp="20190402 05:38:31.457" level="INFO">${output} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190402 05:38:31.457" starttime="20190402 05:38:31.456"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:31.459" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:31.459" starttime="20190402 05:38:31.458"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:31.460" level="INFO">0</msg>
<msg timestamp="20190402 05:38:31.460" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:31.460" starttime="20190402 05:38:31.460"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:31.461" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:31.461" starttime="20190402 05:38:31.460"></status>
</kw>
<msg timestamp="20190402 05:38:31.461" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:31.461" starttime="20190402 05:38:31.458"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.462" starttime="20190402 05:38:31.462"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:31.462" starttime="20190402 05:38:31.461"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.462" starttime="20190402 05:38:31.462"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:31.463" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                                         
-4      0         host controller-0                                   
-3      0         host controller-1                                   
 0      0 osd.0                        down        0          1.00000</msg>
<status status="PASS" endtime="20190402 05:38:31.463" starttime="20190402 05:38:31.462"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:31.463" starttime="20190402 05:38:31.306"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:31.463" starttime="20190402 05:38:28.790"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}'=='Simplex'</arg>
<arg>Set Ceph Pool Replication</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.463" starttime="20190402 05:38:31.463"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:31.463" starttime="20190402 05:36:08.905"></status>
</kw>
<kw name="Unlock Master Controller" library="Utils">
<doc>Verify that controller with ACTIVE ssh connection
is unlocked and reestablish the ssh connection on the suite.</doc>
<arguments>
<arg>${master_controller}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>*Socket is closed*</arg>
</arguments>
<assign>
<var>${error_expected}</var>
</assign>
<msg timestamp="20190402 05:38:31.464" level="INFO">${error_expected} = *Socket is closed*</msg>
<status status="PASS" endtime="20190402 05:38:31.464" starttime="20190402 05:38:31.464"></status>
</kw>
<kw name="Unlock Controller" library="Utils">
<doc>Unlocks specified controller.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>15 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value</arg>
<arg>${controller_name}</arg>
<arg>availability</arg>
<arg>online</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>availability</arg>
<arg>online</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:38:31.466" level="INFO">${system_cmd} = system host-show controller-0|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:38:31.466" starttime="20190402 05:38:31.465"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.467" starttime="20190402 05:38:31.466"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:31.467" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:31.467" starttime="20190402 05:38:31.467"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.468" starttime="20190402 05:38:31.467"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:31.468" starttime="20190402 05:38:31.468"></status>
</kw>
<msg timestamp="20190402 05:38:31.468" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:31.468" starttime="20190402 05:38:31.467"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:31.469" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:31.469" starttime="20190402 05:38:31.468"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:31.485" level="INFO">system host-show controller-0|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:38:31.485" starttime="20190402 05:38:31.469"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:32.505" level="INFO">online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:32.505" level="INFO">${output} = online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:32.505" starttime="20190402 05:38:31.486"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:32.506" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:32.506" starttime="20190402 05:38:32.505"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:32.506" level="INFO">${clean_out} = online
</msg>
<status status="PASS" endtime="20190402 05:38:32.506" starttime="20190402 05:38:32.506"></status>
</kw>
<msg timestamp="20190402 05:38:32.506" level="INFO">${output} = online
</msg>
<status status="PASS" endtime="20190402 05:38:32.506" starttime="20190402 05:38:32.505"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:32.508" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:32.508" starttime="20190402 05:38:32.506"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:32.509" level="INFO">0</msg>
<msg timestamp="20190402 05:38:32.509" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:32.509" starttime="20190402 05:38:32.508"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:32.509" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:32.510" starttime="20190402 05:38:32.509"></status>
</kw>
<msg timestamp="20190402 05:38:32.510" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:32.510" starttime="20190402 05:38:32.506"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:32.510" starttime="20190402 05:38:32.510"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:32.510" starttime="20190402 05:38:32.510"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:32.511" starttime="20190402 05:38:32.511"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:32.511" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: online</msg>
<status status="PASS" endtime="20190402 05:38:32.511" starttime="20190402 05:38:32.511"></status>
</kw>
<msg timestamp="20190402 05:38:32.511" level="INFO">${result} = {u'stdout': u'online', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:38:32.511" starttime="20190402 05:38:31.466"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:38:32.512" level="INFO">${value} = online</msg>
<status status="PASS" endtime="20190402 05:38:32.512" starttime="20190402 05:38:32.511"></status>
</kw>
<msg timestamp="20190402 05:38:32.512" level="INFO">${current_value} = online</msg>
<status status="PASS" endtime="20190402 05:38:32.512" starttime="20190402 05:38:31.465"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:32.512" starttime="20190402 05:38:32.512"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:32.512" starttime="20190402 05:38:31.465"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:32.512" starttime="20190402 05:38:31.464"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-unlock ${controller_name}</arg>
<arg>True</arg>
<arg>60</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:32.513" starttime="20190402 05:38:32.513"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:32.514" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:32.514" starttime="20190402 05:38:32.513"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:32.514" starttime="20190402 05:38:32.514"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:32.514" starttime="20190402 05:38:32.514"></status>
</kw>
<msg timestamp="20190402 05:38:32.515" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:32.515" starttime="20190402 05:38:32.513"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:32.515" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:32.515" starttime="20190402 05:38:32.515"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:32.517" level="INFO">system host-unlock controller-0</msg>
<status status="PASS" endtime="20190402 05:38:32.517" starttime="20190402 05:38:32.515"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:37.262" level="INFO">+---------------------+--------------------------------------------+
| Property            | Value                                      |
+---------------------+--------------------------------------------+
| action              | none                                       |
| administrative      | locked                                     |
| availability        | online                                     |
| bm_ip               | None                                       |
| bm_type             | None                                       |
| bm_username         | None                                       |
| boot_device         | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0 |
| capabilities        | {u'stor_function': u'monitor'}             |
| config_applied      | 2af14b81-2224-498d-b57d-9ae557db757b       |
| config_status       | Config out-of-date                         |
| config_target       | eb36ffe5-99a6-4d69-9306-79d23c18526d       |
| console             | ttyS0,115200                               |
| created_at          | 2019-04-02T10:06:51.861866+00:00           |
| hostname            | controller-0                               |
| id                  | 1                                          |
| install_output      | text                                       |
| install_state       | None                                       |
| install_state_info  | None                                       |
| invprovision        | provisioned                                |
| location            | {}                                         |
| mgmt_ip             | 10.10.53.3                                 |
| mgmt_mac            | a4:bf:01:55:03:28                          |
| operational         | disabled                                   |
| personality         | controller                                 |
| reserved            | False                                      |
| rootfs_device       | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0 |
| serialid            | None                                       |
| software_load       | 19.01                                      |
| subfunction_avail   | online                                     |
| subfunction_oper    | disabled                                   |
| subfunctions        | controller,worker                          |
| task                | Unlocking                                  |
| tboot               | false                                      |
| ttys_dcd            | None                                       |
| updated_at          | 2019-04-02T11:27:14.996302+00:00           |
| uptime              | 5132                                       |
| uuid                | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd       |
| vim_progress_status | None                                       |
+---------------------+--------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:37.262" level="INFO">${output} = +---------------------+--------------------------------------------+
| Property            | Value                                      |
+---------------------+-------------------------------------...</msg>
<status status="PASS" endtime="20190402 05:38:37.262" starttime="20190402 05:38:32.517"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:37.263" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:37.263" starttime="20190402 05:38:37.263"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:37.263" level="INFO">${clean_out} = +---------------------+--------------------------------------------+
| Property            | Value                                      |
+---------------------+-------------------------------------...</msg>
<status status="PASS" endtime="20190402 05:38:37.263" starttime="20190402 05:38:37.263"></status>
</kw>
<msg timestamp="20190402 05:38:37.264" level="INFO">${output} = +---------------------+--------------------------------------------+
| Property            | Value                                      |
+---------------------+-------------------------------------...</msg>
<status status="PASS" endtime="20190402 05:38:37.264" starttime="20190402 05:38:37.262"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:37.265" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:37.265" starttime="20190402 05:38:37.264"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:37.266" level="INFO">0</msg>
<msg timestamp="20190402 05:38:37.266" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:37.266" starttime="20190402 05:38:37.265"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:37.266" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:37.266" starttime="20190402 05:38:37.266"></status>
</kw>
<msg timestamp="20190402 05:38:37.266" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:37.266" starttime="20190402 05:38:37.264"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:37.267" starttime="20190402 05:38:37.267"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:37.267" starttime="20190402 05:38:37.266"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:37.267" starttime="20190402 05:38:37.267"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:37.268" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +---------------------+--------------------------------------------+
| Property            | Value                                      |
+---------------------+--------------------------------------------+
| action              | none                                       |
| administrative      | locked                                     |
| availability        | online                                     |
| bm_ip               | None                                       |
| bm_type             | None                                       |
| bm_username         | None                                       |
| boot_device         | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0 |
| capabilities        | {u'stor_function': u'monitor'}             |
| config_applied      | 2af14b81-2224-498d-b57d-9ae557db757b       |
| config_status       | Config out-of-date                         |
| config_target       | eb36ffe5-99a6-4d69-9306-79d23c18526d       |
| console             | ttyS0,115200                               |
| created_at          | 2019-04-02T10:06:51.861866+00:00           |
| hostname            | controller-0                               |
| id                  | 1                                          |
| install_output      | text                                       |
| install_state       | None                                       |
| install_state_info  | None                                       |
| invprovision        | provisioned                                |
| location            | {}                                         |
| mgmt_ip             | 10.10.53.3                                 |
| mgmt_mac            | a4:bf:01:55:03:28                          |
| operational         | disabled                                   |
| personality         | controller                                 |
| reserved            | False                                      |
| rootfs_device       | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0 |
| serialid            | None                                       |
| software_load       | 19.01                                      |
| subfunction_avail   | online                                     |
| subfunction_oper    | disabled                                   |
| subfunctions        | controller,worker                          |
| task                | Unlocking                                  |
| tboot               | false                                      |
| ttys_dcd            | None                                       |
| updated_at          | 2019-04-02T11:27:14.996302+00:00           |
| uptime              | 5132                                       |
| uuid                | 59c2e4e6-5023-4aff-9a6e-5d1452ff28bd       |
| vim_progress_status | None                                       |
+---------------------+--------------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:38:37.268" starttime="20190402 05:38:37.268"></status>
</kw>
<msg timestamp="20190402 05:38:37.268" level="INFO">${result} = {u'stdout': u"+---------------------+--------------------------------------------+\r\n| Property            | Value                                      |\r\n+---------------------+-------------------...</msg>
<status status="PASS" endtime="20190402 05:38:37.268" starttime="20190402 05:38:32.512"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:37.268" starttime="20190402 05:38:31.464"></status>
</kw>
<kw name="Wait Until Keyword Fails" library="Utils">
<doc>Waits until executed keyword returns the expected error.</doc>
<arguments>
<arg>10 min</arg>
<arg>20 sec</arg>
<arg>${error_expected}</arg>
<arg>Run Command</arg>
<arg>whoami</arg>
</arguments>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>${timeout}</arg>
<arg>${retry}</arg>
<arg>Run Keyword And Expect Error</arg>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:37.270" starttime="20190402 05:38:37.270"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:37.271" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:37.271" starttime="20190402 05:38:37.270"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:37.271" starttime="20190402 05:38:37.271"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:37.271" starttime="20190402 05:38:37.271"></status>
</kw>
<msg timestamp="20190402 05:38:37.272" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:37.272" starttime="20190402 05:38:37.270"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:37.272" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:37.272" starttime="20190402 05:38:37.272"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:37.273" level="INFO">whoami</msg>
<status status="PASS" endtime="20190402 05:38:37.273" starttime="20190402 05:38:37.272"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:37.276" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:37.276" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:37.276" starttime="20190402 05:38:37.273"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:37.276" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:37.276" starttime="20190402 05:38:37.276"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:37.277" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:38:37.277" starttime="20190402 05:38:37.277"></status>
</kw>
<msg timestamp="20190402 05:38:37.277" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:38:37.277" starttime="20190402 05:38:37.276"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:37.279" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:37.279" starttime="20190402 05:38:37.277"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:37.279" level="INFO">0</msg>
<msg timestamp="20190402 05:38:37.280" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:37.280" starttime="20190402 05:38:37.279"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:37.280" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:37.280" starttime="20190402 05:38:37.280"></status>
</kw>
<msg timestamp="20190402 05:38:37.280" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:37.280" starttime="20190402 05:38:37.277"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:37.281" starttime="20190402 05:38:37.281"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:37.281" starttime="20190402 05:38:37.280"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:37.281" starttime="20190402 05:38:37.281"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:37.281" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190402 05:38:37.282" starttime="20190402 05:38:37.281"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:37.282" starttime="20190402 05:38:37.269"></status>
</kw>
<msg timestamp="20190402 05:38:37.282" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190402 05:38:37.282" starttime="20190402 05:38:37.269"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:57.286" starttime="20190402 05:38:57.285"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:38:57.289" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:38:57.289" starttime="20190402 05:38:57.288"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:57.291" starttime="20190402 05:38:57.290"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:57.292" starttime="20190402 05:38:57.291"></status>
</kw>
<msg timestamp="20190402 05:38:57.293" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:38:57.293" starttime="20190402 05:38:57.287"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:38:57.294" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:57.294" starttime="20190402 05:38:57.294"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:38:57.300" level="INFO">whoami</msg>
<status status="PASS" endtime="20190402 05:38:57.300" starttime="20190402 05:38:57.295"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:38:57.303" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:38:57.303" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:57.303" starttime="20190402 05:38:57.301"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:38:57.305" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:38:57.305" starttime="20190402 05:38:57.305"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:38:57.306" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:38:57.307" starttime="20190402 05:38:57.306"></status>
</kw>
<msg timestamp="20190402 05:38:57.307" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:38:57.307" starttime="20190402 05:38:57.304"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:38:57.312" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:38:57.313" starttime="20190402 05:38:57.308"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:38:57.314" level="INFO">0</msg>
<msg timestamp="20190402 05:38:57.314" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:57.314" starttime="20190402 05:38:57.313"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:38:57.315" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:38:57.315" starttime="20190402 05:38:57.315"></status>
</kw>
<msg timestamp="20190402 05:38:57.316" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:38:57.316" starttime="20190402 05:38:57.307"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:57.318" starttime="20190402 05:38:57.317"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:57.318" starttime="20190402 05:38:57.316"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:38:57.319" starttime="20190402 05:38:57.318"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:38:57.319" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190402 05:38:57.319" starttime="20190402 05:38:57.319"></status>
</kw>
<status status="PASS" endtime="20190402 05:38:57.320" starttime="20190402 05:38:57.284"></status>
</kw>
<msg timestamp="20190402 05:38:57.320" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190402 05:38:57.320" starttime="20190402 05:38:57.283"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:17.325" starttime="20190402 05:39:17.324"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:39:17.326" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:39:17.326" starttime="20190402 05:39:17.326"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:17.327" starttime="20190402 05:39:17.326"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:17.327" starttime="20190402 05:39:17.327"></status>
</kw>
<msg timestamp="20190402 05:39:17.327" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:39:17.327" starttime="20190402 05:39:17.325"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:39:17.327" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:39:17.328" starttime="20190402 05:39:17.327"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:39:17.329" level="INFO">whoami</msg>
<status status="PASS" endtime="20190402 05:39:17.329" starttime="20190402 05:39:17.328"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:39:17.331" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:39:17.331" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:39:17.331" starttime="20190402 05:39:17.329"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:39:17.332" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:39:17.332" starttime="20190402 05:39:17.331"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:39:17.332" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:39:17.332" starttime="20190402 05:39:17.332"></status>
</kw>
<msg timestamp="20190402 05:39:17.332" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:39:17.332" starttime="20190402 05:39:17.331"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:39:17.334" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:39:17.335" starttime="20190402 05:39:17.333"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:39:17.335" level="INFO">0</msg>
<msg timestamp="20190402 05:39:17.335" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:39:17.335" starttime="20190402 05:39:17.335"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:39:17.336" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:39:17.336" starttime="20190402 05:39:17.335"></status>
</kw>
<msg timestamp="20190402 05:39:17.336" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:39:17.336" starttime="20190402 05:39:17.333"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:17.337" starttime="20190402 05:39:17.336"></status>
</kw>
<status status="PASS" endtime="20190402 05:39:17.337" starttime="20190402 05:39:17.336"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:17.337" starttime="20190402 05:39:17.337"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:39:17.337" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190402 05:39:17.337" starttime="20190402 05:39:17.337"></status>
</kw>
<status status="PASS" endtime="20190402 05:39:17.338" starttime="20190402 05:39:17.322"></status>
</kw>
<msg timestamp="20190402 05:39:17.338" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190402 05:39:17.338" starttime="20190402 05:39:17.321"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:37.339" starttime="20190402 05:39:37.339"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:39:37.340" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:39:37.340" starttime="20190402 05:39:37.340"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:37.340" starttime="20190402 05:39:37.340"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:37.341" starttime="20190402 05:39:37.341"></status>
</kw>
<msg timestamp="20190402 05:39:37.341" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:39:37.341" starttime="20190402 05:39:37.339"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:39:37.341" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:39:37.341" starttime="20190402 05:39:37.341"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:39:37.343" level="INFO">whoami</msg>
<status status="PASS" endtime="20190402 05:39:37.343" starttime="20190402 05:39:37.342"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:39:37.345" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:39:37.345" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:39:37.345" starttime="20190402 05:39:37.344"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:39:37.346" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:39:37.346" starttime="20190402 05:39:37.346"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:39:37.346" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:39:37.346" starttime="20190402 05:39:37.346"></status>
</kw>
<msg timestamp="20190402 05:39:37.346" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:39:37.347" starttime="20190402 05:39:37.345"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:39:37.349" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:39:37.349" starttime="20190402 05:39:37.347"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:39:37.349" level="INFO">0</msg>
<msg timestamp="20190402 05:39:37.349" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:39:37.349" starttime="20190402 05:39:37.349"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:39:37.350" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:39:37.350" starttime="20190402 05:39:37.350"></status>
</kw>
<msg timestamp="20190402 05:39:37.350" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:39:37.350" starttime="20190402 05:39:37.347"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:37.351" starttime="20190402 05:39:37.351"></status>
</kw>
<status status="PASS" endtime="20190402 05:39:37.351" starttime="20190402 05:39:37.350"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:37.351" starttime="20190402 05:39:37.351"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:39:37.352" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190402 05:39:37.352" starttime="20190402 05:39:37.351"></status>
</kw>
<status status="PASS" endtime="20190402 05:39:37.352" starttime="20190402 05:39:37.338"></status>
</kw>
<msg timestamp="20190402 05:39:37.352" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190402 05:39:37.352" starttime="20190402 05:39:37.338"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:57.355" starttime="20190402 05:39:57.355"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:39:57.357" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:39:57.357" starttime="20190402 05:39:57.356"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:57.358" starttime="20190402 05:39:57.358"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:57.358" starttime="20190402 05:39:57.358"></status>
</kw>
<msg timestamp="20190402 05:39:57.359" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:39:57.359" starttime="20190402 05:39:57.356"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:39:57.359" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:39:57.359" starttime="20190402 05:39:57.359"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:39:57.361" level="INFO">whoami</msg>
<status status="PASS" endtime="20190402 05:39:57.361" starttime="20190402 05:39:57.359"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:39:57.362" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:39:57.362" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:39:57.362" starttime="20190402 05:39:57.361"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:39:57.363" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:39:57.363" starttime="20190402 05:39:57.363"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:39:57.363" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:39:57.363" starttime="20190402 05:39:57.363"></status>
</kw>
<msg timestamp="20190402 05:39:57.364" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:39:57.364" starttime="20190402 05:39:57.362"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:39:57.365" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:39:57.366" starttime="20190402 05:39:57.364"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:39:57.366" level="INFO">0</msg>
<msg timestamp="20190402 05:39:57.366" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:39:57.366" starttime="20190402 05:39:57.366"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:39:57.366" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:39:57.366" starttime="20190402 05:39:57.366"></status>
</kw>
<msg timestamp="20190402 05:39:57.367" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:39:57.367" starttime="20190402 05:39:57.364"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:57.367" starttime="20190402 05:39:57.367"></status>
</kw>
<status status="PASS" endtime="20190402 05:39:57.368" starttime="20190402 05:39:57.367"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:39:57.368" starttime="20190402 05:39:57.368"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:39:57.368" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190402 05:39:57.368" starttime="20190402 05:39:57.368"></status>
</kw>
<status status="PASS" endtime="20190402 05:39:57.368" starttime="20190402 05:39:57.354"></status>
</kw>
<msg timestamp="20190402 05:39:57.368" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190402 05:39:57.369" starttime="20190402 05:39:57.353"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:17.370" starttime="20190402 05:40:17.370"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:40:17.371" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:40:17.371" starttime="20190402 05:40:17.370"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:17.371" starttime="20190402 05:40:17.371"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:17.372" starttime="20190402 05:40:17.371"></status>
</kw>
<msg timestamp="20190402 05:40:17.372" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:40:17.372" starttime="20190402 05:40:17.370"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:40:17.372" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:40:17.372" starttime="20190402 05:40:17.372"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:40:17.374" level="INFO">whoami</msg>
<status status="PASS" endtime="20190402 05:40:17.374" starttime="20190402 05:40:17.372"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:40:17.375" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:40:17.375" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:40:17.375" starttime="20190402 05:40:17.374"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:40:17.376" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:40:17.376" starttime="20190402 05:40:17.376"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:40:17.376" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:40:17.376" starttime="20190402 05:40:17.376"></status>
</kw>
<msg timestamp="20190402 05:40:17.377" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:40:17.377" starttime="20190402 05:40:17.376"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:40:17.378" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:40:17.378" starttime="20190402 05:40:17.377"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:40:17.379" level="INFO">0</msg>
<msg timestamp="20190402 05:40:17.379" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:40:17.379" starttime="20190402 05:40:17.379"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:40:17.380" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:40:17.380" starttime="20190402 05:40:17.379"></status>
</kw>
<msg timestamp="20190402 05:40:17.380" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:40:17.380" starttime="20190402 05:40:17.377"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:17.381" starttime="20190402 05:40:17.380"></status>
</kw>
<status status="PASS" endtime="20190402 05:40:17.381" starttime="20190402 05:40:17.380"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:17.381" starttime="20190402 05:40:17.381"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:40:17.381" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190402 05:40:17.381" starttime="20190402 05:40:17.381"></status>
</kw>
<status status="PASS" endtime="20190402 05:40:17.381" starttime="20190402 05:40:17.369"></status>
</kw>
<msg timestamp="20190402 05:40:17.382" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190402 05:40:17.382" starttime="20190402 05:40:17.369"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:37.383" starttime="20190402 05:40:37.383"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:40:37.384" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:40:37.384" starttime="20190402 05:40:37.384"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:37.385" starttime="20190402 05:40:37.384"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:37.385" starttime="20190402 05:40:37.385"></status>
</kw>
<msg timestamp="20190402 05:40:37.385" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:40:37.385" starttime="20190402 05:40:37.383"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:40:37.386" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:40:37.386" starttime="20190402 05:40:37.385"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:40:37.387" level="INFO">whoami</msg>
<status status="PASS" endtime="20190402 05:40:37.388" starttime="20190402 05:40:37.386"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:40:37.389" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:40:37.389" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:40:37.389" starttime="20190402 05:40:37.388"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:40:37.390" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:40:37.390" starttime="20190402 05:40:37.390"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:40:37.391" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:40:37.391" starttime="20190402 05:40:37.390"></status>
</kw>
<msg timestamp="20190402 05:40:37.391" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190402 05:40:37.391" starttime="20190402 05:40:37.390"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:40:37.393" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:40:37.393" starttime="20190402 05:40:37.391"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:40:37.393" level="INFO">0</msg>
<msg timestamp="20190402 05:40:37.393" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:40:37.393" starttime="20190402 05:40:37.393"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:40:37.394" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:40:37.394" starttime="20190402 05:40:37.394"></status>
</kw>
<msg timestamp="20190402 05:40:37.394" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:40:37.394" starttime="20190402 05:40:37.391"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:37.395" starttime="20190402 05:40:37.395"></status>
</kw>
<status status="PASS" endtime="20190402 05:40:37.395" starttime="20190402 05:40:37.394"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:37.395" starttime="20190402 05:40:37.395"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:40:37.396" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190402 05:40:37.396" starttime="20190402 05:40:37.395"></status>
</kw>
<status status="PASS" endtime="20190402 05:40:37.396" starttime="20190402 05:40:37.382"></status>
</kw>
<msg timestamp="20190402 05:40:37.396" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190402 05:40:37.396" starttime="20190402 05:40:37.382"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:57.398" starttime="20190402 05:40:57.397"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:40:57.398" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:40:57.398" starttime="20190402 05:40:57.398"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:57.399" starttime="20190402 05:40:57.399"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:40:57.399" starttime="20190402 05:40:57.399"></status>
</kw>
<msg timestamp="20190402 05:40:57.399" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:40:57.399" starttime="20190402 05:40:57.398"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:40:57.400" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:40:57.400" starttime="20190402 05:40:57.399"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:41:57.400" level="FAIL">No match found for '
' in 1 minute
Output:
.</msg>
<status status="FAIL" endtime="20190402 05:41:57.401" starttime="20190402 05:40:57.400"></status>
</kw>
<status status="FAIL" endtime="20190402 05:41:57.401" starttime="20190402 05:40:57.397"></status>
</kw>
<msg timestamp="20190402 05:41:57.401" level="FAIL">Expected error '*Socket is closed*' but got 'No match found for '
' in 1 minute
Output:
.'.</msg>
<status status="FAIL" endtime="20190402 05:41:57.401" starttime="20190402 05:40:57.397"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:42:17.406" starttime="20190402 05:42:17.405"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:42:17.407" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:42:17.407" starttime="20190402 05:42:17.407"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:42:17.408" starttime="20190402 05:42:17.408"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:42:17.408" starttime="20190402 05:42:17.408"></status>
</kw>
<msg timestamp="20190402 05:42:17.408" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:42:17.408" starttime="20190402 05:42:17.406"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190402 05:42:17.409" starttime="20190402 05:42:17.408"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:43:17.409" level="FAIL">No match found for '
' in 1 minute
Output:
.</msg>
<status status="FAIL" endtime="20190402 05:43:17.410" starttime="20190402 05:42:17.409"></status>
</kw>
<status status="FAIL" endtime="20190402 05:43:17.410" starttime="20190402 05:42:17.403"></status>
</kw>
<msg timestamp="20190402 05:43:17.410" level="FAIL">Expected error '*Socket is closed*' but got 'No match found for '
' in 1 minute
Output:
.'.</msg>
<status status="FAIL" endtime="20190402 05:43:17.410" starttime="20190402 05:42:17.402"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:37.414" starttime="20190402 05:43:37.413"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:43:37.416" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:43:37.416" starttime="20190402 05:43:37.415"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:37.416" starttime="20190402 05:43:37.416"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:37.416" starttime="20190402 05:43:37.416"></status>
</kw>
<msg timestamp="20190402 05:43:37.416" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:43:37.417" starttime="20190402 05:43:37.415"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190402 05:43:37.417" starttime="20190402 05:43:37.417"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:43:37.417" level="FAIL">error: Socket is closed</msg>
<status status="FAIL" endtime="20190402 05:43:37.418" starttime="20190402 05:43:37.417"></status>
</kw>
<status status="FAIL" endtime="20190402 05:43:37.418" starttime="20190402 05:43:37.412"></status>
</kw>
<status status="PASS" endtime="20190402 05:43:37.418" starttime="20190402 05:43:37.411"></status>
</kw>
<status status="PASS" endtime="20190402 05:43:37.418" starttime="20190402 05:38:37.269"></status>
</kw>
<status status="PASS" endtime="20190402 05:43:37.418" starttime="20190402 05:38:37.268"></status>
</kw>
<kw name="Close Connection" library="SSHLibrary">
<doc>Closes the current connection.</doc>
<status status="PASS" endtime="20190402 05:43:37.418" starttime="20190402 05:43:37.418"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>10 min</arg>
<arg>30 sec</arg>
<arg>Open Master Controller Connection</arg>
</arguments>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190402 05:43:37.420" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 05:43:37.420" starttime="20190402 05:43:37.419"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190402 05:43:37.420" level="INFO">Length is 10</msg>
<msg timestamp="20190402 05:43:37.420" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190402 05:43:37.420" starttime="20190402 05:43:37.420"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190402 05:43:37.421" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190402 05:43:38.574" level="INFO">Read output: Last login: Tue Apr  2 11:23:40 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:43:38.575" starttime="20190402 05:43:37.421"></status>
</kw>
<msg timestamp="20190402 05:43:38.575" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190402 05:43:38.575" starttime="20190402 05:43:37.420"></status>
</kw>
<status status="PASS" endtime="20190402 05:43:38.576" starttime="20190402 05:43:37.420"></status>
</kw>
<msg timestamp="20190402 05:43:38.577" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 05:43:38.577" starttime="20190402 05:43:37.419"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190402 05:43:38.578" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 05:43:38.578" starttime="20190402 05:43:38.577"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190402 05:43:38.579" level="INFO">1</msg>
<status status="PASS" endtime="20190402 05:43:38.579" starttime="20190402 05:43:38.579"></status>
</kw>
<status status="PASS" endtime="20190402 05:43:38.579" starttime="20190402 05:43:37.419"></status>
</kw>
<status status="PASS" endtime="20190402 05:43:38.579" starttime="20190402 05:43:37.418"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>25 min</arg>
<arg>30 sec</arg>
<arg>Check Controller Is Unlocked</arg>
<arg>${controller}</arg>
</arguments>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:38.581" starttime="20190402 05:43:38.581"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:43:38.582" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:43:38.582" starttime="20190402 05:43:38.581"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:38.582" starttime="20190402 05:43:38.582"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:38.582" starttime="20190402 05:43:38.582"></status>
</kw>
<msg timestamp="20190402 05:43:38.583" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:43:38.583" starttime="20190402 05:43:38.581"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190402 05:43:38.583" starttime="20190402 05:43:38.583"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:43:38.588" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:43:38.588" starttime="20190402 05:43:38.583"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:43:38.589" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:43:38.589" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:43:38.589" starttime="20190402 05:43:38.588"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:43:38.590" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:43:38.590" starttime="20190402 05:43:38.589"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:43:38.590" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:43:38.590" starttime="20190402 05:43:38.590"></status>
</kw>
<msg timestamp="20190402 05:43:38.590" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:43:38.590" starttime="20190402 05:43:38.589"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:43:38.593" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:43:38.593" starttime="20190402 05:43:38.591"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:43:38.593" level="INFO">0</msg>
<msg timestamp="20190402 05:43:38.593" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:43:38.593" starttime="20190402 05:43:38.593"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:43:38.594" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:43:38.594" starttime="20190402 05:43:38.593"></status>
</kw>
<msg timestamp="20190402 05:43:38.594" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:43:38.594" starttime="20190402 05:43:38.590"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:38.595" starttime="20190402 05:43:38.595"></status>
</kw>
<status status="PASS" endtime="20190402 05:43:38.595" starttime="20190402 05:43:38.594"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:38.595" starttime="20190402 05:43:38.595"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:43:38.596" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:43:38.596" starttime="20190402 05:43:38.595"></status>
</kw>
<status status="PASS" endtime="20190402 05:43:38.596" starttime="20190402 05:43:38.580"></status>
</kw>
<status status="PASS" endtime="20190402 05:43:38.596" starttime="20190402 05:43:38.580"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:43:38.597" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:43:38.597" starttime="20190402 05:43:38.597"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:38.598" starttime="20190402 05:43:38.598"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:43:38.599" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:43:38.599" starttime="20190402 05:43:38.598"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:38.599" starttime="20190402 05:43:38.599"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:38.600" starttime="20190402 05:43:38.599"></status>
</kw>
<msg timestamp="20190402 05:43:38.600" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:43:38.600" starttime="20190402 05:43:38.598"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:43:38.600" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:43:38.600" starttime="20190402 05:43:38.600"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:43:38.609" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:43:38.609" starttime="20190402 05:43:38.600"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:43:39.069" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:43:39.070" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:43:39.070" starttime="20190402 05:43:38.610"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:43:39.070" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:43:39.070" starttime="20190402 05:43:39.070"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:43:39.071" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:43:39.071" starttime="20190402 05:43:39.071"></status>
</kw>
<msg timestamp="20190402 05:43:39.071" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:43:39.071" starttime="20190402 05:43:39.070"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:43:39.073" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:43:39.073" starttime="20190402 05:43:39.071"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:43:39.073" level="INFO">0</msg>
<msg timestamp="20190402 05:43:39.073" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:43:39.073" starttime="20190402 05:43:39.073"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:43:39.074" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:43:39.074" starttime="20190402 05:43:39.073"></status>
</kw>
<msg timestamp="20190402 05:43:39.074" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:43:39.074" starttime="20190402 05:43:39.071"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:39.075" starttime="20190402 05:43:39.074"></status>
</kw>
<status status="PASS" endtime="20190402 05:43:39.075" starttime="20190402 05:43:39.074"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:43:39.075" starttime="20190402 05:43:39.075"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:43:39.075" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:43:39.075" starttime="20190402 05:43:39.075"></status>
</kw>
<msg timestamp="20190402 05:43:39.075" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:43:39.075" starttime="20190402 05:43:38.597"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:43:39.076" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:43:39.076" starttime="20190402 05:43:39.076"></status>
</kw>
<msg timestamp="20190402 05:43:39.076" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:43:39.076" starttime="20190402 05:43:38.596"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:43:39.077" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:43:39.077" starttime="20190402 05:43:39.076"></status>
</kw>
<status status="FAIL" endtime="20190402 05:43:39.077" starttime="20190402 05:43:38.596"></status>
</kw>
<status status="FAIL" endtime="20190402 05:43:39.077" starttime="20190402 05:43:38.580"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:09.082" starttime="20190402 05:44:09.081"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:44:09.083" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:44:09.083" starttime="20190402 05:44:09.082"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:09.083" starttime="20190402 05:44:09.083"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:09.084" starttime="20190402 05:44:09.083"></status>
</kw>
<msg timestamp="20190402 05:44:09.084" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:44:09.084" starttime="20190402 05:44:09.082"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:44:09.084" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:09.084" starttime="20190402 05:44:09.084"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:44:09.089" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:44:09.090" starttime="20190402 05:44:09.084"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:44:09.090" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:44:09.091" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:09.091" starttime="20190402 05:44:09.090"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:44:09.091" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:09.091" starttime="20190402 05:44:09.091"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:44:09.091" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:44:09.092" starttime="20190402 05:44:09.091"></status>
</kw>
<msg timestamp="20190402 05:44:09.092" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:44:09.092" starttime="20190402 05:44:09.091"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:44:09.093" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:44:09.093" starttime="20190402 05:44:09.092"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:44:09.093" level="INFO">0</msg>
<msg timestamp="20190402 05:44:09.093" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:44:09.093" starttime="20190402 05:44:09.093"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:44:09.093" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:44:09.094" starttime="20190402 05:44:09.093"></status>
</kw>
<msg timestamp="20190402 05:44:09.094" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:44:09.094" starttime="20190402 05:44:09.092"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:09.094" starttime="20190402 05:44:09.094"></status>
</kw>
<status status="PASS" endtime="20190402 05:44:09.095" starttime="20190402 05:44:09.094"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:09.095" starttime="20190402 05:44:09.095"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:44:09.095" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:44:09.095" starttime="20190402 05:44:09.095"></status>
</kw>
<status status="PASS" endtime="20190402 05:44:09.095" starttime="20190402 05:44:09.080"></status>
</kw>
<status status="PASS" endtime="20190402 05:44:09.095" starttime="20190402 05:44:09.079"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:44:09.096" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:44:09.096" starttime="20190402 05:44:09.096"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:09.097" starttime="20190402 05:44:09.097"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:44:09.098" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:44:09.098" starttime="20190402 05:44:09.097"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:09.098" starttime="20190402 05:44:09.098"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:09.098" starttime="20190402 05:44:09.098"></status>
</kw>
<msg timestamp="20190402 05:44:09.099" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:44:09.099" starttime="20190402 05:44:09.097"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:44:09.099" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:09.099" starttime="20190402 05:44:09.099"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:44:09.100" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:44:09.100" starttime="20190402 05:44:09.099"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:44:09.544" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:44:09.544" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:09.544" starttime="20190402 05:44:09.100"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:44:09.545" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:09.545" starttime="20190402 05:44:09.545"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:44:09.546" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:44:09.546" starttime="20190402 05:44:09.545"></status>
</kw>
<msg timestamp="20190402 05:44:09.546" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:44:09.546" starttime="20190402 05:44:09.544"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:44:09.548" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:44:09.548" starttime="20190402 05:44:09.546"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:44:09.548" level="INFO">0</msg>
<msg timestamp="20190402 05:44:09.548" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:44:09.548" starttime="20190402 05:44:09.548"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:44:09.549" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:44:09.549" starttime="20190402 05:44:09.549"></status>
</kw>
<msg timestamp="20190402 05:44:09.549" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:44:09.549" starttime="20190402 05:44:09.546"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:09.550" starttime="20190402 05:44:09.550"></status>
</kw>
<status status="PASS" endtime="20190402 05:44:09.550" starttime="20190402 05:44:09.549"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:09.550" starttime="20190402 05:44:09.550"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:44:09.550" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:44:09.550" starttime="20190402 05:44:09.550"></status>
</kw>
<msg timestamp="20190402 05:44:09.551" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:44:09.551" starttime="20190402 05:44:09.096"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:44:09.551" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:44:09.551" starttime="20190402 05:44:09.551"></status>
</kw>
<msg timestamp="20190402 05:44:09.551" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:44:09.551" starttime="20190402 05:44:09.096"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:44:09.552" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:44:09.552" starttime="20190402 05:44:09.551"></status>
</kw>
<status status="FAIL" endtime="20190402 05:44:09.552" starttime="20190402 05:44:09.095"></status>
</kw>
<status status="FAIL" endtime="20190402 05:44:09.552" starttime="20190402 05:44:09.078"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:39.557" starttime="20190402 05:44:39.556"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:44:39.558" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:44:39.558" starttime="20190402 05:44:39.558"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:39.558" starttime="20190402 05:44:39.558"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:39.559" starttime="20190402 05:44:39.558"></status>
</kw>
<msg timestamp="20190402 05:44:39.559" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:44:39.559" starttime="20190402 05:44:39.557"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:44:39.559" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:39.559" starttime="20190402 05:44:39.559"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:44:39.564" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:44:39.564" starttime="20190402 05:44:39.559"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:44:39.565" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:44:39.565" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:39.566" starttime="20190402 05:44:39.565"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:44:39.566" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:39.566" starttime="20190402 05:44:39.566"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:44:39.567" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:44:39.567" starttime="20190402 05:44:39.566"></status>
</kw>
<msg timestamp="20190402 05:44:39.567" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:44:39.567" starttime="20190402 05:44:39.566"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:44:39.569" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:44:39.569" starttime="20190402 05:44:39.567"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:44:39.569" level="INFO">0</msg>
<msg timestamp="20190402 05:44:39.569" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:44:39.569" starttime="20190402 05:44:39.569"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:44:39.569" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:44:39.569" starttime="20190402 05:44:39.569"></status>
</kw>
<msg timestamp="20190402 05:44:39.570" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:44:39.570" starttime="20190402 05:44:39.567"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:39.571" starttime="20190402 05:44:39.570"></status>
</kw>
<status status="PASS" endtime="20190402 05:44:39.571" starttime="20190402 05:44:39.570"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:39.571" starttime="20190402 05:44:39.571"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:44:39.571" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:44:39.571" starttime="20190402 05:44:39.571"></status>
</kw>
<status status="PASS" endtime="20190402 05:44:39.571" starttime="20190402 05:44:39.555"></status>
</kw>
<status status="PASS" endtime="20190402 05:44:39.572" starttime="20190402 05:44:39.554"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:44:39.573" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:44:39.573" starttime="20190402 05:44:39.572"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:39.573" starttime="20190402 05:44:39.573"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:44:39.574" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:44:39.574" starttime="20190402 05:44:39.574"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:39.574" starttime="20190402 05:44:39.574"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:39.575" starttime="20190402 05:44:39.575"></status>
</kw>
<msg timestamp="20190402 05:44:39.575" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:44:39.575" starttime="20190402 05:44:39.573"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:44:39.575" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:39.575" starttime="20190402 05:44:39.575"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:44:39.577" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:44:39.578" starttime="20190402 05:44:39.575"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:44:39.890" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:44:39.890" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:39.890" starttime="20190402 05:44:39.578"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:44:39.891" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:44:39.891" starttime="20190402 05:44:39.891"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:44:39.891" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:44:39.891" starttime="20190402 05:44:39.891"></status>
</kw>
<msg timestamp="20190402 05:44:39.891" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:44:39.892" starttime="20190402 05:44:39.890"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:44:39.892" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:44:39.893" starttime="20190402 05:44:39.892"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:44:39.893" level="INFO">0</msg>
<msg timestamp="20190402 05:44:39.893" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:44:39.893" starttime="20190402 05:44:39.893"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:44:39.893" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:44:39.894" starttime="20190402 05:44:39.893"></status>
</kw>
<msg timestamp="20190402 05:44:39.894" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:44:39.894" starttime="20190402 05:44:39.892"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:39.894" starttime="20190402 05:44:39.894"></status>
</kw>
<status status="PASS" endtime="20190402 05:44:39.895" starttime="20190402 05:44:39.894"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:44:39.895" starttime="20190402 05:44:39.895"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:44:39.895" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:44:39.895" starttime="20190402 05:44:39.895"></status>
</kw>
<msg timestamp="20190402 05:44:39.895" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:44:39.895" starttime="20190402 05:44:39.573"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:44:39.896" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:44:39.896" starttime="20190402 05:44:39.895"></status>
</kw>
<msg timestamp="20190402 05:44:39.896" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:44:39.896" starttime="20190402 05:44:39.572"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:44:39.896" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:44:39.896" starttime="20190402 05:44:39.896"></status>
</kw>
<status status="FAIL" endtime="20190402 05:44:39.896" starttime="20190402 05:44:39.572"></status>
</kw>
<status status="FAIL" endtime="20190402 05:44:39.897" starttime="20190402 05:44:39.553"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:09.899" starttime="20190402 05:45:09.899"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:45:09.900" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:45:09.901" starttime="20190402 05:45:09.900"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:09.901" starttime="20190402 05:45:09.901"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:09.902" starttime="20190402 05:45:09.901"></status>
</kw>
<msg timestamp="20190402 05:45:09.902" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:45:09.902" starttime="20190402 05:45:09.899"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:45:09.903" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:09.903" starttime="20190402 05:45:09.902"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:45:09.911" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:45:09.911" starttime="20190402 05:45:09.903"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:45:09.913" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:45:09.913" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:09.913" starttime="20190402 05:45:09.912"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:45:09.915" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:09.915" starttime="20190402 05:45:09.914"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:45:09.915" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:45:09.915" starttime="20190402 05:45:09.915"></status>
</kw>
<msg timestamp="20190402 05:45:09.916" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:45:09.916" starttime="20190402 05:45:09.914"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:45:09.919" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:45:09.919" starttime="20190402 05:45:09.916"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:45:09.920" level="INFO">0</msg>
<msg timestamp="20190402 05:45:09.920" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:45:09.920" starttime="20190402 05:45:09.919"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:45:09.921" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:45:09.921" starttime="20190402 05:45:09.921"></status>
</kw>
<msg timestamp="20190402 05:45:09.921" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:45:09.921" starttime="20190402 05:45:09.916"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:09.923" starttime="20190402 05:45:09.922"></status>
</kw>
<status status="PASS" endtime="20190402 05:45:09.923" starttime="20190402 05:45:09.922"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:09.924" starttime="20190402 05:45:09.923"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:45:09.924" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:45:09.924" starttime="20190402 05:45:09.924"></status>
</kw>
<status status="PASS" endtime="20190402 05:45:09.924" starttime="20190402 05:45:09.898"></status>
</kw>
<status status="PASS" endtime="20190402 05:45:09.925" starttime="20190402 05:45:09.898"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:45:09.926" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:45:09.926" starttime="20190402 05:45:09.926"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:09.928" starttime="20190402 05:45:09.927"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:45:09.929" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:45:09.929" starttime="20190402 05:45:09.929"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:09.930" starttime="20190402 05:45:09.930"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:09.931" starttime="20190402 05:45:09.930"></status>
</kw>
<msg timestamp="20190402 05:45:09.931" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:45:09.931" starttime="20190402 05:45:09.928"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:45:09.931" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:09.931" starttime="20190402 05:45:09.931"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:45:09.946" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:45:09.946" starttime="20190402 05:45:09.932"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:45:10.245" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:45:10.245" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:10.245" starttime="20190402 05:45:09.946"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:45:10.246" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:10.246" starttime="20190402 05:45:10.246"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:45:10.246" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:45:10.246" starttime="20190402 05:45:10.246"></status>
</kw>
<msg timestamp="20190402 05:45:10.246" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:45:10.246" starttime="20190402 05:45:10.245"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:45:10.248" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:45:10.248" starttime="20190402 05:45:10.247"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:45:10.249" level="INFO">0</msg>
<msg timestamp="20190402 05:45:10.249" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:45:10.249" starttime="20190402 05:45:10.248"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:45:10.249" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:45:10.249" starttime="20190402 05:45:10.249"></status>
</kw>
<msg timestamp="20190402 05:45:10.249" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:45:10.249" starttime="20190402 05:45:10.246"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:10.250" starttime="20190402 05:45:10.250"></status>
</kw>
<status status="PASS" endtime="20190402 05:45:10.250" starttime="20190402 05:45:10.249"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:10.250" starttime="20190402 05:45:10.250"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:45:10.251" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:45:10.251" starttime="20190402 05:45:10.250"></status>
</kw>
<msg timestamp="20190402 05:45:10.251" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:45:10.251" starttime="20190402 05:45:09.927"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:45:10.251" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:45:10.251" starttime="20190402 05:45:10.251"></status>
</kw>
<msg timestamp="20190402 05:45:10.251" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:45:10.251" starttime="20190402 05:45:09.925"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:45:10.252" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:45:10.252" starttime="20190402 05:45:10.252"></status>
</kw>
<status status="FAIL" endtime="20190402 05:45:10.252" starttime="20190402 05:45:09.925"></status>
</kw>
<status status="FAIL" endtime="20190402 05:45:10.252" starttime="20190402 05:45:09.897"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:40.257" starttime="20190402 05:45:40.256"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:45:40.259" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:45:40.259" starttime="20190402 05:45:40.258"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:40.259" starttime="20190402 05:45:40.259"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:40.259" starttime="20190402 05:45:40.259"></status>
</kw>
<msg timestamp="20190402 05:45:40.260" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:45:40.260" starttime="20190402 05:45:40.258"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:45:40.260" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:40.260" starttime="20190402 05:45:40.260"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:45:40.264" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:45:40.264" starttime="20190402 05:45:40.260"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:45:40.265" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:45:40.265" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:40.265" starttime="20190402 05:45:40.264"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:45:40.266" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:40.266" starttime="20190402 05:45:40.266"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:45:40.266" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:45:40.266" starttime="20190402 05:45:40.266"></status>
</kw>
<msg timestamp="20190402 05:45:40.266" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:45:40.266" starttime="20190402 05:45:40.265"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:45:40.268" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:45:40.268" starttime="20190402 05:45:40.267"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:45:40.269" level="INFO">0</msg>
<msg timestamp="20190402 05:45:40.269" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:45:40.269" starttime="20190402 05:45:40.269"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:45:40.269" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:45:40.269" starttime="20190402 05:45:40.269"></status>
</kw>
<msg timestamp="20190402 05:45:40.269" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:45:40.269" starttime="20190402 05:45:40.267"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:40.270" starttime="20190402 05:45:40.270"></status>
</kw>
<status status="PASS" endtime="20190402 05:45:40.270" starttime="20190402 05:45:40.269"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:40.271" starttime="20190402 05:45:40.270"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:45:40.271" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:45:40.271" starttime="20190402 05:45:40.271"></status>
</kw>
<status status="PASS" endtime="20190402 05:45:40.271" starttime="20190402 05:45:40.255"></status>
</kw>
<status status="PASS" endtime="20190402 05:45:40.271" starttime="20190402 05:45:40.254"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:45:40.272" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:45:40.272" starttime="20190402 05:45:40.272"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:40.273" starttime="20190402 05:45:40.273"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:45:40.274" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:45:40.274" starttime="20190402 05:45:40.273"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:40.274" starttime="20190402 05:45:40.274"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:40.274" starttime="20190402 05:45:40.274"></status>
</kw>
<msg timestamp="20190402 05:45:40.275" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:45:40.275" starttime="20190402 05:45:40.273"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:45:40.275" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:40.275" starttime="20190402 05:45:40.275"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:45:40.285" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:45:40.285" starttime="20190402 05:45:40.275"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:45:40.625" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:45:40.625" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:40.625" starttime="20190402 05:45:40.285"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:45:40.626" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:45:40.626" starttime="20190402 05:45:40.626"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:45:40.627" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:45:40.627" starttime="20190402 05:45:40.626"></status>
</kw>
<msg timestamp="20190402 05:45:40.627" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:45:40.627" starttime="20190402 05:45:40.625"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:45:40.628" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:45:40.628" starttime="20190402 05:45:40.627"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:45:40.629" level="INFO">0</msg>
<msg timestamp="20190402 05:45:40.629" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:45:40.629" starttime="20190402 05:45:40.628"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:45:40.629" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:45:40.629" starttime="20190402 05:45:40.629"></status>
</kw>
<msg timestamp="20190402 05:45:40.629" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:45:40.629" starttime="20190402 05:45:40.627"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:40.630" starttime="20190402 05:45:40.630"></status>
</kw>
<status status="PASS" endtime="20190402 05:45:40.630" starttime="20190402 05:45:40.629"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:45:40.630" starttime="20190402 05:45:40.630"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:45:40.631" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:45:40.631" starttime="20190402 05:45:40.631"></status>
</kw>
<msg timestamp="20190402 05:45:40.631" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:45:40.631" starttime="20190402 05:45:40.272"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:45:40.631" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:45:40.631" starttime="20190402 05:45:40.631"></status>
</kw>
<msg timestamp="20190402 05:45:40.631" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:45:40.631" starttime="20190402 05:45:40.271"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:45:40.632" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:45:40.632" starttime="20190402 05:45:40.632"></status>
</kw>
<status status="FAIL" endtime="20190402 05:45:40.632" starttime="20190402 05:45:40.271"></status>
</kw>
<status status="FAIL" endtime="20190402 05:45:40.632" starttime="20190402 05:45:40.253"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:10.637" starttime="20190402 05:46:10.637"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:46:10.639" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:46:10.639" starttime="20190402 05:46:10.638"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:10.639" starttime="20190402 05:46:10.639"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:10.639" starttime="20190402 05:46:10.639"></status>
</kw>
<msg timestamp="20190402 05:46:10.640" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:46:10.640" starttime="20190402 05:46:10.638"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:46:10.640" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:10.640" starttime="20190402 05:46:10.640"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:46:10.645" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:46:10.646" starttime="20190402 05:46:10.640"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:46:10.647" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:46:10.647" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:10.647" starttime="20190402 05:46:10.646"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:46:10.647" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:10.647" starttime="20190402 05:46:10.647"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:46:10.648" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:46:10.648" starttime="20190402 05:46:10.647"></status>
</kw>
<msg timestamp="20190402 05:46:10.648" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:46:10.648" starttime="20190402 05:46:10.647"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:46:10.649" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:46:10.649" starttime="20190402 05:46:10.648"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:46:10.649" level="INFO">0</msg>
<msg timestamp="20190402 05:46:10.650" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:46:10.650" starttime="20190402 05:46:10.649"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:46:10.650" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:46:10.650" starttime="20190402 05:46:10.650"></status>
</kw>
<msg timestamp="20190402 05:46:10.650" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:46:10.650" starttime="20190402 05:46:10.648"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:10.651" starttime="20190402 05:46:10.651"></status>
</kw>
<status status="PASS" endtime="20190402 05:46:10.651" starttime="20190402 05:46:10.650"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:10.651" starttime="20190402 05:46:10.651"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:46:10.652" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:46:10.652" starttime="20190402 05:46:10.651"></status>
</kw>
<status status="PASS" endtime="20190402 05:46:10.652" starttime="20190402 05:46:10.635"></status>
</kw>
<status status="PASS" endtime="20190402 05:46:10.652" starttime="20190402 05:46:10.634"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:46:10.653" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:46:10.653" starttime="20190402 05:46:10.653"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:10.653" starttime="20190402 05:46:10.653"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:46:10.654" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:46:10.654" starttime="20190402 05:46:10.654"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:10.654" starttime="20190402 05:46:10.654"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:10.655" starttime="20190402 05:46:10.655"></status>
</kw>
<msg timestamp="20190402 05:46:10.655" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:46:10.655" starttime="20190402 05:46:10.654"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:46:10.655" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:10.655" starttime="20190402 05:46:10.655"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:46:10.657" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:46:10.657" starttime="20190402 05:46:10.655"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:46:10.984" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:46:10.984" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:10.984" starttime="20190402 05:46:10.657"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:46:10.985" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:10.985" starttime="20190402 05:46:10.984"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:46:10.985" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:46:10.985" starttime="20190402 05:46:10.985"></status>
</kw>
<msg timestamp="20190402 05:46:10.985" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:46:10.985" starttime="20190402 05:46:10.984"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:46:10.986" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:46:10.987" starttime="20190402 05:46:10.985"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:46:10.987" level="INFO">0</msg>
<msg timestamp="20190402 05:46:10.987" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:46:10.987" starttime="20190402 05:46:10.987"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:46:10.987" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:46:10.987" starttime="20190402 05:46:10.987"></status>
</kw>
<msg timestamp="20190402 05:46:10.987" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:46:10.988" starttime="20190402 05:46:10.985"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:10.988" starttime="20190402 05:46:10.988"></status>
</kw>
<status status="PASS" endtime="20190402 05:46:10.988" starttime="20190402 05:46:10.988"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:10.989" starttime="20190402 05:46:10.988"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:46:10.989" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:46:10.989" starttime="20190402 05:46:10.989"></status>
</kw>
<msg timestamp="20190402 05:46:10.989" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:46:10.989" starttime="20190402 05:46:10.653"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:46:10.990" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:46:10.990" starttime="20190402 05:46:10.989"></status>
</kw>
<msg timestamp="20190402 05:46:10.990" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:46:10.990" starttime="20190402 05:46:10.652"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:46:10.990" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:46:10.990" starttime="20190402 05:46:10.990"></status>
</kw>
<status status="FAIL" endtime="20190402 05:46:10.990" starttime="20190402 05:46:10.652"></status>
</kw>
<status status="FAIL" endtime="20190402 05:46:10.991" starttime="20190402 05:46:10.633"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:40.996" starttime="20190402 05:46:40.995"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:46:40.997" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:46:40.997" starttime="20190402 05:46:40.996"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:40.997" starttime="20190402 05:46:40.997"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:40.997" starttime="20190402 05:46:40.997"></status>
</kw>
<msg timestamp="20190402 05:46:40.998" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:46:40.998" starttime="20190402 05:46:40.996"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:46:40.998" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:40.998" starttime="20190402 05:46:40.998"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:46:41.003" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:46:41.003" starttime="20190402 05:46:40.998"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:46:41.005" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:46:41.005" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:41.005" starttime="20190402 05:46:41.004"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:46:41.005" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:41.005" starttime="20190402 05:46:41.005"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:46:41.006" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:46:41.006" starttime="20190402 05:46:41.005"></status>
</kw>
<msg timestamp="20190402 05:46:41.006" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:46:41.006" starttime="20190402 05:46:41.005"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:46:41.008" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:46:41.008" starttime="20190402 05:46:41.006"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:46:41.009" level="INFO">0</msg>
<msg timestamp="20190402 05:46:41.009" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:46:41.009" starttime="20190402 05:46:41.008"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:46:41.009" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:46:41.009" starttime="20190402 05:46:41.009"></status>
</kw>
<msg timestamp="20190402 05:46:41.009" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:46:41.009" starttime="20190402 05:46:41.006"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:41.010" starttime="20190402 05:46:41.010"></status>
</kw>
<status status="PASS" endtime="20190402 05:46:41.010" starttime="20190402 05:46:41.010"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:41.011" starttime="20190402 05:46:41.010"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:46:41.011" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:46:41.011" starttime="20190402 05:46:41.011"></status>
</kw>
<status status="PASS" endtime="20190402 05:46:41.011" starttime="20190402 05:46:40.994"></status>
</kw>
<status status="PASS" endtime="20190402 05:46:41.011" starttime="20190402 05:46:40.993"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:46:41.012" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:46:41.012" starttime="20190402 05:46:41.012"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:41.013" starttime="20190402 05:46:41.013"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:46:41.014" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:46:41.014" starttime="20190402 05:46:41.014"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:41.014" starttime="20190402 05:46:41.014"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:41.015" starttime="20190402 05:46:41.014"></status>
</kw>
<msg timestamp="20190402 05:46:41.015" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:46:41.015" starttime="20190402 05:46:41.013"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:46:41.015" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:41.015" starttime="20190402 05:46:41.015"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:46:41.017" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:46:41.018" starttime="20190402 05:46:41.015"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:46:41.364" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:46:41.364" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:41.364" starttime="20190402 05:46:41.018"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:46:41.364" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:46:41.365" starttime="20190402 05:46:41.364"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:46:41.365" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:46:41.365" starttime="20190402 05:46:41.365"></status>
</kw>
<msg timestamp="20190402 05:46:41.365" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:46:41.365" starttime="20190402 05:46:41.364"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:46:41.367" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:46:41.367" starttime="20190402 05:46:41.365"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:46:41.367" level="INFO">0</msg>
<msg timestamp="20190402 05:46:41.368" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:46:41.368" starttime="20190402 05:46:41.367"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:46:41.368" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:46:41.368" starttime="20190402 05:46:41.368"></status>
</kw>
<msg timestamp="20190402 05:46:41.368" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:46:41.368" starttime="20190402 05:46:41.365"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:41.369" starttime="20190402 05:46:41.369"></status>
</kw>
<status status="PASS" endtime="20190402 05:46:41.369" starttime="20190402 05:46:41.368"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:46:41.369" starttime="20190402 05:46:41.369"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:46:41.369" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:46:41.370" starttime="20190402 05:46:41.369"></status>
</kw>
<msg timestamp="20190402 05:46:41.370" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:46:41.370" starttime="20190402 05:46:41.012"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:46:41.370" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:46:41.370" starttime="20190402 05:46:41.370"></status>
</kw>
<msg timestamp="20190402 05:46:41.370" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:46:41.370" starttime="20190402 05:46:41.012"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:46:41.371" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:46:41.371" starttime="20190402 05:46:41.370"></status>
</kw>
<status status="FAIL" endtime="20190402 05:46:41.371" starttime="20190402 05:46:41.011"></status>
</kw>
<status status="FAIL" endtime="20190402 05:46:41.371" starttime="20190402 05:46:40.991"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:11.373" starttime="20190402 05:47:11.373"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:47:11.374" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:47:11.374" starttime="20190402 05:47:11.374"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:11.375" starttime="20190402 05:47:11.375"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:11.375" starttime="20190402 05:47:11.375"></status>
</kw>
<msg timestamp="20190402 05:47:11.376" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:47:11.376" starttime="20190402 05:47:11.373"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:47:11.376" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:11.376" starttime="20190402 05:47:11.376"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:47:11.379" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:47:11.379" starttime="20190402 05:47:11.376"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:47:11.382" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:47:11.382" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:11.382" starttime="20190402 05:47:11.379"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:47:11.383" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:11.383" starttime="20190402 05:47:11.382"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:47:11.383" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:47:11.383" starttime="20190402 05:47:11.383"></status>
</kw>
<msg timestamp="20190402 05:47:11.383" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:47:11.383" starttime="20190402 05:47:11.382"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:47:11.386" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:47:11.386" starttime="20190402 05:47:11.384"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:47:11.386" level="INFO">0</msg>
<msg timestamp="20190402 05:47:11.386" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:47:11.386" starttime="20190402 05:47:11.386"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:47:11.387" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:47:11.387" starttime="20190402 05:47:11.387"></status>
</kw>
<msg timestamp="20190402 05:47:11.387" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:47:11.387" starttime="20190402 05:47:11.383"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:11.388" starttime="20190402 05:47:11.388"></status>
</kw>
<status status="PASS" endtime="20190402 05:47:11.388" starttime="20190402 05:47:11.387"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:11.388" starttime="20190402 05:47:11.388"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:47:11.388" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:47:11.389" starttime="20190402 05:47:11.388"></status>
</kw>
<status status="PASS" endtime="20190402 05:47:11.389" starttime="20190402 05:47:11.372"></status>
</kw>
<status status="PASS" endtime="20190402 05:47:11.389" starttime="20190402 05:47:11.372"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:47:11.390" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:47:11.390" starttime="20190402 05:47:11.389"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:11.391" starttime="20190402 05:47:11.390"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:47:11.391" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:47:11.391" starttime="20190402 05:47:11.391"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:11.392" starttime="20190402 05:47:11.391"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:11.392" starttime="20190402 05:47:11.392"></status>
</kw>
<msg timestamp="20190402 05:47:11.392" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:47:11.392" starttime="20190402 05:47:11.391"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:47:11.393" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:11.393" starttime="20190402 05:47:11.392"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:47:11.395" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:47:11.395" starttime="20190402 05:47:11.393"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:47:11.707" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:47:11.707" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:11.707" starttime="20190402 05:47:11.395"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:47:11.708" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:11.708" starttime="20190402 05:47:11.708"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:47:11.708" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:47:11.708" starttime="20190402 05:47:11.708"></status>
</kw>
<msg timestamp="20190402 05:47:11.708" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:47:11.708" starttime="20190402 05:47:11.707"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:47:11.710" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:47:11.710" starttime="20190402 05:47:11.709"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:47:11.711" level="INFO">0</msg>
<msg timestamp="20190402 05:47:11.711" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:47:11.711" starttime="20190402 05:47:11.710"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:47:11.711" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:47:11.711" starttime="20190402 05:47:11.711"></status>
</kw>
<msg timestamp="20190402 05:47:11.711" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:47:11.711" starttime="20190402 05:47:11.708"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:11.712" starttime="20190402 05:47:11.712"></status>
</kw>
<status status="PASS" endtime="20190402 05:47:11.712" starttime="20190402 05:47:11.711"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:11.712" starttime="20190402 05:47:11.712"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:47:11.713" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:47:11.713" starttime="20190402 05:47:11.712"></status>
</kw>
<msg timestamp="20190402 05:47:11.713" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:47:11.713" starttime="20190402 05:47:11.390"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:47:11.713" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:47:11.713" starttime="20190402 05:47:11.713"></status>
</kw>
<msg timestamp="20190402 05:47:11.713" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:47:11.713" starttime="20190402 05:47:11.389"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:47:11.714" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:47:11.714" starttime="20190402 05:47:11.714"></status>
</kw>
<status status="FAIL" endtime="20190402 05:47:11.714" starttime="20190402 05:47:11.389"></status>
</kw>
<status status="FAIL" endtime="20190402 05:47:11.714" starttime="20190402 05:47:11.371"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:41.720" starttime="20190402 05:47:41.719"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:47:41.721" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:47:41.721" starttime="20190402 05:47:41.720"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:41.721" starttime="20190402 05:47:41.721"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:41.721" starttime="20190402 05:47:41.721"></status>
</kw>
<msg timestamp="20190402 05:47:41.722" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:47:41.722" starttime="20190402 05:47:41.720"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:47:41.722" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:41.722" starttime="20190402 05:47:41.722"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:47:41.726" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:47:41.727" starttime="20190402 05:47:41.722"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:47:41.727" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:47:41.728" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:41.728" starttime="20190402 05:47:41.727"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:47:41.728" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:41.728" starttime="20190402 05:47:41.728"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:47:41.729" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:47:41.729" starttime="20190402 05:47:41.728"></status>
</kw>
<msg timestamp="20190402 05:47:41.729" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:47:41.729" starttime="20190402 05:47:41.728"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:47:41.730" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:47:41.731" starttime="20190402 05:47:41.729"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:47:41.732" level="INFO">0</msg>
<msg timestamp="20190402 05:47:41.732" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:47:41.732" starttime="20190402 05:47:41.731"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:47:41.732" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:47:41.732" starttime="20190402 05:47:41.732"></status>
</kw>
<msg timestamp="20190402 05:47:41.732" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:47:41.732" starttime="20190402 05:47:41.729"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:41.733" starttime="20190402 05:47:41.733"></status>
</kw>
<status status="PASS" endtime="20190402 05:47:41.733" starttime="20190402 05:47:41.732"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:41.734" starttime="20190402 05:47:41.733"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:47:41.734" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:47:41.734" starttime="20190402 05:47:41.734"></status>
</kw>
<status status="PASS" endtime="20190402 05:47:41.734" starttime="20190402 05:47:41.717"></status>
</kw>
<status status="PASS" endtime="20190402 05:47:41.734" starttime="20190402 05:47:41.716"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:47:41.735" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:47:41.735" starttime="20190402 05:47:41.735"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:41.736" starttime="20190402 05:47:41.736"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:47:41.737" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:47:41.737" starttime="20190402 05:47:41.736"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:41.737" starttime="20190402 05:47:41.737"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:41.737" starttime="20190402 05:47:41.737"></status>
</kw>
<msg timestamp="20190402 05:47:41.738" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:47:41.738" starttime="20190402 05:47:41.736"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:47:41.738" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:41.738" starttime="20190402 05:47:41.738"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:47:41.740" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:47:41.740" starttime="20190402 05:47:41.738"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:47:42.048" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:47:42.048" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:42.048" starttime="20190402 05:47:41.740"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:47:42.049" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:47:42.049" starttime="20190402 05:47:42.049"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:47:42.049" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:47:42.050" starttime="20190402 05:47:42.049"></status>
</kw>
<msg timestamp="20190402 05:47:42.050" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:47:42.050" starttime="20190402 05:47:42.049"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:47:42.051" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:47:42.052" starttime="20190402 05:47:42.050"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:47:42.052" level="INFO">0</msg>
<msg timestamp="20190402 05:47:42.052" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:47:42.052" starttime="20190402 05:47:42.052"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:47:42.053" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:47:42.053" starttime="20190402 05:47:42.052"></status>
</kw>
<msg timestamp="20190402 05:47:42.053" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:47:42.053" starttime="20190402 05:47:42.050"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:42.054" starttime="20190402 05:47:42.054"></status>
</kw>
<status status="PASS" endtime="20190402 05:47:42.054" starttime="20190402 05:47:42.053"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:47:42.054" starttime="20190402 05:47:42.054"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:47:42.054" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:47:42.055" starttime="20190402 05:47:42.054"></status>
</kw>
<msg timestamp="20190402 05:47:42.055" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:47:42.055" starttime="20190402 05:47:41.735"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:47:42.055" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:47:42.055" starttime="20190402 05:47:42.055"></status>
</kw>
<msg timestamp="20190402 05:47:42.055" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:47:42.055" starttime="20190402 05:47:41.734"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:47:42.056" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:47:42.056" starttime="20190402 05:47:42.055"></status>
</kw>
<status status="FAIL" endtime="20190402 05:47:42.056" starttime="20190402 05:47:41.734"></status>
</kw>
<status status="FAIL" endtime="20190402 05:47:42.056" starttime="20190402 05:47:41.715"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:12.060" starttime="20190402 05:48:12.059"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:48:12.061" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:48:12.061" starttime="20190402 05:48:12.061"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:12.062" starttime="20190402 05:48:12.061"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:12.062" starttime="20190402 05:48:12.062"></status>
</kw>
<msg timestamp="20190402 05:48:12.062" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:48:12.062" starttime="20190402 05:48:12.060"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:48:12.063" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:12.063" starttime="20190402 05:48:12.062"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:48:12.068" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:48:12.068" starttime="20190402 05:48:12.063"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:48:12.069" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:48:12.069" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:12.069" starttime="20190402 05:48:12.068"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:48:12.070" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:12.070" starttime="20190402 05:48:12.069"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:48:12.070" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:48:12.070" starttime="20190402 05:48:12.070"></status>
</kw>
<msg timestamp="20190402 05:48:12.070" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:48:12.070" starttime="20190402 05:48:12.069"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:48:12.071" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:48:12.071" starttime="20190402 05:48:12.070"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:48:12.072" level="INFO">0</msg>
<msg timestamp="20190402 05:48:12.072" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:48:12.072" starttime="20190402 05:48:12.072"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:48:12.073" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:48:12.073" starttime="20190402 05:48:12.072"></status>
</kw>
<msg timestamp="20190402 05:48:12.073" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:48:12.073" starttime="20190402 05:48:12.070"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:12.074" starttime="20190402 05:48:12.073"></status>
</kw>
<status status="PASS" endtime="20190402 05:48:12.074" starttime="20190402 05:48:12.073"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:12.074" starttime="20190402 05:48:12.074"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:48:12.074" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:48:12.074" starttime="20190402 05:48:12.074"></status>
</kw>
<status status="PASS" endtime="20190402 05:48:12.074" starttime="20190402 05:48:12.058"></status>
</kw>
<status status="PASS" endtime="20190402 05:48:12.075" starttime="20190402 05:48:12.057"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:48:12.076" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:48:12.076" starttime="20190402 05:48:12.075"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:12.076" starttime="20190402 05:48:12.076"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:48:12.077" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:48:12.077" starttime="20190402 05:48:12.077"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:12.077" starttime="20190402 05:48:12.077"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:12.078" starttime="20190402 05:48:12.078"></status>
</kw>
<msg timestamp="20190402 05:48:12.078" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:48:12.078" starttime="20190402 05:48:12.077"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:48:12.078" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:12.078" starttime="20190402 05:48:12.078"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:48:12.080" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:48:12.080" starttime="20190402 05:48:12.078"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:48:12.391" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:48:12.391" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:12.391" starttime="20190402 05:48:12.080"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:48:12.392" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:12.392" starttime="20190402 05:48:12.391"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:48:12.392" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:48:12.392" starttime="20190402 05:48:12.392"></status>
</kw>
<msg timestamp="20190402 05:48:12.392" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:48:12.392" starttime="20190402 05:48:12.391"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:48:12.394" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:48:12.394" starttime="20190402 05:48:12.392"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:48:12.395" level="INFO">0</msg>
<msg timestamp="20190402 05:48:12.395" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:48:12.395" starttime="20190402 05:48:12.395"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:48:12.395" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:48:12.395" starttime="20190402 05:48:12.395"></status>
</kw>
<msg timestamp="20190402 05:48:12.395" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:48:12.395" starttime="20190402 05:48:12.392"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:12.396" starttime="20190402 05:48:12.396"></status>
</kw>
<status status="PASS" endtime="20190402 05:48:12.396" starttime="20190402 05:48:12.396"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:12.397" starttime="20190402 05:48:12.396"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:48:12.397" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:48:12.397" starttime="20190402 05:48:12.397"></status>
</kw>
<msg timestamp="20190402 05:48:12.397" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:48:12.397" starttime="20190402 05:48:12.076"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:48:12.397" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:48:12.397" starttime="20190402 05:48:12.397"></status>
</kw>
<msg timestamp="20190402 05:48:12.398" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:48:12.398" starttime="20190402 05:48:12.075"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:48:12.398" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:48:12.398" starttime="20190402 05:48:12.398"></status>
</kw>
<status status="FAIL" endtime="20190402 05:48:12.398" starttime="20190402 05:48:12.075"></status>
</kw>
<status status="FAIL" endtime="20190402 05:48:12.398" starttime="20190402 05:48:12.056"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:42.404" starttime="20190402 05:48:42.402"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:48:42.405" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:48:42.405" starttime="20190402 05:48:42.404"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:42.405" starttime="20190402 05:48:42.405"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:42.406" starttime="20190402 05:48:42.405"></status>
</kw>
<msg timestamp="20190402 05:48:42.406" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:48:42.406" starttime="20190402 05:48:42.404"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:48:42.406" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:42.406" starttime="20190402 05:48:42.406"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:48:42.411" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:48:42.411" starttime="20190402 05:48:42.406"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:48:42.412" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:48:42.412" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:42.412" starttime="20190402 05:48:42.411"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:48:42.412" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:42.412" starttime="20190402 05:48:42.412"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:48:42.413" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:48:42.413" starttime="20190402 05:48:42.412"></status>
</kw>
<msg timestamp="20190402 05:48:42.413" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:48:42.413" starttime="20190402 05:48:42.412"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:48:42.415" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:48:42.415" starttime="20190402 05:48:42.413"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:48:42.415" level="INFO">0</msg>
<msg timestamp="20190402 05:48:42.415" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:48:42.415" starttime="20190402 05:48:42.415"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:48:42.415" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:48:42.415" starttime="20190402 05:48:42.415"></status>
</kw>
<msg timestamp="20190402 05:48:42.416" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:48:42.416" starttime="20190402 05:48:42.413"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:42.416" starttime="20190402 05:48:42.416"></status>
</kw>
<status status="PASS" endtime="20190402 05:48:42.416" starttime="20190402 05:48:42.416"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:42.417" starttime="20190402 05:48:42.417"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:48:42.417" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:48:42.417" starttime="20190402 05:48:42.417"></status>
</kw>
<status status="PASS" endtime="20190402 05:48:42.417" starttime="20190402 05:48:42.401"></status>
</kw>
<status status="PASS" endtime="20190402 05:48:42.417" starttime="20190402 05:48:42.400"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:48:42.418" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:48:42.418" starttime="20190402 05:48:42.418"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:42.419" starttime="20190402 05:48:42.419"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:48:42.420" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:48:42.420" starttime="20190402 05:48:42.419"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:42.420" starttime="20190402 05:48:42.420"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:42.421" starttime="20190402 05:48:42.420"></status>
</kw>
<msg timestamp="20190402 05:48:42.421" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:48:42.421" starttime="20190402 05:48:42.419"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:48:42.421" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:42.421" starttime="20190402 05:48:42.421"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:48:42.423" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:48:42.423" starttime="20190402 05:48:42.421"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:48:42.732" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:48:42.733" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:42.733" starttime="20190402 05:48:42.423"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:48:42.733" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:48:42.733" starttime="20190402 05:48:42.733"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:48:42.734" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:48:42.734" starttime="20190402 05:48:42.733"></status>
</kw>
<msg timestamp="20190402 05:48:42.734" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:48:42.734" starttime="20190402 05:48:42.733"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:48:42.736" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:48:42.736" starttime="20190402 05:48:42.734"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:48:42.736" level="INFO">0</msg>
<msg timestamp="20190402 05:48:42.736" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:48:42.736" starttime="20190402 05:48:42.736"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:48:42.737" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:48:42.737" starttime="20190402 05:48:42.736"></status>
</kw>
<msg timestamp="20190402 05:48:42.737" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:48:42.737" starttime="20190402 05:48:42.734"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:42.738" starttime="20190402 05:48:42.737"></status>
</kw>
<status status="PASS" endtime="20190402 05:48:42.738" starttime="20190402 05:48:42.737"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:48:42.738" starttime="20190402 05:48:42.738"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:48:42.738" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:48:42.738" starttime="20190402 05:48:42.738"></status>
</kw>
<msg timestamp="20190402 05:48:42.738" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:48:42.738" starttime="20190402 05:48:42.418"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:48:42.739" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:48:42.739" starttime="20190402 05:48:42.739"></status>
</kw>
<msg timestamp="20190402 05:48:42.739" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:48:42.739" starttime="20190402 05:48:42.418"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:48:42.739" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:48:42.739" starttime="20190402 05:48:42.739"></status>
</kw>
<status status="FAIL" endtime="20190402 05:48:42.740" starttime="20190402 05:48:42.417"></status>
</kw>
<status status="FAIL" endtime="20190402 05:48:42.740" starttime="20190402 05:48:42.399"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:12.745" starttime="20190402 05:49:12.744"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:49:12.748" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:49:12.748" starttime="20190402 05:49:12.747"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:12.749" starttime="20190402 05:49:12.748"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:12.751" starttime="20190402 05:49:12.750"></status>
</kw>
<msg timestamp="20190402 05:49:12.752" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:49:12.752" starttime="20190402 05:49:12.746"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:49:12.753" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:12.753" starttime="20190402 05:49:12.752"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:49:12.769" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:49:12.769" starttime="20190402 05:49:12.753"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:49:12.772" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:49:12.772" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:12.772" starttime="20190402 05:49:12.769"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:49:12.774" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:12.774" starttime="20190402 05:49:12.774"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:49:12.775" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:49:12.775" starttime="20190402 05:49:12.775"></status>
</kw>
<msg timestamp="20190402 05:49:12.776" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:49:12.776" starttime="20190402 05:49:12.772"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:49:12.778" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:49:12.778" starttime="20190402 05:49:12.776"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:49:12.779" level="INFO">0</msg>
<msg timestamp="20190402 05:49:12.779" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:49:12.779" starttime="20190402 05:49:12.778"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:49:12.779" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:49:12.780" starttime="20190402 05:49:12.779"></status>
</kw>
<msg timestamp="20190402 05:49:12.780" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:49:12.780" starttime="20190402 05:49:12.776"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:12.781" starttime="20190402 05:49:12.781"></status>
</kw>
<status status="PASS" endtime="20190402 05:49:12.781" starttime="20190402 05:49:12.780"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:12.782" starttime="20190402 05:49:12.782"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:49:12.782" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:49:12.783" starttime="20190402 05:49:12.782"></status>
</kw>
<status status="PASS" endtime="20190402 05:49:12.783" starttime="20190402 05:49:12.743"></status>
</kw>
<status status="PASS" endtime="20190402 05:49:12.783" starttime="20190402 05:49:12.742"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:49:12.785" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:49:12.785" starttime="20190402 05:49:12.784"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:12.786" starttime="20190402 05:49:12.785"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:49:12.787" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:49:12.787" starttime="20190402 05:49:12.786"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:12.787" starttime="20190402 05:49:12.787"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:12.788" starttime="20190402 05:49:12.788"></status>
</kw>
<msg timestamp="20190402 05:49:12.788" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:49:12.788" starttime="20190402 05:49:12.786"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:49:12.789" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:12.789" starttime="20190402 05:49:12.788"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:49:12.791" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:49:12.791" starttime="20190402 05:49:12.789"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:49:13.111" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:49:13.111" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:13.111" starttime="20190402 05:49:12.791"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:49:13.112" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:13.112" starttime="20190402 05:49:13.112"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:49:13.112" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:49:13.112" starttime="20190402 05:49:13.112"></status>
</kw>
<msg timestamp="20190402 05:49:13.112" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:49:13.112" starttime="20190402 05:49:13.111"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:49:13.114" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:49:13.114" starttime="20190402 05:49:13.113"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:49:13.115" level="INFO">0</msg>
<msg timestamp="20190402 05:49:13.115" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:49:13.115" starttime="20190402 05:49:13.114"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:49:13.115" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:49:13.116" starttime="20190402 05:49:13.115"></status>
</kw>
<msg timestamp="20190402 05:49:13.116" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:49:13.116" starttime="20190402 05:49:13.113"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:13.116" starttime="20190402 05:49:13.116"></status>
</kw>
<status status="PASS" endtime="20190402 05:49:13.116" starttime="20190402 05:49:13.116"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:13.117" starttime="20190402 05:49:13.117"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:49:13.117" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:49:13.117" starttime="20190402 05:49:13.117"></status>
</kw>
<msg timestamp="20190402 05:49:13.117" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:49:13.117" starttime="20190402 05:49:12.785"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:49:13.118" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:49:13.118" starttime="20190402 05:49:13.117"></status>
</kw>
<msg timestamp="20190402 05:49:13.118" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:49:13.118" starttime="20190402 05:49:12.784"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:49:13.118" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:49:13.118" starttime="20190402 05:49:13.118"></status>
</kw>
<status status="FAIL" endtime="20190402 05:49:13.119" starttime="20190402 05:49:12.783"></status>
</kw>
<status status="FAIL" endtime="20190402 05:49:13.119" starttime="20190402 05:49:12.740"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:43.124" starttime="20190402 05:49:43.123"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:49:43.127" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:49:43.127" starttime="20190402 05:49:43.125"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:43.129" starttime="20190402 05:49:43.128"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:43.131" starttime="20190402 05:49:43.130"></status>
</kw>
<msg timestamp="20190402 05:49:43.132" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:49:43.132" starttime="20190402 05:49:43.124"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:49:43.133" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:43.133" starttime="20190402 05:49:43.133"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:49:43.137" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:49:43.137" starttime="20190402 05:49:43.134"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:49:43.140" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:49:43.140" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:43.141" starttime="20190402 05:49:43.137"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:49:43.142" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:43.143" starttime="20190402 05:49:43.142"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:49:43.144" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:49:43.144" starttime="20190402 05:49:43.143"></status>
</kw>
<msg timestamp="20190402 05:49:43.144" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:49:43.144" starttime="20190402 05:49:43.141"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:49:43.147" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:49:43.147" starttime="20190402 05:49:43.145"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:49:43.148" level="INFO">0</msg>
<msg timestamp="20190402 05:49:43.149" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:49:43.149" starttime="20190402 05:49:43.148"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:49:43.149" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:49:43.150" starttime="20190402 05:49:43.149"></status>
</kw>
<msg timestamp="20190402 05:49:43.150" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:49:43.150" starttime="20190402 05:49:43.145"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:43.152" starttime="20190402 05:49:43.151"></status>
</kw>
<status status="PASS" endtime="20190402 05:49:43.152" starttime="20190402 05:49:43.150"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:43.153" starttime="20190402 05:49:43.152"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:49:43.154" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:49:43.154" starttime="20190402 05:49:43.153"></status>
</kw>
<status status="PASS" endtime="20190402 05:49:43.154" starttime="20190402 05:49:43.122"></status>
</kw>
<status status="PASS" endtime="20190402 05:49:43.154" starttime="20190402 05:49:43.121"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:49:43.157" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:49:43.157" starttime="20190402 05:49:43.156"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:43.158" starttime="20190402 05:49:43.158"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:49:43.160" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:49:43.160" starttime="20190402 05:49:43.159"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:43.160" starttime="20190402 05:49:43.160"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:43.161" starttime="20190402 05:49:43.161"></status>
</kw>
<msg timestamp="20190402 05:49:43.161" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:49:43.161" starttime="20190402 05:49:43.159"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:49:43.162" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:43.162" starttime="20190402 05:49:43.162"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:49:43.165" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:49:43.165" starttime="20190402 05:49:43.162"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:49:43.471" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:49:43.471" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:43.471" starttime="20190402 05:49:43.166"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:49:43.472" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:49:43.472" starttime="20190402 05:49:43.472"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:49:43.472" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:49:43.472" starttime="20190402 05:49:43.472"></status>
</kw>
<msg timestamp="20190402 05:49:43.472" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:49:43.472" starttime="20190402 05:49:43.471"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:49:43.474" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:49:43.474" starttime="20190402 05:49:43.473"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:49:43.475" level="INFO">0</msg>
<msg timestamp="20190402 05:49:43.475" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:49:43.475" starttime="20190402 05:49:43.474"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:49:43.475" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:49:43.475" starttime="20190402 05:49:43.475"></status>
</kw>
<msg timestamp="20190402 05:49:43.475" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:49:43.475" starttime="20190402 05:49:43.472"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:43.476" starttime="20190402 05:49:43.476"></status>
</kw>
<status status="PASS" endtime="20190402 05:49:43.476" starttime="20190402 05:49:43.475"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:49:43.476" starttime="20190402 05:49:43.476"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:49:43.477" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:49:43.477" starttime="20190402 05:49:43.476"></status>
</kw>
<msg timestamp="20190402 05:49:43.477" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:49:43.477" starttime="20190402 05:49:43.157"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:49:43.477" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:49:43.477" starttime="20190402 05:49:43.477"></status>
</kw>
<msg timestamp="20190402 05:49:43.477" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:49:43.477" starttime="20190402 05:49:43.155"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:49:43.478" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:49:43.478" starttime="20190402 05:49:43.478"></status>
</kw>
<status status="FAIL" endtime="20190402 05:49:43.478" starttime="20190402 05:49:43.155"></status>
</kw>
<status status="FAIL" endtime="20190402 05:49:43.478" starttime="20190402 05:49:43.119"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:13.484" starttime="20190402 05:50:13.482"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:50:13.487" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:50:13.487" starttime="20190402 05:50:13.485"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:13.488" starttime="20190402 05:50:13.487"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:13.489" starttime="20190402 05:50:13.488"></status>
</kw>
<msg timestamp="20190402 05:50:13.490" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:50:13.490" starttime="20190402 05:50:13.484"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:50:13.491" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:13.491" starttime="20190402 05:50:13.491"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:50:13.507" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:50:13.508" starttime="20190402 05:50:13.492"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:50:13.510" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:50:13.510" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:13.510" starttime="20190402 05:50:13.508"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:50:13.512" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:13.512" starttime="20190402 05:50:13.511"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:50:13.513" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:50:13.513" starttime="20190402 05:50:13.512"></status>
</kw>
<msg timestamp="20190402 05:50:13.513" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:50:13.514" starttime="20190402 05:50:13.511"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:50:13.516" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:50:13.516" starttime="20190402 05:50:13.514"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:50:13.517" level="INFO">0</msg>
<msg timestamp="20190402 05:50:13.517" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:50:13.517" starttime="20190402 05:50:13.516"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:50:13.517" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:50:13.518" starttime="20190402 05:50:13.517"></status>
</kw>
<msg timestamp="20190402 05:50:13.518" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:50:13.518" starttime="20190402 05:50:13.514"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:13.519" starttime="20190402 05:50:13.519"></status>
</kw>
<status status="PASS" endtime="20190402 05:50:13.519" starttime="20190402 05:50:13.518"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:13.520" starttime="20190402 05:50:13.520"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:50:13.521" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:50:13.521" starttime="20190402 05:50:13.520"></status>
</kw>
<status status="PASS" endtime="20190402 05:50:13.521" starttime="20190402 05:50:13.481"></status>
</kw>
<status status="PASS" endtime="20190402 05:50:13.521" starttime="20190402 05:50:13.480"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:50:13.523" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:50:13.523" starttime="20190402 05:50:13.522"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:13.524" starttime="20190402 05:50:13.524"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:50:13.525" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:50:13.525" starttime="20190402 05:50:13.524"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:13.526" starttime="20190402 05:50:13.525"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:13.526" starttime="20190402 05:50:13.526"></status>
</kw>
<msg timestamp="20190402 05:50:13.527" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:50:13.527" starttime="20190402 05:50:13.524"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:50:13.527" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:13.527" starttime="20190402 05:50:13.527"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:50:13.530" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:50:13.530" starttime="20190402 05:50:13.527"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:50:13.840" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:50:13.840" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:13.840" starttime="20190402 05:50:13.530"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:50:13.841" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:13.841" starttime="20190402 05:50:13.841"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:50:13.841" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:50:13.841" starttime="20190402 05:50:13.841"></status>
</kw>
<msg timestamp="20190402 05:50:13.841" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:50:13.841" starttime="20190402 05:50:13.840"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:50:13.843" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:50:13.843" starttime="20190402 05:50:13.842"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:50:13.844" level="INFO">0</msg>
<msg timestamp="20190402 05:50:13.844" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:50:13.844" starttime="20190402 05:50:13.843"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:50:13.844" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:50:13.844" starttime="20190402 05:50:13.844"></status>
</kw>
<msg timestamp="20190402 05:50:13.844" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:50:13.844" starttime="20190402 05:50:13.842"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:13.845" starttime="20190402 05:50:13.845"></status>
</kw>
<status status="PASS" endtime="20190402 05:50:13.845" starttime="20190402 05:50:13.844"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:13.845" starttime="20190402 05:50:13.845"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:50:13.846" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:50:13.846" starttime="20190402 05:50:13.845"></status>
</kw>
<msg timestamp="20190402 05:50:13.846" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:50:13.846" starttime="20190402 05:50:13.523"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:50:13.846" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:50:13.846" starttime="20190402 05:50:13.846"></status>
</kw>
<msg timestamp="20190402 05:50:13.846" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:50:13.846" starttime="20190402 05:50:13.522"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:50:13.847" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:50:13.847" starttime="20190402 05:50:13.846"></status>
</kw>
<status status="FAIL" endtime="20190402 05:50:13.847" starttime="20190402 05:50:13.521"></status>
</kw>
<status status="FAIL" endtime="20190402 05:50:13.847" starttime="20190402 05:50:13.479"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:43.852" starttime="20190402 05:50:43.851"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:50:43.854" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:50:43.854" starttime="20190402 05:50:43.853"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:43.854" starttime="20190402 05:50:43.854"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:43.854" starttime="20190402 05:50:43.854"></status>
</kw>
<msg timestamp="20190402 05:50:43.854" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:50:43.854" starttime="20190402 05:50:43.853"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:50:43.855" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:43.855" starttime="20190402 05:50:43.855"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:50:43.860" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:50:43.860" starttime="20190402 05:50:43.855"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:50:43.861" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:50:43.861" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:43.861" starttime="20190402 05:50:43.860"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:50:43.862" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:43.862" starttime="20190402 05:50:43.861"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:50:43.862" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:50:43.862" starttime="20190402 05:50:43.862"></status>
</kw>
<msg timestamp="20190402 05:50:43.862" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:50:43.862" starttime="20190402 05:50:43.861"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:50:43.863" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:50:43.863" starttime="20190402 05:50:43.862"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:50:43.864" level="INFO">0</msg>
<msg timestamp="20190402 05:50:43.864" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:50:43.864" starttime="20190402 05:50:43.863"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:50:43.864" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:50:43.864" starttime="20190402 05:50:43.864"></status>
</kw>
<msg timestamp="20190402 05:50:43.864" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:50:43.864" starttime="20190402 05:50:43.862"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:43.865" starttime="20190402 05:50:43.865"></status>
</kw>
<status status="PASS" endtime="20190402 05:50:43.865" starttime="20190402 05:50:43.864"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:43.865" starttime="20190402 05:50:43.865"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:50:43.866" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:50:43.866" starttime="20190402 05:50:43.866"></status>
</kw>
<status status="PASS" endtime="20190402 05:50:43.866" starttime="20190402 05:50:43.850"></status>
</kw>
<status status="PASS" endtime="20190402 05:50:43.866" starttime="20190402 05:50:43.849"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:50:43.867" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:50:43.867" starttime="20190402 05:50:43.867"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:43.868" starttime="20190402 05:50:43.867"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:50:43.868" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:50:43.868" starttime="20190402 05:50:43.868"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:43.869" starttime="20190402 05:50:43.868"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:43.869" starttime="20190402 05:50:43.869"></status>
</kw>
<msg timestamp="20190402 05:50:43.869" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:50:43.869" starttime="20190402 05:50:43.868"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:50:43.869" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:43.869" starttime="20190402 05:50:43.869"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:50:43.872" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:50:43.872" starttime="20190402 05:50:43.870"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:50:44.182" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:50:44.183" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:44.183" starttime="20190402 05:50:43.872"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:50:44.183" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:50:44.183" starttime="20190402 05:50:44.183"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:50:44.184" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:50:44.184" starttime="20190402 05:50:44.184"></status>
</kw>
<msg timestamp="20190402 05:50:44.184" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:50:44.184" starttime="20190402 05:50:44.183"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:50:44.186" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:50:44.186" starttime="20190402 05:50:44.184"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:50:44.186" level="INFO">0</msg>
<msg timestamp="20190402 05:50:44.187" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:50:44.187" starttime="20190402 05:50:44.186"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:50:44.187" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:50:44.187" starttime="20190402 05:50:44.187"></status>
</kw>
<msg timestamp="20190402 05:50:44.187" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:50:44.187" starttime="20190402 05:50:44.184"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:44.188" starttime="20190402 05:50:44.187"></status>
</kw>
<status status="PASS" endtime="20190402 05:50:44.188" starttime="20190402 05:50:44.187"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:50:44.188" starttime="20190402 05:50:44.188"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:50:44.188" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:50:44.188" starttime="20190402 05:50:44.188"></status>
</kw>
<msg timestamp="20190402 05:50:44.189" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:50:44.189" starttime="20190402 05:50:43.867"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:50:44.189" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:50:44.189" starttime="20190402 05:50:44.189"></status>
</kw>
<msg timestamp="20190402 05:50:44.189" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:50:44.189" starttime="20190402 05:50:43.866"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:50:44.190" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:50:44.190" starttime="20190402 05:50:44.189"></status>
</kw>
<status status="FAIL" endtime="20190402 05:50:44.190" starttime="20190402 05:50:43.866"></status>
</kw>
<status status="FAIL" endtime="20190402 05:50:44.190" starttime="20190402 05:50:43.848"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:14.195" starttime="20190402 05:51:14.194"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:51:14.196" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:51:14.196" starttime="20190402 05:51:14.195"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:14.196" starttime="20190402 05:51:14.196"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:14.196" starttime="20190402 05:51:14.196"></status>
</kw>
<msg timestamp="20190402 05:51:14.197" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:51:14.197" starttime="20190402 05:51:14.195"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:51:14.197" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:14.197" starttime="20190402 05:51:14.197"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:51:14.201" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:51:14.201" starttime="20190402 05:51:14.197"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:51:14.202" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:51:14.202" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:14.202" starttime="20190402 05:51:14.201"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:51:14.203" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:14.203" starttime="20190402 05:51:14.203"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:51:14.203" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:51:14.203" starttime="20190402 05:51:14.203"></status>
</kw>
<msg timestamp="20190402 05:51:14.204" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:51:14.204" starttime="20190402 05:51:14.202"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:51:14.204" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:51:14.205" starttime="20190402 05:51:14.204"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:51:14.205" level="INFO">0</msg>
<msg timestamp="20190402 05:51:14.205" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:51:14.205" starttime="20190402 05:51:14.205"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:51:14.205" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:51:14.206" starttime="20190402 05:51:14.205"></status>
</kw>
<msg timestamp="20190402 05:51:14.206" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:51:14.206" starttime="20190402 05:51:14.204"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:14.207" starttime="20190402 05:51:14.206"></status>
</kw>
<status status="PASS" endtime="20190402 05:51:14.207" starttime="20190402 05:51:14.206"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:14.207" starttime="20190402 05:51:14.207"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:51:14.207" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:51:14.207" starttime="20190402 05:51:14.207"></status>
</kw>
<status status="PASS" endtime="20190402 05:51:14.207" starttime="20190402 05:51:14.193"></status>
</kw>
<status status="PASS" endtime="20190402 05:51:14.207" starttime="20190402 05:51:14.192"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:51:14.209" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:51:14.209" starttime="20190402 05:51:14.208"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:14.209" starttime="20190402 05:51:14.209"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:51:14.210" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:51:14.210" starttime="20190402 05:51:14.210"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:14.211" starttime="20190402 05:51:14.210"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:14.211" starttime="20190402 05:51:14.211"></status>
</kw>
<msg timestamp="20190402 05:51:14.211" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:51:14.211" starttime="20190402 05:51:14.210"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:51:14.212" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:14.212" starttime="20190402 05:51:14.211"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:51:14.213" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:51:14.213" starttime="20190402 05:51:14.212"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:51:14.525" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:51:14.525" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:14.525" starttime="20190402 05:51:14.213"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:51:14.526" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:14.526" starttime="20190402 05:51:14.526"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:51:14.526" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:51:14.526" starttime="20190402 05:51:14.526"></status>
</kw>
<msg timestamp="20190402 05:51:14.526" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:51:14.526" starttime="20190402 05:51:14.525"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:51:14.528" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:51:14.528" starttime="20190402 05:51:14.527"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:51:14.529" level="INFO">0</msg>
<msg timestamp="20190402 05:51:14.529" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:51:14.529" starttime="20190402 05:51:14.528"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:51:14.529" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:51:14.529" starttime="20190402 05:51:14.529"></status>
</kw>
<msg timestamp="20190402 05:51:14.529" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:51:14.529" starttime="20190402 05:51:14.527"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:14.530" starttime="20190402 05:51:14.530"></status>
</kw>
<status status="PASS" endtime="20190402 05:51:14.530" starttime="20190402 05:51:14.529"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:14.530" starttime="20190402 05:51:14.530"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:51:14.531" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:51:14.531" starttime="20190402 05:51:14.530"></status>
</kw>
<msg timestamp="20190402 05:51:14.531" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:51:14.531" starttime="20190402 05:51:14.209"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:51:14.531" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:51:14.531" starttime="20190402 05:51:14.531"></status>
</kw>
<msg timestamp="20190402 05:51:14.531" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:51:14.531" starttime="20190402 05:51:14.208"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:51:14.532" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:51:14.532" starttime="20190402 05:51:14.531"></status>
</kw>
<status status="FAIL" endtime="20190402 05:51:14.532" starttime="20190402 05:51:14.208"></status>
</kw>
<status status="FAIL" endtime="20190402 05:51:14.532" starttime="20190402 05:51:14.191"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:44.539" starttime="20190402 05:51:44.538"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:51:44.542" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:51:44.542" starttime="20190402 05:51:44.540"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:44.543" starttime="20190402 05:51:44.542"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:44.544" starttime="20190402 05:51:44.543"></status>
</kw>
<msg timestamp="20190402 05:51:44.545" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:51:44.545" starttime="20190402 05:51:44.539"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:51:44.546" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:44.546" starttime="20190402 05:51:44.546"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:51:44.562" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:51:44.563" starttime="20190402 05:51:44.547"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:51:44.565" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190402 05:51:44.565" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:44.565" starttime="20190402 05:51:44.563"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:51:44.566" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:44.566" starttime="20190402 05:51:44.566"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:51:44.567" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:51:44.568" starttime="20190402 05:51:44.567"></status>
</kw>
<msg timestamp="20190402 05:51:44.568" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190402 05:51:44.568" starttime="20190402 05:51:44.565"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:51:44.570" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:51:44.570" starttime="20190402 05:51:44.569"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:51:44.572" level="INFO">0</msg>
<msg timestamp="20190402 05:51:44.572" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:51:44.572" starttime="20190402 05:51:44.570"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:51:44.573" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:51:44.573" starttime="20190402 05:51:44.572"></status>
</kw>
<msg timestamp="20190402 05:51:44.573" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:51:44.573" starttime="20190402 05:51:44.568"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:44.574" starttime="20190402 05:51:44.574"></status>
</kw>
<status status="PASS" endtime="20190402 05:51:44.574" starttime="20190402 05:51:44.573"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:44.575" starttime="20190402 05:51:44.575"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:51:44.575" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190402 05:51:44.575" starttime="20190402 05:51:44.575"></status>
</kw>
<status status="PASS" endtime="20190402 05:51:44.575" starttime="20190402 05:51:44.535"></status>
</kw>
<status status="PASS" endtime="20190402 05:51:44.576" starttime="20190402 05:51:44.534"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:51:44.577" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:51:44.577" starttime="20190402 05:51:44.577"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:44.578" starttime="20190402 05:51:44.578"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:51:44.579" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:51:44.579" starttime="20190402 05:51:44.578"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:44.580" starttime="20190402 05:51:44.579"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:44.580" starttime="20190402 05:51:44.580"></status>
</kw>
<msg timestamp="20190402 05:51:44.580" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:51:44.580" starttime="20190402 05:51:44.578"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:51:44.581" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:44.581" starttime="20190402 05:51:44.580"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:51:44.594" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 05:51:44.594" starttime="20190402 05:51:44.581"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:51:44.900" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190402 05:51:44.900" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:44.901" starttime="20190402 05:51:44.594"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:51:44.901" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:51:44.901" starttime="20190402 05:51:44.901"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:51:44.902" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:51:44.902" starttime="20190402 05:51:44.901"></status>
</kw>
<msg timestamp="20190402 05:51:44.902" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190402 05:51:44.902" starttime="20190402 05:51:44.901"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:51:44.904" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:51:44.904" starttime="20190402 05:51:44.902"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:51:44.905" level="INFO">0</msg>
<msg timestamp="20190402 05:51:44.905" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:51:44.905" starttime="20190402 05:51:44.904"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:51:44.905" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:51:44.905" starttime="20190402 05:51:44.905"></status>
</kw>
<msg timestamp="20190402 05:51:44.905" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:51:44.905" starttime="20190402 05:51:44.902"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:44.906" starttime="20190402 05:51:44.906"></status>
</kw>
<status status="PASS" endtime="20190402 05:51:44.906" starttime="20190402 05:51:44.905"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:51:44.906" starttime="20190402 05:51:44.906"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:51:44.907" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:51:44.907" starttime="20190402 05:51:44.906"></status>
</kw>
<msg timestamp="20190402 05:51:44.907" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:51:44.907" starttime="20190402 05:51:44.577"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:51:44.907" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:51:44.907" starttime="20190402 05:51:44.907"></status>
</kw>
<msg timestamp="20190402 05:51:44.907" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190402 05:51:44.907" starttime="20190402 05:51:44.576"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:51:44.908" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190402 05:51:44.908" starttime="20190402 05:51:44.907"></status>
</kw>
<status status="FAIL" endtime="20190402 05:51:44.908" starttime="20190402 05:51:44.576"></status>
</kw>
<status status="FAIL" endtime="20190402 05:51:44.908" starttime="20190402 05:51:44.533"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:14.914" starttime="20190402 05:52:14.913"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:14.916" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:14.916" starttime="20190402 05:52:14.915"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:14.918" starttime="20190402 05:52:14.917"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:14.919" starttime="20190402 05:52:14.918"></status>
</kw>
<msg timestamp="20190402 05:52:14.920" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:14.920" starttime="20190402 05:52:14.914"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:14.921" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190402 05:52:14.921" starttime="20190402 05:52:14.920"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:14.936" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 05:52:14.936" starttime="20190402 05:52:14.921"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:52:16.021" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:52:16.022" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:16.022" starttime="20190402 05:52:14.936"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:52:16.023" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:16.023" starttime="20190402 05:52:16.023"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:52:16.023" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190402 05:52:16.023" starttime="20190402 05:52:16.023"></status>
</kw>
<msg timestamp="20190402 05:52:16.023" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190402 05:52:16.024" starttime="20190402 05:52:16.022"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:52:16.027" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:52:16.027" starttime="20190402 05:52:16.024"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:52:16.028" level="INFO">0</msg>
<msg timestamp="20190402 05:52:16.028" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:16.028" starttime="20190402 05:52:16.027"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:52:16.028" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:52:16.028" starttime="20190402 05:52:16.028"></status>
</kw>
<msg timestamp="20190402 05:52:16.029" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:16.029" starttime="20190402 05:52:16.024"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:16.029" starttime="20190402 05:52:16.029"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:16.029" starttime="20190402 05:52:16.029"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:16.030" starttime="20190402 05:52:16.029"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:52:16.030" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190402 05:52:16.030" starttime="20190402 05:52:16.030"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:16.030" starttime="20190402 05:52:14.911"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:16.030" starttime="20190402 05:52:14.910"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:52:16.031" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:16.031" starttime="20190402 05:52:16.031"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:16.032" starttime="20190402 05:52:16.032"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:16.033" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:16.033" starttime="20190402 05:52:16.032"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:16.033" starttime="20190402 05:52:16.033"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:16.033" starttime="20190402 05:52:16.033"></status>
</kw>
<msg timestamp="20190402 05:52:16.033" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:16.033" starttime="20190402 05:52:16.032"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:16.034" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:16.034" starttime="20190402 05:52:16.034"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:16.046" level="INFO">system host-show controller-0|grep -w  administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:16.046" starttime="20190402 05:52:16.034"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:52:21.755" level="INFO">unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:52:21.755" level="INFO">${output} = unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:21.755" starttime="20190402 05:52:16.046"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:52:21.756" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:21.756" starttime="20190402 05:52:21.756"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:52:21.756" level="INFO">${clean_out} = unlocked
</msg>
<status status="PASS" endtime="20190402 05:52:21.756" starttime="20190402 05:52:21.756"></status>
</kw>
<msg timestamp="20190402 05:52:21.756" level="INFO">${output} = unlocked
</msg>
<status status="PASS" endtime="20190402 05:52:21.756" starttime="20190402 05:52:21.755"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:52:21.758" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:52:21.758" starttime="20190402 05:52:21.757"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:52:21.765" level="INFO">0</msg>
<msg timestamp="20190402 05:52:21.765" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:21.765" starttime="20190402 05:52:21.758"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:52:21.765" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:52:21.765" starttime="20190402 05:52:21.765"></status>
</kw>
<msg timestamp="20190402 05:52:21.766" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:21.766" starttime="20190402 05:52:21.756"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:21.766" starttime="20190402 05:52:21.766"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:21.766" starttime="20190402 05:52:21.766"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:21.767" starttime="20190402 05:52:21.767"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:52:21.767" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: unlocked</msg>
<status status="PASS" endtime="20190402 05:52:21.767" starttime="20190402 05:52:21.767"></status>
</kw>
<msg timestamp="20190402 05:52:21.767" level="INFO">${result} = {u'stdout': u'unlocked', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:52:21.767" starttime="20190402 05:52:16.031"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:52:21.768" level="INFO">${value} = unlocked</msg>
<status status="PASS" endtime="20190402 05:52:21.768" starttime="20190402 05:52:21.767"></status>
</kw>
<msg timestamp="20190402 05:52:21.768" level="INFO">${current_value} = unlocked</msg>
<status status="PASS" endtime="20190402 05:52:21.768" starttime="20190402 05:52:16.031"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:21.768" starttime="20190402 05:52:21.768"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:21.768" starttime="20190402 05:52:16.030"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:21.768" starttime="20190402 05:52:14.909"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:21.768" starttime="20190402 05:43:38.580"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:21.768" starttime="20190402 05:38:31.463"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Check Ceph Status</arg>
<arg>HEALTH_WARN</arg>
</arguments>
<kw name="Check Ceph Status" library="Utils">
<doc>Verifies the status of the CEPH feature.</doc>
<arguments>
<arg>HEALTH_WARN</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph -s</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:21.770" starttime="20190402 05:52:21.770"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:21.770" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:21.770" starttime="20190402 05:52:21.770"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:21.771" starttime="20190402 05:52:21.771"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:21.771" starttime="20190402 05:52:21.771"></status>
</kw>
<msg timestamp="20190402 05:52:21.771" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:21.771" starttime="20190402 05:52:21.770"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:21.772" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:21.772" starttime="20190402 05:52:21.771"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:21.773" level="INFO">ceph -s</msg>
<status status="PASS" endtime="20190402 05:52:21.773" starttime="20190402 05:52:21.772"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:52:22.064" level="INFO">cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_WARN
            384 pgs degraded
            64 pgs stuck unclean
            384 pgs undersized
            recovery 1116/2232 objects degraded (50.000%)
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e15: 1 osds: 1 up, 1 in
            flags sortbitwise,require_jewel_osds
      pgmap v19: 384 pgs, 6 pools, 1588 bytes data, 1116 objects
            43424 kB used, 445 GB / 445 GB avail
            1116/2232 objects degraded (50.000%)
                 384 active+undersized+degraded
  client io 374 kB/s rd, 0 B/s wr, 561 op/s rd, 374 op/s wr
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:52:22.064" level="INFO">${output} =     cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_WARN
            384 pgs degraded
            64 pgs stuck unclean
            384 pgs undersized
            recovery 1116/223...</msg>
<status status="PASS" endtime="20190402 05:52:22.064" starttime="20190402 05:52:21.774"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:52:22.065" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:22.065" starttime="20190402 05:52:22.064"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:52:22.065" level="INFO">${clean_out} =     cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_WARN
            384 pgs degraded
            64 pgs stuck unclean
            384 pgs undersized
            recovery 1116/223...</msg>
<status status="PASS" endtime="20190402 05:52:22.065" starttime="20190402 05:52:22.065"></status>
</kw>
<msg timestamp="20190402 05:52:22.065" level="INFO">${output} =     cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_WARN
            384 pgs degraded
            64 pgs stuck unclean
            384 pgs undersized
            recovery 1116/223...</msg>
<status status="PASS" endtime="20190402 05:52:22.065" starttime="20190402 05:52:22.064"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:52:22.067" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:52:22.067" starttime="20190402 05:52:22.066"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:52:22.070" level="INFO">0</msg>
<msg timestamp="20190402 05:52:22.070" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:22.070" starttime="20190402 05:52:22.067"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:52:22.070" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:52:22.070" starttime="20190402 05:52:22.070"></status>
</kw>
<msg timestamp="20190402 05:52:22.070" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:22.070" starttime="20190402 05:52:22.065"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.071" starttime="20190402 05:52:22.071"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:22.071" starttime="20190402 05:52:22.070"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.071" starttime="20190402 05:52:22.071"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:52:22.072" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_WARN
            384 pgs degraded
            64 pgs stuck unclean
            384 pgs undersized
            recovery 1116/2232 objects degraded (50.000%)
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e15: 1 osds: 1 up, 1 in
            flags sortbitwise,require_jewel_osds
      pgmap v19: 384 pgs, 6 pools, 1588 bytes data, 1116 objects
            43424 kB used, 445 GB / 445 GB avail
            1116/2232 objects degraded (50.000%)
                 384 active+undersized+degraded
  client io 374 kB/s rd, 0 B/s wr, 561 op/s rd, 374 op/s wr</msg>
<status status="PASS" endtime="20190402 05:52:22.072" starttime="20190402 05:52:22.072"></status>
</kw>
<msg timestamp="20190402 05:52:22.072" level="INFO">${result} = {u'stdout': u'cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7\r\n     health HEALTH_WARN\r\n            384 pgs degraded\r\n            64 pgs stuck unclean\r\n            384 pgs undersized\r\n         ...</msg>
<status status="PASS" endtime="20190402 05:52:22.072" starttime="20190402 05:52:21.769"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${result.stdout}</arg>
<arg>${status}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.072" starttime="20190402 05:52:22.072"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd tree</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.073" starttime="20190402 05:52:22.073"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:22.074" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:22.074" starttime="20190402 05:52:22.074"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.075" starttime="20190402 05:52:22.074"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.075" starttime="20190402 05:52:22.075"></status>
</kw>
<msg timestamp="20190402 05:52:22.075" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:22.075" starttime="20190402 05:52:22.073"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:22.076" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:22.076" starttime="20190402 05:52:22.076"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:22.077" level="INFO">ceph osd tree</msg>
<status status="PASS" endtime="20190402 05:52:22.078" starttime="20190402 05:52:22.076"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:52:22.371" level="INFO">ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3       0         host controller-1                                   
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:52:22.371" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190402 05:52:22.371" starttime="20190402 05:52:22.078"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:52:22.372" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:22.372" starttime="20190402 05:52:22.371"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:52:22.372" level="INFO">${clean_out} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190402 05:52:22.372" starttime="20190402 05:52:22.372"></status>
</kw>
<msg timestamp="20190402 05:52:22.372" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190402 05:52:22.372" starttime="20190402 05:52:22.371"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:52:22.374" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:52:22.374" starttime="20190402 05:52:22.372"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:52:22.378" level="INFO">0</msg>
<msg timestamp="20190402 05:52:22.378" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:22.378" starttime="20190402 05:52:22.374"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:52:22.378" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:52:22.378" starttime="20190402 05:52:22.378"></status>
</kw>
<msg timestamp="20190402 05:52:22.378" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:22.378" starttime="20190402 05:52:22.372"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.379" starttime="20190402 05:52:22.379"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:22.379" starttime="20190402 05:52:22.378"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.379" starttime="20190402 05:52:22.379"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:52:22.380" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3       0         host controller-1</msg>
<status status="PASS" endtime="20190402 05:52:22.380" starttime="20190402 05:52:22.379"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:22.380" starttime="20190402 05:52:22.073"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:22.380" starttime="20190402 05:52:21.769"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:22.380" starttime="20190402 05:52:21.769"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${ENVIRONMENT}'=='virtual'</arg>
<arg>Install Remaining Nodes Virtual</arg>
<arg>ELSE</arg>
<arg>Install Remaining Nodes Baremetal</arg>
</arguments>
<kw name="Install Remaining Nodes Baremetal" library="provisioning">
<doc>Install rest of the nodes according to the info on the
installation yaml file.</doc>
<kw name="Get List Of Installation Nodes" library="provisioning">
<doc>Return a list of nodes candidate to be installed,
controller-0 is removed by default</doc>
<assign>
<var>@{nodes_list}</var>
</assign>
<kw name="Get Dictionary Keys" library="Collections">
<doc>Returns keys of the given ``dictionary``.</doc>
<arguments>
<arg>${NODES}</arg>
</arguments>
<assign>
<var>${nodes_list}</var>
</assign>
<msg timestamp="20190402 05:52:22.381" level="INFO">${nodes_list} = ['controller-0', 'controller-1']</msg>
<status status="PASS" endtime="20190402 05:52:22.381" starttime="20190402 05:52:22.381"></status>
</kw>
<kw name="Remove Values From List" library="Collections">
<doc>Removes all occurrences of given ``values`` from ``list``.</doc>
<arguments>
<arg>${nodes_list}</arg>
<arg>controller-0</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.381" starttime="20190402 05:52:22.381"></status>
</kw>
<msg timestamp="20190402 05:52:22.382" level="INFO">@{nodes_list} = [ controller-1 ]</msg>
<status status="PASS" endtime="20190402 05:52:22.382" starttime="20190402 05:52:22.381"></status>
</kw>
<kw type="for" name="${node} IN [ @{nodes_list} ]">
<kw type="foritem" name="${node} = controller-1">
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{NODES}[${node}]</arg>
</arguments>
<assign>
<var>&amp;{node_data}</var>
</assign>
<msg timestamp="20190402 05:52:22.382" level="INFO">&amp;{node_data} = { bmc_user=starlingx | bmc_ip=192.168.100.77 | name=controller-1 | pxe_nic_mac=a4:bf:01:55:03:bb | bmc_pswd=Passw0rd | personality=controller }</msg>
<status status="PASS" endtime="20190402 05:52:22.382" starttime="20190402 05:52:22.382"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[bmc_ip]</arg>
</arguments>
<assign>
<var>${bmc_ip}</var>
</assign>
<msg timestamp="20190402 05:52:22.383" level="INFO">${bmc_ip} = 192.168.100.77</msg>
<status status="PASS" endtime="20190402 05:52:22.383" starttime="20190402 05:52:22.383"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[bmc_user]</arg>
</arguments>
<assign>
<var>${bmc_user}</var>
</assign>
<msg timestamp="20190402 05:52:22.383" level="INFO">${bmc_user} = starlingx</msg>
<status status="PASS" endtime="20190402 05:52:22.383" starttime="20190402 05:52:22.383"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[bmc_pswd]</arg>
</arguments>
<assign>
<var>${pswd}</var>
</assign>
<msg timestamp="20190402 05:52:22.384" level="INFO">${pswd} = Passw0rd</msg>
<status status="PASS" endtime="20190402 05:52:22.384" starttime="20190402 05:52:22.383"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>ipmitool -H ${bmc_ip}</arg>
<arg>-U ${bmc_user} -P ${pswd}</arg>
<arg>-I lanplus chassis bootparam set bootflag force_pxe</arg>
</arguments>
<assign>
<var>${set_pxe_boot_device}</var>
</assign>
<msg timestamp="20190402 05:52:22.384" level="INFO">${set_pxe_boot_device} = ipmitool -H 192.168.100.77 -U starlingx -P Passw0rd -I lanplus chassis bootparam set bootflag force_pxe</msg>
<status status="PASS" endtime="20190402 05:52:22.384" starttime="20190402 05:52:22.384"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>ipmitool -H ${bmc_ip} -U ${bmc_user}</arg>
<arg>-P ${pswd} -I lanplus chassis power on</arg>
</arguments>
<assign>
<var>${turn_on_node}</var>
</assign>
<msg timestamp="20190402 05:52:22.384" level="INFO">${turn_on_node} = ipmitool -H 192.168.100.77 -U starlingx -P Passw0rd -I lanplus chassis power on</msg>
<status status="PASS" endtime="20190402 05:52:22.384" starttime="20190402 05:52:22.384"></status>
</kw>
<kw name="Run" library="OperatingSystem">
<doc>Runs the given command in the system and returns the output.</doc>
<arguments>
<arg>${set_pxe_boot_device}</arg>
</arguments>
<msg timestamp="20190402 05:52:22.386" level="INFO">Running command 'ipmitool -H 192.168.100.77 -U starlingx -P Passw0rd -I lanplus chassis bootparam set bootflag force_pxe 2&gt;&amp;1'.</msg>
<status status="PASS" endtime="20190402 05:52:22.433" starttime="20190402 05:52:22.385"></status>
</kw>
<kw name="Run" library="OperatingSystem">
<doc>Runs the given command in the system and returns the output.</doc>
<arguments>
<arg>${turn_on_node}</arg>
</arguments>
<msg timestamp="20190402 05:52:22.435" level="INFO">Running command 'ipmitool -H 192.168.100.77 -U starlingx -P Passw0rd -I lanplus chassis power on 2&gt;&amp;1'.</msg>
<status status="PASS" endtime="20190402 05:52:22.464" starttime="20190402 05:52:22.433"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:22.464" starttime="20190402 05:52:22.382"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:22.464" starttime="20190402 05:52:22.382"></status>
</kw>
<kw type="for" name="${node} IN [ @{nodes_list} ]">
<kw type="foritem" name="${node} = controller-1">
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{NODES}[${node}]</arg>
</arguments>
<assign>
<var>&amp;{node_data}</var>
</assign>
<msg timestamp="20190402 05:52:22.467" level="INFO">&amp;{node_data} = { bmc_user=starlingx | bmc_ip=192.168.100.77 | name=controller-1 | pxe_nic_mac=a4:bf:01:55:03:bb | bmc_pswd=Passw0rd | personality=controller }</msg>
<status status="PASS" endtime="20190402 05:52:22.467" starttime="20190402 05:52:22.466"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[name]</arg>
</arguments>
<assign>
<var>${name}</var>
</assign>
<msg timestamp="20190402 05:52:22.468" level="INFO">${name} = controller-1</msg>
<status status="PASS" endtime="20190402 05:52:22.468" starttime="20190402 05:52:22.467"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[personality]</arg>
</arguments>
<assign>
<var>${personality}</var>
</assign>
<msg timestamp="20190402 05:52:22.469" level="INFO">${personality} = controller</msg>
<status status="PASS" endtime="20190402 05:52:22.469" starttime="20190402 05:52:22.468"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[pxe_nic_mac]</arg>
</arguments>
<assign>
<var>${mac_address}</var>
</assign>
<msg timestamp="20190402 05:52:22.470" level="INFO">${mac_address} = a4:bf:01:55:03:bb</msg>
<status status="PASS" endtime="20190402 05:52:22.470" starttime="20190402 05:52:22.470"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Run Command</arg>
<arg>system host-add -n ${name} -p ${personality} -m ${mac_address}</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-add -n ${name} -p ${personality} -m ${mac_address}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.473" starttime="20190402 05:52:22.473"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:22.475" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:22.475" starttime="20190402 05:52:22.474"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.476" starttime="20190402 05:52:22.476"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:22.477" starttime="20190402 05:52:22.477"></status>
</kw>
<msg timestamp="20190402 05:52:22.478" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:22.478" starttime="20190402 05:52:22.474"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:22.479" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:22.479" starttime="20190402 05:52:22.478"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:22.502" level="INFO">system host-add -n controller-1 -p con troller -m a4:bf:01:55:03:bb</msg>
<status status="PASS" endtime="20190402 05:52:22.502" starttime="20190402 05:52:22.479"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:52:28.117" level="INFO">+---------------------+-----------------------------------------+
| Property            | Value                                   |
+---------------------+-----------------------------------------+
| action              | none                                    |
| administrative      | locked                                  |
| availability        | offline                                 |
| bm_ip               | None                                    |
| bm_type             | None                                    |
| bm_username         | None                                    |
| boot_device         | sda                                     |
| capabilities        | {u'Personality': u'Controller-Standby'} |
| config_applied      | None                                    |
| config_status       | None                                    |
| config_target       | None                                    |
| console             | ttyS0,115200                            |
| created_at          | 2019-04-02T11:41:09.555447+00:00        |
| hostname            | controller-1                            |
| id                  | 2                                       |
| install_output      | text                                    |
| install_state       | None                                    |
| install_state_info  | None                                    |
| invprovision        | None                                    |
| location            | {}                                      |
| mgmt_ip             | 10.10.53.4                              |
| mgmt_mac            | a4:bf:01:55:03:bb                       |
| operational         | disabled                                |
| personality         | controller                              |
| reserved            | False                                   |
| rootfs_device       | sda                                     |
| serialid            | None                                    |
| software_load       | 19.01                                   |
| subfunction_avail   | not-installed                           |
| subfunction_oper    | disabled                                |
| subfunctions        | controller,worker                       |
| task                | None                                    |
| tboot               | false                                   |
| ttys_dcd            | None                                    |
| updated_at          | None                                    |
| uptime              | 0                                       |
| uuid                | 7e3e37c8-5ee4-424c-b253-7335a13f97dd    |
| vim_progress_status | None                                    |
+---------------------+-----------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:52:28.117" level="INFO">${output} = +---------------------+-----------------------------------------+
| Property            | Value                                   |
+---------------------+-----------------------------------------+...</msg>
<status status="PASS" endtime="20190402 05:52:28.117" starttime="20190402 05:52:22.502"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:52:28.118" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:28.118" starttime="20190402 05:52:28.118"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:52:28.119" level="INFO">${clean_out} = +---------------------+-----------------------------------------+
| Property            | Value                                   |
+---------------------+-----------------------------------------+...</msg>
<status status="PASS" endtime="20190402 05:52:28.119" starttime="20190402 05:52:28.118"></status>
</kw>
<msg timestamp="20190402 05:52:28.119" level="INFO">${output} = +---------------------+-----------------------------------------+
| Property            | Value                                   |
+---------------------+-----------------------------------------+...</msg>
<status status="PASS" endtime="20190402 05:52:28.119" starttime="20190402 05:52:28.118"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:52:28.122" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:52:28.122" starttime="20190402 05:52:28.119"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:52:28.130" level="INFO">0</msg>
<msg timestamp="20190402 05:52:28.130" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:28.130" starttime="20190402 05:52:28.122"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:52:28.130" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:52:28.130" starttime="20190402 05:52:28.130"></status>
</kw>
<msg timestamp="20190402 05:52:28.130" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:28.130" starttime="20190402 05:52:28.119"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:28.131" starttime="20190402 05:52:28.131"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:28.131" starttime="20190402 05:52:28.131"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:28.132" starttime="20190402 05:52:28.131"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:52:28.132" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +---------------------+-----------------------------------------+
| Property            | Value                                   |
+---------------------+-----------------------------------------+
| action              | none                                    |
| administrative      | locked                                  |
| availability        | offline                                 |
| bm_ip               | None                                    |
| bm_type             | None                                    |
| bm_username         | None                                    |
| boot_device         | sda                                     |
| capabilities        | {u'Personality': u'Controller-Standby'} |
| config_applied      | None                                    |
| config_status       | None                                    |
| config_target       | None                                    |
| console             | ttyS0,115200                            |
| created_at          | 2019-04-02T11:41:09.555447+00:00        |
| hostname            | controller-1                            |
| id                  | 2                                       |
| install_output      | text                                    |
| install_state       | None                                    |
| install_state_info  | None                                    |
| invprovision        | None                                    |
| location            | {}                                      |
| mgmt_ip             | 10.10.53.4                              |
| mgmt_mac            | a4:bf:01:55:03:bb                       |
| operational         | disabled                                |
| personality         | controller                              |
| reserved            | False                                   |
| rootfs_device       | sda                                     |
| serialid            | None                                    |
| software_load       | 19.01                                   |
| subfunction_avail   | not-installed                           |
| subfunction_oper    | disabled                                |
| subfunctions        | controller,worker                       |
| task                | None                                    |
| tboot               | false                                   |
| ttys_dcd            | None                                    |
| updated_at          | None                                    |
| uptime              | 0                                       |
| uuid                | 7e3e37c8-5ee4-424c-b253-7335a13f97dd    |
| vim_progress_status | None                                    |
+---------------------+-----------------------------------------+</msg>
<status status="PASS" endtime="20190402 05:52:28.132" starttime="20190402 05:52:28.132"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:28.132" starttime="20190402 05:52:22.472"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:28.132" starttime="20190402 05:52:22.471"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:28.132" starttime="20190402 05:52:22.465"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:28.132" starttime="20190402 05:52:22.465"></status>
</kw>
<kw type="for" name="${node} IN [ @{nodes_list} ]">
<kw type="foritem" name="${node} = controller-1">
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{NODES}[${node}]</arg>
</arguments>
<assign>
<var>&amp;{node_data}</var>
</assign>
<msg timestamp="20190402 05:52:28.133" level="INFO">&amp;{node_data} = { bmc_user=starlingx | bmc_ip=192.168.100.77 | name=controller-1 | pxe_nic_mac=a4:bf:01:55:03:bb | bmc_pswd=Passw0rd | personality=controller }</msg>
<status status="PASS" endtime="20190402 05:52:28.133" starttime="20190402 05:52:28.132"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[name]</arg>
</arguments>
<assign>
<var>${name}</var>
</assign>
<msg timestamp="20190402 05:52:28.133" level="INFO">${name} = controller-1</msg>
<status status="PASS" endtime="20190402 05:52:28.133" starttime="20190402 05:52:28.133"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>20 min</arg>
<arg>5 sec</arg>
<arg>Check Property Value</arg>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:52:28.135" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:28.135" starttime="20190402 05:52:28.134"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:28.135" starttime="20190402 05:52:28.135"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:28.136" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:28.136" starttime="20190402 05:52:28.136"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:28.136" starttime="20190402 05:52:28.136"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:28.137" starttime="20190402 05:52:28.136"></status>
</kw>
<msg timestamp="20190402 05:52:28.137" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:28.137" starttime="20190402 05:52:28.135"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:28.137" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:28.137" starttime="20190402 05:52:28.137"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:28.147" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:28.147" starttime="20190402 05:52:28.137"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:52:29.930" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:52:29.930" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:29.930" starttime="20190402 05:52:28.147"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:52:29.931" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:29.931" starttime="20190402 05:52:29.931"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:52:29.932" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:52:29.932" starttime="20190402 05:52:29.931"></status>
</kw>
<msg timestamp="20190402 05:52:29.932" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:52:29.932" starttime="20190402 05:52:29.930"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:52:29.933" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:52:29.933" starttime="20190402 05:52:29.932"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:52:29.939" level="INFO">0</msg>
<msg timestamp="20190402 05:52:29.940" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:29.940" starttime="20190402 05:52:29.933"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:52:29.940" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:52:29.940" starttime="20190402 05:52:29.940"></status>
</kw>
<msg timestamp="20190402 05:52:29.940" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:29.940" starttime="20190402 05:52:29.932"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:29.941" starttime="20190402 05:52:29.941"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:29.941" starttime="20190402 05:52:29.940"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:29.941" starttime="20190402 05:52:29.941"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:52:29.942" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:52:29.942" starttime="20190402 05:52:29.941"></status>
</kw>
<msg timestamp="20190402 05:52:29.942" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:52:29.942" starttime="20190402 05:52:28.135"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:52:29.942" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:52:29.942" starttime="20190402 05:52:29.942"></status>
</kw>
<msg timestamp="20190402 05:52:29.942" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:52:29.942" starttime="20190402 05:52:28.134"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:52:29.943" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:52:29.943" starttime="20190402 05:52:29.943"></status>
</kw>
<status status="FAIL" endtime="20190402 05:52:29.943" starttime="20190402 05:52:28.134"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:52:34.948" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:34.948" starttime="20190402 05:52:34.947"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:34.950" starttime="20190402 05:52:34.949"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:34.950" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:34.950" starttime="20190402 05:52:34.950"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:34.951" starttime="20190402 05:52:34.950"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:34.951" starttime="20190402 05:52:34.951"></status>
</kw>
<msg timestamp="20190402 05:52:34.951" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:34.951" starttime="20190402 05:52:34.950"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:34.951" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:34.951" starttime="20190402 05:52:34.951"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:34.953" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:34.953" starttime="20190402 05:52:34.952"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:52:36.051" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:52:36.051" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:36.051" starttime="20190402 05:52:34.953"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:52:36.052" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:36.052" starttime="20190402 05:52:36.052"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:52:36.053" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:52:36.053" starttime="20190402 05:52:36.052"></status>
</kw>
<msg timestamp="20190402 05:52:36.053" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:52:36.053" starttime="20190402 05:52:36.052"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:52:36.054" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:52:36.054" starttime="20190402 05:52:36.054"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:52:36.055" level="INFO">0</msg>
<msg timestamp="20190402 05:52:36.055" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:36.055" starttime="20190402 05:52:36.054"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:52:36.056" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:52:36.056" starttime="20190402 05:52:36.055"></status>
</kw>
<msg timestamp="20190402 05:52:36.056" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:36.056" starttime="20190402 05:52:36.053"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:36.057" starttime="20190402 05:52:36.056"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:36.057" starttime="20190402 05:52:36.056"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:36.057" starttime="20190402 05:52:36.057"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:52:36.058" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:52:36.058" starttime="20190402 05:52:36.057"></status>
</kw>
<msg timestamp="20190402 05:52:36.058" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:52:36.058" starttime="20190402 05:52:34.948"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:52:36.058" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:52:36.058" starttime="20190402 05:52:36.058"></status>
</kw>
<msg timestamp="20190402 05:52:36.058" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:52:36.058" starttime="20190402 05:52:34.945"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:52:36.059" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:52:36.059" starttime="20190402 05:52:36.059"></status>
</kw>
<status status="FAIL" endtime="20190402 05:52:36.059" starttime="20190402 05:52:34.944"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:52:41.064" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:41.064" starttime="20190402 05:52:41.062"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:41.065" starttime="20190402 05:52:41.065"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:41.066" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:41.066" starttime="20190402 05:52:41.066"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:41.066" starttime="20190402 05:52:41.066"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:41.067" starttime="20190402 05:52:41.067"></status>
</kw>
<msg timestamp="20190402 05:52:41.067" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:41.067" starttime="20190402 05:52:41.066"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:41.067" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:41.067" starttime="20190402 05:52:41.067"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:41.078" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:41.078" starttime="20190402 05:52:41.067"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:52:42.174" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:52:42.174" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:42.174" starttime="20190402 05:52:41.078"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:52:42.175" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:42.175" starttime="20190402 05:52:42.175"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:52:42.175" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:52:42.175" starttime="20190402 05:52:42.175"></status>
</kw>
<msg timestamp="20190402 05:52:42.175" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:52:42.175" starttime="20190402 05:52:42.174"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:52:42.177" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:52:42.177" starttime="20190402 05:52:42.176"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:52:42.178" level="INFO">0</msg>
<msg timestamp="20190402 05:52:42.178" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:42.178" starttime="20190402 05:52:42.177"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:52:42.178" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:52:42.179" starttime="20190402 05:52:42.178"></status>
</kw>
<msg timestamp="20190402 05:52:42.179" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:42.179" starttime="20190402 05:52:42.176"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:42.180" starttime="20190402 05:52:42.179"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:42.180" starttime="20190402 05:52:42.179"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:42.180" starttime="20190402 05:52:42.180"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:52:42.180" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:52:42.180" starttime="20190402 05:52:42.180"></status>
</kw>
<msg timestamp="20190402 05:52:42.180" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:52:42.180" starttime="20190402 05:52:41.064"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:52:42.181" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:52:42.181" starttime="20190402 05:52:42.181"></status>
</kw>
<msg timestamp="20190402 05:52:42.181" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:52:42.181" starttime="20190402 05:52:41.061"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:52:42.181" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:52:42.182" starttime="20190402 05:52:42.181"></status>
</kw>
<status status="FAIL" endtime="20190402 05:52:42.182" starttime="20190402 05:52:41.060"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:52:47.185" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:47.185" starttime="20190402 05:52:47.184"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:47.187" starttime="20190402 05:52:47.187"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:47.189" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:47.189" starttime="20190402 05:52:47.188"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:47.190" starttime="20190402 05:52:47.190"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:47.191" starttime="20190402 05:52:47.191"></status>
</kw>
<msg timestamp="20190402 05:52:47.192" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:47.192" starttime="20190402 05:52:47.188"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:47.193" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:47.193" starttime="20190402 05:52:47.192"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:47.218" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:47.218" starttime="20190402 05:52:47.193"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:52:48.204" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:52:48.204" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:48.204" starttime="20190402 05:52:47.219"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:52:48.205" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:48.205" starttime="20190402 05:52:48.205"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:52:48.205" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:52:48.205" starttime="20190402 05:52:48.205"></status>
</kw>
<msg timestamp="20190402 05:52:48.206" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:52:48.206" starttime="20190402 05:52:48.204"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:52:48.207" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:52:48.207" starttime="20190402 05:52:48.206"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:52:48.208" level="INFO">0</msg>
<msg timestamp="20190402 05:52:48.208" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:48.208" starttime="20190402 05:52:48.207"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:52:48.208" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:52:48.208" starttime="20190402 05:52:48.208"></status>
</kw>
<msg timestamp="20190402 05:52:48.208" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:48.208" starttime="20190402 05:52:48.206"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:48.209" starttime="20190402 05:52:48.209"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:48.209" starttime="20190402 05:52:48.208"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:48.210" starttime="20190402 05:52:48.209"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:52:48.210" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:52:48.210" starttime="20190402 05:52:48.210"></status>
</kw>
<msg timestamp="20190402 05:52:48.210" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:52:48.210" starttime="20190402 05:52:47.185"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:52:48.210" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:52:48.210" starttime="20190402 05:52:48.210"></status>
</kw>
<msg timestamp="20190402 05:52:48.211" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:52:48.211" starttime="20190402 05:52:47.183"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:52:48.211" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:52:48.211" starttime="20190402 05:52:48.211"></status>
</kw>
<status status="FAIL" endtime="20190402 05:52:48.211" starttime="20190402 05:52:47.182"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:52:53.215" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:53.215" starttime="20190402 05:52:53.214"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:53.217" starttime="20190402 05:52:53.217"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:53.218" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:53.218" starttime="20190402 05:52:53.218"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:53.218" starttime="20190402 05:52:53.218"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:53.219" starttime="20190402 05:52:53.218"></status>
</kw>
<msg timestamp="20190402 05:52:53.219" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:53.219" starttime="20190402 05:52:53.217"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:53.219" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:53.219" starttime="20190402 05:52:53.219"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:53.230" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:53.230" starttime="20190402 05:52:53.219"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:52:54.241" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:52:54.241" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:54.241" starttime="20190402 05:52:53.230"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:52:54.242" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:54.242" starttime="20190402 05:52:54.242"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:52:54.242" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:52:54.242" starttime="20190402 05:52:54.242"></status>
</kw>
<msg timestamp="20190402 05:52:54.242" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:52:54.242" starttime="20190402 05:52:54.241"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:52:54.244" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:52:54.244" starttime="20190402 05:52:54.243"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:52:54.245" level="INFO">0</msg>
<msg timestamp="20190402 05:52:54.245" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:54.245" starttime="20190402 05:52:54.245"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:52:54.245" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:52:54.245" starttime="20190402 05:52:54.245"></status>
</kw>
<msg timestamp="20190402 05:52:54.245" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:52:54.245" starttime="20190402 05:52:54.242"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:54.246" starttime="20190402 05:52:54.246"></status>
</kw>
<status status="PASS" endtime="20190402 05:52:54.246" starttime="20190402 05:52:54.245"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:54.247" starttime="20190402 05:52:54.246"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:52:54.247" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:52:54.247" starttime="20190402 05:52:54.247"></status>
</kw>
<msg timestamp="20190402 05:52:54.247" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:52:54.247" starttime="20190402 05:52:53.215"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:52:54.248" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:52:54.248" starttime="20190402 05:52:54.247"></status>
</kw>
<msg timestamp="20190402 05:52:54.248" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:52:54.248" starttime="20190402 05:52:53.213"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:52:54.248" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:52:54.248" starttime="20190402 05:52:54.248"></status>
</kw>
<status status="FAIL" endtime="20190402 05:52:54.248" starttime="20190402 05:52:53.212"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:52:59.252" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:59.252" starttime="20190402 05:52:59.251"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:59.254" starttime="20190402 05:52:59.254"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:52:59.255" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:52:59.255" starttime="20190402 05:52:59.255"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:59.255" starttime="20190402 05:52:59.255"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:52:59.256" starttime="20190402 05:52:59.255"></status>
</kw>
<msg timestamp="20190402 05:52:59.256" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:52:59.256" starttime="20190402 05:52:59.254"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:52:59.256" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:52:59.256" starttime="20190402 05:52:59.256"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:52:59.268" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:52:59.268" starttime="20190402 05:52:59.256"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:53:00.268" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:53:00.268" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:00.268" starttime="20190402 05:52:59.268"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:53:00.269" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:00.269" starttime="20190402 05:53:00.269"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:53:00.269" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:53:00.269" starttime="20190402 05:53:00.269"></status>
</kw>
<msg timestamp="20190402 05:53:00.269" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:53:00.269" starttime="20190402 05:53:00.268"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:53:00.271" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:53:00.271" starttime="20190402 05:53:00.270"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:53:00.271" level="INFO">0</msg>
<msg timestamp="20190402 05:53:00.271" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:00.271" starttime="20190402 05:53:00.271"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:53:00.272" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:53:00.272" starttime="20190402 05:53:00.272"></status>
</kw>
<msg timestamp="20190402 05:53:00.272" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:00.272" starttime="20190402 05:53:00.269"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:00.273" starttime="20190402 05:53:00.272"></status>
</kw>
<status status="PASS" endtime="20190402 05:53:00.273" starttime="20190402 05:53:00.272"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:00.273" starttime="20190402 05:53:00.273"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:53:00.273" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:53:00.273" starttime="20190402 05:53:00.273"></status>
</kw>
<msg timestamp="20190402 05:53:00.274" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:53:00.274" starttime="20190402 05:52:59.253"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:53:00.274" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:53:00.274" starttime="20190402 05:53:00.274"></status>
</kw>
<msg timestamp="20190402 05:53:00.274" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:53:00.274" starttime="20190402 05:52:59.250"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:53:00.275" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:53:00.275" starttime="20190402 05:53:00.274"></status>
</kw>
<status status="FAIL" endtime="20190402 05:53:00.275" starttime="20190402 05:52:59.249"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:53:05.282" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:05.282" starttime="20190402 05:53:05.281"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:05.285" starttime="20190402 05:53:05.284"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:53:05.287" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:53:05.287" starttime="20190402 05:53:05.286"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:05.289" starttime="20190402 05:53:05.288"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:05.290" starttime="20190402 05:53:05.289"></status>
</kw>
<msg timestamp="20190402 05:53:05.290" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:53:05.291" starttime="20190402 05:53:05.285"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:53:05.291" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:05.292" starttime="20190402 05:53:05.291"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:53:05.320" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:05.320" starttime="20190402 05:53:05.292"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:53:06.339" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:53:06.339" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:06.339" starttime="20190402 05:53:05.320"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:53:06.340" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:06.340" starttime="20190402 05:53:06.339"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:53:06.340" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:53:06.340" starttime="20190402 05:53:06.340"></status>
</kw>
<msg timestamp="20190402 05:53:06.340" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:53:06.340" starttime="20190402 05:53:06.339"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:53:06.342" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:53:06.342" starttime="20190402 05:53:06.340"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:53:06.343" level="INFO">0</msg>
<msg timestamp="20190402 05:53:06.343" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:06.343" starttime="20190402 05:53:06.342"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:53:06.343" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:53:06.343" starttime="20190402 05:53:06.343"></status>
</kw>
<msg timestamp="20190402 05:53:06.343" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:06.343" starttime="20190402 05:53:06.340"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:06.344" starttime="20190402 05:53:06.344"></status>
</kw>
<status status="PASS" endtime="20190402 05:53:06.344" starttime="20190402 05:53:06.343"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:06.344" starttime="20190402 05:53:06.344"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:53:06.345" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:53:06.345" starttime="20190402 05:53:06.344"></status>
</kw>
<msg timestamp="20190402 05:53:06.345" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:53:06.345" starttime="20190402 05:53:05.282"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:53:06.345" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:53:06.345" starttime="20190402 05:53:06.345"></status>
</kw>
<msg timestamp="20190402 05:53:06.345" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:53:06.345" starttime="20190402 05:53:05.277"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:53:06.346" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:53:06.346" starttime="20190402 05:53:06.346"></status>
</kw>
<status status="FAIL" endtime="20190402 05:53:06.346" starttime="20190402 05:53:05.276"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:53:11.351" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:11.351" starttime="20190402 05:53:11.349"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:11.352" starttime="20190402 05:53:11.352"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:53:11.353" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:53:11.353" starttime="20190402 05:53:11.352"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:11.353" starttime="20190402 05:53:11.353"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:11.353" starttime="20190402 05:53:11.353"></status>
</kw>
<msg timestamp="20190402 05:53:11.353" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:53:11.353" starttime="20190402 05:53:11.352"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:53:11.354" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:11.354" starttime="20190402 05:53:11.354"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:53:11.364" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:11.365" starttime="20190402 05:53:11.354"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:53:12.387" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:53:12.387" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:12.387" starttime="20190402 05:53:11.365"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:53:12.388" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:12.388" starttime="20190402 05:53:12.388"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:53:12.388" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:53:12.388" starttime="20190402 05:53:12.388"></status>
</kw>
<msg timestamp="20190402 05:53:12.388" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:53:12.389" starttime="20190402 05:53:12.387"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:53:12.390" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:53:12.390" starttime="20190402 05:53:12.389"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:53:12.391" level="INFO">0</msg>
<msg timestamp="20190402 05:53:12.391" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:12.391" starttime="20190402 05:53:12.390"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:53:12.391" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:53:12.391" starttime="20190402 05:53:12.391"></status>
</kw>
<msg timestamp="20190402 05:53:12.391" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:12.391" starttime="20190402 05:53:12.389"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:12.392" starttime="20190402 05:53:12.392"></status>
</kw>
<status status="PASS" endtime="20190402 05:53:12.392" starttime="20190402 05:53:12.391"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:12.392" starttime="20190402 05:53:12.392"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:53:12.393" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:53:12.393" starttime="20190402 05:53:12.393"></status>
</kw>
<msg timestamp="20190402 05:53:12.393" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:53:12.393" starttime="20190402 05:53:11.351"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:53:12.393" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:53:12.393" starttime="20190402 05:53:12.393"></status>
</kw>
<msg timestamp="20190402 05:53:12.393" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:53:12.394" starttime="20190402 05:53:11.348"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:53:12.394" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:53:12.394" starttime="20190402 05:53:12.394"></status>
</kw>
<status status="FAIL" endtime="20190402 05:53:12.394" starttime="20190402 05:53:11.347"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:53:17.399" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:17.399" starttime="20190402 05:53:17.398"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:17.401" starttime="20190402 05:53:17.400"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:53:17.401" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:53:17.402" starttime="20190402 05:53:17.401"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:17.402" starttime="20190402 05:53:17.402"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:17.402" starttime="20190402 05:53:17.402"></status>
</kw>
<msg timestamp="20190402 05:53:17.402" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:53:17.402" starttime="20190402 05:53:17.401"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:53:17.403" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:17.403" starttime="20190402 05:53:17.403"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:53:17.417" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:17.417" starttime="20190402 05:53:17.403"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:53:18.562" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:53:18.562" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:18.562" starttime="20190402 05:53:17.417"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:53:18.563" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:18.563" starttime="20190402 05:53:18.563"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:53:18.563" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:53:18.563" starttime="20190402 05:53:18.563"></status>
</kw>
<msg timestamp="20190402 05:53:18.563" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:53:18.563" starttime="20190402 05:53:18.562"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:53:18.565" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:53:18.565" starttime="20190402 05:53:18.564"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:53:18.568" level="INFO">0</msg>
<msg timestamp="20190402 05:53:18.568" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:18.568" starttime="20190402 05:53:18.565"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:53:18.568" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:53:18.568" starttime="20190402 05:53:18.568"></status>
</kw>
<msg timestamp="20190402 05:53:18.568" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:18.568" starttime="20190402 05:53:18.563"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:18.569" starttime="20190402 05:53:18.569"></status>
</kw>
<status status="PASS" endtime="20190402 05:53:18.569" starttime="20190402 05:53:18.569"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:18.569" starttime="20190402 05:53:18.569"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:53:18.570" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:53:18.570" starttime="20190402 05:53:18.570"></status>
</kw>
<msg timestamp="20190402 05:53:18.570" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:53:18.570" starttime="20190402 05:53:17.399"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:53:18.570" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:53:18.570" starttime="20190402 05:53:18.570"></status>
</kw>
<msg timestamp="20190402 05:53:18.570" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:53:18.571" starttime="20190402 05:53:17.396"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:53:18.571" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:53:18.571" starttime="20190402 05:53:18.571"></status>
</kw>
<status status="FAIL" endtime="20190402 05:53:18.571" starttime="20190402 05:53:17.395"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:53:23.575" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:23.576" starttime="20190402 05:53:23.574"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:23.577" starttime="20190402 05:53:23.577"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:53:23.578" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:53:23.578" starttime="20190402 05:53:23.578"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:23.579" starttime="20190402 05:53:23.579"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:23.579" starttime="20190402 05:53:23.579"></status>
</kw>
<msg timestamp="20190402 05:53:23.579" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:53:23.579" starttime="20190402 05:53:23.578"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:53:23.580" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:23.580" starttime="20190402 05:53:23.579"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:53:23.592" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:23.592" starttime="20190402 05:53:23.580"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:53:24.757" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:53:24.757" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:24.757" starttime="20190402 05:53:23.592"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:53:24.758" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:24.758" starttime="20190402 05:53:24.758"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:53:24.758" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:53:24.758" starttime="20190402 05:53:24.758"></status>
</kw>
<msg timestamp="20190402 05:53:24.758" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:53:24.758" starttime="20190402 05:53:24.757"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:53:24.760" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:53:24.760" starttime="20190402 05:53:24.759"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:53:24.761" level="INFO">0</msg>
<msg timestamp="20190402 05:53:24.761" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:24.761" starttime="20190402 05:53:24.761"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:53:24.761" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:53:24.761" starttime="20190402 05:53:24.761"></status>
</kw>
<msg timestamp="20190402 05:53:24.762" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:24.762" starttime="20190402 05:53:24.758"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:24.762" starttime="20190402 05:53:24.762"></status>
</kw>
<status status="PASS" endtime="20190402 05:53:24.762" starttime="20190402 05:53:24.762"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:24.763" starttime="20190402 05:53:24.763"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:53:24.763" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:53:24.763" starttime="20190402 05:53:24.763"></status>
</kw>
<msg timestamp="20190402 05:53:24.763" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:53:24.763" starttime="20190402 05:53:23.576"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:53:24.764" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:53:24.764" starttime="20190402 05:53:24.764"></status>
</kw>
<msg timestamp="20190402 05:53:24.764" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:53:24.764" starttime="20190402 05:53:23.573"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:53:24.765" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:53:24.765" starttime="20190402 05:53:24.764"></status>
</kw>
<status status="FAIL" endtime="20190402 05:53:24.765" starttime="20190402 05:53:23.572"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:53:29.769" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:29.769" starttime="20190402 05:53:29.768"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:29.772" starttime="20190402 05:53:29.771"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:53:29.775" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:53:29.775" starttime="20190402 05:53:29.774"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:29.776" starttime="20190402 05:53:29.776"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:29.778" starttime="20190402 05:53:29.777"></status>
</kw>
<msg timestamp="20190402 05:53:29.779" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:53:29.779" starttime="20190402 05:53:29.773"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:53:29.780" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:29.780" starttime="20190402 05:53:29.779"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:53:29.809" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:29.810" starttime="20190402 05:53:29.780"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:53:30.965" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:53:30.965" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:30.965" starttime="20190402 05:53:29.810"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:53:30.966" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:30.966" starttime="20190402 05:53:30.966"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:53:30.966" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:53:30.966" starttime="20190402 05:53:30.966"></status>
</kw>
<msg timestamp="20190402 05:53:30.966" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:53:30.966" starttime="20190402 05:53:30.965"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:53:30.968" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:53:30.968" starttime="20190402 05:53:30.967"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:53:30.969" level="INFO">0</msg>
<msg timestamp="20190402 05:53:30.969" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:30.969" starttime="20190402 05:53:30.968"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:53:30.969" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:53:30.969" starttime="20190402 05:53:30.969"></status>
</kw>
<msg timestamp="20190402 05:53:30.969" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:30.969" starttime="20190402 05:53:30.967"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:30.970" starttime="20190402 05:53:30.970"></status>
</kw>
<status status="PASS" endtime="20190402 05:53:30.970" starttime="20190402 05:53:30.969"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:30.970" starttime="20190402 05:53:30.970"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:53:30.971" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:53:30.971" starttime="20190402 05:53:30.970"></status>
</kw>
<msg timestamp="20190402 05:53:30.971" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:53:30.971" starttime="20190402 05:53:29.770"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:53:30.971" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:53:30.971" starttime="20190402 05:53:30.971"></status>
</kw>
<msg timestamp="20190402 05:53:30.971" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:53:30.971" starttime="20190402 05:53:29.767"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:53:30.972" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:53:30.972" starttime="20190402 05:53:30.972"></status>
</kw>
<status status="FAIL" endtime="20190402 05:53:30.972" starttime="20190402 05:53:29.766"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:53:35.976" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:35.976" starttime="20190402 05:53:35.975"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:35.978" starttime="20190402 05:53:35.977"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:53:35.978" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:53:35.978" starttime="20190402 05:53:35.978"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:35.979" starttime="20190402 05:53:35.978"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:35.979" starttime="20190402 05:53:35.979"></status>
</kw>
<msg timestamp="20190402 05:53:35.979" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:53:35.979" starttime="20190402 05:53:35.978"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:53:35.979" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:35.980" starttime="20190402 05:53:35.979"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:53:35.989" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:35.989" starttime="20190402 05:53:35.980"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:53:37.148" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:53:37.148" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:37.148" starttime="20190402 05:53:35.990"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:53:37.149" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:37.149" starttime="20190402 05:53:37.149"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:53:37.149" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:53:37.149" starttime="20190402 05:53:37.149"></status>
</kw>
<msg timestamp="20190402 05:53:37.149" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:53:37.149" starttime="20190402 05:53:37.148"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:53:37.151" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:53:37.151" starttime="20190402 05:53:37.150"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:53:37.151" level="INFO">0</msg>
<msg timestamp="20190402 05:53:37.152" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:37.152" starttime="20190402 05:53:37.151"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:53:37.152" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:53:37.152" starttime="20190402 05:53:37.152"></status>
</kw>
<msg timestamp="20190402 05:53:37.152" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:37.152" starttime="20190402 05:53:37.149"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:37.153" starttime="20190402 05:53:37.153"></status>
</kw>
<status status="PASS" endtime="20190402 05:53:37.153" starttime="20190402 05:53:37.152"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:37.153" starttime="20190402 05:53:37.153"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:53:37.153" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:53:37.153" starttime="20190402 05:53:37.153"></status>
</kw>
<msg timestamp="20190402 05:53:37.154" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:53:37.154" starttime="20190402 05:53:35.976"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:53:37.154" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:53:37.154" starttime="20190402 05:53:37.154"></status>
</kw>
<msg timestamp="20190402 05:53:37.154" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:53:37.154" starttime="20190402 05:53:35.974"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:53:37.155" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:53:37.155" starttime="20190402 05:53:37.154"></status>
</kw>
<status status="FAIL" endtime="20190402 05:53:37.155" starttime="20190402 05:53:35.973"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:53:42.159" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:42.159" starttime="20190402 05:53:42.158"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:42.161" starttime="20190402 05:53:42.160"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:53:42.161" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:53:42.161" starttime="20190402 05:53:42.161"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:42.162" starttime="20190402 05:53:42.161"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:42.162" starttime="20190402 05:53:42.162"></status>
</kw>
<msg timestamp="20190402 05:53:42.162" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:53:42.162" starttime="20190402 05:53:42.161"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:53:42.163" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:42.163" starttime="20190402 05:53:42.162"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:53:42.173" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:42.173" starttime="20190402 05:53:42.163"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:53:43.403" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:53:43.403" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:43.403" starttime="20190402 05:53:42.173"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:53:43.404" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:43.404" starttime="20190402 05:53:43.404"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:53:43.405" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:53:43.405" starttime="20190402 05:53:43.405"></status>
</kw>
<msg timestamp="20190402 05:53:43.405" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:53:43.405" starttime="20190402 05:53:43.404"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:53:43.407" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:53:43.407" starttime="20190402 05:53:43.405"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:53:43.407" level="INFO">0</msg>
<msg timestamp="20190402 05:53:43.407" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:43.407" starttime="20190402 05:53:43.407"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:53:43.408" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:53:43.408" starttime="20190402 05:53:43.407"></status>
</kw>
<msg timestamp="20190402 05:53:43.408" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:43.408" starttime="20190402 05:53:43.405"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:43.409" starttime="20190402 05:53:43.408"></status>
</kw>
<status status="PASS" endtime="20190402 05:53:43.409" starttime="20190402 05:53:43.408"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:43.409" starttime="20190402 05:53:43.409"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:53:43.409" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:53:43.409" starttime="20190402 05:53:43.409"></status>
</kw>
<msg timestamp="20190402 05:53:43.409" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:53:43.409" starttime="20190402 05:53:42.160"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:53:43.410" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:53:43.410" starttime="20190402 05:53:43.410"></status>
</kw>
<msg timestamp="20190402 05:53:43.410" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:53:43.410" starttime="20190402 05:53:42.157"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:53:43.410" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:53:43.410" starttime="20190402 05:53:43.410"></status>
</kw>
<status status="FAIL" endtime="20190402 05:53:43.411" starttime="20190402 05:53:42.156"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:53:48.415" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:48.415" starttime="20190402 05:53:48.414"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:48.417" starttime="20190402 05:53:48.416"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:53:48.417" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:53:48.417" starttime="20190402 05:53:48.417"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:48.418" starttime="20190402 05:53:48.417"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:48.418" starttime="20190402 05:53:48.418"></status>
</kw>
<msg timestamp="20190402 05:53:48.418" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:53:48.418" starttime="20190402 05:53:48.417"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:53:48.419" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:48.419" starttime="20190402 05:53:48.418"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:53:48.429" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:48.429" starttime="20190402 05:53:48.419"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:53:49.590" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:53:49.590" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:49.590" starttime="20190402 05:53:48.429"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:53:49.591" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:49.591" starttime="20190402 05:53:49.590"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:53:49.591" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:53:49.591" starttime="20190402 05:53:49.591"></status>
</kw>
<msg timestamp="20190402 05:53:49.591" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:53:49.591" starttime="20190402 05:53:49.590"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:53:49.594" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:53:49.594" starttime="20190402 05:53:49.592"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:53:49.594" level="INFO">0</msg>
<msg timestamp="20190402 05:53:49.594" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:49.594" starttime="20190402 05:53:49.594"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:53:49.594" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:53:49.594" starttime="20190402 05:53:49.594"></status>
</kw>
<msg timestamp="20190402 05:53:49.595" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:49.595" starttime="20190402 05:53:49.591"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:49.595" starttime="20190402 05:53:49.595"></status>
</kw>
<status status="PASS" endtime="20190402 05:53:49.595" starttime="20190402 05:53:49.595"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:49.596" starttime="20190402 05:53:49.595"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:53:49.596" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:53:49.596" starttime="20190402 05:53:49.596"></status>
</kw>
<msg timestamp="20190402 05:53:49.596" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:53:49.596" starttime="20190402 05:53:48.415"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:53:49.596" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:53:49.597" starttime="20190402 05:53:49.596"></status>
</kw>
<msg timestamp="20190402 05:53:49.597" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:53:49.597" starttime="20190402 05:53:48.413"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:53:49.597" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:53:49.597" starttime="20190402 05:53:49.597"></status>
</kw>
<status status="FAIL" endtime="20190402 05:53:49.597" starttime="20190402 05:53:48.411"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:53:54.602" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:54.602" starttime="20190402 05:53:54.601"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:54.604" starttime="20190402 05:53:54.603"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:53:54.604" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:53:54.604" starttime="20190402 05:53:54.604"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:54.605" starttime="20190402 05:53:54.604"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:54.605" starttime="20190402 05:53:54.605"></status>
</kw>
<msg timestamp="20190402 05:53:54.605" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:53:54.605" starttime="20190402 05:53:54.604"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:53:54.606" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:54.606" starttime="20190402 05:53:54.605"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:53:54.607" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:53:54.608" starttime="20190402 05:53:54.606"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:53:55.673" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:53:55.673" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:55.673" starttime="20190402 05:53:54.608"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:53:55.674" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:53:55.674" starttime="20190402 05:53:55.673"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:53:55.674" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190402 05:53:55.674" starttime="20190402 05:53:55.674"></status>
</kw>
<msg timestamp="20190402 05:53:55.674" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190402 05:53:55.674" starttime="20190402 05:53:55.673"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:53:55.676" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:53:55.676" starttime="20190402 05:53:55.674"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:53:55.676" level="INFO">0</msg>
<msg timestamp="20190402 05:53:55.676" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:55.677" starttime="20190402 05:53:55.676"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:53:55.677" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:53:55.677" starttime="20190402 05:53:55.677"></status>
</kw>
<msg timestamp="20190402 05:53:55.677" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:53:55.677" starttime="20190402 05:53:55.674"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:55.678" starttime="20190402 05:53:55.677"></status>
</kw>
<status status="PASS" endtime="20190402 05:53:55.678" starttime="20190402 05:53:55.677"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:53:55.678" starttime="20190402 05:53:55.678"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:53:55.679" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190402 05:53:55.679" starttime="20190402 05:53:55.678"></status>
</kw>
<msg timestamp="20190402 05:53:55.679" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:53:55.679" starttime="20190402 05:53:54.603"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:53:55.679" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190402 05:53:55.679" starttime="20190402 05:53:55.679"></status>
</kw>
<msg timestamp="20190402 05:53:55.679" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190402 05:53:55.679" starttime="20190402 05:53:54.600"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:53:55.680" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190402 05:53:55.680" starttime="20190402 05:53:55.680"></status>
</kw>
<status status="FAIL" endtime="20190402 05:53:55.680" starttime="20190402 05:53:54.598"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:54:00.684" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:00.684" starttime="20190402 05:54:00.683"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:00.686" starttime="20190402 05:54:00.685"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:54:00.686" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:54:00.686" starttime="20190402 05:54:00.686"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:00.687" starttime="20190402 05:54:00.686"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:00.687" starttime="20190402 05:54:00.687"></status>
</kw>
<msg timestamp="20190402 05:54:00.687" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:54:00.687" starttime="20190402 05:54:00.686"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:54:00.687" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:00.688" starttime="20190402 05:54:00.687"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:54:00.698" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:00.698" starttime="20190402 05:54:00.688"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:54:01.847" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:54:01.847" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:01.847" starttime="20190402 05:54:00.699"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:54:01.848" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:01.848" starttime="20190402 05:54:01.848"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:54:01.848" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:01.848" starttime="20190402 05:54:01.848"></status>
</kw>
<msg timestamp="20190402 05:54:01.849" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:01.849" starttime="20190402 05:54:01.847"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:54:01.850" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:54:01.850" starttime="20190402 05:54:01.849"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:54:01.851" level="INFO">0</msg>
<msg timestamp="20190402 05:54:01.851" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:01.851" starttime="20190402 05:54:01.850"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:54:01.851" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:54:01.851" starttime="20190402 05:54:01.851"></status>
</kw>
<msg timestamp="20190402 05:54:01.851" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:01.851" starttime="20190402 05:54:01.849"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:01.852" starttime="20190402 05:54:01.852"></status>
</kw>
<status status="PASS" endtime="20190402 05:54:01.852" starttime="20190402 05:54:01.851"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:01.852" starttime="20190402 05:54:01.852"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:54:01.853" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190402 05:54:01.853" starttime="20190402 05:54:01.852"></status>
</kw>
<msg timestamp="20190402 05:54:01.853" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:54:01.853" starttime="20190402 05:54:00.685"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:54:01.853" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:01.853" starttime="20190402 05:54:01.853"></status>
</kw>
<msg timestamp="20190402 05:54:01.853" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:01.853" starttime="20190402 05:54:00.682"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:54:01.854" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:54:01.854" starttime="20190402 05:54:01.853"></status>
</kw>
<status status="FAIL" endtime="20190402 05:54:01.854" starttime="20190402 05:54:00.681"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:54:06.859" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:06.859" starttime="20190402 05:54:06.858"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:06.860" starttime="20190402 05:54:06.860"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:54:06.860" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:54:06.860" starttime="20190402 05:54:06.860"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:06.861" starttime="20190402 05:54:06.861"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:06.861" starttime="20190402 05:54:06.861"></status>
</kw>
<msg timestamp="20190402 05:54:06.861" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:54:06.861" starttime="20190402 05:54:06.860"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:54:06.862" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:06.862" starttime="20190402 05:54:06.861"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:54:06.872" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:06.872" starttime="20190402 05:54:06.862"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:54:08.207" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:54:08.208" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:08.208" starttime="20190402 05:54:06.872"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:54:08.208" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:08.208" starttime="20190402 05:54:08.208"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:54:08.209" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:08.209" starttime="20190402 05:54:08.209"></status>
</kw>
<msg timestamp="20190402 05:54:08.209" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:08.209" starttime="20190402 05:54:08.208"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:54:08.211" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:54:08.211" starttime="20190402 05:54:08.209"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:54:08.211" level="INFO">0</msg>
<msg timestamp="20190402 05:54:08.211" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:08.211" starttime="20190402 05:54:08.211"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:54:08.212" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:54:08.212" starttime="20190402 05:54:08.212"></status>
</kw>
<msg timestamp="20190402 05:54:08.212" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:08.212" starttime="20190402 05:54:08.209"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:08.213" starttime="20190402 05:54:08.212"></status>
</kw>
<status status="PASS" endtime="20190402 05:54:08.213" starttime="20190402 05:54:08.212"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:08.213" starttime="20190402 05:54:08.213"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:54:08.213" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190402 05:54:08.213" starttime="20190402 05:54:08.213"></status>
</kw>
<msg timestamp="20190402 05:54:08.214" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:54:08.214" starttime="20190402 05:54:06.859"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:54:08.214" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:08.214" starttime="20190402 05:54:08.214"></status>
</kw>
<msg timestamp="20190402 05:54:08.214" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:08.214" starttime="20190402 05:54:06.856"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:54:08.215" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:54:08.215" starttime="20190402 05:54:08.214"></status>
</kw>
<status status="FAIL" endtime="20190402 05:54:08.215" starttime="20190402 05:54:06.855"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:54:13.220" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:13.220" starttime="20190402 05:54:13.219"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:13.223" starttime="20190402 05:54:13.222"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:54:13.226" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:54:13.226" starttime="20190402 05:54:13.224"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:13.227" starttime="20190402 05:54:13.226"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:13.228" starttime="20190402 05:54:13.227"></status>
</kw>
<msg timestamp="20190402 05:54:13.229" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:54:13.229" starttime="20190402 05:54:13.223"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:54:13.230" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:13.230" starttime="20190402 05:54:13.230"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:54:13.259" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:13.259" starttime="20190402 05:54:13.231"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:54:14.317" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:54:14.317" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:14.317" starttime="20190402 05:54:13.259"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:54:14.318" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:14.318" starttime="20190402 05:54:14.318"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:54:14.319" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:14.319" starttime="20190402 05:54:14.318"></status>
</kw>
<msg timestamp="20190402 05:54:14.319" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:14.319" starttime="20190402 05:54:14.318"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:54:14.320" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:54:14.320" starttime="20190402 05:54:14.319"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:54:14.321" level="INFO">0</msg>
<msg timestamp="20190402 05:54:14.321" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:14.321" starttime="20190402 05:54:14.321"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:54:14.321" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:54:14.321" starttime="20190402 05:54:14.321"></status>
</kw>
<msg timestamp="20190402 05:54:14.321" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:14.322" starttime="20190402 05:54:14.319"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:14.322" starttime="20190402 05:54:14.322"></status>
</kw>
<status status="PASS" endtime="20190402 05:54:14.322" starttime="20190402 05:54:14.322"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:14.323" starttime="20190402 05:54:14.322"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:54:14.323" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190402 05:54:14.323" starttime="20190402 05:54:14.323"></status>
</kw>
<msg timestamp="20190402 05:54:14.323" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:54:14.323" starttime="20190402 05:54:13.221"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:54:14.323" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:14.323" starttime="20190402 05:54:14.323"></status>
</kw>
<msg timestamp="20190402 05:54:14.324" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:14.324" starttime="20190402 05:54:13.217"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:54:14.324" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:54:14.324" starttime="20190402 05:54:14.324"></status>
</kw>
<status status="FAIL" endtime="20190402 05:54:14.324" starttime="20190402 05:54:13.216"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:54:19.329" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:19.329" starttime="20190402 05:54:19.328"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:19.331" starttime="20190402 05:54:19.331"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:54:19.332" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:54:19.332" starttime="20190402 05:54:19.331"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:19.332" starttime="20190402 05:54:19.332"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:19.332" starttime="20190402 05:54:19.332"></status>
</kw>
<msg timestamp="20190402 05:54:19.333" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:54:19.333" starttime="20190402 05:54:19.331"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:54:19.333" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:19.333" starttime="20190402 05:54:19.333"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:54:19.342" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:19.342" starttime="20190402 05:54:19.333"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:54:20.402" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:54:20.402" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:20.402" starttime="20190402 05:54:19.342"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:54:20.403" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:20.403" starttime="20190402 05:54:20.403"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:54:20.404" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:20.404" starttime="20190402 05:54:20.403"></status>
</kw>
<msg timestamp="20190402 05:54:20.404" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:20.404" starttime="20190402 05:54:20.403"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:54:20.405" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:54:20.405" starttime="20190402 05:54:20.404"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:54:20.406" level="INFO">0</msg>
<msg timestamp="20190402 05:54:20.406" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:20.406" starttime="20190402 05:54:20.406"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:54:20.406" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:54:20.406" starttime="20190402 05:54:20.406"></status>
</kw>
<msg timestamp="20190402 05:54:20.406" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:20.406" starttime="20190402 05:54:20.404"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:20.407" starttime="20190402 05:54:20.407"></status>
</kw>
<status status="PASS" endtime="20190402 05:54:20.407" starttime="20190402 05:54:20.407"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:20.407" starttime="20190402 05:54:20.407"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:54:20.408" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190402 05:54:20.408" starttime="20190402 05:54:20.408"></status>
</kw>
<msg timestamp="20190402 05:54:20.408" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:54:20.408" starttime="20190402 05:54:19.330"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:54:20.408" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:20.408" starttime="20190402 05:54:20.408"></status>
</kw>
<msg timestamp="20190402 05:54:20.409" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:20.409" starttime="20190402 05:54:19.327"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:54:20.409" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:54:20.409" starttime="20190402 05:54:20.409"></status>
</kw>
<status status="FAIL" endtime="20190402 05:54:20.409" starttime="20190402 05:54:19.325"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:54:25.414" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:25.414" starttime="20190402 05:54:25.414"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:25.415" starttime="20190402 05:54:25.415"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:54:25.417" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:54:25.417" starttime="20190402 05:54:25.416"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:25.417" starttime="20190402 05:54:25.417"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:25.417" starttime="20190402 05:54:25.417"></status>
</kw>
<msg timestamp="20190402 05:54:25.418" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:54:25.418" starttime="20190402 05:54:25.415"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:54:25.418" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:25.418" starttime="20190402 05:54:25.418"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:54:25.427" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:25.427" starttime="20190402 05:54:25.418"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:54:26.448" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:54:26.449" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:26.449" starttime="20190402 05:54:25.427"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:54:26.449" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:26.449" starttime="20190402 05:54:26.449"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:54:26.450" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:26.450" starttime="20190402 05:54:26.450"></status>
</kw>
<msg timestamp="20190402 05:54:26.450" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:26.450" starttime="20190402 05:54:26.449"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:54:26.452" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:54:26.452" starttime="20190402 05:54:26.450"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:54:26.452" level="INFO">0</msg>
<msg timestamp="20190402 05:54:26.452" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:26.452" starttime="20190402 05:54:26.452"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:54:26.453" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:54:26.453" starttime="20190402 05:54:26.452"></status>
</kw>
<msg timestamp="20190402 05:54:26.453" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:26.453" starttime="20190402 05:54:26.450"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:26.453" starttime="20190402 05:54:26.453"></status>
</kw>
<status status="PASS" endtime="20190402 05:54:26.454" starttime="20190402 05:54:26.453"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:26.454" starttime="20190402 05:54:26.454"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:54:26.454" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190402 05:54:26.454" starttime="20190402 05:54:26.454"></status>
</kw>
<msg timestamp="20190402 05:54:26.454" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:54:26.454" starttime="20190402 05:54:25.415"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:54:26.455" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:26.455" starttime="20190402 05:54:26.454"></status>
</kw>
<msg timestamp="20190402 05:54:26.455" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:26.455" starttime="20190402 05:54:25.412"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:54:26.455" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:54:26.455" starttime="20190402 05:54:26.455"></status>
</kw>
<status status="FAIL" endtime="20190402 05:54:26.455" starttime="20190402 05:54:25.410"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:54:31.457" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:31.457" starttime="20190402 05:54:31.457"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:31.458" starttime="20190402 05:54:31.457"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:54:31.474" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:54:31.474" starttime="20190402 05:54:31.458"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:31.475" starttime="20190402 05:54:31.474"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:31.475" starttime="20190402 05:54:31.475"></status>
</kw>
<msg timestamp="20190402 05:54:31.475" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:54:31.475" starttime="20190402 05:54:31.458"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:54:31.476" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:31.476" starttime="20190402 05:54:31.475"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:54:31.487" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:31.487" starttime="20190402 05:54:31.476"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:54:32.535" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:54:32.535" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:32.535" starttime="20190402 05:54:31.487"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:54:32.536" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:32.536" starttime="20190402 05:54:32.536"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:54:32.537" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:32.537" starttime="20190402 05:54:32.536"></status>
</kw>
<msg timestamp="20190402 05:54:32.537" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:32.537" starttime="20190402 05:54:32.535"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:54:32.540" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:54:32.540" starttime="20190402 05:54:32.538"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:54:32.540" level="INFO">0</msg>
<msg timestamp="20190402 05:54:32.541" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:32.541" starttime="20190402 05:54:32.540"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:54:32.541" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:54:32.541" starttime="20190402 05:54:32.541"></status>
</kw>
<msg timestamp="20190402 05:54:32.542" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:32.542" starttime="20190402 05:54:32.537"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:32.543" starttime="20190402 05:54:32.542"></status>
</kw>
<status status="PASS" endtime="20190402 05:54:32.543" starttime="20190402 05:54:32.542"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:32.544" starttime="20190402 05:54:32.543"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:54:32.544" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190402 05:54:32.544" starttime="20190402 05:54:32.544"></status>
</kw>
<msg timestamp="20190402 05:54:32.544" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:54:32.544" starttime="20190402 05:54:31.457"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:54:32.545" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:32.545" starttime="20190402 05:54:32.545"></status>
</kw>
<msg timestamp="20190402 05:54:32.545" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:32.545" starttime="20190402 05:54:31.456"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:54:32.546" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:54:32.546" starttime="20190402 05:54:32.546"></status>
</kw>
<status status="FAIL" endtime="20190402 05:54:32.547" starttime="20190402 05:54:31.456"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:54:37.548" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:37.548" starttime="20190402 05:54:37.548"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:37.549" starttime="20190402 05:54:37.549"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:54:37.550" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:54:37.550" starttime="20190402 05:54:37.549"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:37.550" starttime="20190402 05:54:37.550"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:37.551" starttime="20190402 05:54:37.550"></status>
</kw>
<msg timestamp="20190402 05:54:37.551" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:54:37.551" starttime="20190402 05:54:37.549"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:54:37.551" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:37.551" starttime="20190402 05:54:37.551"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:54:37.562" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:37.562" starttime="20190402 05:54:37.551"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:54:38.582" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:54:38.582" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:38.582" starttime="20190402 05:54:37.562"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:54:38.583" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:38.583" starttime="20190402 05:54:38.582"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:54:38.583" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:38.583" starttime="20190402 05:54:38.583"></status>
</kw>
<msg timestamp="20190402 05:54:38.583" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:38.583" starttime="20190402 05:54:38.582"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:54:38.585" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:54:38.585" starttime="20190402 05:54:38.583"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:54:38.586" level="INFO">0</msg>
<msg timestamp="20190402 05:54:38.586" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:38.586" starttime="20190402 05:54:38.585"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:54:38.586" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:54:38.586" starttime="20190402 05:54:38.586"></status>
</kw>
<msg timestamp="20190402 05:54:38.586" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:38.586" starttime="20190402 05:54:38.583"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:38.587" starttime="20190402 05:54:38.587"></status>
</kw>
<status status="PASS" endtime="20190402 05:54:38.587" starttime="20190402 05:54:38.586"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:38.587" starttime="20190402 05:54:38.587"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:54:38.588" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190402 05:54:38.588" starttime="20190402 05:54:38.588"></status>
</kw>
<msg timestamp="20190402 05:54:38.588" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:54:38.588" starttime="20190402 05:54:37.548"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:54:38.588" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:38.588" starttime="20190402 05:54:38.588"></status>
</kw>
<msg timestamp="20190402 05:54:38.588" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:38.589" starttime="20190402 05:54:37.547"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:54:38.589" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:54:38.589" starttime="20190402 05:54:38.589"></status>
</kw>
<status status="FAIL" endtime="20190402 05:54:38.589" starttime="20190402 05:54:37.547"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:54:43.591" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:43.591" starttime="20190402 05:54:43.590"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:43.591" starttime="20190402 05:54:43.591"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:54:43.592" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:54:43.592" starttime="20190402 05:54:43.592"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:43.593" starttime="20190402 05:54:43.592"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:43.593" starttime="20190402 05:54:43.593"></status>
</kw>
<msg timestamp="20190402 05:54:43.593" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:54:43.593" starttime="20190402 05:54:43.591"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:54:43.594" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:43.594" starttime="20190402 05:54:43.594"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:54:43.604" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:43.605" starttime="20190402 05:54:43.594"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:54:44.634" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:54:44.634" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:44.634" starttime="20190402 05:54:43.605"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:54:44.635" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:44.635" starttime="20190402 05:54:44.635"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:54:44.636" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:44.636" starttime="20190402 05:54:44.635"></status>
</kw>
<msg timestamp="20190402 05:54:44.636" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190402 05:54:44.636" starttime="20190402 05:54:44.635"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:54:44.638" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:54:44.638" starttime="20190402 05:54:44.636"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:54:44.638" level="INFO">0</msg>
<msg timestamp="20190402 05:54:44.638" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:44.638" starttime="20190402 05:54:44.638"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:54:44.639" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:54:44.639" starttime="20190402 05:54:44.638"></status>
</kw>
<msg timestamp="20190402 05:54:44.639" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:44.639" starttime="20190402 05:54:44.636"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:44.640" starttime="20190402 05:54:44.639"></status>
</kw>
<status status="PASS" endtime="20190402 05:54:44.640" starttime="20190402 05:54:44.639"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:44.640" starttime="20190402 05:54:44.640"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:54:44.640" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190402 05:54:44.640" starttime="20190402 05:54:44.640"></status>
</kw>
<msg timestamp="20190402 05:54:44.641" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:54:44.641" starttime="20190402 05:54:43.591"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:54:44.641" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:44.641" starttime="20190402 05:54:44.641"></status>
</kw>
<msg timestamp="20190402 05:54:44.641" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190402 05:54:44.641" starttime="20190402 05:54:43.590"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:54:44.642" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:54:44.642" starttime="20190402 05:54:44.641"></status>
</kw>
<status status="FAIL" endtime="20190402 05:54:44.642" starttime="20190402 05:54:43.589"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:54:49.643" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:49.643" starttime="20190402 05:54:49.643"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:49.644" starttime="20190402 05:54:49.644"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:54:49.645" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:54:49.645" starttime="20190402 05:54:49.644"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:49.645" starttime="20190402 05:54:49.645"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:49.646" starttime="20190402 05:54:49.645"></status>
</kw>
<msg timestamp="20190402 05:54:49.646" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:54:49.646" starttime="20190402 05:54:49.644"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:54:49.646" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:49.647" starttime="20190402 05:54:49.646"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:54:49.657" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:49.657" starttime="20190402 05:54:49.647"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:54:50.711" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:54:50.711" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:50.711" starttime="20190402 05:54:49.657"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:54:50.712" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:50.712" starttime="20190402 05:54:50.712"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:54:50.712" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:54:50.712" starttime="20190402 05:54:50.712"></status>
</kw>
<msg timestamp="20190402 05:54:50.712" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:54:50.712" starttime="20190402 05:54:50.711"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:54:50.714" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:54:50.714" starttime="20190402 05:54:50.713"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:54:50.715" level="INFO">0</msg>
<msg timestamp="20190402 05:54:50.715" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:50.715" starttime="20190402 05:54:50.714"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:54:50.715" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:54:50.715" starttime="20190402 05:54:50.715"></status>
</kw>
<msg timestamp="20190402 05:54:50.715" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:50.715" starttime="20190402 05:54:50.712"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:50.716" starttime="20190402 05:54:50.716"></status>
</kw>
<status status="PASS" endtime="20190402 05:54:50.716" starttime="20190402 05:54:50.716"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:50.717" starttime="20190402 05:54:50.716"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:54:50.717" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:54:50.717" starttime="20190402 05:54:50.717"></status>
</kw>
<msg timestamp="20190402 05:54:50.717" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:54:50.717" starttime="20190402 05:54:49.643"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:54:50.717" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:54:50.717" starttime="20190402 05:54:50.717"></status>
</kw>
<msg timestamp="20190402 05:54:50.718" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:54:50.718" starttime="20190402 05:54:49.643"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:54:50.718" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:54:50.718" starttime="20190402 05:54:50.718"></status>
</kw>
<status status="FAIL" endtime="20190402 05:54:50.718" starttime="20190402 05:54:49.642"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:54:55.720" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:55.720" starttime="20190402 05:54:55.720"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:55.721" starttime="20190402 05:54:55.721"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:54:55.723" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:54:55.723" starttime="20190402 05:54:55.722"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:55.723" starttime="20190402 05:54:55.723"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:55.724" starttime="20190402 05:54:55.723"></status>
</kw>
<msg timestamp="20190402 05:54:55.724" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:54:55.724" starttime="20190402 05:54:55.722"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:54:55.725" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:55.725" starttime="20190402 05:54:55.724"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:54:55.740" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:54:55.740" starttime="20190402 05:54:55.725"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:54:56.724" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:54:56.724" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:56.724" starttime="20190402 05:54:55.740"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:54:56.725" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:54:56.726" starttime="20190402 05:54:56.725"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:54:56.726" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:54:56.726" starttime="20190402 05:54:56.726"></status>
</kw>
<msg timestamp="20190402 05:54:56.726" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:54:56.726" starttime="20190402 05:54:56.725"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:54:56.728" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:54:56.728" starttime="20190402 05:54:56.726"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:54:56.729" level="INFO">0</msg>
<msg timestamp="20190402 05:54:56.729" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:56.729" starttime="20190402 05:54:56.728"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:54:56.729" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:54:56.729" starttime="20190402 05:54:56.729"></status>
</kw>
<msg timestamp="20190402 05:54:56.729" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:54:56.729" starttime="20190402 05:54:56.726"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:56.730" starttime="20190402 05:54:56.730"></status>
</kw>
<status status="PASS" endtime="20190402 05:54:56.730" starttime="20190402 05:54:56.729"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:54:56.731" starttime="20190402 05:54:56.730"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:54:56.731" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:54:56.731" starttime="20190402 05:54:56.731"></status>
</kw>
<msg timestamp="20190402 05:54:56.731" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:54:56.731" starttime="20190402 05:54:55.721"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:54:56.731" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:54:56.731" starttime="20190402 05:54:56.731"></status>
</kw>
<msg timestamp="20190402 05:54:56.732" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:54:56.732" starttime="20190402 05:54:55.719"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:54:56.732" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:54:56.732" starttime="20190402 05:54:56.732"></status>
</kw>
<status status="FAIL" endtime="20190402 05:54:56.732" starttime="20190402 05:54:55.719"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:55:01.734" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:01.734" starttime="20190402 05:55:01.733"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:01.734" starttime="20190402 05:55:01.734"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:55:01.735" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:55:01.735" starttime="20190402 05:55:01.735"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:01.736" starttime="20190402 05:55:01.736"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:01.736" starttime="20190402 05:55:01.736"></status>
</kw>
<msg timestamp="20190402 05:55:01.736" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:55:01.736" starttime="20190402 05:55:01.735"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:55:01.737" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:01.737" starttime="20190402 05:55:01.736"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:55:01.746" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:01.747" starttime="20190402 05:55:01.737"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:55:02.745" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:55:02.745" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:02.745" starttime="20190402 05:55:01.747"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:55:02.746" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:02.746" starttime="20190402 05:55:02.746"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:55:02.747" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:02.747" starttime="20190402 05:55:02.746"></status>
</kw>
<msg timestamp="20190402 05:55:02.747" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:02.747" starttime="20190402 05:55:02.745"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:55:02.749" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:55:02.749" starttime="20190402 05:55:02.747"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:55:02.749" level="INFO">0</msg>
<msg timestamp="20190402 05:55:02.749" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:02.749" starttime="20190402 05:55:02.749"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:55:02.750" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:55:02.750" starttime="20190402 05:55:02.750"></status>
</kw>
<msg timestamp="20190402 05:55:02.750" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:02.750" starttime="20190402 05:55:02.747"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:02.751" starttime="20190402 05:55:02.750"></status>
</kw>
<status status="PASS" endtime="20190402 05:55:02.751" starttime="20190402 05:55:02.750"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:02.751" starttime="20190402 05:55:02.751"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:55:02.751" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:55:02.751" starttime="20190402 05:55:02.751"></status>
</kw>
<msg timestamp="20190402 05:55:02.752" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:55:02.752" starttime="20190402 05:55:01.734"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:55:02.752" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:02.752" starttime="20190402 05:55:02.752"></status>
</kw>
<msg timestamp="20190402 05:55:02.752" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:02.752" starttime="20190402 05:55:01.733"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:55:02.753" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:55:02.753" starttime="20190402 05:55:02.752"></status>
</kw>
<status status="FAIL" endtime="20190402 05:55:02.753" starttime="20190402 05:55:01.733"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:55:07.756" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:07.756" starttime="20190402 05:55:07.756"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:07.759" starttime="20190402 05:55:07.758"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:55:07.761" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:55:07.761" starttime="20190402 05:55:07.760"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:07.762" starttime="20190402 05:55:07.761"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:07.763" starttime="20190402 05:55:07.762"></status>
</kw>
<msg timestamp="20190402 05:55:07.763" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:55:07.763" starttime="20190402 05:55:07.759"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:55:07.764" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:07.764" starttime="20190402 05:55:07.764"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:55:07.792" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:07.792" starttime="20190402 05:55:07.764"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:55:08.786" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:55:08.787" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:08.787" starttime="20190402 05:55:07.792"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:55:08.787" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:08.787" starttime="20190402 05:55:08.787"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:55:08.788" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:08.788" starttime="20190402 05:55:08.788"></status>
</kw>
<msg timestamp="20190402 05:55:08.788" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:08.788" starttime="20190402 05:55:08.787"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:55:08.790" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:55:08.790" starttime="20190402 05:55:08.788"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:55:08.790" level="INFO">0</msg>
<msg timestamp="20190402 05:55:08.790" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:08.791" starttime="20190402 05:55:08.790"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:55:08.791" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:55:08.791" starttime="20190402 05:55:08.791"></status>
</kw>
<msg timestamp="20190402 05:55:08.791" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:08.791" starttime="20190402 05:55:08.788"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:08.792" starttime="20190402 05:55:08.791"></status>
</kw>
<status status="PASS" endtime="20190402 05:55:08.792" starttime="20190402 05:55:08.791"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:08.792" starttime="20190402 05:55:08.792"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:55:08.792" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:55:08.792" starttime="20190402 05:55:08.792"></status>
</kw>
<msg timestamp="20190402 05:55:08.793" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:55:08.793" starttime="20190402 05:55:07.757"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:55:08.793" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:08.793" starttime="20190402 05:55:08.793"></status>
</kw>
<msg timestamp="20190402 05:55:08.793" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:08.793" starttime="20190402 05:55:07.755"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:55:08.793" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:55:08.794" starttime="20190402 05:55:08.793"></status>
</kw>
<status status="FAIL" endtime="20190402 05:55:08.794" starttime="20190402 05:55:07.754"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:55:13.797" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:13.797" starttime="20190402 05:55:13.796"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:13.799" starttime="20190402 05:55:13.799"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:55:13.800" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:55:13.800" starttime="20190402 05:55:13.800"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:13.800" starttime="20190402 05:55:13.800"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:13.801" starttime="20190402 05:55:13.801"></status>
</kw>
<msg timestamp="20190402 05:55:13.801" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:55:13.801" starttime="20190402 05:55:13.799"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:55:13.801" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:13.801" starttime="20190402 05:55:13.801"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:55:13.813" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:13.813" starttime="20190402 05:55:13.801"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:55:14.816" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:55:14.816" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:14.816" starttime="20190402 05:55:13.813"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:55:14.817" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:14.817" starttime="20190402 05:55:14.817"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:55:14.817" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:14.817" starttime="20190402 05:55:14.817"></status>
</kw>
<msg timestamp="20190402 05:55:14.818" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:14.818" starttime="20190402 05:55:14.816"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:55:14.819" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:55:14.820" starttime="20190402 05:55:14.818"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:55:14.820" level="INFO">0</msg>
<msg timestamp="20190402 05:55:14.820" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:14.820" starttime="20190402 05:55:14.820"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:55:14.820" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:55:14.820" starttime="20190402 05:55:14.820"></status>
</kw>
<msg timestamp="20190402 05:55:14.820" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:14.820" starttime="20190402 05:55:14.818"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:14.821" starttime="20190402 05:55:14.821"></status>
</kw>
<status status="PASS" endtime="20190402 05:55:14.822" starttime="20190402 05:55:14.821"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:14.822" starttime="20190402 05:55:14.822"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:55:14.822" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:55:14.822" starttime="20190402 05:55:14.822"></status>
</kw>
<msg timestamp="20190402 05:55:14.822" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:55:14.822" starttime="20190402 05:55:13.798"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:55:14.823" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:14.823" starttime="20190402 05:55:14.822"></status>
</kw>
<msg timestamp="20190402 05:55:14.823" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:14.823" starttime="20190402 05:55:13.795"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:55:14.823" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:55:14.823" starttime="20190402 05:55:14.823"></status>
</kw>
<status status="FAIL" endtime="20190402 05:55:14.823" starttime="20190402 05:55:13.794"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:55:19.828" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:19.828" starttime="20190402 05:55:19.827"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:19.830" starttime="20190402 05:55:19.829"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:55:19.830" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:55:19.830" starttime="20190402 05:55:19.830"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:19.831" starttime="20190402 05:55:19.830"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:19.831" starttime="20190402 05:55:19.831"></status>
</kw>
<msg timestamp="20190402 05:55:19.831" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:55:19.831" starttime="20190402 05:55:19.830"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:55:19.832" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:19.832" starttime="20190402 05:55:19.832"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:55:19.841" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:19.842" starttime="20190402 05:55:19.832"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:55:20.841" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:55:20.842" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:20.842" starttime="20190402 05:55:19.842"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:55:20.842" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:20.842" starttime="20190402 05:55:20.842"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:55:20.843" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:20.843" starttime="20190402 05:55:20.842"></status>
</kw>
<msg timestamp="20190402 05:55:20.843" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:20.843" starttime="20190402 05:55:20.842"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:55:20.844" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:55:20.844" starttime="20190402 05:55:20.843"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:55:20.845" level="INFO">0</msg>
<msg timestamp="20190402 05:55:20.845" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:20.845" starttime="20190402 05:55:20.844"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:55:20.845" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:55:20.845" starttime="20190402 05:55:20.845"></status>
</kw>
<msg timestamp="20190402 05:55:20.845" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:20.845" starttime="20190402 05:55:20.843"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:20.846" starttime="20190402 05:55:20.846"></status>
</kw>
<status status="PASS" endtime="20190402 05:55:20.846" starttime="20190402 05:55:20.845"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:20.847" starttime="20190402 05:55:20.846"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:55:20.847" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:55:20.847" starttime="20190402 05:55:20.847"></status>
</kw>
<msg timestamp="20190402 05:55:20.847" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:55:20.847" starttime="20190402 05:55:19.828"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:55:20.848" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:20.848" starttime="20190402 05:55:20.848"></status>
</kw>
<msg timestamp="20190402 05:55:20.848" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:20.848" starttime="20190402 05:55:19.826"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:55:20.849" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:55:20.849" starttime="20190402 05:55:20.848"></status>
</kw>
<status status="FAIL" endtime="20190402 05:55:20.849" starttime="20190402 05:55:19.824"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:55:25.853" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:25.854" starttime="20190402 05:55:25.852"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:25.855" starttime="20190402 05:55:25.855"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:55:25.855" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:55:25.855" starttime="20190402 05:55:25.855"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:25.856" starttime="20190402 05:55:25.856"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:25.856" starttime="20190402 05:55:25.856"></status>
</kw>
<msg timestamp="20190402 05:55:25.856" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:55:25.856" starttime="20190402 05:55:25.855"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:55:25.857" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:25.857" starttime="20190402 05:55:25.856"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:55:25.871" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:25.871" starttime="20190402 05:55:25.857"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:55:26.877" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:55:26.877" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:26.877" starttime="20190402 05:55:25.871"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:55:26.878" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:26.878" starttime="20190402 05:55:26.878"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:55:26.878" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:26.878" starttime="20190402 05:55:26.878"></status>
</kw>
<msg timestamp="20190402 05:55:26.878" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:26.878" starttime="20190402 05:55:26.877"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:55:26.881" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:55:26.881" starttime="20190402 05:55:26.879"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:55:26.881" level="INFO">0</msg>
<msg timestamp="20190402 05:55:26.881" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:26.881" starttime="20190402 05:55:26.881"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:55:26.882" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:55:26.882" starttime="20190402 05:55:26.881"></status>
</kw>
<msg timestamp="20190402 05:55:26.882" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:26.882" starttime="20190402 05:55:26.879"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:26.883" starttime="20190402 05:55:26.882"></status>
</kw>
<status status="PASS" endtime="20190402 05:55:26.883" starttime="20190402 05:55:26.882"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:26.883" starttime="20190402 05:55:26.883"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:55:26.883" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:55:26.883" starttime="20190402 05:55:26.883"></status>
</kw>
<msg timestamp="20190402 05:55:26.883" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:55:26.883" starttime="20190402 05:55:25.854"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:55:26.884" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:26.884" starttime="20190402 05:55:26.884"></status>
</kw>
<msg timestamp="20190402 05:55:26.884" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:26.884" starttime="20190402 05:55:25.851"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:55:26.884" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:55:26.884" starttime="20190402 05:55:26.884"></status>
</kw>
<status status="FAIL" endtime="20190402 05:55:26.885" starttime="20190402 05:55:25.850"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:55:31.889" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:31.889" starttime="20190402 05:55:31.888"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:31.891" starttime="20190402 05:55:31.890"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:55:31.891" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:55:31.891" starttime="20190402 05:55:31.891"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:31.892" starttime="20190402 05:55:31.891"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:31.892" starttime="20190402 05:55:31.892"></status>
</kw>
<msg timestamp="20190402 05:55:31.892" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:55:31.892" starttime="20190402 05:55:31.891"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:55:31.892" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:31.892" starttime="20190402 05:55:31.892"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:55:31.907" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:31.907" starttime="20190402 05:55:31.893"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:55:32.939" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:55:32.939" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:32.939" starttime="20190402 05:55:31.907"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:55:32.940" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:32.940" starttime="20190402 05:55:32.940"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:55:32.940" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:32.941" starttime="20190402 05:55:32.940"></status>
</kw>
<msg timestamp="20190402 05:55:32.941" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:32.941" starttime="20190402 05:55:32.940"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:55:32.943" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:55:32.943" starttime="20190402 05:55:32.941"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:55:32.943" level="INFO">0</msg>
<msg timestamp="20190402 05:55:32.943" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:32.944" starttime="20190402 05:55:32.943"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:55:32.944" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:55:32.944" starttime="20190402 05:55:32.944"></status>
</kw>
<msg timestamp="20190402 05:55:32.944" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:32.944" starttime="20190402 05:55:32.941"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:32.945" starttime="20190402 05:55:32.944"></status>
</kw>
<status status="PASS" endtime="20190402 05:55:32.945" starttime="20190402 05:55:32.944"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:32.945" starttime="20190402 05:55:32.945"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:55:32.945" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:55:32.945" starttime="20190402 05:55:32.945"></status>
</kw>
<msg timestamp="20190402 05:55:32.946" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:55:32.946" starttime="20190402 05:55:31.889"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:55:32.946" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:32.946" starttime="20190402 05:55:32.946"></status>
</kw>
<msg timestamp="20190402 05:55:32.946" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:32.946" starttime="20190402 05:55:31.887"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:55:32.947" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:55:32.947" starttime="20190402 05:55:32.946"></status>
</kw>
<status status="FAIL" endtime="20190402 05:55:32.947" starttime="20190402 05:55:31.885"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:55:37.951" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:37.952" starttime="20190402 05:55:37.950"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:37.954" starttime="20190402 05:55:37.953"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:55:37.957" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:55:37.957" starttime="20190402 05:55:37.956"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:37.958" starttime="20190402 05:55:37.957"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:37.959" starttime="20190402 05:55:37.958"></status>
</kw>
<msg timestamp="20190402 05:55:37.960" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:55:37.960" starttime="20190402 05:55:37.955"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:55:37.961" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:37.961" starttime="20190402 05:55:37.960"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:55:37.987" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:37.987" starttime="20190402 05:55:37.961"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:55:38.978" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:55:38.978" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:38.978" starttime="20190402 05:55:37.987"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:55:38.979" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:38.979" starttime="20190402 05:55:38.979"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:55:38.980" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:38.980" starttime="20190402 05:55:38.979"></status>
</kw>
<msg timestamp="20190402 05:55:38.980" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:38.980" starttime="20190402 05:55:38.979"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:55:38.982" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:55:38.982" starttime="20190402 05:55:38.980"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:55:38.982" level="INFO">0</msg>
<msg timestamp="20190402 05:55:38.982" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:38.982" starttime="20190402 05:55:38.982"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:55:38.982" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:55:38.982" starttime="20190402 05:55:38.982"></status>
</kw>
<msg timestamp="20190402 05:55:38.983" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:38.983" starttime="20190402 05:55:38.980"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:38.983" starttime="20190402 05:55:38.983"></status>
</kw>
<status status="PASS" endtime="20190402 05:55:38.983" starttime="20190402 05:55:38.983"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:38.984" starttime="20190402 05:55:38.984"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:55:38.984" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:55:38.984" starttime="20190402 05:55:38.984"></status>
</kw>
<msg timestamp="20190402 05:55:38.984" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:55:38.984" starttime="20190402 05:55:37.952"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:55:38.985" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:38.985" starttime="20190402 05:55:38.984"></status>
</kw>
<msg timestamp="20190402 05:55:38.985" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:38.985" starttime="20190402 05:55:37.949"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:55:38.985" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:55:38.985" starttime="20190402 05:55:38.985"></status>
</kw>
<status status="FAIL" endtime="20190402 05:55:38.985" starttime="20190402 05:55:37.947"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:55:43.990" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:43.990" starttime="20190402 05:55:43.989"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:43.994" starttime="20190402 05:55:43.993"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:55:43.997" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:55:43.997" starttime="20190402 05:55:43.995"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:43.998" starttime="20190402 05:55:43.997"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:43.999" starttime="20190402 05:55:43.998"></status>
</kw>
<msg timestamp="20190402 05:55:44.000" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:55:44.000" starttime="20190402 05:55:43.994"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:55:44.001" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:44.001" starttime="20190402 05:55:44.001"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:55:44.028" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:44.028" starttime="20190402 05:55:44.002"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:55:45.014" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:55:45.014" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:45.014" starttime="20190402 05:55:44.028"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:55:45.015" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:45.015" starttime="20190402 05:55:45.014"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:55:45.015" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:45.015" starttime="20190402 05:55:45.015"></status>
</kw>
<msg timestamp="20190402 05:55:45.015" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:45.015" starttime="20190402 05:55:45.014"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:55:45.017" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:55:45.017" starttime="20190402 05:55:45.016"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:55:45.018" level="INFO">0</msg>
<msg timestamp="20190402 05:55:45.018" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:45.018" starttime="20190402 05:55:45.018"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:55:45.018" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:55:45.018" starttime="20190402 05:55:45.018"></status>
</kw>
<msg timestamp="20190402 05:55:45.018" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:45.018" starttime="20190402 05:55:45.015"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:45.019" starttime="20190402 05:55:45.019"></status>
</kw>
<status status="PASS" endtime="20190402 05:55:45.019" starttime="20190402 05:55:45.018"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:45.019" starttime="20190402 05:55:45.019"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:55:45.020" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:55:45.020" starttime="20190402 05:55:45.019"></status>
</kw>
<msg timestamp="20190402 05:55:45.020" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:55:45.020" starttime="20190402 05:55:43.991"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:55:45.020" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:45.020" starttime="20190402 05:55:45.020"></status>
</kw>
<msg timestamp="20190402 05:55:45.020" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:45.020" starttime="20190402 05:55:43.988"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:55:45.021" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:55:45.021" starttime="20190402 05:55:45.021"></status>
</kw>
<status status="FAIL" endtime="20190402 05:55:45.021" starttime="20190402 05:55:43.986"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:55:50.025" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:50.026" starttime="20190402 05:55:50.024"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:50.028" starttime="20190402 05:55:50.027"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:55:50.029" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:55:50.029" starttime="20190402 05:55:50.028"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:50.029" starttime="20190402 05:55:50.029"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:50.029" starttime="20190402 05:55:50.029"></status>
</kw>
<msg timestamp="20190402 05:55:50.030" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:55:50.030" starttime="20190402 05:55:50.028"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:55:50.030" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:50.030" starttime="20190402 05:55:50.030"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:55:50.040" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:50.040" starttime="20190402 05:55:50.030"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:55:51.044" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:55:51.044" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:51.044" starttime="20190402 05:55:50.040"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:55:51.045" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:51.045" starttime="20190402 05:55:51.045"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:55:51.045" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:51.045" starttime="20190402 05:55:51.045"></status>
</kw>
<msg timestamp="20190402 05:55:51.045" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:51.045" starttime="20190402 05:55:51.044"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:55:51.047" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:55:51.047" starttime="20190402 05:55:51.046"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:55:51.048" level="INFO">0</msg>
<msg timestamp="20190402 05:55:51.048" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:51.048" starttime="20190402 05:55:51.047"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:55:51.048" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:55:51.048" starttime="20190402 05:55:51.048"></status>
</kw>
<msg timestamp="20190402 05:55:51.048" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:51.048" starttime="20190402 05:55:51.045"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:51.049" starttime="20190402 05:55:51.049"></status>
</kw>
<status status="PASS" endtime="20190402 05:55:51.049" starttime="20190402 05:55:51.048"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:51.049" starttime="20190402 05:55:51.049"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:55:51.050" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:55:51.050" starttime="20190402 05:55:51.049"></status>
</kw>
<msg timestamp="20190402 05:55:51.050" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:55:51.050" starttime="20190402 05:55:50.026"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:55:51.050" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:51.050" starttime="20190402 05:55:51.050"></status>
</kw>
<msg timestamp="20190402 05:55:51.050" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:51.050" starttime="20190402 05:55:50.023"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:55:51.051" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:55:51.051" starttime="20190402 05:55:51.050"></status>
</kw>
<status status="FAIL" endtime="20190402 05:55:51.051" starttime="20190402 05:55:50.022"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:55:56.052" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:56.052" starttime="20190402 05:55:56.052"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:56.053" starttime="20190402 05:55:56.053"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:55:56.054" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:55:56.054" starttime="20190402 05:55:56.054"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:56.054" starttime="20190402 05:55:56.054"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:56.055" starttime="20190402 05:55:56.055"></status>
</kw>
<msg timestamp="20190402 05:55:56.055" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:55:56.055" starttime="20190402 05:55:56.053"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:55:56.056" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:56.056" starttime="20190402 05:55:56.056"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:55:56.067" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:55:56.067" starttime="20190402 05:55:56.056"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:55:57.112" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:55:57.113" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:57.113" starttime="20190402 05:55:56.067"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:55:57.113" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:55:57.113" starttime="20190402 05:55:57.113"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:55:57.114" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:57.114" starttime="20190402 05:55:57.113"></status>
</kw>
<msg timestamp="20190402 05:55:57.114" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:55:57.114" starttime="20190402 05:55:57.113"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:55:57.115" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:55:57.115" starttime="20190402 05:55:57.114"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:55:57.116" level="INFO">0</msg>
<msg timestamp="20190402 05:55:57.116" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:57.116" starttime="20190402 05:55:57.116"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:55:57.116" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:55:57.116" starttime="20190402 05:55:57.116"></status>
</kw>
<msg timestamp="20190402 05:55:57.116" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:55:57.116" starttime="20190402 05:55:57.114"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:57.117" starttime="20190402 05:55:57.117"></status>
</kw>
<status status="PASS" endtime="20190402 05:55:57.117" starttime="20190402 05:55:57.117"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:55:57.118" starttime="20190402 05:55:57.117"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:55:57.118" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:55:57.118" starttime="20190402 05:55:57.118"></status>
</kw>
<msg timestamp="20190402 05:55:57.118" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:55:57.118" starttime="20190402 05:55:56.053"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:55:57.118" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:57.118" starttime="20190402 05:55:57.118"></status>
</kw>
<msg timestamp="20190402 05:55:57.119" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:55:57.119" starttime="20190402 05:55:56.052"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:55:57.119" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:55:57.119" starttime="20190402 05:55:57.119"></status>
</kw>
<status status="FAIL" endtime="20190402 05:55:57.119" starttime="20190402 05:55:56.051"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:56:02.124" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:02.124" starttime="20190402 05:56:02.123"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:02.126" starttime="20190402 05:56:02.125"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:56:02.126" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:56:02.126" starttime="20190402 05:56:02.126"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:02.127" starttime="20190402 05:56:02.126"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:02.127" starttime="20190402 05:56:02.127"></status>
</kw>
<msg timestamp="20190402 05:56:02.127" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:56:02.127" starttime="20190402 05:56:02.126"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:56:02.127" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:02.127" starttime="20190402 05:56:02.127"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:56:02.136" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:02.136" starttime="20190402 05:56:02.128"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:56:03.129" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:56:03.129" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:03.129" starttime="20190402 05:56:02.137"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:56:03.130" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:03.130" starttime="20190402 05:56:03.129"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:56:03.130" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:03.130" starttime="20190402 05:56:03.130"></status>
</kw>
<msg timestamp="20190402 05:56:03.130" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:03.130" starttime="20190402 05:56:03.129"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:56:03.132" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:56:03.132" starttime="20190402 05:56:03.131"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:56:03.132" level="INFO">0</msg>
<msg timestamp="20190402 05:56:03.133" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:03.133" starttime="20190402 05:56:03.132"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:56:03.133" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:56:03.133" starttime="20190402 05:56:03.133"></status>
</kw>
<msg timestamp="20190402 05:56:03.133" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:03.133" starttime="20190402 05:56:03.130"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:03.134" starttime="20190402 05:56:03.134"></status>
</kw>
<status status="PASS" endtime="20190402 05:56:03.134" starttime="20190402 05:56:03.133"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:03.134" starttime="20190402 05:56:03.134"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:56:03.135" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:56:03.135" starttime="20190402 05:56:03.134"></status>
</kw>
<msg timestamp="20190402 05:56:03.135" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:56:03.135" starttime="20190402 05:56:02.124"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:56:03.135" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:03.135" starttime="20190402 05:56:03.135"></status>
</kw>
<msg timestamp="20190402 05:56:03.135" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:03.135" starttime="20190402 05:56:02.121"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:56:03.136" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:56:03.136" starttime="20190402 05:56:03.135"></status>
</kw>
<status status="FAIL" endtime="20190402 05:56:03.136" starttime="20190402 05:56:02.120"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:56:08.140" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:08.141" starttime="20190402 05:56:08.139"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:08.142" starttime="20190402 05:56:08.142"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:56:08.142" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:56:08.142" starttime="20190402 05:56:08.142"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:08.143" starttime="20190402 05:56:08.143"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:08.143" starttime="20190402 05:56:08.143"></status>
</kw>
<msg timestamp="20190402 05:56:08.143" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:56:08.143" starttime="20190402 05:56:08.142"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:56:08.144" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:08.144" starttime="20190402 05:56:08.143"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:56:08.154" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:08.154" starttime="20190402 05:56:08.144"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:56:09.152" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:56:09.152" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:09.152" starttime="20190402 05:56:08.154"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:56:09.153" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:09.153" starttime="20190402 05:56:09.153"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:56:09.153" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:09.153" starttime="20190402 05:56:09.153"></status>
</kw>
<msg timestamp="20190402 05:56:09.154" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:09.154" starttime="20190402 05:56:09.152"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:56:09.156" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:56:09.156" starttime="20190402 05:56:09.154"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:56:09.156" level="INFO">0</msg>
<msg timestamp="20190402 05:56:09.156" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:09.156" starttime="20190402 05:56:09.156"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:56:09.156" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:56:09.156" starttime="20190402 05:56:09.156"></status>
</kw>
<msg timestamp="20190402 05:56:09.157" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:09.157" starttime="20190402 05:56:09.154"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:09.157" starttime="20190402 05:56:09.157"></status>
</kw>
<status status="PASS" endtime="20190402 05:56:09.157" starttime="20190402 05:56:09.157"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:09.158" starttime="20190402 05:56:09.157"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:56:09.158" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:56:09.158" starttime="20190402 05:56:09.158"></status>
</kw>
<msg timestamp="20190402 05:56:09.158" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:56:09.158" starttime="20190402 05:56:08.141"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:56:09.158" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:09.158" starttime="20190402 05:56:09.158"></status>
</kw>
<msg timestamp="20190402 05:56:09.159" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:09.159" starttime="20190402 05:56:08.138"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:56:09.159" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:56:09.159" starttime="20190402 05:56:09.159"></status>
</kw>
<status status="FAIL" endtime="20190402 05:56:09.159" starttime="20190402 05:56:08.137"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:56:14.164" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:14.164" starttime="20190402 05:56:14.163"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:14.166" starttime="20190402 05:56:14.165"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:56:14.166" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:56:14.166" starttime="20190402 05:56:14.166"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:14.167" starttime="20190402 05:56:14.166"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:14.167" starttime="20190402 05:56:14.167"></status>
</kw>
<msg timestamp="20190402 05:56:14.167" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:56:14.167" starttime="20190402 05:56:14.166"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:56:14.167" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:14.168" starttime="20190402 05:56:14.167"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:56:14.180" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:14.180" starttime="20190402 05:56:14.168"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:56:15.177" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:56:15.177" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:15.177" starttime="20190402 05:56:14.180"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:56:15.178" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:15.178" starttime="20190402 05:56:15.178"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:56:15.179" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:15.179" starttime="20190402 05:56:15.178"></status>
</kw>
<msg timestamp="20190402 05:56:15.179" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:15.179" starttime="20190402 05:56:15.178"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:56:15.181" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:56:15.181" starttime="20190402 05:56:15.179"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:56:15.182" level="INFO">0</msg>
<msg timestamp="20190402 05:56:15.182" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:15.182" starttime="20190402 05:56:15.181"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:56:15.182" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:56:15.182" starttime="20190402 05:56:15.182"></status>
</kw>
<msg timestamp="20190402 05:56:15.182" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:15.182" starttime="20190402 05:56:15.179"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:15.183" starttime="20190402 05:56:15.183"></status>
</kw>
<status status="PASS" endtime="20190402 05:56:15.183" starttime="20190402 05:56:15.182"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:15.183" starttime="20190402 05:56:15.183"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:56:15.184" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:56:15.184" starttime="20190402 05:56:15.183"></status>
</kw>
<msg timestamp="20190402 05:56:15.184" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:56:15.184" starttime="20190402 05:56:14.164"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:56:15.184" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:15.184" starttime="20190402 05:56:15.184"></status>
</kw>
<msg timestamp="20190402 05:56:15.184" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:15.184" starttime="20190402 05:56:14.162"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:56:15.185" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:56:15.185" starttime="20190402 05:56:15.185"></status>
</kw>
<status status="FAIL" endtime="20190402 05:56:15.185" starttime="20190402 05:56:14.160"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:56:20.189" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:20.189" starttime="20190402 05:56:20.188"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:20.191" starttime="20190402 05:56:20.191"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:56:20.191" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:56:20.192" starttime="20190402 05:56:20.191"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:20.192" starttime="20190402 05:56:20.192"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:20.192" starttime="20190402 05:56:20.192"></status>
</kw>
<msg timestamp="20190402 05:56:20.192" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:56:20.192" starttime="20190402 05:56:20.191"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:56:20.193" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:20.193" starttime="20190402 05:56:20.193"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:56:20.205" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:20.205" starttime="20190402 05:56:20.193"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:56:21.193" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:56:21.193" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:21.193" starttime="20190402 05:56:20.205"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:56:21.194" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:21.194" starttime="20190402 05:56:21.193"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:56:21.194" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:21.194" starttime="20190402 05:56:21.194"></status>
</kw>
<msg timestamp="20190402 05:56:21.194" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:21.194" starttime="20190402 05:56:21.193"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:56:21.196" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:56:21.196" starttime="20190402 05:56:21.195"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:56:21.197" level="INFO">0</msg>
<msg timestamp="20190402 05:56:21.197" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:21.197" starttime="20190402 05:56:21.196"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:56:21.197" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:56:21.197" starttime="20190402 05:56:21.197"></status>
</kw>
<msg timestamp="20190402 05:56:21.197" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:21.197" starttime="20190402 05:56:21.194"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:21.198" starttime="20190402 05:56:21.198"></status>
</kw>
<status status="PASS" endtime="20190402 05:56:21.198" starttime="20190402 05:56:21.197"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:21.198" starttime="20190402 05:56:21.198"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:56:21.199" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:56:21.199" starttime="20190402 05:56:21.199"></status>
</kw>
<msg timestamp="20190402 05:56:21.199" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:56:21.199" starttime="20190402 05:56:20.190"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:56:21.199" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:21.199" starttime="20190402 05:56:21.199"></status>
</kw>
<msg timestamp="20190402 05:56:21.199" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:21.200" starttime="20190402 05:56:20.187"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:56:21.200" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:56:21.200" starttime="20190402 05:56:21.200"></status>
</kw>
<status status="FAIL" endtime="20190402 05:56:21.200" starttime="20190402 05:56:20.186"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:56:26.204" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:26.204" starttime="20190402 05:56:26.203"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:26.207" starttime="20190402 05:56:26.206"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:56:26.209" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:56:26.210" starttime="20190402 05:56:26.208"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:26.211" starttime="20190402 05:56:26.210"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:26.212" starttime="20190402 05:56:26.211"></status>
</kw>
<msg timestamp="20190402 05:56:26.213" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:56:26.213" starttime="20190402 05:56:26.207"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:56:26.213" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:26.214" starttime="20190402 05:56:26.213"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:56:26.241" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:26.241" starttime="20190402 05:56:26.214"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:56:27.228" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:56:27.228" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:27.228" starttime="20190402 05:56:26.241"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:56:27.229" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:27.229" starttime="20190402 05:56:27.229"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:56:27.229" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:27.229" starttime="20190402 05:56:27.229"></status>
</kw>
<msg timestamp="20190402 05:56:27.229" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:27.229" starttime="20190402 05:56:27.228"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:56:27.231" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:56:27.231" starttime="20190402 05:56:27.230"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:56:27.232" level="INFO">0</msg>
<msg timestamp="20190402 05:56:27.232" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:27.232" starttime="20190402 05:56:27.231"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:56:27.232" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:56:27.232" starttime="20190402 05:56:27.232"></status>
</kw>
<msg timestamp="20190402 05:56:27.232" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:27.232" starttime="20190402 05:56:27.230"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:27.233" starttime="20190402 05:56:27.233"></status>
</kw>
<status status="PASS" endtime="20190402 05:56:27.233" starttime="20190402 05:56:27.232"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:27.233" starttime="20190402 05:56:27.233"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:56:27.234" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:56:27.234" starttime="20190402 05:56:27.233"></status>
</kw>
<msg timestamp="20190402 05:56:27.234" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:56:27.234" starttime="20190402 05:56:26.205"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:56:27.234" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:27.234" starttime="20190402 05:56:27.234"></status>
</kw>
<msg timestamp="20190402 05:56:27.234" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:27.234" starttime="20190402 05:56:26.202"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:56:27.235" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:56:27.235" starttime="20190402 05:56:27.235"></status>
</kw>
<status status="FAIL" endtime="20190402 05:56:27.235" starttime="20190402 05:56:26.201"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:56:32.240" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:32.240" starttime="20190402 05:56:32.239"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:32.242" starttime="20190402 05:56:32.241"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:56:32.242" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:56:32.242" starttime="20190402 05:56:32.242"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:32.243" starttime="20190402 05:56:32.242"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:32.243" starttime="20190402 05:56:32.243"></status>
</kw>
<msg timestamp="20190402 05:56:32.243" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:56:32.243" starttime="20190402 05:56:32.242"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:56:32.243" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:32.243" starttime="20190402 05:56:32.243"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:56:32.255" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:32.255" starttime="20190402 05:56:32.244"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:56:33.246" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:56:33.247" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:33.247" starttime="20190402 05:56:32.255"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:56:33.247" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:33.247" starttime="20190402 05:56:33.247"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:56:33.248" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:33.248" starttime="20190402 05:56:33.247"></status>
</kw>
<msg timestamp="20190402 05:56:33.248" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:33.248" starttime="20190402 05:56:33.247"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:56:33.250" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:56:33.250" starttime="20190402 05:56:33.248"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:56:33.250" level="INFO">0</msg>
<msg timestamp="20190402 05:56:33.250" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:33.250" starttime="20190402 05:56:33.250"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:56:33.251" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:56:33.251" starttime="20190402 05:56:33.250"></status>
</kw>
<msg timestamp="20190402 05:56:33.251" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:33.251" starttime="20190402 05:56:33.248"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:33.252" starttime="20190402 05:56:33.251"></status>
</kw>
<status status="PASS" endtime="20190402 05:56:33.252" starttime="20190402 05:56:33.251"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:33.252" starttime="20190402 05:56:33.252"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:56:33.252" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:56:33.252" starttime="20190402 05:56:33.252"></status>
</kw>
<msg timestamp="20190402 05:56:33.252" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:56:33.252" starttime="20190402 05:56:32.240"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:56:33.253" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:33.253" starttime="20190402 05:56:33.252"></status>
</kw>
<msg timestamp="20190402 05:56:33.253" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:33.253" starttime="20190402 05:56:32.237"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:56:33.253" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:56:33.253" starttime="20190402 05:56:33.253"></status>
</kw>
<status status="FAIL" endtime="20190402 05:56:33.254" starttime="20190402 05:56:32.236"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:56:38.259" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:38.259" starttime="20190402 05:56:38.257"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:38.261" starttime="20190402 05:56:38.260"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:56:38.264" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:56:38.264" starttime="20190402 05:56:38.262"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:38.265" starttime="20190402 05:56:38.264"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:38.266" starttime="20190402 05:56:38.266"></status>
</kw>
<msg timestamp="20190402 05:56:38.267" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:56:38.267" starttime="20190402 05:56:38.262"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:56:38.268" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:38.268" starttime="20190402 05:56:38.268"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:56:38.295" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:38.295" starttime="20190402 05:56:38.268"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:56:39.274" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:56:39.274" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:39.274" starttime="20190402 05:56:38.295"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:56:39.275" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:39.275" starttime="20190402 05:56:39.275"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:56:39.275" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:39.275" starttime="20190402 05:56:39.275"></status>
</kw>
<msg timestamp="20190402 05:56:39.275" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:39.275" starttime="20190402 05:56:39.274"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:56:39.277" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:56:39.277" starttime="20190402 05:56:39.276"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:56:39.277" level="INFO">0</msg>
<msg timestamp="20190402 05:56:39.278" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:39.278" starttime="20190402 05:56:39.277"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:56:39.278" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:56:39.278" starttime="20190402 05:56:39.278"></status>
</kw>
<msg timestamp="20190402 05:56:39.278" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:39.278" starttime="20190402 05:56:39.275"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:39.279" starttime="20190402 05:56:39.279"></status>
</kw>
<status status="PASS" endtime="20190402 05:56:39.279" starttime="20190402 05:56:39.278"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:39.279" starttime="20190402 05:56:39.279"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:56:39.279" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:56:39.279" starttime="20190402 05:56:39.279"></status>
</kw>
<msg timestamp="20190402 05:56:39.280" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:56:39.280" starttime="20190402 05:56:38.259"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:56:39.280" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:39.280" starttime="20190402 05:56:39.280"></status>
</kw>
<msg timestamp="20190402 05:56:39.280" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:39.280" starttime="20190402 05:56:38.256"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:56:39.281" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:56:39.281" starttime="20190402 05:56:39.280"></status>
</kw>
<status status="FAIL" endtime="20190402 05:56:39.281" starttime="20190402 05:56:38.254"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:56:44.286" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:44.286" starttime="20190402 05:56:44.284"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:44.287" starttime="20190402 05:56:44.287"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:56:44.288" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:56:44.288" starttime="20190402 05:56:44.287"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:44.288" starttime="20190402 05:56:44.288"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:44.288" starttime="20190402 05:56:44.288"></status>
</kw>
<msg timestamp="20190402 05:56:44.289" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:56:44.289" starttime="20190402 05:56:44.287"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:56:44.289" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:44.289" starttime="20190402 05:56:44.289"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:56:44.298" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:44.298" starttime="20190402 05:56:44.289"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:56:45.327" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:56:45.327" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:45.327" starttime="20190402 05:56:44.298"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:56:45.328" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:45.328" starttime="20190402 05:56:45.328"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:56:45.328" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:45.328" starttime="20190402 05:56:45.328"></status>
</kw>
<msg timestamp="20190402 05:56:45.329" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:45.329" starttime="20190402 05:56:45.328"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:56:45.330" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:56:45.330" starttime="20190402 05:56:45.329"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:56:45.330" level="INFO">0</msg>
<msg timestamp="20190402 05:56:45.330" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:45.330" starttime="20190402 05:56:45.330"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:56:45.331" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:56:45.331" starttime="20190402 05:56:45.331"></status>
</kw>
<msg timestamp="20190402 05:56:45.331" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:45.331" starttime="20190402 05:56:45.329"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:45.332" starttime="20190402 05:56:45.331"></status>
</kw>
<status status="PASS" endtime="20190402 05:56:45.332" starttime="20190402 05:56:45.331"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:45.332" starttime="20190402 05:56:45.332"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:56:45.332" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:56:45.332" starttime="20190402 05:56:45.332"></status>
</kw>
<msg timestamp="20190402 05:56:45.333" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:56:45.333" starttime="20190402 05:56:44.286"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:56:45.333" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:45.333" starttime="20190402 05:56:45.333"></status>
</kw>
<msg timestamp="20190402 05:56:45.333" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:45.333" starttime="20190402 05:56:44.283"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:56:45.334" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:56:45.334" starttime="20190402 05:56:45.333"></status>
</kw>
<status status="FAIL" endtime="20190402 05:56:45.334" starttime="20190402 05:56:44.282"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:56:50.338" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:50.339" starttime="20190402 05:56:50.337"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:50.340" starttime="20190402 05:56:50.340"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:56:50.341" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:56:50.341" starttime="20190402 05:56:50.340"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:50.341" starttime="20190402 05:56:50.341"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:50.341" starttime="20190402 05:56:50.341"></status>
</kw>
<msg timestamp="20190402 05:56:50.342" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:56:50.342" starttime="20190402 05:56:50.340"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:56:50.342" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:50.342" starttime="20190402 05:56:50.342"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:56:50.352" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:50.352" starttime="20190402 05:56:50.342"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:56:51.360" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:56:51.360" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:51.360" starttime="20190402 05:56:50.352"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:56:51.361" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:51.361" starttime="20190402 05:56:51.361"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:56:51.361" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:51.361" starttime="20190402 05:56:51.361"></status>
</kw>
<msg timestamp="20190402 05:56:51.361" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:51.361" starttime="20190402 05:56:51.360"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:56:51.363" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:56:51.363" starttime="20190402 05:56:51.362"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:56:51.364" level="INFO">0</msg>
<msg timestamp="20190402 05:56:51.364" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:51.364" starttime="20190402 05:56:51.363"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:56:51.364" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:56:51.364" starttime="20190402 05:56:51.364"></status>
</kw>
<msg timestamp="20190402 05:56:51.364" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:51.364" starttime="20190402 05:56:51.361"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:51.365" starttime="20190402 05:56:51.365"></status>
</kw>
<status status="PASS" endtime="20190402 05:56:51.365" starttime="20190402 05:56:51.364"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:51.365" starttime="20190402 05:56:51.365"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:56:51.366" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:56:51.366" starttime="20190402 05:56:51.365"></status>
</kw>
<msg timestamp="20190402 05:56:51.366" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:56:51.366" starttime="20190402 05:56:50.339"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:56:51.366" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:51.366" starttime="20190402 05:56:51.366"></status>
</kw>
<msg timestamp="20190402 05:56:51.366" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:51.366" starttime="20190402 05:56:50.336"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:56:51.367" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:56:51.367" starttime="20190402 05:56:51.367"></status>
</kw>
<status status="FAIL" endtime="20190402 05:56:51.367" starttime="20190402 05:56:50.335"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:56:56.372" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:56.372" starttime="20190402 05:56:56.371"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:56.373" starttime="20190402 05:56:56.373"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:56:56.374" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:56:56.374" starttime="20190402 05:56:56.373"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:56.374" starttime="20190402 05:56:56.374"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:56.374" starttime="20190402 05:56:56.374"></status>
</kw>
<msg timestamp="20190402 05:56:56.375" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:56:56.375" starttime="20190402 05:56:56.373"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:56:56.375" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:56.375" starttime="20190402 05:56:56.375"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:56:56.384" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:56:56.384" starttime="20190402 05:56:56.375"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:56:57.390" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:56:57.390" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:57.390" starttime="20190402 05:56:56.384"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:56:57.391" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:56:57.391" starttime="20190402 05:56:57.391"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:56:57.391" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:57.391" starttime="20190402 05:56:57.391"></status>
</kw>
<msg timestamp="20190402 05:56:57.392" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:56:57.392" starttime="20190402 05:56:57.390"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:56:57.393" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:56:57.393" starttime="20190402 05:56:57.392"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:56:57.394" level="INFO">0</msg>
<msg timestamp="20190402 05:56:57.394" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:57.394" starttime="20190402 05:56:57.393"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:56:57.394" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:56:57.394" starttime="20190402 05:56:57.394"></status>
</kw>
<msg timestamp="20190402 05:56:57.394" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:56:57.394" starttime="20190402 05:56:57.392"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:57.395" starttime="20190402 05:56:57.395"></status>
</kw>
<status status="PASS" endtime="20190402 05:56:57.395" starttime="20190402 05:56:57.394"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:56:57.395" starttime="20190402 05:56:57.395"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:56:57.396" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:56:57.396" starttime="20190402 05:56:57.395"></status>
</kw>
<msg timestamp="20190402 05:56:57.396" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:56:57.396" starttime="20190402 05:56:56.372"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:56:57.396" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:57.396" starttime="20190402 05:56:57.396"></status>
</kw>
<msg timestamp="20190402 05:56:57.397" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:56:57.397" starttime="20190402 05:56:56.369"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:56:57.397" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:56:57.397" starttime="20190402 05:56:57.397"></status>
</kw>
<status status="FAIL" endtime="20190402 05:56:57.397" starttime="20190402 05:56:56.368"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:57:02.402" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:02.402" starttime="20190402 05:57:02.401"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:02.404" starttime="20190402 05:57:02.403"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:57:02.405" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:57:02.405" starttime="20190402 05:57:02.404"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:02.405" starttime="20190402 05:57:02.405"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:02.406" starttime="20190402 05:57:02.405"></status>
</kw>
<msg timestamp="20190402 05:57:02.406" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:57:02.406" starttime="20190402 05:57:02.404"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:57:02.406" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:02.406" starttime="20190402 05:57:02.406"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:57:02.416" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:02.417" starttime="20190402 05:57:02.406"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:57:03.431" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:57:03.431" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:03.432" starttime="20190402 05:57:02.417"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:57:03.432" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:03.432" starttime="20190402 05:57:03.432"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:57:03.433" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:03.433" starttime="20190402 05:57:03.432"></status>
</kw>
<msg timestamp="20190402 05:57:03.433" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:03.433" starttime="20190402 05:57:03.432"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:57:03.435" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:57:03.435" starttime="20190402 05:57:03.433"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:57:03.435" level="INFO">0</msg>
<msg timestamp="20190402 05:57:03.435" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:03.435" starttime="20190402 05:57:03.435"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:57:03.436" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:57:03.436" starttime="20190402 05:57:03.435"></status>
</kw>
<msg timestamp="20190402 05:57:03.436" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:03.436" starttime="20190402 05:57:03.433"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:03.437" starttime="20190402 05:57:03.436"></status>
</kw>
<status status="PASS" endtime="20190402 05:57:03.437" starttime="20190402 05:57:03.436"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:03.437" starttime="20190402 05:57:03.437"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:57:03.437" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:57:03.437" starttime="20190402 05:57:03.437"></status>
</kw>
<msg timestamp="20190402 05:57:03.437" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:57:03.437" starttime="20190402 05:57:02.402"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:57:03.438" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:03.438" starttime="20190402 05:57:03.437"></status>
</kw>
<msg timestamp="20190402 05:57:03.438" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:03.438" starttime="20190402 05:57:02.400"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:57:03.438" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:57:03.438" starttime="20190402 05:57:03.438"></status>
</kw>
<status status="FAIL" endtime="20190402 05:57:03.439" starttime="20190402 05:57:02.398"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:57:08.443" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:08.443" starttime="20190402 05:57:08.442"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:08.445" starttime="20190402 05:57:08.444"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:57:08.445" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:57:08.445" starttime="20190402 05:57:08.445"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:08.446" starttime="20190402 05:57:08.446"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:08.446" starttime="20190402 05:57:08.446"></status>
</kw>
<msg timestamp="20190402 05:57:08.446" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:57:08.446" starttime="20190402 05:57:08.445"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:57:08.447" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:08.447" starttime="20190402 05:57:08.446"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:57:08.456" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:08.457" starttime="20190402 05:57:08.447"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:57:09.455" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:57:09.456" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:09.456" starttime="20190402 05:57:08.457"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:57:09.456" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:09.456" starttime="20190402 05:57:09.456"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:57:09.457" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:09.457" starttime="20190402 05:57:09.457"></status>
</kw>
<msg timestamp="20190402 05:57:09.457" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:09.457" starttime="20190402 05:57:09.456"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:57:09.459" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:57:09.459" starttime="20190402 05:57:09.457"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:57:09.459" level="INFO">0</msg>
<msg timestamp="20190402 05:57:09.459" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:09.459" starttime="20190402 05:57:09.459"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:57:09.460" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:57:09.460" starttime="20190402 05:57:09.459"></status>
</kw>
<msg timestamp="20190402 05:57:09.460" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:09.460" starttime="20190402 05:57:09.457"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:09.461" starttime="20190402 05:57:09.460"></status>
</kw>
<status status="PASS" endtime="20190402 05:57:09.461" starttime="20190402 05:57:09.460"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:09.461" starttime="20190402 05:57:09.461"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:57:09.461" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:57:09.461" starttime="20190402 05:57:09.461"></status>
</kw>
<msg timestamp="20190402 05:57:09.461" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:57:09.461" starttime="20190402 05:57:08.444"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:57:09.462" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:09.462" starttime="20190402 05:57:09.462"></status>
</kw>
<msg timestamp="20190402 05:57:09.462" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:09.462" starttime="20190402 05:57:08.441"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:57:09.462" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:57:09.462" starttime="20190402 05:57:09.462"></status>
</kw>
<status status="FAIL" endtime="20190402 05:57:09.463" starttime="20190402 05:57:08.439"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:57:14.467" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:14.467" starttime="20190402 05:57:14.466"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:14.469" starttime="20190402 05:57:14.468"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:57:14.469" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:57:14.469" starttime="20190402 05:57:14.469"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:14.470" starttime="20190402 05:57:14.470"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:14.470" starttime="20190402 05:57:14.470"></status>
</kw>
<msg timestamp="20190402 05:57:14.470" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:57:14.470" starttime="20190402 05:57:14.469"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:57:14.471" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:14.471" starttime="20190402 05:57:14.470"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:57:14.481" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:14.481" starttime="20190402 05:57:14.471"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:57:15.526" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:57:15.526" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:15.526" starttime="20190402 05:57:14.481"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:57:15.527" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:15.527" starttime="20190402 05:57:15.527"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:57:15.527" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:15.527" starttime="20190402 05:57:15.527"></status>
</kw>
<msg timestamp="20190402 05:57:15.528" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:15.528" starttime="20190402 05:57:15.526"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:57:15.530" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:57:15.530" starttime="20190402 05:57:15.528"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:57:15.530" level="INFO">0</msg>
<msg timestamp="20190402 05:57:15.530" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:15.530" starttime="20190402 05:57:15.530"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:57:15.530" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:57:15.530" starttime="20190402 05:57:15.530"></status>
</kw>
<msg timestamp="20190402 05:57:15.531" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:15.531" starttime="20190402 05:57:15.528"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:15.531" starttime="20190402 05:57:15.531"></status>
</kw>
<status status="PASS" endtime="20190402 05:57:15.531" starttime="20190402 05:57:15.531"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:15.532" starttime="20190402 05:57:15.531"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:57:15.532" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:57:15.532" starttime="20190402 05:57:15.532"></status>
</kw>
<msg timestamp="20190402 05:57:15.532" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:57:15.532" starttime="20190402 05:57:14.468"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:57:15.532" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:15.532" starttime="20190402 05:57:15.532"></status>
</kw>
<msg timestamp="20190402 05:57:15.533" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:15.533" starttime="20190402 05:57:14.465"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:57:15.533" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:57:15.533" starttime="20190402 05:57:15.533"></status>
</kw>
<status status="FAIL" endtime="20190402 05:57:15.533" starttime="20190402 05:57:14.463"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:57:20.538" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:20.538" starttime="20190402 05:57:20.537"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:20.540" starttime="20190402 05:57:20.539"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:57:20.540" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:57:20.540" starttime="20190402 05:57:20.540"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:20.541" starttime="20190402 05:57:20.540"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:20.541" starttime="20190402 05:57:20.541"></status>
</kw>
<msg timestamp="20190402 05:57:20.541" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:57:20.541" starttime="20190402 05:57:20.540"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:57:20.541" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:20.541" starttime="20190402 05:57:20.541"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:57:20.553" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:20.553" starttime="20190402 05:57:20.542"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:57:21.555" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:57:21.555" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:21.555" starttime="20190402 05:57:20.553"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:57:21.556" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:21.556" starttime="20190402 05:57:21.555"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:57:21.556" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:21.556" starttime="20190402 05:57:21.556"></status>
</kw>
<msg timestamp="20190402 05:57:21.556" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:21.556" starttime="20190402 05:57:21.555"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:57:21.558" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:57:21.558" starttime="20190402 05:57:21.556"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:57:21.559" level="INFO">0</msg>
<msg timestamp="20190402 05:57:21.559" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:21.559" starttime="20190402 05:57:21.558"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:57:21.559" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:57:21.559" starttime="20190402 05:57:21.559"></status>
</kw>
<msg timestamp="20190402 05:57:21.559" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:21.559" starttime="20190402 05:57:21.556"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:21.560" starttime="20190402 05:57:21.560"></status>
</kw>
<status status="PASS" endtime="20190402 05:57:21.560" starttime="20190402 05:57:21.559"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:21.560" starttime="20190402 05:57:21.560"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:57:21.561" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:57:21.561" starttime="20190402 05:57:21.560"></status>
</kw>
<msg timestamp="20190402 05:57:21.561" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:57:21.561" starttime="20190402 05:57:20.538"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:57:21.561" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:21.561" starttime="20190402 05:57:21.561"></status>
</kw>
<msg timestamp="20190402 05:57:21.561" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:21.561" starttime="20190402 05:57:20.535"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:57:21.562" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:57:21.562" starttime="20190402 05:57:21.561"></status>
</kw>
<status status="FAIL" endtime="20190402 05:57:21.562" starttime="20190402 05:57:20.534"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:57:26.566" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:26.566" starttime="20190402 05:57:26.565"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:26.569" starttime="20190402 05:57:26.568"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:57:26.572" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:57:26.572" starttime="20190402 05:57:26.570"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:26.574" starttime="20190402 05:57:26.573"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:26.575" starttime="20190402 05:57:26.574"></status>
</kw>
<msg timestamp="20190402 05:57:26.576" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:57:26.576" starttime="20190402 05:57:26.570"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:57:26.577" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:26.577" starttime="20190402 05:57:26.576"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:57:26.605" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:26.605" starttime="20190402 05:57:26.577"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:57:27.580" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:57:27.580" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:27.580" starttime="20190402 05:57:26.605"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:57:27.581" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:27.581" starttime="20190402 05:57:27.581"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:57:27.581" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:27.581" starttime="20190402 05:57:27.581"></status>
</kw>
<msg timestamp="20190402 05:57:27.582" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:27.582" starttime="20190402 05:57:27.580"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:57:27.583" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:57:27.583" starttime="20190402 05:57:27.582"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:57:27.584" level="INFO">0</msg>
<msg timestamp="20190402 05:57:27.584" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:27.584" starttime="20190402 05:57:27.583"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:57:27.584" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:57:27.584" starttime="20190402 05:57:27.584"></status>
</kw>
<msg timestamp="20190402 05:57:27.584" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:27.584" starttime="20190402 05:57:27.582"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:27.585" starttime="20190402 05:57:27.585"></status>
</kw>
<status status="PASS" endtime="20190402 05:57:27.585" starttime="20190402 05:57:27.584"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:27.586" starttime="20190402 05:57:27.585"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:57:27.586" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:57:27.586" starttime="20190402 05:57:27.586"></status>
</kw>
<msg timestamp="20190402 05:57:27.586" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:57:27.586" starttime="20190402 05:57:26.567"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:57:27.586" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:27.586" starttime="20190402 05:57:27.586"></status>
</kw>
<msg timestamp="20190402 05:57:27.587" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:27.587" starttime="20190402 05:57:26.564"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:57:27.587" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:57:27.587" starttime="20190402 05:57:27.587"></status>
</kw>
<status status="FAIL" endtime="20190402 05:57:27.587" starttime="20190402 05:57:26.563"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:57:32.592" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:32.592" starttime="20190402 05:57:32.591"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:32.595" starttime="20190402 05:57:32.594"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:57:32.598" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:57:32.598" starttime="20190402 05:57:32.596"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:32.599" starttime="20190402 05:57:32.598"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:32.600" starttime="20190402 05:57:32.599"></status>
</kw>
<msg timestamp="20190402 05:57:32.601" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:57:32.601" starttime="20190402 05:57:32.595"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:57:32.602" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:32.602" starttime="20190402 05:57:32.601"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:57:32.630" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:32.631" starttime="20190402 05:57:32.602"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:57:33.606" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:57:33.606" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:33.606" starttime="20190402 05:57:32.631"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:57:33.607" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:33.607" starttime="20190402 05:57:33.606"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:57:33.607" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:33.607" starttime="20190402 05:57:33.607"></status>
</kw>
<msg timestamp="20190402 05:57:33.607" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:33.607" starttime="20190402 05:57:33.606"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:57:33.609" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:57:33.609" starttime="20190402 05:57:33.607"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:57:33.609" level="INFO">0</msg>
<msg timestamp="20190402 05:57:33.610" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:33.610" starttime="20190402 05:57:33.609"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:57:33.610" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:57:33.610" starttime="20190402 05:57:33.610"></status>
</kw>
<msg timestamp="20190402 05:57:33.610" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:33.610" starttime="20190402 05:57:33.607"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:33.611" starttime="20190402 05:57:33.611"></status>
</kw>
<status status="PASS" endtime="20190402 05:57:33.611" starttime="20190402 05:57:33.610"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:33.611" starttime="20190402 05:57:33.611"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:57:33.611" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:57:33.612" starttime="20190402 05:57:33.611"></status>
</kw>
<msg timestamp="20190402 05:57:33.612" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:57:33.612" starttime="20190402 05:57:32.592"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:57:33.612" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:33.612" starttime="20190402 05:57:33.612"></status>
</kw>
<msg timestamp="20190402 05:57:33.612" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:33.613" starttime="20190402 05:57:32.589"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:57:33.613" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:57:33.613" starttime="20190402 05:57:33.613"></status>
</kw>
<status status="FAIL" endtime="20190402 05:57:33.613" starttime="20190402 05:57:32.588"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:57:38.617" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:38.618" starttime="20190402 05:57:38.616"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:38.619" starttime="20190402 05:57:38.619"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:57:38.620" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:57:38.620" starttime="20190402 05:57:38.620"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:38.620" starttime="20190402 05:57:38.620"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:38.621" starttime="20190402 05:57:38.621"></status>
</kw>
<msg timestamp="20190402 05:57:38.621" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:57:38.621" starttime="20190402 05:57:38.620"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:57:38.621" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:38.621" starttime="20190402 05:57:38.621"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:57:38.631" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:38.631" starttime="20190402 05:57:38.621"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:57:39.645" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:57:39.645" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:39.645" starttime="20190402 05:57:38.631"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:57:39.646" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:39.646" starttime="20190402 05:57:39.646"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:57:39.647" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:39.647" starttime="20190402 05:57:39.646"></status>
</kw>
<msg timestamp="20190402 05:57:39.647" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:39.647" starttime="20190402 05:57:39.646"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:57:39.649" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:57:39.649" starttime="20190402 05:57:39.647"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:57:39.649" level="INFO">0</msg>
<msg timestamp="20190402 05:57:39.649" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:39.649" starttime="20190402 05:57:39.649"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:57:39.650" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:57:39.650" starttime="20190402 05:57:39.649"></status>
</kw>
<msg timestamp="20190402 05:57:39.650" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:39.650" starttime="20190402 05:57:39.647"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:39.651" starttime="20190402 05:57:39.650"></status>
</kw>
<status status="PASS" endtime="20190402 05:57:39.651" starttime="20190402 05:57:39.650"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:39.651" starttime="20190402 05:57:39.651"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:57:39.651" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:57:39.651" starttime="20190402 05:57:39.651"></status>
</kw>
<msg timestamp="20190402 05:57:39.651" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:57:39.651" starttime="20190402 05:57:38.618"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:57:39.652" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:39.652" starttime="20190402 05:57:39.652"></status>
</kw>
<msg timestamp="20190402 05:57:39.652" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:39.652" starttime="20190402 05:57:38.615"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:57:39.652" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:57:39.652" starttime="20190402 05:57:39.652"></status>
</kw>
<status status="FAIL" endtime="20190402 05:57:39.653" starttime="20190402 05:57:38.614"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:57:44.658" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:44.658" starttime="20190402 05:57:44.657"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:44.659" starttime="20190402 05:57:44.659"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:57:44.660" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:57:44.660" starttime="20190402 05:57:44.659"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:44.660" starttime="20190402 05:57:44.660"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:44.660" starttime="20190402 05:57:44.660"></status>
</kw>
<msg timestamp="20190402 05:57:44.660" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:57:44.660" starttime="20190402 05:57:44.659"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:57:44.661" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:44.661" starttime="20190402 05:57:44.661"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:57:44.672" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:44.672" starttime="20190402 05:57:44.661"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:57:45.677" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:57:45.677" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:45.678" starttime="20190402 05:57:44.672"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:57:45.678" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:45.678" starttime="20190402 05:57:45.678"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:57:45.679" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:45.679" starttime="20190402 05:57:45.678"></status>
</kw>
<msg timestamp="20190402 05:57:45.679" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:45.679" starttime="20190402 05:57:45.678"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:57:45.681" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:57:45.681" starttime="20190402 05:57:45.679"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:57:45.681" level="INFO">0</msg>
<msg timestamp="20190402 05:57:45.681" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:45.681" starttime="20190402 05:57:45.681"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:57:45.682" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:57:45.682" starttime="20190402 05:57:45.682"></status>
</kw>
<msg timestamp="20190402 05:57:45.682" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:45.682" starttime="20190402 05:57:45.679"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:45.683" starttime="20190402 05:57:45.682"></status>
</kw>
<status status="PASS" endtime="20190402 05:57:45.683" starttime="20190402 05:57:45.682"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:45.683" starttime="20190402 05:57:45.683"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:57:45.683" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:57:45.683" starttime="20190402 05:57:45.683"></status>
</kw>
<msg timestamp="20190402 05:57:45.683" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:57:45.684" starttime="20190402 05:57:44.658"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:57:45.684" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:45.684" starttime="20190402 05:57:45.684"></status>
</kw>
<msg timestamp="20190402 05:57:45.684" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:45.684" starttime="20190402 05:57:44.655"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:57:45.684" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:57:45.685" starttime="20190402 05:57:45.684"></status>
</kw>
<status status="FAIL" endtime="20190402 05:57:45.685" starttime="20190402 05:57:44.653"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:57:50.690" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:50.690" starttime="20190402 05:57:50.688"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:50.691" starttime="20190402 05:57:50.691"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:57:50.692" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:57:50.692" starttime="20190402 05:57:50.691"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:50.692" starttime="20190402 05:57:50.692"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:50.692" starttime="20190402 05:57:50.692"></status>
</kw>
<msg timestamp="20190402 05:57:50.692" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:57:50.693" starttime="20190402 05:57:50.691"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:57:50.693" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:50.693" starttime="20190402 05:57:50.693"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:57:50.703" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:50.703" starttime="20190402 05:57:50.693"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:57:51.818" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:57:51.818" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:51.818" starttime="20190402 05:57:50.703"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:57:51.819" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:51.819" starttime="20190402 05:57:51.819"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:57:51.819" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:51.819" starttime="20190402 05:57:51.819"></status>
</kw>
<msg timestamp="20190402 05:57:51.819" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:51.819" starttime="20190402 05:57:51.818"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:57:51.821" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:57:51.821" starttime="20190402 05:57:51.820"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:57:51.821" level="INFO">0</msg>
<msg timestamp="20190402 05:57:51.821" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:51.821" starttime="20190402 05:57:51.821"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:57:51.822" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:57:51.822" starttime="20190402 05:57:51.821"></status>
</kw>
<msg timestamp="20190402 05:57:51.822" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:51.822" starttime="20190402 05:57:51.819"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:51.823" starttime="20190402 05:57:51.822"></status>
</kw>
<status status="PASS" endtime="20190402 05:57:51.823" starttime="20190402 05:57:51.822"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:51.823" starttime="20190402 05:57:51.823"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:57:51.823" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:57:51.823" starttime="20190402 05:57:51.823"></status>
</kw>
<msg timestamp="20190402 05:57:51.823" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:57:51.823" starttime="20190402 05:57:50.690"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:57:51.824" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:51.824" starttime="20190402 05:57:51.824"></status>
</kw>
<msg timestamp="20190402 05:57:51.824" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:51.824" starttime="20190402 05:57:50.687"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:57:51.824" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:57:51.824" starttime="20190402 05:57:51.824"></status>
</kw>
<status status="FAIL" endtime="20190402 05:57:51.825" starttime="20190402 05:57:50.685"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:57:56.829" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:56.829" starttime="20190402 05:57:56.828"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:56.831" starttime="20190402 05:57:56.830"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:57:56.832" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:57:56.832" starttime="20190402 05:57:56.831"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:56.832" starttime="20190402 05:57:56.832"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:56.832" starttime="20190402 05:57:56.832"></status>
</kw>
<msg timestamp="20190402 05:57:56.832" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:57:56.832" starttime="20190402 05:57:56.831"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:57:56.833" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:56.833" starttime="20190402 05:57:56.833"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:57:56.842" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:57:56.842" starttime="20190402 05:57:56.833"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:57:57.837" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:57:57.837" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:57.837" starttime="20190402 05:57:56.842"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:57:57.838" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:57:57.838" starttime="20190402 05:57:57.838"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:57:57.838" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:57.838" starttime="20190402 05:57:57.838"></status>
</kw>
<msg timestamp="20190402 05:57:57.839" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:57:57.839" starttime="20190402 05:57:57.837"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:57:57.840" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:57:57.840" starttime="20190402 05:57:57.839"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:57:57.841" level="INFO">0</msg>
<msg timestamp="20190402 05:57:57.841" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:57.841" starttime="20190402 05:57:57.840"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:57:57.841" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:57:57.841" starttime="20190402 05:57:57.841"></status>
</kw>
<msg timestamp="20190402 05:57:57.841" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:57:57.841" starttime="20190402 05:57:57.839"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:57.842" starttime="20190402 05:57:57.842"></status>
</kw>
<status status="PASS" endtime="20190402 05:57:57.842" starttime="20190402 05:57:57.841"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:57:57.842" starttime="20190402 05:57:57.842"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:57:57.843" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:57:57.843" starttime="20190402 05:57:57.842"></status>
</kw>
<msg timestamp="20190402 05:57:57.843" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:57:57.843" starttime="20190402 05:57:56.830"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:57:57.843" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:57.843" starttime="20190402 05:57:57.843"></status>
</kw>
<msg timestamp="20190402 05:57:57.843" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:57:57.843" starttime="20190402 05:57:56.827"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:57:57.844" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:57:57.844" starttime="20190402 05:57:57.844"></status>
</kw>
<status status="FAIL" endtime="20190402 05:57:57.844" starttime="20190402 05:57:56.825"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:58:02.848" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:02.849" starttime="20190402 05:58:02.847"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:02.850" starttime="20190402 05:58:02.850"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:58:02.851" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:58:02.851" starttime="20190402 05:58:02.850"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:02.851" starttime="20190402 05:58:02.851"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:02.851" starttime="20190402 05:58:02.851"></status>
</kw>
<msg timestamp="20190402 05:58:02.852" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:58:02.852" starttime="20190402 05:58:02.850"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:58:02.852" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:02.852" starttime="20190402 05:58:02.852"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:58:02.863" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:02.863" starttime="20190402 05:58:02.852"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:58:03.891" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:58:03.891" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:03.891" starttime="20190402 05:58:02.863"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:58:03.892" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:03.892" starttime="20190402 05:58:03.892"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:58:03.892" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:58:03.892" starttime="20190402 05:58:03.892"></status>
</kw>
<msg timestamp="20190402 05:58:03.893" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:58:03.893" starttime="20190402 05:58:03.891"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:58:03.894" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:58:03.894" starttime="20190402 05:58:03.893"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:58:03.895" level="INFO">0</msg>
<msg timestamp="20190402 05:58:03.895" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:03.895" starttime="20190402 05:58:03.895"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:58:03.895" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:58:03.895" starttime="20190402 05:58:03.895"></status>
</kw>
<msg timestamp="20190402 05:58:03.895" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:03.895" starttime="20190402 05:58:03.893"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:03.896" starttime="20190402 05:58:03.896"></status>
</kw>
<status status="PASS" endtime="20190402 05:58:03.896" starttime="20190402 05:58:03.895"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:03.896" starttime="20190402 05:58:03.896"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:58:03.897" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:58:03.897" starttime="20190402 05:58:03.896"></status>
</kw>
<msg timestamp="20190402 05:58:03.897" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:58:03.897" starttime="20190402 05:58:02.849"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:58:03.897" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:58:03.897" starttime="20190402 05:58:03.897"></status>
</kw>
<msg timestamp="20190402 05:58:03.897" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:58:03.897" starttime="20190402 05:58:02.846"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:58:03.898" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:58:03.898" starttime="20190402 05:58:03.898"></status>
</kw>
<status status="FAIL" endtime="20190402 05:58:03.898" starttime="20190402 05:58:02.845"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:58:08.902" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:08.902" starttime="20190402 05:58:08.901"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:08.905" starttime="20190402 05:58:08.904"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:58:08.908" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:58:08.908" starttime="20190402 05:58:08.906"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:08.909" starttime="20190402 05:58:08.908"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:08.911" starttime="20190402 05:58:08.909"></status>
</kw>
<msg timestamp="20190402 05:58:08.911" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:58:08.911" starttime="20190402 05:58:08.905"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:58:08.912" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:08.912" starttime="20190402 05:58:08.912"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:58:08.940" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:08.940" starttime="20190402 05:58:08.913"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:58:09.922" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:58:09.922" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:09.922" starttime="20190402 05:58:08.941"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:58:09.923" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:09.923" starttime="20190402 05:58:09.923"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:58:09.923" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:58:09.923" starttime="20190402 05:58:09.923"></status>
</kw>
<msg timestamp="20190402 05:58:09.923" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:58:09.923" starttime="20190402 05:58:09.922"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:58:09.925" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:58:09.925" starttime="20190402 05:58:09.924"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:58:09.926" level="INFO">0</msg>
<msg timestamp="20190402 05:58:09.926" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:09.926" starttime="20190402 05:58:09.926"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:58:09.926" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:58:09.926" starttime="20190402 05:58:09.926"></status>
</kw>
<msg timestamp="20190402 05:58:09.926" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:09.926" starttime="20190402 05:58:09.924"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:09.927" starttime="20190402 05:58:09.927"></status>
</kw>
<status status="PASS" endtime="20190402 05:58:09.927" starttime="20190402 05:58:09.926"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:09.927" starttime="20190402 05:58:09.927"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:58:09.928" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:58:09.928" starttime="20190402 05:58:09.928"></status>
</kw>
<msg timestamp="20190402 05:58:09.928" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:58:09.928" starttime="20190402 05:58:08.903"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:58:09.928" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:58:09.928" starttime="20190402 05:58:09.928"></status>
</kw>
<msg timestamp="20190402 05:58:09.929" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:58:09.929" starttime="20190402 05:58:08.900"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:58:09.929" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:58:09.929" starttime="20190402 05:58:09.929"></status>
</kw>
<status status="FAIL" endtime="20190402 05:58:09.929" starttime="20190402 05:58:08.899"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:58:14.933" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:14.933" starttime="20190402 05:58:14.932"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:14.935" starttime="20190402 05:58:14.935"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:58:14.936" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:58:14.936" starttime="20190402 05:58:14.936"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:14.936" starttime="20190402 05:58:14.936"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:14.937" starttime="20190402 05:58:14.936"></status>
</kw>
<msg timestamp="20190402 05:58:14.937" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:58:14.937" starttime="20190402 05:58:14.935"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:58:14.937" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:14.937" starttime="20190402 05:58:14.937"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:58:14.948" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:14.948" starttime="20190402 05:58:14.937"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:58:15.950" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:58:15.950" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:15.950" starttime="20190402 05:58:14.948"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:58:15.951" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:15.951" starttime="20190402 05:58:15.951"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:58:15.951" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:58:15.952" starttime="20190402 05:58:15.951"></status>
</kw>
<msg timestamp="20190402 05:58:15.952" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:58:15.952" starttime="20190402 05:58:15.951"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:58:15.953" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:58:15.954" starttime="20190402 05:58:15.952"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:58:15.954" level="INFO">0</msg>
<msg timestamp="20190402 05:58:15.954" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:15.954" starttime="20190402 05:58:15.954"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:58:15.954" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:58:15.954" starttime="20190402 05:58:15.954"></status>
</kw>
<msg timestamp="20190402 05:58:15.955" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:15.955" starttime="20190402 05:58:15.952"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:15.955" starttime="20190402 05:58:15.955"></status>
</kw>
<status status="PASS" endtime="20190402 05:58:15.955" starttime="20190402 05:58:15.955"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:15.956" starttime="20190402 05:58:15.956"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:58:15.956" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:58:15.956" starttime="20190402 05:58:15.956"></status>
</kw>
<msg timestamp="20190402 05:58:15.956" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:58:15.956" starttime="20190402 05:58:14.933"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:58:15.957" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:58:15.957" starttime="20190402 05:58:15.956"></status>
</kw>
<msg timestamp="20190402 05:58:15.957" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:58:15.957" starttime="20190402 05:58:14.931"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:58:15.957" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:58:15.957" starttime="20190402 05:58:15.957"></status>
</kw>
<status status="FAIL" endtime="20190402 05:58:15.957" starttime="20190402 05:58:14.930"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:58:20.962" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:20.962" starttime="20190402 05:58:20.961"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:20.964" starttime="20190402 05:58:20.963"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:58:20.964" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:58:20.964" starttime="20190402 05:58:20.964"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:20.965" starttime="20190402 05:58:20.964"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:20.965" starttime="20190402 05:58:20.965"></status>
</kw>
<msg timestamp="20190402 05:58:20.965" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:58:20.965" starttime="20190402 05:58:20.964"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:58:20.965" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:20.966" starttime="20190402 05:58:20.965"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:58:20.976" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:20.976" starttime="20190402 05:58:20.966"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:58:22.027" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:58:22.027" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:22.027" starttime="20190402 05:58:20.976"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:58:22.028" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:22.028" starttime="20190402 05:58:22.028"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:58:22.029" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190402 05:58:22.029" starttime="20190402 05:58:22.028"></status>
</kw>
<msg timestamp="20190402 05:58:22.029" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190402 05:58:22.029" starttime="20190402 05:58:22.028"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:58:22.031" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:58:22.031" starttime="20190402 05:58:22.029"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:58:22.031" level="INFO">0</msg>
<msg timestamp="20190402 05:58:22.031" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:22.032" starttime="20190402 05:58:22.031"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:58:22.032" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:58:22.032" starttime="20190402 05:58:22.032"></status>
</kw>
<msg timestamp="20190402 05:58:22.032" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:22.032" starttime="20190402 05:58:22.029"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:22.033" starttime="20190402 05:58:22.032"></status>
</kw>
<status status="PASS" endtime="20190402 05:58:22.033" starttime="20190402 05:58:22.032"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:22.033" starttime="20190402 05:58:22.033"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:58:22.033" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190402 05:58:22.033" starttime="20190402 05:58:22.033"></status>
</kw>
<msg timestamp="20190402 05:58:22.034" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:58:22.034" starttime="20190402 05:58:20.962"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:58:22.034" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190402 05:58:22.034" starttime="20190402 05:58:22.034"></status>
</kw>
<msg timestamp="20190402 05:58:22.034" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190402 05:58:22.034" starttime="20190402 05:58:20.960"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:58:22.035" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190402 05:58:22.035" starttime="20190402 05:58:22.034"></status>
</kw>
<status status="FAIL" endtime="20190402 05:58:22.035" starttime="20190402 05:58:20.958"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:58:27.039" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:27.039" starttime="20190402 05:58:27.038"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:27.041" starttime="20190402 05:58:27.040"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:58:27.041" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:58:27.041" starttime="20190402 05:58:27.041"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:27.042" starttime="20190402 05:58:27.042"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:27.042" starttime="20190402 05:58:27.042"></status>
</kw>
<msg timestamp="20190402 05:58:27.042" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:58:27.042" starttime="20190402 05:58:27.041"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:58:27.043" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:27.043" starttime="20190402 05:58:27.043"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:58:27.053" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:27.054" starttime="20190402 05:58:27.043"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:58:28.079" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:58:28.080" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:28.080" starttime="20190402 05:58:27.054"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:58:28.080" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:28.080" starttime="20190402 05:58:28.080"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:58:28.081" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:28.081" starttime="20190402 05:58:28.081"></status>
</kw>
<msg timestamp="20190402 05:58:28.081" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:28.081" starttime="20190402 05:58:28.080"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:58:28.083" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:58:28.084" starttime="20190402 05:58:28.081"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:58:28.084" level="INFO">0</msg>
<msg timestamp="20190402 05:58:28.084" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:28.084" starttime="20190402 05:58:28.084"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:58:28.084" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:58:28.084" starttime="20190402 05:58:28.084"></status>
</kw>
<msg timestamp="20190402 05:58:28.085" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:28.085" starttime="20190402 05:58:28.081"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:28.085" starttime="20190402 05:58:28.085"></status>
</kw>
<status status="PASS" endtime="20190402 05:58:28.085" starttime="20190402 05:58:28.085"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:28.086" starttime="20190402 05:58:28.086"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:58:28.086" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:58:28.086" starttime="20190402 05:58:28.086"></status>
</kw>
<msg timestamp="20190402 05:58:28.086" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:58:28.086" starttime="20190402 05:58:27.040"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:58:28.087" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:28.087" starttime="20190402 05:58:28.086"></status>
</kw>
<msg timestamp="20190402 05:58:28.087" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:28.087" starttime="20190402 05:58:27.037"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:58:28.087" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:58:28.087" starttime="20190402 05:58:28.087"></status>
</kw>
<status status="FAIL" endtime="20190402 05:58:28.087" starttime="20190402 05:58:27.035"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:58:33.091" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:33.091" starttime="20190402 05:58:33.090"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:33.093" starttime="20190402 05:58:33.093"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:58:33.094" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:58:33.094" starttime="20190402 05:58:33.094"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:33.094" starttime="20190402 05:58:33.094"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:33.095" starttime="20190402 05:58:33.095"></status>
</kw>
<msg timestamp="20190402 05:58:33.095" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:58:33.095" starttime="20190402 05:58:33.093"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:58:33.095" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:33.095" starttime="20190402 05:58:33.095"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:58:33.105" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:33.105" starttime="20190402 05:58:33.095"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:58:34.120" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:58:34.120" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:34.120" starttime="20190402 05:58:33.105"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:58:34.121" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:34.121" starttime="20190402 05:58:34.121"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:58:34.122" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:34.122" starttime="20190402 05:58:34.121"></status>
</kw>
<msg timestamp="20190402 05:58:34.122" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:34.122" starttime="20190402 05:58:34.121"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:58:34.124" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:58:34.124" starttime="20190402 05:58:34.122"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:58:34.124" level="INFO">0</msg>
<msg timestamp="20190402 05:58:34.124" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:34.124" starttime="20190402 05:58:34.124"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:58:34.124" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:58:34.125" starttime="20190402 05:58:34.124"></status>
</kw>
<msg timestamp="20190402 05:58:34.125" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:34.125" starttime="20190402 05:58:34.122"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:34.126" starttime="20190402 05:58:34.125"></status>
</kw>
<status status="PASS" endtime="20190402 05:58:34.126" starttime="20190402 05:58:34.125"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:34.126" starttime="20190402 05:58:34.126"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:58:34.126" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:58:34.126" starttime="20190402 05:58:34.126"></status>
</kw>
<msg timestamp="20190402 05:58:34.127" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:58:34.127" starttime="20190402 05:58:33.092"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:58:34.127" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:34.127" starttime="20190402 05:58:34.127"></status>
</kw>
<msg timestamp="20190402 05:58:34.127" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:34.127" starttime="20190402 05:58:33.089"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:58:34.128" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:58:34.128" starttime="20190402 05:58:34.127"></status>
</kw>
<status status="FAIL" endtime="20190402 05:58:34.128" starttime="20190402 05:58:33.088"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:58:39.132" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:39.132" starttime="20190402 05:58:39.131"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:39.134" starttime="20190402 05:58:39.133"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:58:39.134" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:58:39.134" starttime="20190402 05:58:39.134"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:39.135" starttime="20190402 05:58:39.135"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:39.135" starttime="20190402 05:58:39.135"></status>
</kw>
<msg timestamp="20190402 05:58:39.135" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:58:39.135" starttime="20190402 05:58:39.134"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:58:39.136" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:39.136" starttime="20190402 05:58:39.135"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:58:39.145" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:39.145" starttime="20190402 05:58:39.136"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:58:40.156" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:58:40.156" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:40.156" starttime="20190402 05:58:39.145"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:58:40.157" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:40.157" starttime="20190402 05:58:40.157"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:58:40.157" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:40.157" starttime="20190402 05:58:40.157"></status>
</kw>
<msg timestamp="20190402 05:58:40.157" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:40.157" starttime="20190402 05:58:40.156"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:58:40.159" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:58:40.159" starttime="20190402 05:58:40.158"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:58:40.160" level="INFO">0</msg>
<msg timestamp="20190402 05:58:40.160" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:40.160" starttime="20190402 05:58:40.160"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:58:40.160" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:58:40.160" starttime="20190402 05:58:40.160"></status>
</kw>
<msg timestamp="20190402 05:58:40.160" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:40.160" starttime="20190402 05:58:40.158"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:40.161" starttime="20190402 05:58:40.161"></status>
</kw>
<status status="PASS" endtime="20190402 05:58:40.161" starttime="20190402 05:58:40.160"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:40.161" starttime="20190402 05:58:40.161"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:58:40.162" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:58:40.162" starttime="20190402 05:58:40.161"></status>
</kw>
<msg timestamp="20190402 05:58:40.162" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:58:40.162" starttime="20190402 05:58:39.133"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:58:40.162" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:40.162" starttime="20190402 05:58:40.162"></status>
</kw>
<msg timestamp="20190402 05:58:40.163" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:40.163" starttime="20190402 05:58:39.130"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:58:40.163" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:58:40.163" starttime="20190402 05:58:40.163"></status>
</kw>
<status status="FAIL" endtime="20190402 05:58:40.163" starttime="20190402 05:58:39.129"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:58:45.168" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:45.168" starttime="20190402 05:58:45.167"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:45.170" starttime="20190402 05:58:45.169"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:58:45.170" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:58:45.170" starttime="20190402 05:58:45.170"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:45.171" starttime="20190402 05:58:45.170"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:45.171" starttime="20190402 05:58:45.171"></status>
</kw>
<msg timestamp="20190402 05:58:45.171" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:58:45.171" starttime="20190402 05:58:45.170"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:58:45.171" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:45.172" starttime="20190402 05:58:45.171"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:58:45.183" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:45.183" starttime="20190402 05:58:45.172"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:58:46.197" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:58:46.197" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:46.197" starttime="20190402 05:58:45.183"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:58:46.197" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:46.198" starttime="20190402 05:58:46.197"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:58:46.198" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:46.198" starttime="20190402 05:58:46.198"></status>
</kw>
<msg timestamp="20190402 05:58:46.198" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:46.198" starttime="20190402 05:58:46.197"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:58:46.200" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:58:46.201" starttime="20190402 05:58:46.198"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:58:46.201" level="INFO">0</msg>
<msg timestamp="20190402 05:58:46.201" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:46.201" starttime="20190402 05:58:46.201"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:58:46.201" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:58:46.201" starttime="20190402 05:58:46.201"></status>
</kw>
<msg timestamp="20190402 05:58:46.202" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:46.202" starttime="20190402 05:58:46.198"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:46.202" starttime="20190402 05:58:46.202"></status>
</kw>
<status status="PASS" endtime="20190402 05:58:46.202" starttime="20190402 05:58:46.202"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:46.203" starttime="20190402 05:58:46.203"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:58:46.203" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:58:46.203" starttime="20190402 05:58:46.203"></status>
</kw>
<msg timestamp="20190402 05:58:46.203" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:58:46.203" starttime="20190402 05:58:45.168"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:58:46.204" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:46.204" starttime="20190402 05:58:46.203"></status>
</kw>
<msg timestamp="20190402 05:58:46.204" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:46.204" starttime="20190402 05:58:45.165"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:58:46.204" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:58:46.204" starttime="20190402 05:58:46.204"></status>
</kw>
<status status="FAIL" endtime="20190402 05:58:46.204" starttime="20190402 05:58:45.164"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:58:51.210" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:51.210" starttime="20190402 05:58:51.209"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:51.212" starttime="20190402 05:58:51.211"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:58:51.215" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:58:51.215" starttime="20190402 05:58:51.214"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:51.216" starttime="20190402 05:58:51.215"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:51.217" starttime="20190402 05:58:51.217"></status>
</kw>
<msg timestamp="20190402 05:58:51.218" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:58:51.218" starttime="20190402 05:58:51.213"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:58:51.219" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:51.219" starttime="20190402 05:58:51.219"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:58:51.250" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:51.250" starttime="20190402 05:58:51.220"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:58:52.244" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:58:52.244" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:52.245" starttime="20190402 05:58:51.251"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:58:52.245" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:52.245" starttime="20190402 05:58:52.245"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:58:52.246" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:52.246" starttime="20190402 05:58:52.246"></status>
</kw>
<msg timestamp="20190402 05:58:52.246" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:52.246" starttime="20190402 05:58:52.245"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:58:52.248" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:58:52.248" starttime="20190402 05:58:52.246"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:58:52.248" level="INFO">0</msg>
<msg timestamp="20190402 05:58:52.248" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:52.248" starttime="20190402 05:58:52.248"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:58:52.248" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:58:52.249" starttime="20190402 05:58:52.248"></status>
</kw>
<msg timestamp="20190402 05:58:52.249" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:52.249" starttime="20190402 05:58:52.246"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:52.250" starttime="20190402 05:58:52.249"></status>
</kw>
<status status="PASS" endtime="20190402 05:58:52.250" starttime="20190402 05:58:52.249"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:52.250" starttime="20190402 05:58:52.250"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:58:52.250" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:58:52.250" starttime="20190402 05:58:52.250"></status>
</kw>
<msg timestamp="20190402 05:58:52.250" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:58:52.250" starttime="20190402 05:58:51.210"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:58:52.251" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:52.251" starttime="20190402 05:58:52.250"></status>
</kw>
<msg timestamp="20190402 05:58:52.251" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:52.251" starttime="20190402 05:58:51.207"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:58:52.251" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:58:52.251" starttime="20190402 05:58:52.251"></status>
</kw>
<status status="FAIL" endtime="20190402 05:58:52.252" starttime="20190402 05:58:51.205"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:58:57.257" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:57.257" starttime="20190402 05:58:57.255"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:57.258" starttime="20190402 05:58:57.258"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:58:57.258" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:58:57.259" starttime="20190402 05:58:57.258"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:57.259" starttime="20190402 05:58:57.259"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:57.259" starttime="20190402 05:58:57.259"></status>
</kw>
<msg timestamp="20190402 05:58:57.259" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:58:57.259" starttime="20190402 05:58:57.258"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:58:57.260" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:57.260" starttime="20190402 05:58:57.260"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:58:57.272" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:58:57.272" starttime="20190402 05:58:57.260"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:58:58.258" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:58:58.258" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:58.258" starttime="20190402 05:58:57.272"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:58:58.259" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:58:58.259" starttime="20190402 05:58:58.259"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:58:58.259" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:58.259" starttime="20190402 05:58:58.259"></status>
</kw>
<msg timestamp="20190402 05:58:58.260" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:58:58.260" starttime="20190402 05:58:58.259"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:58:58.261" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:58:58.261" starttime="20190402 05:58:58.260"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:58:58.262" level="INFO">0</msg>
<msg timestamp="20190402 05:58:58.262" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:58.262" starttime="20190402 05:58:58.261"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:58:58.262" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:58:58.262" starttime="20190402 05:58:58.262"></status>
</kw>
<msg timestamp="20190402 05:58:58.262" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:58:58.262" starttime="20190402 05:58:58.260"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:58.263" starttime="20190402 05:58:58.263"></status>
</kw>
<status status="PASS" endtime="20190402 05:58:58.263" starttime="20190402 05:58:58.262"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:58:58.263" starttime="20190402 05:58:58.263"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:58:58.264" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:58:58.264" starttime="20190402 05:58:58.263"></status>
</kw>
<msg timestamp="20190402 05:58:58.264" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:58:58.264" starttime="20190402 05:58:57.257"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:58:58.264" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:58.264" starttime="20190402 05:58:58.264"></status>
</kw>
<msg timestamp="20190402 05:58:58.264" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:58:58.264" starttime="20190402 05:58:57.254"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:58:58.265" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:58:58.265" starttime="20190402 05:58:58.265"></status>
</kw>
<status status="FAIL" endtime="20190402 05:58:58.265" starttime="20190402 05:58:57.252"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:59:03.269" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:03.270" starttime="20190402 05:59:03.268"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:03.271" starttime="20190402 05:59:03.271"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:59:03.272" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:59:03.272" starttime="20190402 05:59:03.271"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:03.272" starttime="20190402 05:59:03.272"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:03.272" starttime="20190402 05:59:03.272"></status>
</kw>
<msg timestamp="20190402 05:59:03.273" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:59:03.273" starttime="20190402 05:59:03.271"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:59:03.273" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:03.273" starttime="20190402 05:59:03.273"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:59:03.283" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:03.283" starttime="20190402 05:59:03.273"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:59:04.293" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:59:04.293" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:04.293" starttime="20190402 05:59:03.283"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:59:04.294" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:04.294" starttime="20190402 05:59:04.294"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:59:04.295" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:59:04.295" starttime="20190402 05:59:04.294"></status>
</kw>
<msg timestamp="20190402 05:59:04.295" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:59:04.295" starttime="20190402 05:59:04.294"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:59:04.297" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:59:04.297" starttime="20190402 05:59:04.295"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:59:04.297" level="INFO">0</msg>
<msg timestamp="20190402 05:59:04.297" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:04.297" starttime="20190402 05:59:04.297"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:59:04.297" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:59:04.298" starttime="20190402 05:59:04.297"></status>
</kw>
<msg timestamp="20190402 05:59:04.298" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:04.298" starttime="20190402 05:59:04.295"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:04.298" starttime="20190402 05:59:04.298"></status>
</kw>
<status status="PASS" endtime="20190402 05:59:04.299" starttime="20190402 05:59:04.298"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:04.299" starttime="20190402 05:59:04.299"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:59:04.299" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:59:04.299" starttime="20190402 05:59:04.299"></status>
</kw>
<msg timestamp="20190402 05:59:04.299" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:59:04.299" starttime="20190402 05:59:03.270"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:59:04.300" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:59:04.300" starttime="20190402 05:59:04.299"></status>
</kw>
<msg timestamp="20190402 05:59:04.300" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:59:04.300" starttime="20190402 05:59:03.267"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:59:04.300" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:59:04.300" starttime="20190402 05:59:04.300"></status>
</kw>
<status status="FAIL" endtime="20190402 05:59:04.300" starttime="20190402 05:59:03.266"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:59:09.305" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:09.305" starttime="20190402 05:59:09.304"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:09.307" starttime="20190402 05:59:09.307"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:59:09.308" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:59:09.308" starttime="20190402 05:59:09.307"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:09.308" starttime="20190402 05:59:09.308"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:09.308" starttime="20190402 05:59:09.308"></status>
</kw>
<msg timestamp="20190402 05:59:09.309" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:59:09.309" starttime="20190402 05:59:09.307"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:59:09.309" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:09.309" starttime="20190402 05:59:09.309"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:59:09.319" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:09.319" starttime="20190402 05:59:09.309"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:59:10.365" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:59:10.365" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:10.365" starttime="20190402 05:59:09.320"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:59:10.366" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:10.366" starttime="20190402 05:59:10.366"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:59:10.366" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:59:10.366" starttime="20190402 05:59:10.366"></status>
</kw>
<msg timestamp="20190402 05:59:10.366" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:59:10.366" starttime="20190402 05:59:10.365"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:59:10.368" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:59:10.368" starttime="20190402 05:59:10.367"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:59:10.369" level="INFO">0</msg>
<msg timestamp="20190402 05:59:10.369" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:10.369" starttime="20190402 05:59:10.368"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:59:10.369" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:59:10.369" starttime="20190402 05:59:10.369"></status>
</kw>
<msg timestamp="20190402 05:59:10.369" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:10.369" starttime="20190402 05:59:10.367"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:10.370" starttime="20190402 05:59:10.370"></status>
</kw>
<status status="PASS" endtime="20190402 05:59:10.370" starttime="20190402 05:59:10.369"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:10.370" starttime="20190402 05:59:10.370"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:59:10.371" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:59:10.371" starttime="20190402 05:59:10.371"></status>
</kw>
<msg timestamp="20190402 05:59:10.371" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:59:10.371" starttime="20190402 05:59:09.306"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:59:10.371" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:59:10.371" starttime="20190402 05:59:10.371"></status>
</kw>
<msg timestamp="20190402 05:59:10.371" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:59:10.371" starttime="20190402 05:59:09.303"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:59:10.372" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:59:10.372" starttime="20190402 05:59:10.372"></status>
</kw>
<status status="FAIL" endtime="20190402 05:59:10.372" starttime="20190402 05:59:09.301"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:59:15.377" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:15.377" starttime="20190402 05:59:15.376"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:15.380" starttime="20190402 05:59:15.379"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:59:15.383" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:59:15.383" starttime="20190402 05:59:15.381"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:15.384" starttime="20190402 05:59:15.384"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:15.386" starttime="20190402 05:59:15.385"></status>
</kw>
<msg timestamp="20190402 05:59:15.387" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:59:15.387" starttime="20190402 05:59:15.380"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:59:15.388" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:15.389" starttime="20190402 05:59:15.388"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:59:15.416" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:15.416" starttime="20190402 05:59:15.389"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:59:16.401" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:59:16.402" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:16.402" starttime="20190402 05:59:15.417"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:59:16.402" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:16.402" starttime="20190402 05:59:16.402"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:59:16.403" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:59:16.403" starttime="20190402 05:59:16.403"></status>
</kw>
<msg timestamp="20190402 05:59:16.403" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:59:16.403" starttime="20190402 05:59:16.402"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:59:16.405" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:59:16.405" starttime="20190402 05:59:16.403"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:59:16.405" level="INFO">0</msg>
<msg timestamp="20190402 05:59:16.406" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:16.406" starttime="20190402 05:59:16.405"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:59:16.406" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:59:16.406" starttime="20190402 05:59:16.406"></status>
</kw>
<msg timestamp="20190402 05:59:16.406" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:16.406" starttime="20190402 05:59:16.403"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:16.407" starttime="20190402 05:59:16.407"></status>
</kw>
<status status="PASS" endtime="20190402 05:59:16.407" starttime="20190402 05:59:16.406"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:16.407" starttime="20190402 05:59:16.407"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:59:16.407" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:59:16.407" starttime="20190402 05:59:16.407"></status>
</kw>
<msg timestamp="20190402 05:59:16.408" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:59:16.408" starttime="20190402 05:59:15.377"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:59:16.408" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:59:16.408" starttime="20190402 05:59:16.408"></status>
</kw>
<msg timestamp="20190402 05:59:16.408" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:59:16.408" starttime="20190402 05:59:15.374"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:59:16.409" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:59:16.409" starttime="20190402 05:59:16.408"></status>
</kw>
<status status="FAIL" endtime="20190402 05:59:16.409" starttime="20190402 05:59:15.373"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:59:21.413" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:21.414" starttime="20190402 05:59:21.412"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:21.415" starttime="20190402 05:59:21.415"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:59:21.416" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:59:21.416" starttime="20190402 05:59:21.415"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:21.416" starttime="20190402 05:59:21.416"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:21.416" starttime="20190402 05:59:21.416"></status>
</kw>
<msg timestamp="20190402 05:59:21.417" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:59:21.417" starttime="20190402 05:59:21.415"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:59:21.417" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:21.417" starttime="20190402 05:59:21.417"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:59:21.428" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:21.428" starttime="20190402 05:59:21.417"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:59:22.449" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:59:22.449" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:22.449" starttime="20190402 05:59:21.429"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:59:22.450" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:22.450" starttime="20190402 05:59:22.450"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:59:22.450" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:59:22.450" starttime="20190402 05:59:22.450"></status>
</kw>
<msg timestamp="20190402 05:59:22.450" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:59:22.450" starttime="20190402 05:59:22.449"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:59:22.452" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:59:22.452" starttime="20190402 05:59:22.451"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:59:22.453" level="INFO">0</msg>
<msg timestamp="20190402 05:59:22.453" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:22.453" starttime="20190402 05:59:22.452"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:59:22.453" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:59:22.453" starttime="20190402 05:59:22.453"></status>
</kw>
<msg timestamp="20190402 05:59:22.453" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:22.453" starttime="20190402 05:59:22.450"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:22.454" starttime="20190402 05:59:22.454"></status>
</kw>
<status status="PASS" endtime="20190402 05:59:22.454" starttime="20190402 05:59:22.453"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:22.454" starttime="20190402 05:59:22.454"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:59:22.455" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:59:22.455" starttime="20190402 05:59:22.455"></status>
</kw>
<msg timestamp="20190402 05:59:22.455" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:59:22.455" starttime="20190402 05:59:21.414"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:59:22.455" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:59:22.455" starttime="20190402 05:59:22.455"></status>
</kw>
<msg timestamp="20190402 05:59:22.455" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:59:22.455" starttime="20190402 05:59:21.411"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:59:22.456" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:59:22.456" starttime="20190402 05:59:22.456"></status>
</kw>
<status status="FAIL" endtime="20190402 05:59:22.456" starttime="20190402 05:59:21.410"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:59:27.460" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:27.461" starttime="20190402 05:59:27.459"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:27.462" starttime="20190402 05:59:27.462"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:59:27.463" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:59:27.463" starttime="20190402 05:59:27.463"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:27.463" starttime="20190402 05:59:27.463"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:27.464" starttime="20190402 05:59:27.464"></status>
</kw>
<msg timestamp="20190402 05:59:27.464" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:59:27.464" starttime="20190402 05:59:27.463"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:59:27.464" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:27.464" starttime="20190402 05:59:27.464"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:59:27.476" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:27.476" starttime="20190402 05:59:27.464"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:59:28.562" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:59:28.562" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:28.562" starttime="20190402 05:59:27.476"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:59:28.563" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:28.563" starttime="20190402 05:59:28.562"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:59:28.563" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:59:28.563" starttime="20190402 05:59:28.563"></status>
</kw>
<msg timestamp="20190402 05:59:28.563" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190402 05:59:28.564" starttime="20190402 05:59:28.562"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:59:28.565" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:59:28.565" starttime="20190402 05:59:28.564"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:59:28.566" level="INFO">0</msg>
<msg timestamp="20190402 05:59:28.566" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:28.566" starttime="20190402 05:59:28.566"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:59:28.566" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:59:28.566" starttime="20190402 05:59:28.566"></status>
</kw>
<msg timestamp="20190402 05:59:28.566" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:28.566" starttime="20190402 05:59:28.564"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:28.567" starttime="20190402 05:59:28.567"></status>
</kw>
<status status="PASS" endtime="20190402 05:59:28.567" starttime="20190402 05:59:28.566"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:28.567" starttime="20190402 05:59:28.567"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:59:28.568" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190402 05:59:28.568" starttime="20190402 05:59:28.568"></status>
</kw>
<msg timestamp="20190402 05:59:28.568" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:59:28.568" starttime="20190402 05:59:27.461"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:59:28.568" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:59:28.568" starttime="20190402 05:59:28.568"></status>
</kw>
<msg timestamp="20190402 05:59:28.568" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190402 05:59:28.568" starttime="20190402 05:59:27.458"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:59:28.569" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190402 05:59:28.569" starttime="20190402 05:59:28.569"></status>
</kw>
<status status="FAIL" endtime="20190402 05:59:28.569" starttime="20190402 05:59:27.457"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:59:33.574" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:33.574" starttime="20190402 05:59:33.573"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:33.575" starttime="20190402 05:59:33.575"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:59:33.576" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:59:33.576" starttime="20190402 05:59:33.575"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:33.576" starttime="20190402 05:59:33.576"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:33.576" starttime="20190402 05:59:33.576"></status>
</kw>
<msg timestamp="20190402 05:59:33.576" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:59:33.577" starttime="20190402 05:59:33.575"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:59:33.577" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:33.577" starttime="20190402 05:59:33.577"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:59:33.587" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:33.588" starttime="20190402 05:59:33.577"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:59:34.585" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:59:34.585" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:34.585" starttime="20190402 05:59:33.588"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:59:34.586" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:34.586" starttime="20190402 05:59:34.586"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:59:34.586" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 05:59:34.586" starttime="20190402 05:59:34.586"></status>
</kw>
<msg timestamp="20190402 05:59:34.586" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 05:59:34.586" starttime="20190402 05:59:34.585"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:59:34.588" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:59:34.588" starttime="20190402 05:59:34.587"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:59:34.589" level="INFO">0</msg>
<msg timestamp="20190402 05:59:34.589" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:34.589" starttime="20190402 05:59:34.589"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:59:34.589" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:59:34.589" starttime="20190402 05:59:34.589"></status>
</kw>
<msg timestamp="20190402 05:59:34.589" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:34.589" starttime="20190402 05:59:34.587"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:34.590" starttime="20190402 05:59:34.590"></status>
</kw>
<status status="PASS" endtime="20190402 05:59:34.590" starttime="20190402 05:59:34.590"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:34.591" starttime="20190402 05:59:34.590"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:59:34.591" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 05:59:34.591" starttime="20190402 05:59:34.591"></status>
</kw>
<msg timestamp="20190402 05:59:34.591" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:59:34.591" starttime="20190402 05:59:33.574"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:59:34.591" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 05:59:34.591" starttime="20190402 05:59:34.591"></status>
</kw>
<msg timestamp="20190402 05:59:34.592" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 05:59:34.592" starttime="20190402 05:59:33.571"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:59:34.592" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 05:59:34.592" starttime="20190402 05:59:34.592"></status>
</kw>
<status status="FAIL" endtime="20190402 05:59:34.592" starttime="20190402 05:59:33.570"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:59:39.597" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:39.597" starttime="20190402 05:59:39.596"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:39.599" starttime="20190402 05:59:39.598"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:59:39.599" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:59:39.599" starttime="20190402 05:59:39.599"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:39.600" starttime="20190402 05:59:39.599"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:39.600" starttime="20190402 05:59:39.600"></status>
</kw>
<msg timestamp="20190402 05:59:39.600" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:59:39.600" starttime="20190402 05:59:39.599"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:59:39.600" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:39.601" starttime="20190402 05:59:39.600"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:59:39.611" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:39.611" starttime="20190402 05:59:39.601"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:59:40.677" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:59:40.678" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:40.678" starttime="20190402 05:59:39.611"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:59:40.678" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:40.678" starttime="20190402 05:59:40.678"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:59:40.679" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 05:59:40.679" starttime="20190402 05:59:40.679"></status>
</kw>
<msg timestamp="20190402 05:59:40.679" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 05:59:40.679" starttime="20190402 05:59:40.678"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:59:40.680" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:59:40.681" starttime="20190402 05:59:40.679"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:59:40.681" level="INFO">0</msg>
<msg timestamp="20190402 05:59:40.681" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:40.681" starttime="20190402 05:59:40.681"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:59:40.681" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:59:40.681" starttime="20190402 05:59:40.681"></status>
</kw>
<msg timestamp="20190402 05:59:40.682" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:40.682" starttime="20190402 05:59:40.679"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:40.683" starttime="20190402 05:59:40.682"></status>
</kw>
<status status="PASS" endtime="20190402 05:59:40.683" starttime="20190402 05:59:40.682"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:40.683" starttime="20190402 05:59:40.683"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:59:40.683" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 05:59:40.683" starttime="20190402 05:59:40.683"></status>
</kw>
<msg timestamp="20190402 05:59:40.683" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:59:40.683" starttime="20190402 05:59:39.597"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:59:40.684" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 05:59:40.684" starttime="20190402 05:59:40.684"></status>
</kw>
<msg timestamp="20190402 05:59:40.684" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 05:59:40.684" starttime="20190402 05:59:39.595"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:59:40.684" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 05:59:40.684" starttime="20190402 05:59:40.684"></status>
</kw>
<status status="FAIL" endtime="20190402 05:59:40.685" starttime="20190402 05:59:39.593"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:59:45.689" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:45.690" starttime="20190402 05:59:45.688"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:45.691" starttime="20190402 05:59:45.691"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:59:45.691" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:59:45.692" starttime="20190402 05:59:45.691"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:45.692" starttime="20190402 05:59:45.692"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:45.692" starttime="20190402 05:59:45.692"></status>
</kw>
<msg timestamp="20190402 05:59:45.692" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:59:45.692" starttime="20190402 05:59:45.691"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:59:45.693" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:45.693" starttime="20190402 05:59:45.693"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:59:45.703" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:45.703" starttime="20190402 05:59:45.693"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:59:46.699" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:59:46.699" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:46.699" starttime="20190402 05:59:45.703"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:59:46.700" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:46.700" starttime="20190402 05:59:46.700"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:59:46.700" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 05:59:46.701" starttime="20190402 05:59:46.700"></status>
</kw>
<msg timestamp="20190402 05:59:46.701" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 05:59:46.701" starttime="20190402 05:59:46.700"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:59:46.702" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:59:46.702" starttime="20190402 05:59:46.701"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:59:46.703" level="INFO">0</msg>
<msg timestamp="20190402 05:59:46.703" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:46.703" starttime="20190402 05:59:46.702"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:59:46.703" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:59:46.703" starttime="20190402 05:59:46.703"></status>
</kw>
<msg timestamp="20190402 05:59:46.703" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:46.703" starttime="20190402 05:59:46.701"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:46.704" starttime="20190402 05:59:46.704"></status>
</kw>
<status status="PASS" endtime="20190402 05:59:46.704" starttime="20190402 05:59:46.703"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:46.704" starttime="20190402 05:59:46.704"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:59:46.705" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 05:59:46.705" starttime="20190402 05:59:46.704"></status>
</kw>
<msg timestamp="20190402 05:59:46.705" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:59:46.705" starttime="20190402 05:59:45.690"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:59:46.706" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 05:59:46.706" starttime="20190402 05:59:46.705"></status>
</kw>
<msg timestamp="20190402 05:59:46.706" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 05:59:46.706" starttime="20190402 05:59:45.687"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:59:46.706" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 05:59:46.706" starttime="20190402 05:59:46.706"></status>
</kw>
<status status="FAIL" endtime="20190402 05:59:46.707" starttime="20190402 05:59:45.685"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:59:51.711" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:51.711" starttime="20190402 05:59:51.710"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:51.714" starttime="20190402 05:59:51.713"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:59:51.717" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:59:51.717" starttime="20190402 05:59:51.715"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:51.719" starttime="20190402 05:59:51.718"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:51.720" starttime="20190402 05:59:51.719"></status>
</kw>
<msg timestamp="20190402 05:59:51.721" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:59:51.721" starttime="20190402 05:59:51.715"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:59:51.722" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:51.722" starttime="20190402 05:59:51.721"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:59:51.750" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:51.750" starttime="20190402 05:59:51.722"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:59:52.756" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:59:52.756" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:52.756" starttime="20190402 05:59:51.751"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:59:52.757" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:52.757" starttime="20190402 05:59:52.757"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:59:52.757" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 05:59:52.757" starttime="20190402 05:59:52.757"></status>
</kw>
<msg timestamp="20190402 05:59:52.758" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 05:59:52.758" starttime="20190402 05:59:52.756"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:59:52.760" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:59:52.760" starttime="20190402 05:59:52.758"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:59:52.760" level="INFO">0</msg>
<msg timestamp="20190402 05:59:52.760" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:52.760" starttime="20190402 05:59:52.760"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:59:52.760" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:59:52.761" starttime="20190402 05:59:52.760"></status>
</kw>
<msg timestamp="20190402 05:59:52.761" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:52.761" starttime="20190402 05:59:52.758"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:52.761" starttime="20190402 05:59:52.761"></status>
</kw>
<status status="PASS" endtime="20190402 05:59:52.762" starttime="20190402 05:59:52.761"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:52.762" starttime="20190402 05:59:52.762"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:59:52.762" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 05:59:52.762" starttime="20190402 05:59:52.762"></status>
</kw>
<msg timestamp="20190402 05:59:52.762" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:59:52.762" starttime="20190402 05:59:51.712"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:59:52.763" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 05:59:52.763" starttime="20190402 05:59:52.762"></status>
</kw>
<msg timestamp="20190402 05:59:52.763" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 05:59:52.763" starttime="20190402 05:59:51.709"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:59:52.763" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 05:59:52.763" starttime="20190402 05:59:52.763"></status>
</kw>
<status status="FAIL" endtime="20190402 05:59:52.763" starttime="20190402 05:59:51.707"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 05:59:57.769" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:57.769" starttime="20190402 05:59:57.768"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:57.770" starttime="20190402 05:59:57.770"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 05:59:57.771" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 05:59:57.771" starttime="20190402 05:59:57.770"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:57.771" starttime="20190402 05:59:57.771"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:57.771" starttime="20190402 05:59:57.771"></status>
</kw>
<msg timestamp="20190402 05:59:57.771" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 05:59:57.771" starttime="20190402 05:59:57.770"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 05:59:57.772" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:57.772" starttime="20190402 05:59:57.772"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 05:59:57.782" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 05:59:57.782" starttime="20190402 05:59:57.772"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 05:59:58.793" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 05:59:58.793" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:58.793" starttime="20190402 05:59:57.782"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 05:59:58.794" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 05:59:58.794" starttime="20190402 05:59:58.794"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 05:59:58.794" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 05:59:58.794" starttime="20190402 05:59:58.794"></status>
</kw>
<msg timestamp="20190402 05:59:58.794" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 05:59:58.794" starttime="20190402 05:59:58.793"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 05:59:58.796" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 05:59:58.796" starttime="20190402 05:59:58.795"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 05:59:58.797" level="INFO">0</msg>
<msg timestamp="20190402 05:59:58.797" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:58.797" starttime="20190402 05:59:58.796"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 05:59:58.797" level="INFO">0</msg>
<status status="PASS" endtime="20190402 05:59:58.797" starttime="20190402 05:59:58.797"></status>
</kw>
<msg timestamp="20190402 05:59:58.797" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 05:59:58.797" starttime="20190402 05:59:58.795"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:58.798" starttime="20190402 05:59:58.798"></status>
</kw>
<status status="PASS" endtime="20190402 05:59:58.798" starttime="20190402 05:59:58.797"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 05:59:58.798" starttime="20190402 05:59:58.798"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 05:59:58.799" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 05:59:58.799" starttime="20190402 05:59:58.799"></status>
</kw>
<msg timestamp="20190402 05:59:58.799" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 05:59:58.799" starttime="20190402 05:59:57.769"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 05:59:58.799" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 05:59:58.799" starttime="20190402 05:59:58.799"></status>
</kw>
<msg timestamp="20190402 05:59:58.799" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 05:59:58.799" starttime="20190402 05:59:57.766"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 05:59:58.800" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 05:59:58.800" starttime="20190402 05:59:58.800"></status>
</kw>
<status status="FAIL" endtime="20190402 05:59:58.800" starttime="20190402 05:59:57.764"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:00:03.805" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:03.805" starttime="20190402 06:00:03.804"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:03.806" starttime="20190402 06:00:03.806"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:00:03.807" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:00:03.807" starttime="20190402 06:00:03.806"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:03.807" starttime="20190402 06:00:03.807"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:03.807" starttime="20190402 06:00:03.807"></status>
</kw>
<msg timestamp="20190402 06:00:03.808" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:00:03.808" starttime="20190402 06:00:03.806"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:00:03.808" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:03.808" starttime="20190402 06:00:03.808"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:00:03.818" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:03.818" starttime="20190402 06:00:03.808"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:00:04.842" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:00:04.842" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:04.842" starttime="20190402 06:00:03.818"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:00:04.843" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:04.843" starttime="20190402 06:00:04.843"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:00:04.844" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:04.844" starttime="20190402 06:00:04.843"></status>
</kw>
<msg timestamp="20190402 06:00:04.844" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:04.844" starttime="20190402 06:00:04.843"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:00:04.846" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:00:04.846" starttime="20190402 06:00:04.844"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:00:04.846" level="INFO">0</msg>
<msg timestamp="20190402 06:00:04.846" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:04.846" starttime="20190402 06:00:04.846"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:00:04.846" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:00:04.846" starttime="20190402 06:00:04.846"></status>
</kw>
<msg timestamp="20190402 06:00:04.847" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:04.847" starttime="20190402 06:00:04.844"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:04.847" starttime="20190402 06:00:04.847"></status>
</kw>
<status status="PASS" endtime="20190402 06:00:04.847" starttime="20190402 06:00:04.847"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:04.848" starttime="20190402 06:00:04.848"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:00:04.848" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:00:04.848" starttime="20190402 06:00:04.848"></status>
</kw>
<msg timestamp="20190402 06:00:04.848" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:00:04.848" starttime="20190402 06:00:03.805"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:00:04.849" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:04.849" starttime="20190402 06:00:04.848"></status>
</kw>
<msg timestamp="20190402 06:00:04.849" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:04.849" starttime="20190402 06:00:03.802"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:00:04.849" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:00:04.849" starttime="20190402 06:00:04.849"></status>
</kw>
<status status="FAIL" endtime="20190402 06:00:04.849" starttime="20190402 06:00:03.801"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:00:09.853" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:09.854" starttime="20190402 06:00:09.852"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:09.857" starttime="20190402 06:00:09.855"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:00:09.859" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:00:09.859" starttime="20190402 06:00:09.858"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:09.861" starttime="20190402 06:00:09.860"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:09.862" starttime="20190402 06:00:09.861"></status>
</kw>
<msg timestamp="20190402 06:00:09.862" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:00:09.862" starttime="20190402 06:00:09.857"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:00:09.863" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:09.863" starttime="20190402 06:00:09.863"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:00:09.892" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:09.892" starttime="20190402 06:00:09.864"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:00:10.913" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:00:10.913" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:10.913" starttime="20190402 06:00:09.892"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:00:10.914" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:10.914" starttime="20190402 06:00:10.914"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:00:10.914" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:10.914" starttime="20190402 06:00:10.914"></status>
</kw>
<msg timestamp="20190402 06:00:10.915" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:10.915" starttime="20190402 06:00:10.914"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:00:10.916" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:00:10.916" starttime="20190402 06:00:10.915"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:00:10.916" level="INFO">0</msg>
<msg timestamp="20190402 06:00:10.917" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:10.917" starttime="20190402 06:00:10.916"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:00:10.917" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:00:10.917" starttime="20190402 06:00:10.917"></status>
</kw>
<msg timestamp="20190402 06:00:10.917" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:10.917" starttime="20190402 06:00:10.915"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:10.918" starttime="20190402 06:00:10.917"></status>
</kw>
<status status="PASS" endtime="20190402 06:00:10.918" starttime="20190402 06:00:10.917"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:10.918" starttime="20190402 06:00:10.918"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:00:10.918" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:00:10.918" starttime="20190402 06:00:10.918"></status>
</kw>
<msg timestamp="20190402 06:00:10.919" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:00:10.919" starttime="20190402 06:00:09.854"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:00:10.919" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:10.919" starttime="20190402 06:00:10.919"></status>
</kw>
<msg timestamp="20190402 06:00:10.919" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:10.919" starttime="20190402 06:00:09.851"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:00:10.920" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:00:10.920" starttime="20190402 06:00:10.919"></status>
</kw>
<status status="FAIL" endtime="20190402 06:00:10.920" starttime="20190402 06:00:09.850"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:00:15.924" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:15.925" starttime="20190402 06:00:15.923"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:15.926" starttime="20190402 06:00:15.926"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:00:15.927" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:00:15.927" starttime="20190402 06:00:15.926"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:15.927" starttime="20190402 06:00:15.927"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:15.927" starttime="20190402 06:00:15.927"></status>
</kw>
<msg timestamp="20190402 06:00:15.928" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:00:15.928" starttime="20190402 06:00:15.926"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:00:15.928" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:15.928" starttime="20190402 06:00:15.928"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:00:15.937" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:15.938" starttime="20190402 06:00:15.928"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:00:16.936" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:00:16.936" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:16.936" starttime="20190402 06:00:15.938"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:00:16.937" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:16.937" starttime="20190402 06:00:16.937"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:00:16.937" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:16.937" starttime="20190402 06:00:16.937"></status>
</kw>
<msg timestamp="20190402 06:00:16.937" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:16.937" starttime="20190402 06:00:16.936"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:00:16.939" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:00:16.939" starttime="20190402 06:00:16.938"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:00:16.940" level="INFO">0</msg>
<msg timestamp="20190402 06:00:16.940" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:16.940" starttime="20190402 06:00:16.940"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:00:16.940" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:00:16.940" starttime="20190402 06:00:16.940"></status>
</kw>
<msg timestamp="20190402 06:00:16.940" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:16.940" starttime="20190402 06:00:16.938"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:16.941" starttime="20190402 06:00:16.941"></status>
</kw>
<status status="PASS" endtime="20190402 06:00:16.941" starttime="20190402 06:00:16.940"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:16.941" starttime="20190402 06:00:16.941"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:00:16.942" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:00:16.942" starttime="20190402 06:00:16.941"></status>
</kw>
<msg timestamp="20190402 06:00:16.942" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:00:16.942" starttime="20190402 06:00:15.925"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:00:16.942" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:16.942" starttime="20190402 06:00:16.942"></status>
</kw>
<msg timestamp="20190402 06:00:16.942" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:16.942" starttime="20190402 06:00:15.922"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:00:16.943" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:00:16.943" starttime="20190402 06:00:16.943"></status>
</kw>
<status status="FAIL" endtime="20190402 06:00:16.943" starttime="20190402 06:00:15.921"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:00:21.948" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:21.948" starttime="20190402 06:00:21.947"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:21.949" starttime="20190402 06:00:21.949"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:00:21.950" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:00:21.950" starttime="20190402 06:00:21.949"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:21.950" starttime="20190402 06:00:21.950"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:21.950" starttime="20190402 06:00:21.950"></status>
</kw>
<msg timestamp="20190402 06:00:21.951" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:00:21.951" starttime="20190402 06:00:21.949"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:00:21.951" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:21.951" starttime="20190402 06:00:21.951"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:00:21.963" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:21.963" starttime="20190402 06:00:21.951"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:00:22.995" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:00:22.995" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:22.995" starttime="20190402 06:00:21.963"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:00:22.996" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:22.996" starttime="20190402 06:00:22.996"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:00:22.997" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:22.997" starttime="20190402 06:00:22.996"></status>
</kw>
<msg timestamp="20190402 06:00:22.997" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:22.997" starttime="20190402 06:00:22.996"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:00:22.999" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:00:22.999" starttime="20190402 06:00:22.997"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:00:22.999" level="INFO">0</msg>
<msg timestamp="20190402 06:00:22.999" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:22.999" starttime="20190402 06:00:22.999"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:00:22.999" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:00:22.999" starttime="20190402 06:00:22.999"></status>
</kw>
<msg timestamp="20190402 06:00:23.000" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:23.000" starttime="20190402 06:00:22.997"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:23.000" starttime="20190402 06:00:23.000"></status>
</kw>
<status status="PASS" endtime="20190402 06:00:23.000" starttime="20190402 06:00:23.000"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:23.001" starttime="20190402 06:00:23.001"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:00:23.001" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:00:23.001" starttime="20190402 06:00:23.001"></status>
</kw>
<msg timestamp="20190402 06:00:23.001" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:00:23.001" starttime="20190402 06:00:21.948"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:00:23.002" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:23.002" starttime="20190402 06:00:23.001"></status>
</kw>
<msg timestamp="20190402 06:00:23.002" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:23.002" starttime="20190402 06:00:21.945"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:00:23.002" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:00:23.002" starttime="20190402 06:00:23.002"></status>
</kw>
<status status="FAIL" endtime="20190402 06:00:23.002" starttime="20190402 06:00:21.944"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:00:28.007" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:28.007" starttime="20190402 06:00:28.006"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:28.009" starttime="20190402 06:00:28.008"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:00:28.009" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:00:28.009" starttime="20190402 06:00:28.009"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:28.010" starttime="20190402 06:00:28.009"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:28.010" starttime="20190402 06:00:28.010"></status>
</kw>
<msg timestamp="20190402 06:00:28.010" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:00:28.010" starttime="20190402 06:00:28.009"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:00:28.011" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:28.011" starttime="20190402 06:00:28.010"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:00:28.021" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:28.021" starttime="20190402 06:00:28.011"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:00:29.013" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:00:29.013" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:29.013" starttime="20190402 06:00:28.021"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:00:29.014" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:29.014" starttime="20190402 06:00:29.013"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:00:29.014" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:29.014" starttime="20190402 06:00:29.014"></status>
</kw>
<msg timestamp="20190402 06:00:29.014" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:29.014" starttime="20190402 06:00:29.013"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:00:29.016" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:00:29.016" starttime="20190402 06:00:29.014"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:00:29.016" level="INFO">0</msg>
<msg timestamp="20190402 06:00:29.016" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:29.016" starttime="20190402 06:00:29.016"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:00:29.017" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:00:29.017" starttime="20190402 06:00:29.017"></status>
</kw>
<msg timestamp="20190402 06:00:29.017" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:29.017" starttime="20190402 06:00:29.014"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:29.018" starttime="20190402 06:00:29.018"></status>
</kw>
<status status="PASS" endtime="20190402 06:00:29.018" starttime="20190402 06:00:29.017"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:29.018" starttime="20190402 06:00:29.018"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:00:29.018" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:00:29.018" starttime="20190402 06:00:29.018"></status>
</kw>
<msg timestamp="20190402 06:00:29.019" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:00:29.019" starttime="20190402 06:00:28.007"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:00:29.019" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:29.019" starttime="20190402 06:00:29.019"></status>
</kw>
<msg timestamp="20190402 06:00:29.019" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:29.019" starttime="20190402 06:00:28.005"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:00:29.020" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:00:29.020" starttime="20190402 06:00:29.019"></status>
</kw>
<status status="FAIL" endtime="20190402 06:00:29.020" starttime="20190402 06:00:28.003"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:00:34.024" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:34.024" starttime="20190402 06:00:34.023"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:34.026" starttime="20190402 06:00:34.025"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:00:34.026" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:00:34.026" starttime="20190402 06:00:34.026"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:34.027" starttime="20190402 06:00:34.027"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:34.027" starttime="20190402 06:00:34.027"></status>
</kw>
<msg timestamp="20190402 06:00:34.027" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:00:34.027" starttime="20190402 06:00:34.026"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:00:34.028" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:34.028" starttime="20190402 06:00:34.027"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:00:34.039" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:34.039" starttime="20190402 06:00:34.028"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:00:35.057" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:00:35.057" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:35.057" starttime="20190402 06:00:34.039"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:00:35.058" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:35.059" starttime="20190402 06:00:35.058"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:00:35.059" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:35.059" starttime="20190402 06:00:35.059"></status>
</kw>
<msg timestamp="20190402 06:00:35.059" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:35.059" starttime="20190402 06:00:35.058"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:00:35.061" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:00:35.061" starttime="20190402 06:00:35.059"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:00:35.061" level="INFO">0</msg>
<msg timestamp="20190402 06:00:35.061" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:35.061" starttime="20190402 06:00:35.061"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:00:35.062" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:00:35.062" starttime="20190402 06:00:35.062"></status>
</kw>
<msg timestamp="20190402 06:00:35.062" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:35.062" starttime="20190402 06:00:35.059"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:35.063" starttime="20190402 06:00:35.062"></status>
</kw>
<status status="PASS" endtime="20190402 06:00:35.063" starttime="20190402 06:00:35.062"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:35.063" starttime="20190402 06:00:35.063"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:00:35.063" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:00:35.063" starttime="20190402 06:00:35.063"></status>
</kw>
<msg timestamp="20190402 06:00:35.063" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:00:35.063" starttime="20190402 06:00:34.025"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:00:35.064" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:35.064" starttime="20190402 06:00:35.064"></status>
</kw>
<msg timestamp="20190402 06:00:35.064" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:35.064" starttime="20190402 06:00:34.022"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:00:35.064" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:00:35.064" starttime="20190402 06:00:35.064"></status>
</kw>
<status status="FAIL" endtime="20190402 06:00:35.065" starttime="20190402 06:00:34.021"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:00:40.069" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:40.069" starttime="20190402 06:00:40.068"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:40.071" starttime="20190402 06:00:40.070"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:00:40.071" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:00:40.071" starttime="20190402 06:00:40.071"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:40.072" starttime="20190402 06:00:40.072"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:40.072" starttime="20190402 06:00:40.072"></status>
</kw>
<msg timestamp="20190402 06:00:40.072" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:00:40.072" starttime="20190402 06:00:40.071"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:00:40.073" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:40.073" starttime="20190402 06:00:40.072"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:00:40.083" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:40.083" starttime="20190402 06:00:40.073"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:00:41.115" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:00:41.115" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:41.115" starttime="20190402 06:00:40.083"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:00:41.116" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:41.116" starttime="20190402 06:00:41.116"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:00:41.116" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:41.116" starttime="20190402 06:00:41.116"></status>
</kw>
<msg timestamp="20190402 06:00:41.116" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:41.116" starttime="20190402 06:00:41.115"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:00:41.118" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:00:41.118" starttime="20190402 06:00:41.117"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:00:41.119" level="INFO">0</msg>
<msg timestamp="20190402 06:00:41.119" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:41.119" starttime="20190402 06:00:41.118"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:00:41.119" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:00:41.120" starttime="20190402 06:00:41.119"></status>
</kw>
<msg timestamp="20190402 06:00:41.120" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:41.120" starttime="20190402 06:00:41.116"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:41.120" starttime="20190402 06:00:41.120"></status>
</kw>
<status status="PASS" endtime="20190402 06:00:41.120" starttime="20190402 06:00:41.120"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:41.121" starttime="20190402 06:00:41.121"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:00:41.121" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:00:41.121" starttime="20190402 06:00:41.121"></status>
</kw>
<msg timestamp="20190402 06:00:41.121" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:00:41.121" starttime="20190402 06:00:40.070"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:00:41.122" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:41.122" starttime="20190402 06:00:41.121"></status>
</kw>
<msg timestamp="20190402 06:00:41.122" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:41.122" starttime="20190402 06:00:40.067"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:00:41.122" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:00:41.122" starttime="20190402 06:00:41.122"></status>
</kw>
<status status="FAIL" endtime="20190402 06:00:41.122" starttime="20190402 06:00:40.065"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:00:46.127" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:46.127" starttime="20190402 06:00:46.126"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:46.130" starttime="20190402 06:00:46.129"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:00:46.133" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:00:46.133" starttime="20190402 06:00:46.131"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:46.135" starttime="20190402 06:00:46.134"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:46.136" starttime="20190402 06:00:46.135"></status>
</kw>
<msg timestamp="20190402 06:00:46.137" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:00:46.137" starttime="20190402 06:00:46.130"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:00:46.138" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:46.138" starttime="20190402 06:00:46.137"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:00:46.166" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:46.166" starttime="20190402 06:00:46.138"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:00:47.166" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:00:47.166" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:47.166" starttime="20190402 06:00:46.167"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:00:47.167" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:47.167" starttime="20190402 06:00:47.167"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:00:47.168" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:47.168" starttime="20190402 06:00:47.167"></status>
</kw>
<msg timestamp="20190402 06:00:47.168" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:47.168" starttime="20190402 06:00:47.167"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:00:47.169" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:00:47.170" starttime="20190402 06:00:47.168"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:00:47.170" level="INFO">0</msg>
<msg timestamp="20190402 06:00:47.170" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:47.170" starttime="20190402 06:00:47.170"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:00:47.170" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:00:47.170" starttime="20190402 06:00:47.170"></status>
</kw>
<msg timestamp="20190402 06:00:47.171" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:47.171" starttime="20190402 06:00:47.168"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:47.172" starttime="20190402 06:00:47.171"></status>
</kw>
<status status="PASS" endtime="20190402 06:00:47.172" starttime="20190402 06:00:47.171"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:47.172" starttime="20190402 06:00:47.172"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:00:47.172" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:00:47.172" starttime="20190402 06:00:47.172"></status>
</kw>
<msg timestamp="20190402 06:00:47.172" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:00:47.172" starttime="20190402 06:00:46.128"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:00:47.173" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:47.173" starttime="20190402 06:00:47.173"></status>
</kw>
<msg timestamp="20190402 06:00:47.173" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:47.173" starttime="20190402 06:00:46.125"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:00:47.173" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:00:47.173" starttime="20190402 06:00:47.173"></status>
</kw>
<status status="FAIL" endtime="20190402 06:00:47.174" starttime="20190402 06:00:46.123"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:00:52.178" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:52.178" starttime="20190402 06:00:52.177"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:52.180" starttime="20190402 06:00:52.179"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:00:52.180" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:00:52.180" starttime="20190402 06:00:52.180"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:52.181" starttime="20190402 06:00:52.180"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:52.181" starttime="20190402 06:00:52.181"></status>
</kw>
<msg timestamp="20190402 06:00:52.181" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:00:52.181" starttime="20190402 06:00:52.180"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:00:52.182" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:52.182" starttime="20190402 06:00:52.181"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:00:52.192" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:52.192" starttime="20190402 06:00:52.182"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:00:53.262" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:00:53.262" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:53.262" starttime="20190402 06:00:52.192"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:00:53.263" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:53.263" starttime="20190402 06:00:53.263"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:00:53.264" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:53.264" starttime="20190402 06:00:53.263"></status>
</kw>
<msg timestamp="20190402 06:00:53.264" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:53.264" starttime="20190402 06:00:53.263"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:00:53.266" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:00:53.266" starttime="20190402 06:00:53.264"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:00:53.266" level="INFO">0</msg>
<msg timestamp="20190402 06:00:53.266" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:53.266" starttime="20190402 06:00:53.266"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:00:53.266" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:00:53.267" starttime="20190402 06:00:53.266"></status>
</kw>
<msg timestamp="20190402 06:00:53.267" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:53.267" starttime="20190402 06:00:53.264"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:53.267" starttime="20190402 06:00:53.267"></status>
</kw>
<status status="PASS" endtime="20190402 06:00:53.267" starttime="20190402 06:00:53.267"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:53.268" starttime="20190402 06:00:53.268"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:00:53.268" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:00:53.268" starttime="20190402 06:00:53.268"></status>
</kw>
<msg timestamp="20190402 06:00:53.268" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:00:53.268" starttime="20190402 06:00:52.179"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:00:53.269" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:53.269" starttime="20190402 06:00:53.268"></status>
</kw>
<msg timestamp="20190402 06:00:53.269" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:53.269" starttime="20190402 06:00:52.176"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:00:53.269" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:00:53.270" starttime="20190402 06:00:53.269"></status>
</kw>
<status status="FAIL" endtime="20190402 06:00:53.270" starttime="20190402 06:00:52.174"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:00:58.274" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:58.274" starttime="20190402 06:00:58.273"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:58.276" starttime="20190402 06:00:58.275"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:00:58.276" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:00:58.276" starttime="20190402 06:00:58.276"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:58.277" starttime="20190402 06:00:58.277"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:58.277" starttime="20190402 06:00:58.277"></status>
</kw>
<msg timestamp="20190402 06:00:58.277" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:00:58.277" starttime="20190402 06:00:58.276"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:00:58.278" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:58.278" starttime="20190402 06:00:58.277"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:00:58.287" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:00:58.287" starttime="20190402 06:00:58.278"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:00:59.303" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:00:59.303" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:59.304" starttime="20190402 06:00:58.288"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:00:59.304" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:00:59.304" starttime="20190402 06:00:59.304"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:00:59.305" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:59.305" starttime="20190402 06:00:59.304"></status>
</kw>
<msg timestamp="20190402 06:00:59.305" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:00:59.305" starttime="20190402 06:00:59.304"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:00:59.307" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:00:59.307" starttime="20190402 06:00:59.305"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:00:59.307" level="INFO">0</msg>
<msg timestamp="20190402 06:00:59.307" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:59.308" starttime="20190402 06:00:59.307"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:00:59.308" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:00:59.308" starttime="20190402 06:00:59.308"></status>
</kw>
<msg timestamp="20190402 06:00:59.308" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:00:59.308" starttime="20190402 06:00:59.305"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:59.309" starttime="20190402 06:00:59.309"></status>
</kw>
<status status="PASS" endtime="20190402 06:00:59.309" starttime="20190402 06:00:59.308"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:00:59.309" starttime="20190402 06:00:59.309"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:00:59.309" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:00:59.310" starttime="20190402 06:00:59.309"></status>
</kw>
<msg timestamp="20190402 06:00:59.310" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:00:59.310" starttime="20190402 06:00:58.275"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:00:59.310" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:59.310" starttime="20190402 06:00:59.310"></status>
</kw>
<msg timestamp="20190402 06:00:59.310" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:00:59.310" starttime="20190402 06:00:58.272"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:00:59.311" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:00:59.311" starttime="20190402 06:00:59.310"></status>
</kw>
<status status="FAIL" endtime="20190402 06:00:59.311" starttime="20190402 06:00:58.270"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:01:04.316" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:04.316" starttime="20190402 06:01:04.315"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:04.317" starttime="20190402 06:01:04.317"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:04.318" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:04.318" starttime="20190402 06:01:04.317"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:04.318" starttime="20190402 06:01:04.318"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:04.318" starttime="20190402 06:01:04.318"></status>
</kw>
<msg timestamp="20190402 06:01:04.319" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:04.319" starttime="20190402 06:01:04.317"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:04.319" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:04.319" starttime="20190402 06:01:04.319"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:04.330" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:04.330" starttime="20190402 06:01:04.319"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:05.414" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:05.414" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:05.414" starttime="20190402 06:01:04.330"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:05.415" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:05.415" starttime="20190402 06:01:05.415"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:05.415" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:01:05.415" starttime="20190402 06:01:05.415"></status>
</kw>
<msg timestamp="20190402 06:01:05.415" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:01:05.416" starttime="20190402 06:01:05.414"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:05.418" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:05.418" starttime="20190402 06:01:05.416"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:05.418" level="INFO">0</msg>
<msg timestamp="20190402 06:01:05.418" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:05.418" starttime="20190402 06:01:05.418"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:05.418" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:05.418" starttime="20190402 06:01:05.418"></status>
</kw>
<msg timestamp="20190402 06:01:05.419" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:05.419" starttime="20190402 06:01:05.416"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:05.419" starttime="20190402 06:01:05.419"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:05.419" starttime="20190402 06:01:05.419"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:05.420" starttime="20190402 06:01:05.419"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:05.420" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:01:05.420" starttime="20190402 06:01:05.420"></status>
</kw>
<msg timestamp="20190402 06:01:05.420" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:05.420" starttime="20190402 06:01:04.316"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:01:05.421" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:01:05.421" starttime="20190402 06:01:05.420"></status>
</kw>
<msg timestamp="20190402 06:01:05.421" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:01:05.421" starttime="20190402 06:01:04.313"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:01:05.421" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:01:05.421" starttime="20190402 06:01:05.421"></status>
</kw>
<status status="FAIL" endtime="20190402 06:01:05.421" starttime="20190402 06:01:04.312"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:01:10.426" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:10.426" starttime="20190402 06:01:10.425"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:10.428" starttime="20190402 06:01:10.428"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:10.429" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:10.429" starttime="20190402 06:01:10.428"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:10.429" starttime="20190402 06:01:10.429"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:10.429" starttime="20190402 06:01:10.429"></status>
</kw>
<msg timestamp="20190402 06:01:10.430" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:10.430" starttime="20190402 06:01:10.428"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:10.430" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:10.430" starttime="20190402 06:01:10.430"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:10.443" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:10.443" starttime="20190402 06:01:10.430"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:11.451" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:11.451" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:11.451" starttime="20190402 06:01:10.443"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:11.452" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:11.452" starttime="20190402 06:01:11.452"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:11.452" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:01:11.452" starttime="20190402 06:01:11.452"></status>
</kw>
<msg timestamp="20190402 06:01:11.452" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:01:11.452" starttime="20190402 06:01:11.451"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:11.454" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:11.454" starttime="20190402 06:01:11.453"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:11.455" level="INFO">0</msg>
<msg timestamp="20190402 06:01:11.455" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:11.455" starttime="20190402 06:01:11.454"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:11.455" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:11.455" starttime="20190402 06:01:11.455"></status>
</kw>
<msg timestamp="20190402 06:01:11.455" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:11.455" starttime="20190402 06:01:11.453"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:11.456" starttime="20190402 06:01:11.456"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:11.456" starttime="20190402 06:01:11.456"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:11.457" starttime="20190402 06:01:11.456"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:11.457" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:01:11.457" starttime="20190402 06:01:11.457"></status>
</kw>
<msg timestamp="20190402 06:01:11.457" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:11.457" starttime="20190402 06:01:10.426"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:01:11.457" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:01:11.457" starttime="20190402 06:01:11.457"></status>
</kw>
<msg timestamp="20190402 06:01:11.458" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:01:11.458" starttime="20190402 06:01:10.424"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:01:11.458" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:01:11.458" starttime="20190402 06:01:11.458"></status>
</kw>
<status status="FAIL" endtime="20190402 06:01:11.458" starttime="20190402 06:01:10.422"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:01:16.462" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:16.462" starttime="20190402 06:01:16.461"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:16.465" starttime="20190402 06:01:16.464"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:16.468" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:16.468" starttime="20190402 06:01:16.467"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:16.470" starttime="20190402 06:01:16.469"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:16.471" starttime="20190402 06:01:16.470"></status>
</kw>
<msg timestamp="20190402 06:01:16.471" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:16.472" starttime="20190402 06:01:16.465"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:16.472" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:16.472" starttime="20190402 06:01:16.472"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:16.499" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:16.499" starttime="20190402 06:01:16.473"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:17.500" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:17.500" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:17.500" starttime="20190402 06:01:16.499"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:17.501" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:17.501" starttime="20190402 06:01:17.501"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:17.501" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190402 06:01:17.501" starttime="20190402 06:01:17.501"></status>
</kw>
<msg timestamp="20190402 06:01:17.502" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190402 06:01:17.502" starttime="20190402 06:01:17.500"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:17.504" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:17.504" starttime="20190402 06:01:17.502"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:17.504" level="INFO">0</msg>
<msg timestamp="20190402 06:01:17.504" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:17.504" starttime="20190402 06:01:17.504"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:17.505" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:17.505" starttime="20190402 06:01:17.504"></status>
</kw>
<msg timestamp="20190402 06:01:17.505" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:17.505" starttime="20190402 06:01:17.502"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:17.506" starttime="20190402 06:01:17.505"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:17.506" starttime="20190402 06:01:17.505"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:17.506" starttime="20190402 06:01:17.506"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:17.506" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190402 06:01:17.506" starttime="20190402 06:01:17.506"></status>
</kw>
<msg timestamp="20190402 06:01:17.506" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:17.506" starttime="20190402 06:01:16.463"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:01:17.507" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190402 06:01:17.507" starttime="20190402 06:01:17.506"></status>
</kw>
<msg timestamp="20190402 06:01:17.507" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190402 06:01:17.507" starttime="20190402 06:01:16.460"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:01:17.507" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190402 06:01:17.507" starttime="20190402 06:01:17.507"></status>
</kw>
<status status="FAIL" endtime="20190402 06:01:17.508" starttime="20190402 06:01:16.459"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:01:22.512" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:22.512" starttime="20190402 06:01:22.511"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:22.514" starttime="20190402 06:01:22.514"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:22.515" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:22.515" starttime="20190402 06:01:22.514"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:22.515" starttime="20190402 06:01:22.515"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:22.515" starttime="20190402 06:01:22.515"></status>
</kw>
<msg timestamp="20190402 06:01:22.516" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:22.516" starttime="20190402 06:01:22.514"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:22.516" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:22.516" starttime="20190402 06:01:22.516"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:22.526" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:22.526" starttime="20190402 06:01:22.516"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:23.529" level="INFO">completed
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:23.529" level="INFO">${output} = completed
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:23.530" starttime="20190402 06:01:22.526"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:23.530" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:23.530" starttime="20190402 06:01:23.530"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:23.531" level="INFO">${clean_out} = completed
</msg>
<status status="PASS" endtime="20190402 06:01:23.531" starttime="20190402 06:01:23.530"></status>
</kw>
<msg timestamp="20190402 06:01:23.531" level="INFO">${output} = completed
</msg>
<status status="PASS" endtime="20190402 06:01:23.531" starttime="20190402 06:01:23.530"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:23.533" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:23.533" starttime="20190402 06:01:23.531"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:23.533" level="INFO">0</msg>
<msg timestamp="20190402 06:01:23.533" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:23.534" starttime="20190402 06:01:23.533"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:23.534" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:23.534" starttime="20190402 06:01:23.534"></status>
</kw>
<msg timestamp="20190402 06:01:23.534" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:23.534" starttime="20190402 06:01:23.531"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.535" starttime="20190402 06:01:23.534"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:23.535" starttime="20190402 06:01:23.534"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.535" starttime="20190402 06:01:23.535"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:23.535" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: completed</msg>
<status status="PASS" endtime="20190402 06:01:23.535" starttime="20190402 06:01:23.535"></status>
</kw>
<msg timestamp="20190402 06:01:23.536" level="INFO">${result} = {u'stdout': u'completed', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:23.536" starttime="20190402 06:01:22.513"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:01:23.536" level="INFO">${value} = completed</msg>
<status status="PASS" endtime="20190402 06:01:23.536" starttime="20190402 06:01:23.536"></status>
</kw>
<msg timestamp="20190402 06:01:23.536" level="INFO">${current_value} = completed</msg>
<status status="PASS" endtime="20190402 06:01:23.536" starttime="20190402 06:01:22.510"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.536" starttime="20190402 06:01:23.536"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:23.537" starttime="20190402 06:01:22.508"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:23.537" starttime="20190402 05:52:28.133"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:23.537" starttime="20190402 05:52:28.132"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:23.537" starttime="20190402 05:52:28.132"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:23.537" starttime="20190402 05:52:22.380"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:23.537" starttime="20190402 05:52:22.380"></status>
</kw>
<kw name="Configure Data Interfaces" library="Utils">
<doc>Configure data interfaces with proper values.</doc>
<arguments>
<arg>${second_controller}</arg>
<arg>${data0if}</arg>
<arg>${data1if}</arg>
<arg>${physnet0}</arg>
<arg>${physnet1}</arg>
<arg>${mtu}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>Run Keywords</arg>
<arg>Provide OAM Network Interface</arg>
<arg>${host}</arg>
<arg>AND</arg>
<arg>Setup Cluster-host Interfaces</arg>
<arg>${host}</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Provide OAM Network Interface</arg>
<arg>${host}</arg>
<arg>AND</arg>
<arg>Setup Cluster-host Interfaces</arg>
<arg>${host}</arg>
</arguments>
<kw name="Provide OAM Network Interface" library="Utils">
<doc>Enables the OAM interface for second controller.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>oam</arg>
</arguments>
<assign>
<var>${net_type}</var>
</assign>
<msg timestamp="20190402 06:01:23.538" level="INFO">${net_type} = oam</msg>
<status status="PASS" endtime="20190402 06:01:23.538" starttime="20190402 06:01:23.538"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>platform</arg>
</arguments>
<assign>
<var>${class}</var>
</assign>
<msg timestamp="20190402 06:01:23.539" level="INFO">${class} = platform</msg>
<status status="PASS" endtime="20190402 06:01:23.539" starttime="20190402 06:01:23.539"></status>
</kw>
<kw name="Get OAM Interface Name" library="Utils">
<doc>Returns the interface name of the OAM network.</doc>
<assign>
<var>${oam_if}</var>
</assign>
<kw name="Get Release Version" library="Utils">
<doc>Returns the version of the release under validation.</doc>
<assign>
<var>${sw_version}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>cat /etc/build.info |</arg>
<arg>grep SW_VERSION | awk '{ split($1, v, "="); print v[2]}'</arg>
</arguments>
<assign>
<var>${cmd_current_version}</var>
</assign>
<msg timestamp="20190402 06:01:23.539" level="INFO">${cmd_current_version} = cat /etc/build.info | grep SW_VERSION | awk '{ split($1, v, "="); print v[2]}'</msg>
<status status="PASS" endtime="20190402 06:01:23.539" starttime="20190402 06:01:23.539"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd_current_version}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.540" starttime="20190402 06:01:23.540"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:23.541" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:23.541" starttime="20190402 06:01:23.541"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.541" starttime="20190402 06:01:23.541"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.542" starttime="20190402 06:01:23.541"></status>
</kw>
<msg timestamp="20190402 06:01:23.542" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:23.542" starttime="20190402 06:01:23.540"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:23.542" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:23.542" starttime="20190402 06:01:23.542"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:23.552" level="INFO">cat /etc/build.info | grep SW_VERSION  | awk '{ split($1, v, "="); print v[2]}'</msg>
<status status="PASS" endtime="20190402 06:01:23.552" starttime="20190402 06:01:23.542"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:23.553" level="INFO">"19.01"
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:23.553" level="INFO">${output} = "19.01"
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:23.553" starttime="20190402 06:01:23.552"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:23.554" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:23.554" starttime="20190402 06:01:23.553"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:23.554" level="INFO">${clean_out} = "19.01"
</msg>
<status status="PASS" endtime="20190402 06:01:23.554" starttime="20190402 06:01:23.554"></status>
</kw>
<msg timestamp="20190402 06:01:23.554" level="INFO">${output} = "19.01"
</msg>
<status status="PASS" endtime="20190402 06:01:23.554" starttime="20190402 06:01:23.553"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:23.556" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:23.556" starttime="20190402 06:01:23.554"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:23.557" level="INFO">0</msg>
<msg timestamp="20190402 06:01:23.557" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:23.557" starttime="20190402 06:01:23.556"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:23.557" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:23.557" starttime="20190402 06:01:23.557"></status>
</kw>
<msg timestamp="20190402 06:01:23.557" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:23.557" starttime="20190402 06:01:23.554"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.558" starttime="20190402 06:01:23.558"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:23.558" starttime="20190402 06:01:23.557"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.558" starttime="20190402 06:01:23.558"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:23.558" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: "19.01"</msg>
<status status="PASS" endtime="20190402 06:01:23.558" starttime="20190402 06:01:23.558"></status>
</kw>
<msg timestamp="20190402 06:01:23.559" level="INFO">&amp;{result} = { stdout="19.01" | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:01:23.559" starttime="20190402 06:01:23.540"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${current_version}</var>
</assign>
<msg timestamp="20190402 06:01:23.559" level="INFO">${current_version} = "19.01"</msg>
<status status="PASS" endtime="20190402 06:01:23.559" starttime="20190402 06:01:23.559"></status>
</kw>
<msg timestamp="20190402 06:01:23.559" level="INFO">${sw_version} = 19.01</msg>
<status status="PASS" endtime="20190402 06:01:23.559" starttime="20190402 06:01:23.539"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>cat /opt/platform/config/${sw_version}/cgcs_config</arg>
<arg>grep EXTERNAL_OAM_INTERFACE_NAME</arg>
<arg>awk '{ split($1, v, "="); print v[2]}'</arg>
</arguments>
<assign>
<var>${command}</var>
</assign>
<msg timestamp="20190402 06:01:23.560" level="INFO">${command} = cat /opt/platform/config/19.01/cgcs_config|grep EXTERNAL_OAM_INTERFACE_NAME|awk '{ split($1, v, "="); print v[2]}'</msg>
<status status="PASS" endtime="20190402 06:01:23.560" starttime="20190402 06:01:23.559"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${command}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.560" starttime="20190402 06:01:23.560"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:23.561" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:23.561" starttime="20190402 06:01:23.561"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.561" starttime="20190402 06:01:23.561"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.562" starttime="20190402 06:01:23.561"></status>
</kw>
<msg timestamp="20190402 06:01:23.562" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:23.562" starttime="20190402 06:01:23.560"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:23.562" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:23.562" starttime="20190402 06:01:23.562"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:23.564" level="INFO">cat /opt/platform/config/19.01/cgcs_co nfig|grep EXTERNAL_OAM_INTERFACE_NAME|awk '{ split($1, v, "="); print v[2]}'</msg>
<status status="PASS" endtime="20190402 06:01:23.564" starttime="20190402 06:01:23.562"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:23.567" level="INFO">eno1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:23.567" level="INFO">${output} = eno1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:23.567" starttime="20190402 06:01:23.565"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:23.568" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:23.568" starttime="20190402 06:01:23.567"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:23.568" level="INFO">${clean_out} = eno1
</msg>
<status status="PASS" endtime="20190402 06:01:23.568" starttime="20190402 06:01:23.568"></status>
</kw>
<msg timestamp="20190402 06:01:23.568" level="INFO">${output} = eno1
</msg>
<status status="PASS" endtime="20190402 06:01:23.568" starttime="20190402 06:01:23.567"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:23.570" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:23.570" starttime="20190402 06:01:23.568"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:23.570" level="INFO">0</msg>
<msg timestamp="20190402 06:01:23.570" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:23.570" starttime="20190402 06:01:23.570"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:23.571" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:23.571" starttime="20190402 06:01:23.570"></status>
</kw>
<msg timestamp="20190402 06:01:23.571" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:23.571" starttime="20190402 06:01:23.568"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.572" starttime="20190402 06:01:23.571"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:23.572" starttime="20190402 06:01:23.571"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.572" starttime="20190402 06:01:23.572"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:23.572" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: eno1</msg>
<status status="PASS" endtime="20190402 06:01:23.572" starttime="20190402 06:01:23.572"></status>
</kw>
<msg timestamp="20190402 06:01:23.572" level="INFO">${result} = {u'stdout': u'eno1', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:23.572" starttime="20190402 06:01:23.560"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${oam_if}</var>
</assign>
<msg timestamp="20190402 06:01:23.573" level="INFO">${oam_if} = eno1</msg>
<status status="PASS" endtime="20190402 06:01:23.573" starttime="20190402 06:01:23.573"></status>
</kw>
<msg timestamp="20190402 06:01:23.573" level="INFO">${oam_if} = eno1</msg>
<status status="PASS" endtime="20190402 06:01:23.573" starttime="20190402 06:01:23.539"></status>
</kw>
<kw name="Modify Host Interface" library="Utils">
<doc>Modify interface attributes according to given options.</doc>
<arguments>
<arg>${net_type}</arg>
<arg>${class}</arg>
<arg>${controller}</arg>
<arg>${oam_if}</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system host-if-modify</arg>
<arg>-n oam0 -c ${class} --networks ${net_type}</arg>
<arg>${host}</arg>
<arg>${interface}</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:01:23.574" level="INFO">${system_cmd} = system host-if-modify -n oam0 -c platform --networks oam controller-1 eno1</msg>
<status status="PASS" endtime="20190402 06:01:23.574" starttime="20190402 06:01:23.573"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.574" starttime="20190402 06:01:23.574"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:23.575" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:23.575" starttime="20190402 06:01:23.575"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.575" starttime="20190402 06:01:23.575"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:23.576" starttime="20190402 06:01:23.575"></status>
</kw>
<msg timestamp="20190402 06:01:23.576" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:23.576" starttime="20190402 06:01:23.574"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:23.576" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:23.576" starttime="20190402 06:01:23.576"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:23.587" level="INFO">system host-if-modify -n oam0 -c platf orm --networks oam controller-1 eno1</msg>
<status status="PASS" endtime="20190402 06:01:23.587" starttime="20190402 06:01:23.576"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:25.368" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | oam0                                 |
| iftype       | ethernet                             |
| ports        | [u'eno1']                            |
| datanetworks | []                                   |
| imac         | a4:bf:01:55:03:ba                    |
| imtu         | 1500                                 |
| ifclass      | platform                             |
| networks     | oam                                  |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | ec158d70-2710-41fa-8e3e-ef75e5764e47 |
| ihost_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T11:49:47.636810+00:00     |
| updated_at   | 2019-04-02T11:50:09.673004+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | static                               |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:25.368" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | oam0        ...</msg>
<status status="PASS" endtime="20190402 06:01:25.368" starttime="20190402 06:01:23.587"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:25.369" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:25.369" starttime="20190402 06:01:25.369"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:25.370" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | oam0        ...</msg>
<status status="PASS" endtime="20190402 06:01:25.370" starttime="20190402 06:01:25.369"></status>
</kw>
<msg timestamp="20190402 06:01:25.370" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | oam0        ...</msg>
<status status="PASS" endtime="20190402 06:01:25.370" starttime="20190402 06:01:25.369"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:25.372" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:25.372" starttime="20190402 06:01:25.370"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:25.372" level="INFO">0</msg>
<msg timestamp="20190402 06:01:25.372" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:25.372" starttime="20190402 06:01:25.372"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:25.373" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:25.373" starttime="20190402 06:01:25.372"></status>
</kw>
<msg timestamp="20190402 06:01:25.373" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:25.373" starttime="20190402 06:01:25.370"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:25.374" starttime="20190402 06:01:25.373"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:25.374" starttime="20190402 06:01:25.373"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:25.374" starttime="20190402 06:01:25.374"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:25.374" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | oam0                                 |
| iftype       | ethernet                             |
| ports        | [u'eno1']                            |
| datanetworks | []                                   |
| imac         | a4:bf:01:55:03:ba                    |
| imtu         | 1500                                 |
| ifclass      | platform                             |
| networks     | oam                                  |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | ec158d70-2710-41fa-8e3e-ef75e5764e47 |
| ihost_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T11:49:47.636810+00:00     |
| updated_at   | 2019-04-02T11:50:09.673004+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | static                               |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:25.374" starttime="20190402 06:01:25.374"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:25.374" starttime="20190402 06:01:23.574"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:25.374" starttime="20190402 06:01:23.573"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:25.375" starttime="20190402 06:01:23.538"></status>
</kw>
<kw name="Setup Cluster-host Interfaces" library="Utils">
<doc>Setup mgmt network as a cluster-host network interface.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-if-modify ${host} mgmt0 --networks cluster-host</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:25.376" starttime="20190402 06:01:25.375"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:25.376" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:25.376" starttime="20190402 06:01:25.376"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:25.377" starttime="20190402 06:01:25.376"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:25.377" starttime="20190402 06:01:25.377"></status>
</kw>
<msg timestamp="20190402 06:01:25.377" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:25.377" starttime="20190402 06:01:25.376"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:25.377" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:25.377" starttime="20190402 06:01:25.377"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:25.387" level="INFO">system host-if-modify controller-1 mgm t0 --networks cluster-host</msg>
<status status="PASS" endtime="20190402 06:01:25.387" starttime="20190402 06:01:25.378"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:27.248" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | mgmt0                                |
| iftype       | ethernet                             |
| ports        | [u'eno2']                            |
| datanetworks | []                                   |
| imac         | a4:bf:01:55:03:bb                    |
| imtu         | 1500                                 |
| ifclass      | platform                             |
| networks     | mgmt,cluster-host                    |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | ca2bd5bd-bfa6-4bb0-93ab-efe0697a7b20 |
| ihost_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T11:49:47.730286+00:00     |
| updated_at   | 2019-04-02T11:50:11.456640+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | static                               |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:27.248" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | mgmt0       ...</msg>
<status status="PASS" endtime="20190402 06:01:27.248" starttime="20190402 06:01:25.387"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:27.249" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:27.249" starttime="20190402 06:01:27.249"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:27.249" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | mgmt0       ...</msg>
<status status="PASS" endtime="20190402 06:01:27.249" starttime="20190402 06:01:27.249"></status>
</kw>
<msg timestamp="20190402 06:01:27.250" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | mgmt0       ...</msg>
<status status="PASS" endtime="20190402 06:01:27.250" starttime="20190402 06:01:27.248"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:27.252" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:27.252" starttime="20190402 06:01:27.250"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:27.252" level="INFO">0</msg>
<msg timestamp="20190402 06:01:27.252" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:27.252" starttime="20190402 06:01:27.252"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:27.252" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:27.252" starttime="20190402 06:01:27.252"></status>
</kw>
<msg timestamp="20190402 06:01:27.253" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:27.253" starttime="20190402 06:01:27.250"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:27.253" starttime="20190402 06:01:27.253"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:27.253" starttime="20190402 06:01:27.253"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:27.254" starttime="20190402 06:01:27.254"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:27.254" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | mgmt0                                |
| iftype       | ethernet                             |
| ports        | [u'eno2']                            |
| datanetworks | []                                   |
| imac         | a4:bf:01:55:03:bb                    |
| imtu         | 1500                                 |
| ifclass      | platform                             |
| networks     | mgmt,cluster-host                    |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | ca2bd5bd-bfa6-4bb0-93ab-efe0697a7b20 |
| ihost_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T11:49:47.730286+00:00     |
| updated_at   | 2019-04-02T11:50:11.456640+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | static                               |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:27.254" starttime="20190402 06:01:27.254"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:27.254" starttime="20190402 06:01:25.375"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:27.254" starttime="20190402 06:01:25.375"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:27.254" starttime="20190402 06:01:23.538"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:27.254" starttime="20190402 06:01:23.538"></status>
</kw>
<kw name="Get Interface Information" library="Utils">
<doc>Returns a dictionary with the values of the spcecified
interface.</doc>
<arguments>
<arg>${host}</arg>
<arg>${data0if}</arg>
</arguments>
<assign>
<var>${iface_info}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-port-list ${host} --nowrap</arg>
<arg>grep ${interface}</arg>
<arg>awk '{ print $2,$4,$8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:01:27.255" level="INFO">${cmd} = system host-port-list controller-1 --nowrap|grep enp24s0f0|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190402 06:01:27.255" starttime="20190402 06:01:27.255"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:27.256" starttime="20190402 06:01:27.256"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:27.257" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:27.257" starttime="20190402 06:01:27.256"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:27.257" starttime="20190402 06:01:27.257"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:27.257" starttime="20190402 06:01:27.257"></status>
</kw>
<msg timestamp="20190402 06:01:27.258" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:27.258" starttime="20190402 06:01:27.256"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:27.258" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:27.258" starttime="20190402 06:01:27.258"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:27.261" level="INFO">system host-port-list controller-1 --n owrap|grep enp24s0f0|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190402 06:01:27.261" starttime="20190402 06:01:27.258"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:28.296" level="INFO">737a48da-0d5a-4d0d-aab1-d5a09fa6ae59 enp24s0f0 0000:18:00.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:28.296" level="INFO">${output} = 737a48da-0d5a-4d0d-aab1-d5a09fa6ae59 enp24s0f0 0000:18:00.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:28.296" starttime="20190402 06:01:27.261"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:28.297" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:28.297" starttime="20190402 06:01:28.297"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:28.298" level="INFO">${clean_out} = 737a48da-0d5a-4d0d-aab1-d5a09fa6ae59 enp24s0f0 0000:18:00.0
</msg>
<status status="PASS" endtime="20190402 06:01:28.298" starttime="20190402 06:01:28.297"></status>
</kw>
<msg timestamp="20190402 06:01:28.298" level="INFO">${output} = 737a48da-0d5a-4d0d-aab1-d5a09fa6ae59 enp24s0f0 0000:18:00.0
</msg>
<status status="PASS" endtime="20190402 06:01:28.298" starttime="20190402 06:01:28.297"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:28.300" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:28.300" starttime="20190402 06:01:28.298"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:28.300" level="INFO">0</msg>
<msg timestamp="20190402 06:01:28.301" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:28.301" starttime="20190402 06:01:28.300"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:28.301" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:28.301" starttime="20190402 06:01:28.301"></status>
</kw>
<msg timestamp="20190402 06:01:28.301" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:28.301" starttime="20190402 06:01:28.298"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:28.302" starttime="20190402 06:01:28.302"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:28.302" starttime="20190402 06:01:28.301"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:28.302" starttime="20190402 06:01:28.302"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:28.303" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 737a48da-0d5a-4d0d-aab1-d5a09fa6ae59 enp24s0f0 0000:18:00.0</msg>
<status status="PASS" endtime="20190402 06:01:28.303" starttime="20190402 06:01:28.303"></status>
</kw>
<msg timestamp="20190402 06:01:28.303" level="INFO">${info} = {u'stdout': u'737a48da-0d5a-4d0d-aab1-d5a09fa6ae59 enp24s0f0 0000:18:00.0', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:28.303" starttime="20190402 06:01:27.255"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${info}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190402 06:01:28.304" level="INFO">${response} = 737a48da-0d5a-4d0d-aab1-d5a09fa6ae59 enp24s0f0 0000:18:00.0</msg>
<status status="PASS" endtime="20190402 06:01:28.304" starttime="20190402 06:01:28.303"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190402 06:01:28.304" level="INFO">@{res_in_list} = [ 737a48da-0d5a-4d0d-aab1-d5a09fa6ae59 | enp24s0f0 | 0000:18:00.0 ]</msg>
<status status="PASS" endtime="20190402 06:01:28.304" starttime="20190402 06:01:28.304"></status>
</kw>
<msg timestamp="20190402 06:01:28.304" level="INFO">${info} = [u'737a48da-0d5a-4d0d-aab1-d5a09fa6ae59', u'enp24s0f0', u'0000:18:00.0']</msg>
<status status="PASS" endtime="20190402 06:01:28.304" starttime="20190402 06:01:28.303"></status>
</kw>
<msg timestamp="20190402 06:01:28.304" level="INFO">${iface_info} = [u'737a48da-0d5a-4d0d-aab1-d5a09fa6ae59', u'enp24s0f0', u'0000:18:00.0']</msg>
<status status="PASS" endtime="20190402 06:01:28.304" starttime="20190402 06:01:27.255"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data0portuuid}</var>
</assign>
<msg timestamp="20190402 06:01:28.305" level="INFO">${data0portuuid} = 737a48da-0d5a-4d0d-aab1-d5a09fa6ae59</msg>
<status status="PASS" endtime="20190402 06:01:28.305" starttime="20190402 06:01:28.305"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data0portname}</var>
</assign>
<msg timestamp="20190402 06:01:28.305" level="INFO">${data0portname} = enp24s0f0</msg>
<status status="PASS" endtime="20190402 06:01:28.305" starttime="20190402 06:01:28.305"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>2</arg>
</arguments>
<assign>
<var>${data0pciaddr}</var>
</assign>
<msg timestamp="20190402 06:01:28.305" level="INFO">${data0pciaddr} = 0000:18:00.0</msg>
<status status="PASS" endtime="20190402 06:01:28.305" starttime="20190402 06:01:28.305"></status>
</kw>
<kw name="Get Interface Information" library="Utils">
<doc>Returns a dictionary with the values of the spcecified
interface.</doc>
<arguments>
<arg>${host}</arg>
<arg>${data1if}</arg>
</arguments>
<assign>
<var>${iface_info}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-port-list ${host} --nowrap</arg>
<arg>grep ${interface}</arg>
<arg>awk '{ print $2,$4,$8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:01:28.306" level="INFO">${cmd} = system host-port-list controller-1 --nowrap|grep enp24s0f1|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190402 06:01:28.306" starttime="20190402 06:01:28.306"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:28.307" starttime="20190402 06:01:28.307"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:28.308" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:28.308" starttime="20190402 06:01:28.307"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:28.308" starttime="20190402 06:01:28.308"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:28.309" starttime="20190402 06:01:28.308"></status>
</kw>
<msg timestamp="20190402 06:01:28.309" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:28.309" starttime="20190402 06:01:28.307"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:28.309" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:28.309" starttime="20190402 06:01:28.309"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:28.323" level="INFO">system host-port-list controller-1 --n owrap|grep enp24s0f1|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190402 06:01:28.323" starttime="20190402 06:01:28.309"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:29.337" level="INFO">46893fa1-c5ce-4cc0-a27d-f98030cca42d enp24s0f1 0000:18:00.1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:29.337" level="INFO">${output} = 46893fa1-c5ce-4cc0-a27d-f98030cca42d enp24s0f1 0000:18:00.1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:29.337" starttime="20190402 06:01:28.323"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:29.338" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:29.338" starttime="20190402 06:01:29.338"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:29.338" level="INFO">${clean_out} = 46893fa1-c5ce-4cc0-a27d-f98030cca42d enp24s0f1 0000:18:00.1
</msg>
<status status="PASS" endtime="20190402 06:01:29.338" starttime="20190402 06:01:29.338"></status>
</kw>
<msg timestamp="20190402 06:01:29.339" level="INFO">${output} = 46893fa1-c5ce-4cc0-a27d-f98030cca42d enp24s0f1 0000:18:00.1
</msg>
<status status="PASS" endtime="20190402 06:01:29.339" starttime="20190402 06:01:29.337"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:29.340" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:29.341" starttime="20190402 06:01:29.339"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:29.341" level="INFO">0</msg>
<msg timestamp="20190402 06:01:29.341" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:29.341" starttime="20190402 06:01:29.341"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:29.341" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:29.341" starttime="20190402 06:01:29.341"></status>
</kw>
<msg timestamp="20190402 06:01:29.342" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:29.342" starttime="20190402 06:01:29.339"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:29.342" starttime="20190402 06:01:29.342"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:29.342" starttime="20190402 06:01:29.342"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:29.343" starttime="20190402 06:01:29.342"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:29.343" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 46893fa1-c5ce-4cc0-a27d-f98030cca42d enp24s0f1 0000:18:00.1</msg>
<status status="PASS" endtime="20190402 06:01:29.343" starttime="20190402 06:01:29.343"></status>
</kw>
<msg timestamp="20190402 06:01:29.343" level="INFO">${info} = {u'stdout': u'46893fa1-c5ce-4cc0-a27d-f98030cca42d enp24s0f1 0000:18:00.1', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:29.343" starttime="20190402 06:01:28.306"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${info}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190402 06:01:29.344" level="INFO">${response} = 46893fa1-c5ce-4cc0-a27d-f98030cca42d enp24s0f1 0000:18:00.1</msg>
<status status="PASS" endtime="20190402 06:01:29.344" starttime="20190402 06:01:29.344"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190402 06:01:29.344" level="INFO">@{res_in_list} = [ 46893fa1-c5ce-4cc0-a27d-f98030cca42d | enp24s0f1 | 0000:18:00.1 ]</msg>
<status status="PASS" endtime="20190402 06:01:29.344" starttime="20190402 06:01:29.344"></status>
</kw>
<msg timestamp="20190402 06:01:29.344" level="INFO">${info} = [u'46893fa1-c5ce-4cc0-a27d-f98030cca42d', u'enp24s0f1', u'0000:18:00.1']</msg>
<status status="PASS" endtime="20190402 06:01:29.344" starttime="20190402 06:01:29.343"></status>
</kw>
<msg timestamp="20190402 06:01:29.344" level="INFO">${iface_info} = [u'46893fa1-c5ce-4cc0-a27d-f98030cca42d', u'enp24s0f1', u'0000:18:00.1']</msg>
<status status="PASS" endtime="20190402 06:01:29.344" starttime="20190402 06:01:28.306"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data1portuuid}</var>
</assign>
<msg timestamp="20190402 06:01:29.345" level="INFO">${data1portuuid} = 46893fa1-c5ce-4cc0-a27d-f98030cca42d</msg>
<status status="PASS" endtime="20190402 06:01:29.345" starttime="20190402 06:01:29.345"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data1portname}</var>
</assign>
<msg timestamp="20190402 06:01:29.345" level="INFO">${data1portname} = enp24s0f1</msg>
<status status="PASS" endtime="20190402 06:01:29.345" starttime="20190402 06:01:29.345"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>2</arg>
</arguments>
<assign>
<var>${data1pciaddr}</var>
</assign>
<msg timestamp="20190402 06:01:29.345" level="INFO">${data1pciaddr} = 0000:18:00.1</msg>
<status status="PASS" endtime="20190402 06:01:29.345" starttime="20190402 06:01:29.345"></status>
</kw>
<kw name="Get Interface UUID" library="Utils">
<doc>Get Interface id of the specified host and port</doc>
<arguments>
<arg>${host}</arg>
<arg>${data0portname}</arg>
</arguments>
<assign>
<var>${data0ifuuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-if-list -a ${host}</arg>
<arg>grep ${port_name}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:01:29.346" level="INFO">${cmd} = system host-if-list -a controller-1|grep enp24s0f0|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 06:01:29.346" starttime="20190402 06:01:29.346"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${uuid}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:29.347" starttime="20190402 06:01:29.347"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:29.348" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:29.348" starttime="20190402 06:01:29.347"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:29.348" starttime="20190402 06:01:29.348"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:29.348" starttime="20190402 06:01:29.348"></status>
</kw>
<msg timestamp="20190402 06:01:29.349" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:29.349" starttime="20190402 06:01:29.347"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:29.349" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:29.349" starttime="20190402 06:01:29.349"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:29.351" level="INFO">system host-if-list -a controller-1|gr ep enp24s0f0|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 06:01:29.351" starttime="20190402 06:01:29.349"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:30.555" level="INFO">85355b1b-deea-49ce-b6c0-e43fc2b1c943
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:30.555" level="INFO">${output} = 85355b1b-deea-49ce-b6c0-e43fc2b1c943
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:30.555" starttime="20190402 06:01:29.351"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:30.556" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:30.556" starttime="20190402 06:01:30.556"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:30.557" level="INFO">${clean_out} = 85355b1b-deea-49ce-b6c0-e43fc2b1c943
</msg>
<status status="PASS" endtime="20190402 06:01:30.557" starttime="20190402 06:01:30.556"></status>
</kw>
<msg timestamp="20190402 06:01:30.557" level="INFO">${output} = 85355b1b-deea-49ce-b6c0-e43fc2b1c943
</msg>
<status status="PASS" endtime="20190402 06:01:30.557" starttime="20190402 06:01:30.556"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:30.558" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:30.559" starttime="20190402 06:01:30.557"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:30.559" level="INFO">0</msg>
<msg timestamp="20190402 06:01:30.559" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:30.559" starttime="20190402 06:01:30.559"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:30.560" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:30.560" starttime="20190402 06:01:30.559"></status>
</kw>
<msg timestamp="20190402 06:01:30.560" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:30.560" starttime="20190402 06:01:30.557"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:30.560" starttime="20190402 06:01:30.560"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:30.561" starttime="20190402 06:01:30.560"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:30.561" starttime="20190402 06:01:30.561"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:30.561" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 85355b1b-deea-49ce-b6c0-e43fc2b1c943</msg>
<status status="PASS" endtime="20190402 06:01:30.561" starttime="20190402 06:01:30.561"></status>
</kw>
<msg timestamp="20190402 06:01:30.561" level="INFO">${uuid} = {u'stdout': u'85355b1b-deea-49ce-b6c0-e43fc2b1c943', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:30.561" starttime="20190402 06:01:29.346"></status>
</kw>
<msg timestamp="20190402 06:01:30.562" level="INFO">${data0ifuuid} = 85355b1b-deea-49ce-b6c0-e43fc2b1c943</msg>
<status status="PASS" endtime="20190402 06:01:30.562" starttime="20190402 06:01:29.346"></status>
</kw>
<kw name="Get Interface UUID" library="Utils">
<doc>Get Interface id of the specified host and port</doc>
<arguments>
<arg>${host}</arg>
<arg>${data1portname}</arg>
</arguments>
<assign>
<var>${data1ifuuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-if-list -a ${host}</arg>
<arg>grep ${port_name}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:01:30.562" level="INFO">${cmd} = system host-if-list -a controller-1|grep enp24s0f1|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 06:01:30.562" starttime="20190402 06:01:30.562"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${uuid}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:30.563" starttime="20190402 06:01:30.563"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:30.564" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:30.564" starttime="20190402 06:01:30.563"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:30.564" starttime="20190402 06:01:30.564"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:30.565" starttime="20190402 06:01:30.564"></status>
</kw>
<msg timestamp="20190402 06:01:30.565" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:30.565" starttime="20190402 06:01:30.563"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:30.565" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:30.565" starttime="20190402 06:01:30.565"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:30.567" level="INFO">system host-if-list -a controller-1|gr ep enp24s0f1|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 06:01:30.567" starttime="20190402 06:01:30.565"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:31.716" level="INFO">c836334b-2c07-4687-a09c-a337212a6f06
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:31.716" level="INFO">${output} = c836334b-2c07-4687-a09c-a337212a6f06
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:31.716" starttime="20190402 06:01:30.567"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:31.717" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:31.717" starttime="20190402 06:01:31.717"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:31.717" level="INFO">${clean_out} = c836334b-2c07-4687-a09c-a337212a6f06
</msg>
<status status="PASS" endtime="20190402 06:01:31.717" starttime="20190402 06:01:31.717"></status>
</kw>
<msg timestamp="20190402 06:01:31.718" level="INFO">${output} = c836334b-2c07-4687-a09c-a337212a6f06
</msg>
<status status="PASS" endtime="20190402 06:01:31.718" starttime="20190402 06:01:31.716"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:31.719" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:31.720" starttime="20190402 06:01:31.718"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:31.720" level="INFO">0</msg>
<msg timestamp="20190402 06:01:31.720" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:31.720" starttime="20190402 06:01:31.720"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:31.720" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:31.720" starttime="20190402 06:01:31.720"></status>
</kw>
<msg timestamp="20190402 06:01:31.720" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:31.720" starttime="20190402 06:01:31.718"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:31.721" starttime="20190402 06:01:31.721"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:31.721" starttime="20190402 06:01:31.720"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:31.722" starttime="20190402 06:01:31.721"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:31.722" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: c836334b-2c07-4687-a09c-a337212a6f06</msg>
<status status="PASS" endtime="20190402 06:01:31.722" starttime="20190402 06:01:31.722"></status>
</kw>
<msg timestamp="20190402 06:01:31.722" level="INFO">${uuid} = {u'stdout': u'c836334b-2c07-4687-a09c-a337212a6f06', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:31.722" starttime="20190402 06:01:30.562"></status>
</kw>
<msg timestamp="20190402 06:01:31.722" level="INFO">${data1ifuuid} = c836334b-2c07-4687-a09c-a337212a6f06</msg>
<status status="PASS" endtime="20190402 06:01:31.722" starttime="20190402 06:01:30.562"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-0' or '${host}'=='compute-0'</arg>
<arg>Run Keywords</arg>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet0} vlan</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet1} vlan</arg>
<arg>True</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:31.723" starttime="20190402 06:01:31.722"></status>
</kw>
<kw name="Add Interface To Data Network" library="Utils">
<doc>Adds an interface to the specified data network.</doc>
<arguments>
<arg>${mtu}</arg>
<arg>data0</arg>
<arg>${physnet0}</arg>
<arg>${host}</arg>
<arg>${data0ifuuid}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controler-0'</arg>
<arg>-d</arg>
<arg>-p</arg>
</arguments>
<assign>
<var>${option}</var>
</assign>
<msg timestamp="20190402 06:01:31.723" level="INFO">${option} = -p</msg>
<status status="PASS" endtime="20190402 06:01:31.723" starttime="20190402 06:01:31.723"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system host-if-modify</arg>
<arg>-m ${mtu}</arg>
<arg>-n ${if_name}</arg>
<arg>${option} ${datanetwork}</arg>
<arg>-c data</arg>
<arg>${host}</arg>
<arg>${uuid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:01:31.724" level="INFO">${cmd} = system host-if-modify -m 1500 -n data0 -p physnet0 -c data controller-1 85355b1b-deea-49ce-b6c0-e43fc2b1c943</msg>
<status status="PASS" endtime="20190402 06:01:31.724" starttime="20190402 06:01:31.724"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:31.725" starttime="20190402 06:01:31.724"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:31.725" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:31.725" starttime="20190402 06:01:31.725"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:31.726" starttime="20190402 06:01:31.725"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:31.726" starttime="20190402 06:01:31.726"></status>
</kw>
<msg timestamp="20190402 06:01:31.726" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:31.726" starttime="20190402 06:01:31.725"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:31.726" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:31.726" starttime="20190402 06:01:31.726"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:31.729" level="INFO">system host-if-modify -m 1500 -n data0  -p physnet0 -c data controller-1 85355b1b-deea-49ce-b6c0-e43fc2b1c943</msg>
<status status="PASS" endtime="20190402 06:01:31.729" starttime="20190402 06:01:31.727"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:33.307" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f0']                       |
| datanetworks | [u'physnet0']                        |
| imac         | 3c:fd:fe:be:e0:e4                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 85355b1b-deea-49ce-b6c0-e43fc2b1c943 |
| ihost_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T11:49:47.436439+00:00     |
| updated_at   | 2019-04-02T11:50:17.655715+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:33.307" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190402 06:01:33.307" starttime="20190402 06:01:31.729"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:33.308" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:33.308" starttime="20190402 06:01:33.308"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:33.308" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190402 06:01:33.309" starttime="20190402 06:01:33.308"></status>
</kw>
<msg timestamp="20190402 06:01:33.309" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190402 06:01:33.309" starttime="20190402 06:01:33.307"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:33.311" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:33.311" starttime="20190402 06:01:33.309"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:33.311" level="INFO">0</msg>
<msg timestamp="20190402 06:01:33.311" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:33.311" starttime="20190402 06:01:33.311"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:33.312" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:33.312" starttime="20190402 06:01:33.312"></status>
</kw>
<msg timestamp="20190402 06:01:33.312" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:33.312" starttime="20190402 06:01:33.309"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:33.313" starttime="20190402 06:01:33.312"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:33.313" starttime="20190402 06:01:33.312"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:33.313" starttime="20190402 06:01:33.313"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:33.313" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f0']                       |
| datanetworks | [u'physnet0']                        |
| imac         | 3c:fd:fe:be:e0:e4                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 85355b1b-deea-49ce-b6c0-e43fc2b1c943 |
| ihost_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T11:49:47.436439+00:00     |
| updated_at   | 2019-04-02T11:50:17.655715+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:33.313" starttime="20190402 06:01:33.313"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:33.313" starttime="20190402 06:01:31.724"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:33.314" starttime="20190402 06:01:31.723"></status>
</kw>
<kw name="Add Interface To Data Network" library="Utils">
<doc>Adds an interface to the specified data network.</doc>
<arguments>
<arg>${mtu}</arg>
<arg>data1</arg>
<arg>${physnet1}</arg>
<arg>${host}</arg>
<arg>${data1ifuuid}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controler-0'</arg>
<arg>-d</arg>
<arg>-p</arg>
</arguments>
<assign>
<var>${option}</var>
</assign>
<msg timestamp="20190402 06:01:33.314" level="INFO">${option} = -p</msg>
<status status="PASS" endtime="20190402 06:01:33.314" starttime="20190402 06:01:33.314"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system host-if-modify</arg>
<arg>-m ${mtu}</arg>
<arg>-n ${if_name}</arg>
<arg>${option} ${datanetwork}</arg>
<arg>-c data</arg>
<arg>${host}</arg>
<arg>${uuid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:01:33.315" level="INFO">${cmd} = system host-if-modify -m 1500 -n data1 -p physnet1 -c data controller-1 c836334b-2c07-4687-a09c-a337212a6f06</msg>
<status status="PASS" endtime="20190402 06:01:33.315" starttime="20190402 06:01:33.314"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:33.316" starttime="20190402 06:01:33.315"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:33.316" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:33.316" starttime="20190402 06:01:33.316"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:33.317" starttime="20190402 06:01:33.316"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:33.317" starttime="20190402 06:01:33.317"></status>
</kw>
<msg timestamp="20190402 06:01:33.317" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:33.317" starttime="20190402 06:01:33.316"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:33.317" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:33.317" starttime="20190402 06:01:33.317"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:33.320" level="INFO">system host-if-modify -m 1500 -n data1  -p physnet1 -c data controller-1 c836334b-2c07-4687-a09c-a337212a6f06</msg>
<status status="PASS" endtime="20190402 06:01:33.320" starttime="20190402 06:01:33.318"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:34.903" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f1']                       |
| datanetworks | [u'physnet1']                        |
| imac         | 3c:fd:fe:be:e0:e5                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | c836334b-2c07-4687-a09c-a337212a6f06 |
| ihost_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T11:49:47.541842+00:00     |
| updated_at   | 2019-04-02T11:50:19.250904+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:34.903" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190402 06:01:34.903" starttime="20190402 06:01:33.320"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:34.904" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:34.904" starttime="20190402 06:01:34.904"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:34.904" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190402 06:01:34.904" starttime="20190402 06:01:34.904"></status>
</kw>
<msg timestamp="20190402 06:01:34.904" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190402 06:01:34.904" starttime="20190402 06:01:34.903"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:34.906" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:34.906" starttime="20190402 06:01:34.905"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:34.907" level="INFO">0</msg>
<msg timestamp="20190402 06:01:34.907" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:34.907" starttime="20190402 06:01:34.906"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:34.907" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:34.907" starttime="20190402 06:01:34.907"></status>
</kw>
<msg timestamp="20190402 06:01:34.907" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:34.907" starttime="20190402 06:01:34.904"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:34.908" starttime="20190402 06:01:34.908"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:34.908" starttime="20190402 06:01:34.907"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:34.908" starttime="20190402 06:01:34.908"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:34.909" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f1']                       |
| datanetworks | [u'physnet1']                        |
| imac         | 3c:fd:fe:be:e0:e5                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | c836334b-2c07-4687-a09c-a337212a6f06 |
| ihost_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-02T11:49:47.541842+00:00     |
| updated_at   | 2019-04-02T11:50:19.250904+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:34.909" starttime="20190402 06:01:34.909"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:34.909" starttime="20190402 06:01:33.315"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:34.909" starttime="20190402 06:01:33.314"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:34.909" starttime="20190402 06:01:23.537"></status>
</kw>
<kw name="Enable Containerized Services" library="Utils">
<doc>apply all the node labels for each controller
and compute functions.</doc>
<arguments>
<arg>${second_controller}</arg>
</arguments>
<kw name="Evaluate" library="BuiltIn">
<doc>Evaluates the given expression in Python and returns the results.</doc>
<arguments>
<arg>"controller" in """${host}"""</arg>
</arguments>
<assign>
<var>${is_controller}</var>
</assign>
<msg timestamp="20190402 06:01:34.910" level="INFO">${is_controller} = True</msg>
<status status="PASS" endtime="20190402 06:01:34.910" starttime="20190402 06:01:34.910"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-control-plane=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openstack-control-plane=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:34.911" starttime="20190402 06:01:34.911"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:34.912" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:34.912" starttime="20190402 06:01:34.911"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:34.912" starttime="20190402 06:01:34.912"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:34.912" starttime="20190402 06:01:34.912"></status>
</kw>
<msg timestamp="20190402 06:01:34.912" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:34.913" starttime="20190402 06:01:34.911"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:34.913" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:34.913" starttime="20190402 06:01:34.913"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:34.914" level="INFO">system host-label-assign controller-1  openstack-control-plane=enabled</msg>
<status status="PASS" endtime="20190402 06:01:34.914" starttime="20190402 06:01:34.913"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:35.987" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | e12da53e-fd74-4d6e-ab3c-c56e1020559f |
| host_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| label_key   | openstack-control-plane              |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:35.987" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | e12da53e-fd74-4d...</msg>
<status status="PASS" endtime="20190402 06:01:35.987" starttime="20190402 06:01:34.915"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:35.988" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:35.988" starttime="20190402 06:01:35.988"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:35.988" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | e12da53e-fd74-4d...</msg>
<status status="PASS" endtime="20190402 06:01:35.988" starttime="20190402 06:01:35.988"></status>
</kw>
<msg timestamp="20190402 06:01:35.988" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | e12da53e-fd74-4d...</msg>
<status status="PASS" endtime="20190402 06:01:35.988" starttime="20190402 06:01:35.987"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:35.990" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:35.991" starttime="20190402 06:01:35.989"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:35.991" level="INFO">0</msg>
<msg timestamp="20190402 06:01:35.991" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:35.991" starttime="20190402 06:01:35.991"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:35.991" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:35.991" starttime="20190402 06:01:35.991"></status>
</kw>
<msg timestamp="20190402 06:01:35.992" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:35.992" starttime="20190402 06:01:35.989"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:35.992" starttime="20190402 06:01:35.992"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:35.992" starttime="20190402 06:01:35.992"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:35.993" starttime="20190402 06:01:35.992"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:35.993" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | e12da53e-fd74-4d6e-ab3c-c56e1020559f |
| host_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| label_key   | openstack-control-plane              |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:35.993" starttime="20190402 06:01:35.993"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:35.993" starttime="20190402 06:01:34.910"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:35.993" starttime="20190402 06:01:34.910"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}'=='Simplex' or '${CONFIGURATION_TYPE}'=='Duplex' or ${is_controller}==False</arg>
<arg>Run Keywords</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:35.995" starttime="20190402 06:01:35.995"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:35.996" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:35.996" starttime="20190402 06:01:35.995"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:35.996" starttime="20190402 06:01:35.996"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:35.997" starttime="20190402 06:01:35.996"></status>
</kw>
<msg timestamp="20190402 06:01:35.997" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:35.997" starttime="20190402 06:01:35.995"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:35.997" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:35.997" starttime="20190402 06:01:35.997"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:35.999" level="INFO">system host-label-assign controller-1  openstack-compute-node=enabled</msg>
<status status="PASS" endtime="20190402 06:01:35.999" starttime="20190402 06:01:35.997"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:37.061" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | fea96396-98ed-427b-939e-c131673acfc8 |
| host_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| label_key   | openstack-compute-node               |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:37.062" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | fea96396-98ed-42...</msg>
<status status="PASS" endtime="20190402 06:01:37.062" starttime="20190402 06:01:35.999"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:37.062" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:37.062" starttime="20190402 06:01:37.062"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:37.063" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | fea96396-98ed-42...</msg>
<status status="PASS" endtime="20190402 06:01:37.063" starttime="20190402 06:01:37.063"></status>
</kw>
<msg timestamp="20190402 06:01:37.063" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | fea96396-98ed-42...</msg>
<status status="PASS" endtime="20190402 06:01:37.063" starttime="20190402 06:01:37.062"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:37.065" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:37.065" starttime="20190402 06:01:37.063"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:37.066" level="INFO">0</msg>
<msg timestamp="20190402 06:01:37.066" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:37.066" starttime="20190402 06:01:37.065"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:37.066" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:37.066" starttime="20190402 06:01:37.066"></status>
</kw>
<msg timestamp="20190402 06:01:37.066" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:37.066" starttime="20190402 06:01:37.063"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:37.067" starttime="20190402 06:01:37.067"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:37.067" starttime="20190402 06:01:37.066"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:37.067" starttime="20190402 06:01:37.067"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:37.068" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | fea96396-98ed-427b-939e-c131673acfc8 |
| host_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| label_key   | openstack-compute-node               |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:37.068" starttime="20190402 06:01:37.067"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:37.068" starttime="20190402 06:01:35.995"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:37.068" starttime="20190402 06:01:37.068"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:37.069" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:37.069" starttime="20190402 06:01:37.069"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:37.070" starttime="20190402 06:01:37.069"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:37.070" starttime="20190402 06:01:37.070"></status>
</kw>
<msg timestamp="20190402 06:01:37.070" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:37.070" starttime="20190402 06:01:37.069"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:37.071" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:37.071" starttime="20190402 06:01:37.070"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:37.072" level="INFO">system host-label-assign controller-1  openvswitch=enabled</msg>
<status status="PASS" endtime="20190402 06:01:37.072" starttime="20190402 06:01:37.071"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:38.139" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | c9a19d5d-1095-4685-bfcc-8af6bb276be9 |
| host_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| label_key   | openvswitch                          |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:38.140" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | c9a19d5d-1095-46...</msg>
<status status="PASS" endtime="20190402 06:01:38.140" starttime="20190402 06:01:37.072"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:38.140" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:38.140" starttime="20190402 06:01:38.140"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:38.141" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | c9a19d5d-1095-46...</msg>
<status status="PASS" endtime="20190402 06:01:38.141" starttime="20190402 06:01:38.141"></status>
</kw>
<msg timestamp="20190402 06:01:38.141" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | c9a19d5d-1095-46...</msg>
<status status="PASS" endtime="20190402 06:01:38.141" starttime="20190402 06:01:38.140"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:38.143" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:38.143" starttime="20190402 06:01:38.141"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:38.143" level="INFO">0</msg>
<msg timestamp="20190402 06:01:38.143" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:38.143" starttime="20190402 06:01:38.143"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:38.144" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:38.144" starttime="20190402 06:01:38.143"></status>
</kw>
<msg timestamp="20190402 06:01:38.144" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:38.144" starttime="20190402 06:01:38.141"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:38.145" starttime="20190402 06:01:38.144"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:38.145" starttime="20190402 06:01:38.144"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:38.145" starttime="20190402 06:01:38.145"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:38.145" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | c9a19d5d-1095-4685-bfcc-8af6bb276be9 |
| host_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| label_key   | openvswitch                          |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:38.145" starttime="20190402 06:01:38.145"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:38.145" starttime="20190402 06:01:37.068"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:38.146" starttime="20190402 06:01:38.146"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:38.147" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:38.147" starttime="20190402 06:01:38.146"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:38.147" starttime="20190402 06:01:38.147"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:38.147" starttime="20190402 06:01:38.147"></status>
</kw>
<msg timestamp="20190402 06:01:38.148" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:38.148" starttime="20190402 06:01:38.146"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:38.148" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:38.148" starttime="20190402 06:01:38.148"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:38.149" level="INFO">system host-label-assign controller-1  sriov=enabled</msg>
<status status="PASS" endtime="20190402 06:01:38.150" starttime="20190402 06:01:38.148"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:39.207" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 46f512db-2d81-4e68-87d9-3c2b4966b011 |
| host_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| label_key   | sriov                                |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:39.208" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 46f512db-2d81-4e...</msg>
<status status="PASS" endtime="20190402 06:01:39.208" starttime="20190402 06:01:38.150"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:39.208" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:39.208" starttime="20190402 06:01:39.208"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:39.209" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 46f512db-2d81-4e...</msg>
<status status="PASS" endtime="20190402 06:01:39.209" starttime="20190402 06:01:39.208"></status>
</kw>
<msg timestamp="20190402 06:01:39.209" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 46f512db-2d81-4e...</msg>
<status status="PASS" endtime="20190402 06:01:39.209" starttime="20190402 06:01:39.208"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:39.211" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:39.211" starttime="20190402 06:01:39.209"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:39.211" level="INFO">0</msg>
<msg timestamp="20190402 06:01:39.212" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:39.212" starttime="20190402 06:01:39.211"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:39.212" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:39.212" starttime="20190402 06:01:39.212"></status>
</kw>
<msg timestamp="20190402 06:01:39.212" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:39.212" starttime="20190402 06:01:39.209"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:39.213" starttime="20190402 06:01:39.213"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:39.213" starttime="20190402 06:01:39.212"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:39.213" starttime="20190402 06:01:39.213"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:39.213" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 46f512db-2d81-4e68-87d9-3c2b4966b011 |
| host_uuid   | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| label_key   | sriov                                |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:39.213" starttime="20190402 06:01:39.213"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:39.214" starttime="20190402 06:01:38.146"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:39.214" starttime="20190402 06:01:35.994"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:39.214" starttime="20190402 06:01:35.993"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:39.214" starttime="20190402 06:01:34.909"></status>
</kw>
<kw name="Setup Partitions" library="Utils">
<doc>Setup required partition on specified host.</doc>
<arguments>
<arg>${second_controller}</arg>
<arg>${lgv_name}</arg>
<arg>${nova_size}</arg>
<arg>${cgts_part_size}</arg>
</arguments>
<kw name="Get Root Disk Device" library="Utils">
<doc>Get the root disk partition assigned to the specified
node</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<assign>
<var>${root_disk_device}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${host}</arg>
<arg>grep rootfs</arg>
<arg>awk '{print $4}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:01:39.215" level="INFO">${cmd} = system host-show controller-1|grep rootfs|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 06:01:39.215" starttime="20190402 06:01:39.215"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:39.216" starttime="20190402 06:01:39.215"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:39.216" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:39.216" starttime="20190402 06:01:39.216"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:39.217" starttime="20190402 06:01:39.216"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:39.217" starttime="20190402 06:01:39.217"></status>
</kw>
<msg timestamp="20190402 06:01:39.217" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:39.217" starttime="20190402 06:01:39.216"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:39.218" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:39.218" starttime="20190402 06:01:39.217"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:39.219" level="INFO">system host-show controller-1|grep roo tfs|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 06:01:39.219" starttime="20190402 06:01:39.218"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:40.244" level="INFO">sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:40.244" level="INFO">${output} = sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:40.244" starttime="20190402 06:01:39.219"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:40.245" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:40.245" starttime="20190402 06:01:40.245"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:40.246" level="INFO">${clean_out} = sda
</msg>
<status status="PASS" endtime="20190402 06:01:40.246" starttime="20190402 06:01:40.245"></status>
</kw>
<msg timestamp="20190402 06:01:40.246" level="INFO">${output} = sda
</msg>
<status status="PASS" endtime="20190402 06:01:40.246" starttime="20190402 06:01:40.245"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:40.248" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:40.248" starttime="20190402 06:01:40.246"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:40.248" level="INFO">0</msg>
<msg timestamp="20190402 06:01:40.248" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:40.248" starttime="20190402 06:01:40.248"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:40.249" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:40.249" starttime="20190402 06:01:40.248"></status>
</kw>
<msg timestamp="20190402 06:01:40.249" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:40.249" starttime="20190402 06:01:40.246"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:40.250" starttime="20190402 06:01:40.249"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:40.250" starttime="20190402 06:01:40.249"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:40.250" starttime="20190402 06:01:40.250"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:40.250" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: sda</msg>
<status status="PASS" endtime="20190402 06:01:40.250" starttime="20190402 06:01:40.250"></status>
</kw>
<msg timestamp="20190402 06:01:40.250" level="INFO">${result} = {u'stdout': u'sda', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:40.250" starttime="20190402 06:01:39.215"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${result.stdout.strip()}</arg>
</arguments>
<assign>
<var>${root_disk}</var>
</assign>
<msg timestamp="20190402 06:01:40.251" level="INFO">${root_disk} = sda</msg>
<status status="PASS" endtime="20190402 06:01:40.251" starttime="20190402 06:01:40.251"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host} --nowrap</arg>
<arg>grep ${root_disk}</arg>
<arg>awk '{print $4}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:01:40.251" level="INFO">${cmd} = system host-disk-list controller-1 --nowrap|grep sda|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 06:01:40.251" starttime="20190402 06:01:40.251"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${root_disk_device}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:40.252" starttime="20190402 06:01:40.252"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:40.253" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:40.253" starttime="20190402 06:01:40.252"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:40.253" starttime="20190402 06:01:40.253"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:40.253" starttime="20190402 06:01:40.253"></status>
</kw>
<msg timestamp="20190402 06:01:40.254" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:40.254" starttime="20190402 06:01:40.252"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:40.254" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:40.254" starttime="20190402 06:01:40.254"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:40.256" level="INFO">system host-disk-list controller-1 --n owrap|grep sda|awk '{print $4}'</msg>
<status status="PASS" endtime="20190402 06:01:40.256" starttime="20190402 06:01:40.254"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:41.297" level="INFO">/dev/sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:41.298" level="INFO">${output} = /dev/sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:41.298" starttime="20190402 06:01:40.256"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:41.298" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:41.298" starttime="20190402 06:01:41.298"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:41.299" level="INFO">${clean_out} = /dev/sda
</msg>
<status status="PASS" endtime="20190402 06:01:41.299" starttime="20190402 06:01:41.298"></status>
</kw>
<msg timestamp="20190402 06:01:41.299" level="INFO">${output} = /dev/sda
</msg>
<status status="PASS" endtime="20190402 06:01:41.299" starttime="20190402 06:01:41.298"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:41.301" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:41.301" starttime="20190402 06:01:41.299"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:41.301" level="INFO">0</msg>
<msg timestamp="20190402 06:01:41.301" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:41.301" starttime="20190402 06:01:41.301"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:41.301" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:41.302" starttime="20190402 06:01:41.301"></status>
</kw>
<msg timestamp="20190402 06:01:41.302" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:41.302" starttime="20190402 06:01:41.299"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:41.302" starttime="20190402 06:01:41.302"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:41.303" starttime="20190402 06:01:41.302"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:41.303" starttime="20190402 06:01:41.303"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:41.303" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: /dev/sda</msg>
<status status="PASS" endtime="20190402 06:01:41.303" starttime="20190402 06:01:41.303"></status>
</kw>
<msg timestamp="20190402 06:01:41.303" level="INFO">${root_disk_device} = {u'stdout': u'/dev/sda', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:41.303" starttime="20190402 06:01:40.252"></status>
</kw>
<msg timestamp="20190402 06:01:41.304" level="INFO">${root_disk_device} = /dev/sda</msg>
<status status="PASS" endtime="20190402 06:01:41.304" starttime="20190402 06:01:39.214"></status>
</kw>
<kw name="Get Disk List UID" library="Utils">
<doc>Returns the UID of the disk given the device node and
host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_device}</arg>
</arguments>
<assign>
<var>${root_disk_uuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host}</arg>
<arg>grep ${device_node}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:01:41.304" level="INFO">${system_cmd} = system host-disk-list controller-1|grep /dev/sda|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 06:01:41.304" starttime="20190402 06:01:41.304"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:41.305" starttime="20190402 06:01:41.305"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:41.306" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:41.306" starttime="20190402 06:01:41.305"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:41.306" starttime="20190402 06:01:41.306"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:41.306" starttime="20190402 06:01:41.306"></status>
</kw>
<msg timestamp="20190402 06:01:41.307" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:41.307" starttime="20190402 06:01:41.305"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:41.307" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:41.307" starttime="20190402 06:01:41.307"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:41.309" level="INFO">system host-disk-list controller-1|gre p /dev/sda|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 06:01:41.309" starttime="20190402 06:01:41.307"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:42.367" level="INFO">37ba36e6-9632-4ee8-88af-c64401a4c681
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:42.367" level="INFO">${output} = 37ba36e6-9632-4ee8-88af-c64401a4c681
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:42.367" starttime="20190402 06:01:41.309"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:42.368" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:42.368" starttime="20190402 06:01:42.368"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:42.368" level="INFO">${clean_out} = 37ba36e6-9632-4ee8-88af-c64401a4c681
</msg>
<status status="PASS" endtime="20190402 06:01:42.368" starttime="20190402 06:01:42.368"></status>
</kw>
<msg timestamp="20190402 06:01:42.368" level="INFO">${output} = 37ba36e6-9632-4ee8-88af-c64401a4c681
</msg>
<status status="PASS" endtime="20190402 06:01:42.368" starttime="20190402 06:01:42.367"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:42.370" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:42.370" starttime="20190402 06:01:42.369"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:42.371" level="INFO">0</msg>
<msg timestamp="20190402 06:01:42.371" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:42.371" starttime="20190402 06:01:42.370"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:42.371" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:42.371" starttime="20190402 06:01:42.371"></status>
</kw>
<msg timestamp="20190402 06:01:42.371" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:42.371" starttime="20190402 06:01:42.368"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:42.372" starttime="20190402 06:01:42.372"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:42.372" starttime="20190402 06:01:42.371"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:42.372" starttime="20190402 06:01:42.372"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:42.373" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 37ba36e6-9632-4ee8-88af-c64401a4c681</msg>
<status status="PASS" endtime="20190402 06:01:42.373" starttime="20190402 06:01:42.372"></status>
</kw>
<msg timestamp="20190402 06:01:42.373" level="INFO">&amp;{result} = { stdout=37ba36e6-9632-4ee8-88af-c64401a4c681 | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:01:42.373" starttime="20190402 06:01:41.304"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${uid}</var>
</assign>
<msg timestamp="20190402 06:01:42.373" level="INFO">${uid} = 37ba36e6-9632-4ee8-88af-c64401a4c681</msg>
<status status="PASS" endtime="20190402 06:01:42.373" starttime="20190402 06:01:42.373"></status>
</kw>
<msg timestamp="20190402 06:01:42.374" level="INFO">${root_disk_uuid} = 37ba36e6-9632-4ee8-88af-c64401a4c681</msg>
<status status="PASS" endtime="20190402 06:01:42.374" starttime="20190402 06:01:41.304"></status>
</kw>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controller-0'</arg>
<arg>Ready</arg>
<arg>Creating</arg>
</arguments>
<assign>
<var>${part_status}</var>
</assign>
<msg timestamp="20190402 06:01:42.374" level="INFO">${part_status} = Creating</msg>
<status status="PASS" endtime="20190402 06:01:42.374" starttime="20190402 06:01:42.374"></status>
</kw>
<kw name="Evaluate" library="BuiltIn">
<doc>Evaluates the given expression in Python and returns the results.</doc>
<arguments>
<arg>"controller" in """${host}"""</arg>
</arguments>
<assign>
<var>${is_controller}</var>
</assign>
<msg timestamp="20190402 06:01:42.374" level="INFO">${is_controller} = True</msg>
<status status="PASS" endtime="20190402 06:01:42.374" starttime="20190402 06:01:42.374"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${nova_size}==True</arg>
<arg>Calcultae Nova Partition Size For Computes</arg>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>ELSE</arg>
<arg>Set Variable</arg>
<arg>${nova_size}</arg>
</arguments>
<assign>
<var>${nova_size}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${nova_size}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:42.375" starttime="20190402 06:01:42.375"></status>
</kw>
<msg timestamp="20190402 06:01:42.375" level="INFO">${nova_size} = 100</msg>
<status status="PASS" endtime="20190402 06:01:42.375" starttime="20190402 06:01:42.374"></status>
</kw>
<kw name="Add Disk Partition" library="Utils">
<doc>Add a partition for specified disk on the specified host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${nova_size}</arg>
<arg>${part_status}</arg>
</arguments>
<assign>
<var>${nova_partition_uuid}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-disk-partition-add ${host} ${uid} ${size} -t lvm_phys_vol</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:42.376" starttime="20190402 06:01:42.376"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:42.377" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:42.377" starttime="20190402 06:01:42.376"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:42.377" starttime="20190402 06:01:42.377"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:42.378" starttime="20190402 06:01:42.377"></status>
</kw>
<msg timestamp="20190402 06:01:42.378" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:42.378" starttime="20190402 06:01:42.376"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:42.378" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:42.378" starttime="20190402 06:01:42.378"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:42.380" level="INFO">system host-disk-partition-add control ler-1 37ba36e6-9632-4ee8-88af-c64401a4c681 100 -t lvm_phys_vol</msg>
<status status="PASS" endtime="20190402 06:01:42.380" starttime="20190402 06:01:42.378"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:43.518" level="INFO">+-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| device_node | /dev/sda5                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 102400                                           |
| uuid        | 85333ee6-2ead-46da-8e3e-bd41bf58c04e             |
| ihost_uuid  | 7e3e37c8-5ee4-424c-b253-7335a13f97dd             |
| idisk_uuid  | 37ba36e6-9632-4ee8-88af-c64401a4c681             |
| ipv_uuid    | None                                             |
| status      | Creating (on unlock)                             |
| created_at  | 2019-04-02T11:50:27.919492+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:43.518" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:43.518" starttime="20190402 06:01:42.381"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:43.519" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:43.519" starttime="20190402 06:01:43.519"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:43.519" level="INFO">${clean_out} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:43.519" starttime="20190402 06:01:43.519"></status>
</kw>
<msg timestamp="20190402 06:01:43.520" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:43.520" starttime="20190402 06:01:43.518"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:43.521" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:43.521" starttime="20190402 06:01:43.520"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:43.522" level="INFO">0</msg>
<msg timestamp="20190402 06:01:43.522" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:43.522" starttime="20190402 06:01:43.521"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:43.522" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:43.522" starttime="20190402 06:01:43.522"></status>
</kw>
<msg timestamp="20190402 06:01:43.522" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:43.522" starttime="20190402 06:01:43.520"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:43.523" starttime="20190402 06:01:43.523"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:43.523" starttime="20190402 06:01:43.522"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:43.523" starttime="20190402 06:01:43.523"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:43.524" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| device_node | /dev/sda5                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 102400                                           |
| uuid        | 85333ee6-2ead-46da-8e3e-bd41bf58c04e             |
| ihost_uuid  | 7e3e37c8-5ee4-424c-b253-7335a13f97dd             |
| idisk_uuid  | 37ba36e6-9632-4ee8-88af-c64401a4c681             |
| ipv_uuid    | None                                             |
| status      | Creating (on unlock)                             |
| created_at  | 2019-04-02T11:50:27.919492+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:43.524" starttime="20190402 06:01:43.523"></status>
</kw>
<msg timestamp="20190402 06:01:43.524" level="INFO">${result} = {u'stdout': u'+-------------+--------------------------------------------------+\r\n| Property    | Value                                            |\r\n+-------------+-------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:43.524" starttime="20190402 06:01:42.375"></status>
</kw>
<kw name="Get Property From Result" library="Utils">
<arguments>
<arg>${result}</arg>
<arg>uuid</arg>
</arguments>
<assign>
<var>${new_uid}</var>
</assign>
<kw name="String To Dict" library="common">
<doc>Convert string table to dictionary</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 06:01:43.525" level="INFO">${dict} = {'Property': {'status': {'Value': 'Creating (on unlock)'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '85333ee6-2ea...</msg>
<status status="PASS" endtime="20190402 06:01:43.525" starttime="20190402 06:01:43.524"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Property</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 06:01:43.525" level="INFO">${dict} = {'status': {'Value': 'Creating (on unlock)'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '85333ee6-2ead-46da-8e3e-b...</msg>
<status status="PASS" endtime="20190402 06:01:43.525" starttime="20190402 06:01:43.525"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 06:01:43.525" level="INFO">${dict} = {'Value': '85333ee6-2ead-46da-8e3e-bd41bf58c04e'}</msg>
<status status="PASS" endtime="20190402 06:01:43.525" starttime="20190402 06:01:43.525"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Value</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 06:01:43.526" level="INFO">${dict} = 85333ee6-2ead-46da-8e3e-bd41bf58c04e</msg>
<status status="PASS" endtime="20190402 06:01:43.526" starttime="20190402 06:01:43.525"></status>
</kw>
<msg timestamp="20190402 06:01:43.526" level="INFO">${new_uid} = 85333ee6-2ead-46da-8e3e-bd41bf58c04e</msg>
<status status="PASS" endtime="20190402 06:01:43.526" starttime="20190402 06:01:43.524"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>30 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value Of Command</arg>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:43.527" starttime="20190402 06:01:43.527"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:43.528" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:43.528" starttime="20190402 06:01:43.528"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:43.529" starttime="20190402 06:01:43.528"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:43.529" starttime="20190402 06:01:43.529"></status>
</kw>
<msg timestamp="20190402 06:01:43.529" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:43.529" starttime="20190402 06:01:43.528"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:43.529" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:43.530" starttime="20190402 06:01:43.529"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:43.545" level="INFO">system host-disk-partition-show contro ller-1 85333ee6-2ead-46da-8e3e-bd41bf58c04e | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:43.545" starttime="20190402 06:01:43.530"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:44.579" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:44.579" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:44.579" starttime="20190402 06:01:43.546"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:44.580" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:44.580" starttime="20190402 06:01:44.580"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:44.580" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190402 06:01:44.580" starttime="20190402 06:01:44.580"></status>
</kw>
<msg timestamp="20190402 06:01:44.580" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190402 06:01:44.580" starttime="20190402 06:01:44.579"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:44.582" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:44.582" starttime="20190402 06:01:44.581"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:44.583" level="INFO">0</msg>
<msg timestamp="20190402 06:01:44.583" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:44.583" starttime="20190402 06:01:44.582"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:44.583" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:44.583" starttime="20190402 06:01:44.583"></status>
</kw>
<msg timestamp="20190402 06:01:44.583" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:44.583" starttime="20190402 06:01:44.580"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:44.584" starttime="20190402 06:01:44.584"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:44.584" starttime="20190402 06:01:44.583"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:44.584" starttime="20190402 06:01:44.584"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:44.584" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190402 06:01:44.585" starttime="20190402 06:01:44.584"></status>
</kw>
<msg timestamp="20190402 06:01:44.585" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:44.585" starttime="20190402 06:01:43.527"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:01:44.585" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190402 06:01:44.585" starttime="20190402 06:01:44.585"></status>
</kw>
<msg timestamp="20190402 06:01:44.585" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190402 06:01:44.585" starttime="20190402 06:01:43.526"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:44.586" starttime="20190402 06:01:44.586"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:44.586" starttime="20190402 06:01:43.526"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:44.586" starttime="20190402 06:01:43.526"></status>
</kw>
<msg timestamp="20190402 06:01:44.586" level="INFO">${nova_partition_uuid} = 85333ee6-2ead-46da-8e3e-bd41bf58c04e</msg>
<status status="PASS" endtime="20190402 06:01:44.586" starttime="20190402 06:01:42.375"></status>
</kw>
<kw name="Add Local Volume Group" library="Utils">
<doc>Adds a local volume group according to given options.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-lvg-add ${host} ${lvg_name}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:44.587" starttime="20190402 06:01:44.587"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:44.588" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:44.588" starttime="20190402 06:01:44.587"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:44.588" starttime="20190402 06:01:44.588"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:44.588" starttime="20190402 06:01:44.588"></status>
</kw>
<msg timestamp="20190402 06:01:44.589" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:44.589" starttime="20190402 06:01:44.587"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:44.589" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:44.589" starttime="20190402 06:01:44.589"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:44.596" level="INFO">system host-lvg-add controller-1 nova- local</msg>
<status status="PASS" endtime="20190402 06:01:44.596" starttime="20190402 06:01:44.589"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:45.626" level="INFO">+-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+-----------------------+-------------------------------------------------------------------+
| lvm_vg_name           | nova-local                                                        |
| vg_state              | adding                                                            |
| uuid                  | 279cb262-73cb-4e03-9ec8-7d4f6654b571                              |
| ihost_uuid            | 7e3e37c8-5ee4-424c-b253-7335a13f97dd                              |
| lvm_vg_access         | None                                                              |
| lvm_max_lv            | 0                                                                 |
| lvm_cur_lv            | 0                                                                 |
| lvm_max_pv            | 0                                                                 |
| lvm_cur_pv            | 0                                                                 |
| lvm_vg_size_gib       | 0.0                                                               |
| lvm_vg_avail_size_gib | 0.0                                                               |
| lvm_vg_total_pe       | 0                                                                 |
| lvm_vg_free_pe        | 0                                                                 |
| created_at            | 2019-04-02T11:50:30.035126+00:00                                  |
| updated_at            | None                                                              |
| parameters            | {u'concurrent_disk_operations': 2, u'instance_backing': u'image'} |
+-----------------------+-------------------------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:45.627" level="INFO">${output} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190402 06:01:45.627" starttime="20190402 06:01:44.596"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:45.628" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:45.628" starttime="20190402 06:01:45.627"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:45.628" level="INFO">${clean_out} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190402 06:01:45.628" starttime="20190402 06:01:45.628"></status>
</kw>
<msg timestamp="20190402 06:01:45.628" level="INFO">${output} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190402 06:01:45.628" starttime="20190402 06:01:45.627"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:45.630" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:45.630" starttime="20190402 06:01:45.629"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:45.631" level="INFO">0</msg>
<msg timestamp="20190402 06:01:45.631" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:45.631" starttime="20190402 06:01:45.630"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:45.632" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:45.632" starttime="20190402 06:01:45.631"></status>
</kw>
<msg timestamp="20190402 06:01:45.632" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:45.632" starttime="20190402 06:01:45.628"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:45.633" starttime="20190402 06:01:45.633"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:45.633" starttime="20190402 06:01:45.632"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:45.633" starttime="20190402 06:01:45.633"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:45.633" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+-----------------------+-------------------------------------------------------------------+
| lvm_vg_name           | nova-local                                                        |
| vg_state              | adding                                                            |
| uuid                  | 279cb262-73cb-4e03-9ec8-7d4f6654b571                              |
| ihost_uuid            | 7e3e37c8-5ee4-424c-b253-7335a13f97dd                              |
| lvm_vg_access         | None                                                              |
| lvm_max_lv            | 0                                                                 |
| lvm_cur_lv            | 0                                                                 |
| lvm_max_pv            | 0                                                                 |
| lvm_cur_pv            | 0                                                                 |
| lvm_vg_size_gib       | 0.0                                                               |
| lvm_vg_avail_size_gib | 0.0                                                               |
| lvm_vg_total_pe       | 0                                                                 |
| lvm_vg_free_pe        | 0                                                                 |
| created_at            | 2019-04-02T11:50:30.035126+00:00                                  |
| updated_at            | None                                                              |
| parameters            | {u'concurrent_disk_operations': 2, u'instance_backing': u'image'} |
+-----------------------+-------------------------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:45.634" starttime="20190402 06:01:45.633"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:45.634" starttime="20190402 06:01:44.586"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:45.634" starttime="20190402 06:01:44.586"></status>
</kw>
<kw name="Add Physical Volume" library="Utils">
<doc>Adds a physical volume to the specified host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${nova_partition_uuid}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-pv-add ${host} ${lvg name} ${uid}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:45.635" starttime="20190402 06:01:45.635"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:45.636" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:45.636" starttime="20190402 06:01:45.635"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:45.636" starttime="20190402 06:01:45.636"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:45.636" starttime="20190402 06:01:45.636"></status>
</kw>
<msg timestamp="20190402 06:01:45.636" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:45.637" starttime="20190402 06:01:45.635"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:45.637" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:45.637" starttime="20190402 06:01:45.637"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:45.649" level="INFO">system host-pv-add controller-1 nova-l ocal 85333ee6-2ead-46da-8e3e-bd41bf58c04e</msg>
<status status="PASS" endtime="20190402 06:01:45.649" starttime="20190402 06:01:45.637"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:46.774" level="INFO">+--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | 4cffa7fa-cac2-4ef9-8ca2-62ff3c67aea8             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 85333ee6-2ead-46da-8e3e-bd41bf58c04e             |
| disk_or_part_device_node | /dev/sda5                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| lvm_pv_name              | /dev/sda5                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | 7e3e37c8-5ee4-424c-b253-7335a13f97dd             |
| created_at               | 2019-04-02T11:50:31.168707+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:46.774" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 06:01:46.774" starttime="20190402 06:01:45.649"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:46.775" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:46.775" starttime="20190402 06:01:46.775"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:46.776" level="INFO">${clean_out} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 06:01:46.776" starttime="20190402 06:01:46.775"></status>
</kw>
<msg timestamp="20190402 06:01:46.776" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 06:01:46.776" starttime="20190402 06:01:46.775"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:46.778" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:46.778" starttime="20190402 06:01:46.776"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:46.778" level="INFO">0</msg>
<msg timestamp="20190402 06:01:46.778" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:46.778" starttime="20190402 06:01:46.778"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:46.779" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:46.779" starttime="20190402 06:01:46.779"></status>
</kw>
<msg timestamp="20190402 06:01:46.779" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:46.779" starttime="20190402 06:01:46.776"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:46.780" starttime="20190402 06:01:46.779"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:46.780" starttime="20190402 06:01:46.779"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:46.780" starttime="20190402 06:01:46.780"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:46.781" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | 4cffa7fa-cac2-4ef9-8ca2-62ff3c67aea8             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 85333ee6-2ead-46da-8e3e-bd41bf58c04e             |
| disk_or_part_device_node | /dev/sda5                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| lvm_pv_name              | /dev/sda5                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | 7e3e37c8-5ee4-424c-b253-7335a13f97dd             |
| created_at               | 2019-04-02T11:50:31.168707+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:46.781" starttime="20190402 06:01:46.780"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:46.781" starttime="20190402 06:01:45.634"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:46.781" starttime="20190402 06:01:45.634"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==False</arg>
<arg>Modify LVG Attributes</arg>
<arg>-b image</arg>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:46.781" starttime="20190402 06:01:46.781"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True or ${setup_cgts}==True</arg>
<arg>Add Disk Partition</arg>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>${part_status}</arg>
</arguments>
<assign>
<var>${cgts_partition_uuid}</var>
</assign>
<kw name="Add Disk Partition" library="Utils">
<doc>Add a partition for specified disk on the specified host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>${part_status}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-disk-partition-add ${host} ${uid} ${size} -t lvm_phys_vol</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:46.783" starttime="20190402 06:01:46.782"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:46.783" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:46.783" starttime="20190402 06:01:46.783"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:46.784" starttime="20190402 06:01:46.783"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:46.784" starttime="20190402 06:01:46.784"></status>
</kw>
<msg timestamp="20190402 06:01:46.784" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:46.784" starttime="20190402 06:01:46.783"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:46.785" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:46.785" starttime="20190402 06:01:46.784"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:46.800" level="INFO">system host-disk-partition-add control ler-1 37ba36e6-9632-4ee8-88af-c64401a4c681 20 -t lvm_phys_vol</msg>
<status status="PASS" endtime="20190402 06:01:46.800" starttime="20190402 06:01:46.785"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:47.919" level="INFO">+-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| device_node | /dev/sda6                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 20480                                            |
| uuid        | 957717fd-e652-48a8-8124-e774cdeb76b9             |
| ihost_uuid  | 7e3e37c8-5ee4-424c-b253-7335a13f97dd             |
| idisk_uuid  | 37ba36e6-9632-4ee8-88af-c64401a4c681             |
| ipv_uuid    | None                                             |
| status      | Creating (on unlock)                             |
| created_at  | 2019-04-02T11:50:32.323080+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:47.920" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:47.920" starttime="20190402 06:01:46.800"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:47.920" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:47.920" starttime="20190402 06:01:47.920"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:47.921" level="INFO">${clean_out} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:47.921" starttime="20190402 06:01:47.921"></status>
</kw>
<msg timestamp="20190402 06:01:47.921" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:47.921" starttime="20190402 06:01:47.920"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:47.923" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:47.923" starttime="20190402 06:01:47.921"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:47.924" level="INFO">0</msg>
<msg timestamp="20190402 06:01:47.924" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:47.924" starttime="20190402 06:01:47.923"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:47.924" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:47.924" starttime="20190402 06:01:47.924"></status>
</kw>
<msg timestamp="20190402 06:01:47.924" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:47.924" starttime="20190402 06:01:47.921"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:47.925" starttime="20190402 06:01:47.925"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:47.925" starttime="20190402 06:01:47.924"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:47.925" starttime="20190402 06:01:47.925"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:47.925" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| device_node | /dev/sda6                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 20480                                            |
| uuid        | 957717fd-e652-48a8-8124-e774cdeb76b9             |
| ihost_uuid  | 7e3e37c8-5ee4-424c-b253-7335a13f97dd             |
| idisk_uuid  | 37ba36e6-9632-4ee8-88af-c64401a4c681             |
| ipv_uuid    | None                                             |
| status      | Creating (on unlock)                             |
| created_at  | 2019-04-02T11:50:32.323080+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:47.926" starttime="20190402 06:01:47.925"></status>
</kw>
<msg timestamp="20190402 06:01:47.926" level="INFO">${result} = {u'stdout': u'+-------------+--------------------------------------------------+\r\n| Property    | Value                                            |\r\n+-------------+-------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:47.926" starttime="20190402 06:01:46.782"></status>
</kw>
<kw name="Get Property From Result" library="Utils">
<arguments>
<arg>${result}</arg>
<arg>uuid</arg>
</arguments>
<assign>
<var>${new_uid}</var>
</assign>
<kw name="String To Dict" library="common">
<doc>Convert string table to dictionary</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 06:01:47.927" level="INFO">${dict} = {'Property': {'status': {'Value': 'Creating (on unlock)'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '957717fd-e65...</msg>
<status status="PASS" endtime="20190402 06:01:47.927" starttime="20190402 06:01:47.926"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Property</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 06:01:47.927" level="INFO">${dict} = {'status': {'Value': 'Creating (on unlock)'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '957717fd-e652-48a8-8124-e...</msg>
<status status="PASS" endtime="20190402 06:01:47.927" starttime="20190402 06:01:47.927"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 06:01:47.927" level="INFO">${dict} = {'Value': '957717fd-e652-48a8-8124-e774cdeb76b9'}</msg>
<status status="PASS" endtime="20190402 06:01:47.927" starttime="20190402 06:01:47.927"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Value</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190402 06:01:47.928" level="INFO">${dict} = 957717fd-e652-48a8-8124-e774cdeb76b9</msg>
<status status="PASS" endtime="20190402 06:01:47.928" starttime="20190402 06:01:47.928"></status>
</kw>
<msg timestamp="20190402 06:01:47.928" level="INFO">${new_uid} = 957717fd-e652-48a8-8124-e774cdeb76b9</msg>
<status status="PASS" endtime="20190402 06:01:47.928" starttime="20190402 06:01:47.926"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>30 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value Of Command</arg>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:47.930" starttime="20190402 06:01:47.929"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:47.930" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:47.930" starttime="20190402 06:01:47.930"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:47.931" starttime="20190402 06:01:47.930"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:47.931" starttime="20190402 06:01:47.931"></status>
</kw>
<msg timestamp="20190402 06:01:47.931" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:47.931" starttime="20190402 06:01:47.930"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:47.931" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:47.931" starttime="20190402 06:01:47.931"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:47.934" level="INFO">system host-disk-partition-show contro ller-1 957717fd-e652-48a8-8124-e774cdeb76b9 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:47.934" starttime="20190402 06:01:47.932"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:48.942" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:48.942" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:48.942" starttime="20190402 06:01:47.934"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:48.943" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:48.943" starttime="20190402 06:01:48.942"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:48.943" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190402 06:01:48.943" starttime="20190402 06:01:48.943"></status>
</kw>
<msg timestamp="20190402 06:01:48.943" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190402 06:01:48.943" starttime="20190402 06:01:48.942"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:48.945" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:48.945" starttime="20190402 06:01:48.943"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:48.946" level="INFO">0</msg>
<msg timestamp="20190402 06:01:48.946" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:48.946" starttime="20190402 06:01:48.945"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:48.946" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:48.946" starttime="20190402 06:01:48.946"></status>
</kw>
<msg timestamp="20190402 06:01:48.946" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:48.946" starttime="20190402 06:01:48.943"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:48.947" starttime="20190402 06:01:48.947"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:48.947" starttime="20190402 06:01:48.946"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:48.948" starttime="20190402 06:01:48.947"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:48.948" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190402 06:01:48.948" starttime="20190402 06:01:48.948"></status>
</kw>
<msg timestamp="20190402 06:01:48.948" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:48.948" starttime="20190402 06:01:47.929"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:01:48.948" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190402 06:01:48.948" starttime="20190402 06:01:48.948"></status>
</kw>
<msg timestamp="20190402 06:01:48.949" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190402 06:01:48.949" starttime="20190402 06:01:47.929"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:48.949" starttime="20190402 06:01:48.949"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:48.949" starttime="20190402 06:01:47.928"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:48.949" starttime="20190402 06:01:47.928"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:48.949" starttime="20190402 06:01:46.782"></status>
</kw>
<msg timestamp="20190402 06:01:48.949" level="INFO">${cgts_partition_uuid} = 957717fd-e652-48a8-8124-e774cdeb76b9</msg>
<status status="PASS" endtime="20190402 06:01:48.949" starttime="20190402 06:01:46.781"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True or ${setup_cgts}==True</arg>
<arg>Add Physical Volume</arg>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${cgts_partition_uuid}</arg>
</arguments>
<kw name="Add Physical Volume" library="Utils">
<doc>Adds a physical volume to the specified host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${cgts_partition_uuid}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-pv-add ${host} ${lvg name} ${uid}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:48.951" starttime="20190402 06:01:48.951"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:48.951" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:48.952" starttime="20190402 06:01:48.951"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:48.952" starttime="20190402 06:01:48.952"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:48.952" starttime="20190402 06:01:48.952"></status>
</kw>
<msg timestamp="20190402 06:01:48.952" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:48.952" starttime="20190402 06:01:48.951"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:48.953" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:48.953" starttime="20190402 06:01:48.953"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:48.964" level="INFO">system host-pv-add controller-1 nova-l ocal 957717fd-e652-48a8-8124-e774cdeb76b9</msg>
<status status="PASS" endtime="20190402 06:01:48.964" starttime="20190402 06:01:48.953"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:50.084" level="INFO">+--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | ea9ca8a5-2157-4a2e-9ca2-de1e6659ef4c             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 957717fd-e652-48a8-8124-e774cdeb76b9             |
| disk_or_part_device_node | /dev/sda6                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| lvm_pv_name              | /dev/sda6                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | 7e3e37c8-5ee4-424c-b253-7335a13f97dd             |
| created_at               | 2019-04-02T11:50:34.469002+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:50.084" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 06:01:50.084" starttime="20190402 06:01:48.964"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:50.085" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:50.085" starttime="20190402 06:01:50.084"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:50.085" level="INFO">${clean_out} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 06:01:50.085" starttime="20190402 06:01:50.085"></status>
</kw>
<msg timestamp="20190402 06:01:50.085" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190402 06:01:50.085" starttime="20190402 06:01:50.084"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:50.087" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:50.087" starttime="20190402 06:01:50.086"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:50.087" level="INFO">0</msg>
<msg timestamp="20190402 06:01:50.088" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:50.088" starttime="20190402 06:01:50.087"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:50.088" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:50.088" starttime="20190402 06:01:50.088"></status>
</kw>
<msg timestamp="20190402 06:01:50.088" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:50.088" starttime="20190402 06:01:50.085"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:50.089" starttime="20190402 06:01:50.089"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:50.089" starttime="20190402 06:01:50.088"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:50.089" starttime="20190402 06:01:50.089"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:50.089" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | ea9ca8a5-2157-4a2e-9ca2-de1e6659ef4c             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 957717fd-e652-48a8-8124-e774cdeb76b9             |
| disk_or_part_device_node | /dev/sda6                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| lvm_pv_name              | /dev/sda6                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | 7e3e37c8-5ee4-424c-b253-7335a13f97dd             |
| created_at               | 2019-04-02T11:50:34.469002+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:50.089" starttime="20190402 06:01:50.089"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:50.090" starttime="20190402 06:01:48.950"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:50.090" starttime="20190402 06:01:48.950"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:50.090" starttime="20190402 06:01:48.950"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:50.090" starttime="20190402 06:01:39.214"></status>
</kw>
<kw name="Configure Ceph" library="Utils">
<doc>Enable CEPH partition on the specified node</doc>
<arguments>
<arg>${second_controller}</arg>
<arg>${backend_type}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-0'</arg>
<arg>Run Keywords</arg>
<arg>Add LVM Storage Backend</arg>
<arg>${backend_type}</arg>
<arg>--confirmed</arg>
<arg>AND</arg>
<arg>Check Ceph Status</arg>
<arg>HEALTH_ERR</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:50.091" starttime="20190402 06:01:50.090"></status>
</kw>
<kw name="Add ODS To Tier" library="Utils">
<doc>Enable the ODS on the specified node.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>/dev/sdb</arg>
</arguments>
<assign>
<var>${device}</var>
</assign>
<msg timestamp="20190402 06:01:50.091" level="INFO">${device} = /dev/sdb</msg>
<status status="PASS" endtime="20190402 06:01:50.091" starttime="20190402 06:01:50.091"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>ceph_cluster</arg>
</arguments>
<assign>
<var>${tier_name}</var>
</assign>
<msg timestamp="20190402 06:01:50.091" level="INFO">${tier_name} = ceph_cluster</msg>
<status status="PASS" endtime="20190402 06:01:50.091" starttime="20190402 06:01:50.091"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${SPACE}</arg>
</arguments>
<assign>
<var>${tier_opt}</var>
</assign>
<msg timestamp="20190402 06:01:50.092" level="INFO">${tier_opt} =  </msg>
<status status="PASS" endtime="20190402 06:01:50.092" starttime="20190402 06:01:50.091"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host}</arg>
<arg>grep ${device}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:01:50.092" level="INFO">${cmd} = system host-disk-list controller-1|grep /dev/sdb|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 06:01:50.092" starttime="20190402 06:01:50.092"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:50.093" starttime="20190402 06:01:50.093"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:50.094" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:50.094" starttime="20190402 06:01:50.093"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:50.094" starttime="20190402 06:01:50.094"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:50.094" starttime="20190402 06:01:50.094"></status>
</kw>
<msg timestamp="20190402 06:01:50.095" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:50.095" starttime="20190402 06:01:50.093"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:50.095" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:50.095" starttime="20190402 06:01:50.095"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:50.106" level="INFO">system host-disk-list controller-1|gre p /dev/sdb|awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 06:01:50.106" starttime="20190402 06:01:50.095"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:51.190" level="INFO">1e1d7bd5-1096-4eb8-b25d-4de20eb121f3
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:51.190" level="INFO">${output} = 1e1d7bd5-1096-4eb8-b25d-4de20eb121f3
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:51.190" starttime="20190402 06:01:50.106"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:51.191" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:51.191" starttime="20190402 06:01:51.190"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:51.191" level="INFO">${clean_out} = 1e1d7bd5-1096-4eb8-b25d-4de20eb121f3
</msg>
<status status="PASS" endtime="20190402 06:01:51.191" starttime="20190402 06:01:51.191"></status>
</kw>
<msg timestamp="20190402 06:01:51.191" level="INFO">${output} = 1e1d7bd5-1096-4eb8-b25d-4de20eb121f3
</msg>
<status status="PASS" endtime="20190402 06:01:51.191" starttime="20190402 06:01:51.190"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:51.193" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:51.193" starttime="20190402 06:01:51.192"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:51.193" level="INFO">0</msg>
<msg timestamp="20190402 06:01:51.193" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:51.193" starttime="20190402 06:01:51.193"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:51.194" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:51.194" starttime="20190402 06:01:51.194"></status>
</kw>
<msg timestamp="20190402 06:01:51.194" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:51.194" starttime="20190402 06:01:51.191"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:51.195" starttime="20190402 06:01:51.195"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:51.195" starttime="20190402 06:01:51.194"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:51.195" starttime="20190402 06:01:51.195"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:51.195" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 1e1d7bd5-1096-4eb8-b25d-4de20eb121f3</msg>
<status status="PASS" endtime="20190402 06:01:51.195" starttime="20190402 06:01:51.195"></status>
</kw>
<msg timestamp="20190402 06:01:51.196" level="INFO">${result} = {u'stdout': u'1e1d7bd5-1096-4eb8-b25d-4de20eb121f3', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:51.196" starttime="20190402 06:01:50.092"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>Get Tier UUID</arg>
<arg>${tier_name}</arg>
</arguments>
<assign>
<var>${tier_uuid}</var>
</assign>
<kw name="Get Tier UUID" library="Utils">
<doc>Returns the TIER uuid</doc>
<arguments>
<arg>${tier_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>storage</arg>
</arguments>
<assign>
<var>${name}</var>
</assign>
<msg timestamp="20190402 06:01:51.197" level="INFO">${name} = storage</msg>
<status status="PASS" endtime="20190402 06:01:51.197" starttime="20190402 06:01:51.196"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system storage-tier-list</arg>
<arg>${tier_name}</arg>
<arg>|grep ${name}</arg>
<arg>|awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:01:51.197" level="INFO">${cmd} = system storage-tier-list ceph_cluster |grep storage |awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 06:01:51.197" starttime="20190402 06:01:51.197"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${uuid}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:51.198" starttime="20190402 06:01:51.197"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:51.199" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:51.199" starttime="20190402 06:01:51.198"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:51.199" starttime="20190402 06:01:51.199"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:51.200" starttime="20190402 06:01:51.199"></status>
</kw>
<msg timestamp="20190402 06:01:51.200" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:51.200" starttime="20190402 06:01:51.198"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:51.200" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:51.200" starttime="20190402 06:01:51.200"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:51.210" level="INFO">system storage-tier-list ceph_cluster  |grep storage |awk '{print $2}'</msg>
<status status="PASS" endtime="20190402 06:01:51.210" starttime="20190402 06:01:51.200"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:52.285" level="INFO">02919f4d-97d2-40f4-a470-5beb3b7558c1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:52.285" level="INFO">${output} = 02919f4d-97d2-40f4-a470-5beb3b7558c1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:52.285" starttime="20190402 06:01:51.210"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:52.286" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:52.286" starttime="20190402 06:01:52.286"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:52.286" level="INFO">${clean_out} = 02919f4d-97d2-40f4-a470-5beb3b7558c1
</msg>
<status status="PASS" endtime="20190402 06:01:52.286" starttime="20190402 06:01:52.286"></status>
</kw>
<msg timestamp="20190402 06:01:52.287" level="INFO">${output} = 02919f4d-97d2-40f4-a470-5beb3b7558c1
</msg>
<status status="PASS" endtime="20190402 06:01:52.287" starttime="20190402 06:01:52.285"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:52.288" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:52.288" starttime="20190402 06:01:52.287"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:52.289" level="INFO">0</msg>
<msg timestamp="20190402 06:01:52.289" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:52.289" starttime="20190402 06:01:52.288"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:52.289" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:52.289" starttime="20190402 06:01:52.289"></status>
</kw>
<msg timestamp="20190402 06:01:52.289" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:52.289" starttime="20190402 06:01:52.287"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:52.290" starttime="20190402 06:01:52.290"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:52.290" starttime="20190402 06:01:52.289"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:52.290" starttime="20190402 06:01:52.290"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:52.291" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 02919f4d-97d2-40f4-a470-5beb3b7558c1</msg>
<status status="PASS" endtime="20190402 06:01:52.291" starttime="20190402 06:01:52.290"></status>
</kw>
<msg timestamp="20190402 06:01:52.291" level="INFO">${uuid} = {u'stdout': u'02919f4d-97d2-40f4-a470-5beb3b7558c1', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:52.291" starttime="20190402 06:01:51.197"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:52.291" starttime="20190402 06:01:51.196"></status>
</kw>
<msg timestamp="20190402 06:01:52.291" level="INFO">${tier_uuid} = 02919f4d-97d2-40f4-a470-5beb3b7558c1</msg>
<status status="PASS" endtime="20190402 06:01:52.291" starttime="20190402 06:01:51.196"></status>
</kw>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>--tier-uuid ${tier_uuid}</arg>
<arg>${EMPTY}</arg>
</arguments>
<assign>
<var>${tier_opt}</var>
</assign>
<msg timestamp="20190402 06:01:52.291" level="INFO">${tier_opt} = --tier-uuid 02919f4d-97d2-40f4-a470-5beb3b7558c1</msg>
<status status="PASS" endtime="20190402 06:01:52.292" starttime="20190402 06:01:52.291"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-stor-add ${host} ${result.stdout.strip()} ${tier_opt}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:52.292" starttime="20190402 06:01:52.292"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:52.293" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:52.293" starttime="20190402 06:01:52.293"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:52.293" starttime="20190402 06:01:52.293"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:52.294" starttime="20190402 06:01:52.293"></status>
</kw>
<msg timestamp="20190402 06:01:52.294" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:52.294" starttime="20190402 06:01:52.292"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:52.294" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:52.294" starttime="20190402 06:01:52.294"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:52.296" level="INFO">system host-stor-add controller-1 1e1d 7bd5-1096-4eb8-b25d-4de20eb121f3 --tier-uuid 02919f4d-97d2-40f4-a470-5beb3b7558c 1</msg>
<status status="PASS" endtime="20190402 06:01:52.297" starttime="20190402 06:01:52.294"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:53.779" level="INFO">+------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+--------------------------------------------------+
| osdid            | 1                                                |
| function         | osd                                              |
| state            | configuring-on-unlock                            |
| journal_location | 7d514bed-c6d8-43db-8ed9-fd7afd79d455             |
| journal_size_gib | 1024                                             |
| journal_path     | /dev/disk/by-path/pci-0000:00:17.0-ata-2.0-part2 |
| journal_node     | /dev/sdb2                                        |
| uuid             | 7d514bed-c6d8-43db-8ed9-fd7afd79d455             |
| ihost_uuid       | 7e3e37c8-5ee4-424c-b253-7335a13f97dd             |
| idisk_uuid       | 1e1d7bd5-1096-4eb8-b25d-4de20eb121f3             |
| tier_uuid        | 02919f4d-97d2-40f4-a470-5beb3b7558c1             |
| tier_name        | storage                                          |
| created_at       | 2019-04-02T11:50:37.815261+00:00                 |
| updated_at       | 2019-04-02T11:50:38.024821+00:00                 |
+------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:53.779" level="INFO">${output} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:53.779" starttime="20190402 06:01:52.297"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:53.780" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:53.780" starttime="20190402 06:01:53.780"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:53.780" level="INFO">${clean_out} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:53.780" starttime="20190402 06:01:53.780"></status>
</kw>
<msg timestamp="20190402 06:01:53.780" level="INFO">${output} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:53.780" starttime="20190402 06:01:53.779"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:53.782" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:53.782" starttime="20190402 06:01:53.781"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:53.783" level="INFO">0</msg>
<msg timestamp="20190402 06:01:53.783" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:53.783" starttime="20190402 06:01:53.782"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:53.783" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:53.783" starttime="20190402 06:01:53.783"></status>
</kw>
<msg timestamp="20190402 06:01:53.783" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:53.783" starttime="20190402 06:01:53.781"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.784" starttime="20190402 06:01:53.784"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:53.784" starttime="20190402 06:01:53.783"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.784" starttime="20190402 06:01:53.784"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:53.785" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+--------------------------------------------------+
| osdid            | 1                                                |
| function         | osd                                              |
| state            | configuring-on-unlock                            |
| journal_location | 7d514bed-c6d8-43db-8ed9-fd7afd79d455             |
| journal_size_gib | 1024                                             |
| journal_path     | /dev/disk/by-path/pci-0000:00:17.0-ata-2.0-part2 |
| journal_node     | /dev/sdb2                                        |
| uuid             | 7d514bed-c6d8-43db-8ed9-fd7afd79d455             |
| ihost_uuid       | 7e3e37c8-5ee4-424c-b253-7335a13f97dd             |
| idisk_uuid       | 1e1d7bd5-1096-4eb8-b25d-4de20eb121f3             |
| tier_uuid        | 02919f4d-97d2-40f4-a470-5beb3b7558c1             |
| tier_name        | storage                                          |
| created_at       | 2019-04-02T11:50:37.815261+00:00                 |
| updated_at       | 2019-04-02T11:50:38.024821+00:00                 |
+------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:53.785" starttime="20190402 06:01:53.784"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:53.785" starttime="20190402 06:01:52.292"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd tree</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.785" starttime="20190402 06:01:53.785"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:53.786" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:53.786" starttime="20190402 06:01:53.786"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.787" starttime="20190402 06:01:53.786"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.787" starttime="20190402 06:01:53.787"></status>
</kw>
<msg timestamp="20190402 06:01:53.787" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:53.787" starttime="20190402 06:01:53.786"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:53.787" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:53.787" starttime="20190402 06:01:53.787"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:53.788" level="INFO">ceph osd tree</msg>
<status status="PASS" endtime="20190402 06:01:53.788" starttime="20190402 06:01:53.787"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:53.924" level="INFO">ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3       0         host controller-1                                   
 1       0 osd.1                        down        0          1.00000 
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:53.924" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190402 06:01:53.924" starttime="20190402 06:01:53.788"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:53.925" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:53.925" starttime="20190402 06:01:53.924"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:53.925" level="INFO">${clean_out} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190402 06:01:53.925" starttime="20190402 06:01:53.925"></status>
</kw>
<msg timestamp="20190402 06:01:53.925" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190402 06:01:53.925" starttime="20190402 06:01:53.924"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:53.927" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:53.927" starttime="20190402 06:01:53.926"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:53.928" level="INFO">0</msg>
<msg timestamp="20190402 06:01:53.928" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:53.928" starttime="20190402 06:01:53.927"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:53.928" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:53.928" starttime="20190402 06:01:53.928"></status>
</kw>
<msg timestamp="20190402 06:01:53.928" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:53.928" starttime="20190402 06:01:53.925"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.929" starttime="20190402 06:01:53.929"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:53.929" starttime="20190402 06:01:53.928"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.929" starttime="20190402 06:01:53.929"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:53.930" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3       0         host controller-1                                   
 1       0 osd.1                        down        0          1.00000</msg>
<status status="PASS" endtime="20190402 06:01:53.930" starttime="20190402 06:01:53.929"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:53.930" starttime="20190402 06:01:53.785"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:53.930" starttime="20190402 06:01:50.091"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}'=='Simplex'</arg>
<arg>Set Ceph Pool Replication</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.930" starttime="20190402 06:01:53.930"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:53.930" starttime="20190402 06:01:50.090"></status>
</kw>
<kw name="Unlock Second Controller" library="Utils">
<doc>Verify second controller is unlocked.</doc>
<arguments>
<arg>${second_controller}</arg>
</arguments>
<kw name="Unlock Controller" library="Utils">
<doc>Unlocks specified controller.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>15 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value</arg>
<arg>${controller_name}</arg>
<arg>availability</arg>
<arg>online</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>availability</arg>
<arg>online</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:01:53.932" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:53.932" starttime="20190402 06:01:53.932"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.933" starttime="20190402 06:01:53.933"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:53.934" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:53.934" starttime="20190402 06:01:53.933"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.934" starttime="20190402 06:01:53.934"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:53.934" starttime="20190402 06:01:53.934"></status>
</kw>
<msg timestamp="20190402 06:01:53.935" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:53.935" starttime="20190402 06:01:53.933"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:53.935" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:53.935" starttime="20190402 06:01:53.935"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:53.937" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:01:53.937" starttime="20190402 06:01:53.935"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:54.927" level="INFO">online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:54.927" level="INFO">${output} = online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:54.927" starttime="20190402 06:01:53.937"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:54.928" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:54.928" starttime="20190402 06:01:54.927"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:54.928" level="INFO">${clean_out} = online
</msg>
<status status="PASS" endtime="20190402 06:01:54.928" starttime="20190402 06:01:54.928"></status>
</kw>
<msg timestamp="20190402 06:01:54.928" level="INFO">${output} = online
</msg>
<status status="PASS" endtime="20190402 06:01:54.928" starttime="20190402 06:01:54.927"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:54.930" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:54.930" starttime="20190402 06:01:54.929"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:54.931" level="INFO">0</msg>
<msg timestamp="20190402 06:01:54.931" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:54.931" starttime="20190402 06:01:54.930"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:54.931" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:54.931" starttime="20190402 06:01:54.931"></status>
</kw>
<msg timestamp="20190402 06:01:54.931" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:54.932" starttime="20190402 06:01:54.928"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:54.932" starttime="20190402 06:01:54.932"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:54.932" starttime="20190402 06:01:54.932"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:54.933" starttime="20190402 06:01:54.932"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:54.933" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: online</msg>
<status status="PASS" endtime="20190402 06:01:54.933" starttime="20190402 06:01:54.933"></status>
</kw>
<msg timestamp="20190402 06:01:54.933" level="INFO">${result} = {u'stdout': u'online', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:01:54.933" starttime="20190402 06:01:53.932"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:01:54.933" level="INFO">${value} = online</msg>
<status status="PASS" endtime="20190402 06:01:54.933" starttime="20190402 06:01:54.933"></status>
</kw>
<msg timestamp="20190402 06:01:54.934" level="INFO">${current_value} = online</msg>
<status status="PASS" endtime="20190402 06:01:54.934" starttime="20190402 06:01:53.932"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:54.934" starttime="20190402 06:01:54.934"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:54.934" starttime="20190402 06:01:53.931"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:54.934" starttime="20190402 06:01:53.931"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-unlock ${controller_name}</arg>
<arg>True</arg>
<arg>60</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:54.935" starttime="20190402 06:01:54.935"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:54.936" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:54.936" starttime="20190402 06:01:54.935"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:54.936" starttime="20190402 06:01:54.936"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:54.936" starttime="20190402 06:01:54.936"></status>
</kw>
<msg timestamp="20190402 06:01:54.936" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:54.936" starttime="20190402 06:01:54.935"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:54.937" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:54.937" starttime="20190402 06:01:54.937"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:54.938" level="INFO">system host-unlock controller-1</msg>
<status status="PASS" endtime="20190402 06:01:54.938" starttime="20190402 06:01:54.937"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:01:59.937" level="INFO">+---------------------+--------------------------------------+
| Property            | Value                                |
+---------------------+--------------------------------------+
| action              | none                                 |
| administrative      | locked                               |
| availability        | online                               |
| bm_ip               | None                                 |
| bm_type             | None                                 |
| bm_username         | None                                 |
| boot_device         | sda                                  |
| capabilities        | {u'stor_function': u'monitor'}       |
| config_applied      | None                                 |
| config_status       | Config out-of-date                   |
| config_target       | e514ec48-293f-4bb5-9ea7-a333f37ea8d3 |
| console             | ttyS0,115200                         |
| created_at          | 2019-04-02T11:41:09.555447+00:00     |
| hostname            | controller-1                         |
| id                  | 2                                    |
| install_output      | text                                 |
| install_state       | completed                            |
| install_state_info  | None                                 |
| invprovision        | unprovisioned                        |
| location            | {}                                   |
| mgmt_ip             | 10.10.53.4                           |
| mgmt_mac            | a4:bf:01:55:03:bb                    |
| operational         | disabled                             |
| personality         | controller                           |
| reserved            | False                                |
| rootfs_device       | sda                                  |
| serialid            | None                                 |
| software_load       | 19.01                                |
| subfunction_avail   | online                               |
| subfunction_oper    | disabled                             |
| subfunctions        | controller,worker                    |
| task                | Unlocking                            |
| tboot               | false                                |
| ttys_dcd            | None                                 |
| updated_at          | 2019-04-02T11:50:38.100561+00:00     |
| uptime              | 48                                   |
| uuid                | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| vim_progress_status | None                                 |
+---------------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:01:59.937" level="INFO">${output} = +---------------------+--------------------------------------+
| Property            | Value                                |
+---------------------+--------------------------------------+
| action...</msg>
<status status="PASS" endtime="20190402 06:01:59.937" starttime="20190402 06:01:54.938"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:01:59.938" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:59.938" starttime="20190402 06:01:59.938"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:01:59.939" level="INFO">${clean_out} = +---------------------+--------------------------------------+
| Property            | Value                                |
+---------------------+--------------------------------------+
| action...</msg>
<status status="PASS" endtime="20190402 06:01:59.939" starttime="20190402 06:01:59.938"></status>
</kw>
<msg timestamp="20190402 06:01:59.939" level="INFO">${output} = +---------------------+--------------------------------------+
| Property            | Value                                |
+---------------------+--------------------------------------+
| action...</msg>
<status status="PASS" endtime="20190402 06:01:59.939" starttime="20190402 06:01:59.938"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:01:59.941" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:01:59.941" starttime="20190402 06:01:59.939"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:01:59.941" level="INFO">0</msg>
<msg timestamp="20190402 06:01:59.941" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:59.941" starttime="20190402 06:01:59.941"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:01:59.941" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:01:59.941" starttime="20190402 06:01:59.941"></status>
</kw>
<msg timestamp="20190402 06:01:59.942" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:01:59.942" starttime="20190402 06:01:59.939"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:59.942" starttime="20190402 06:01:59.942"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:59.942" starttime="20190402 06:01:59.942"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:59.943" starttime="20190402 06:01:59.943"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:01:59.943" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +---------------------+--------------------------------------+
| Property            | Value                                |
+---------------------+--------------------------------------+
| action              | none                                 |
| administrative      | locked                               |
| availability        | online                               |
| bm_ip               | None                                 |
| bm_type             | None                                 |
| bm_username         | None                                 |
| boot_device         | sda                                  |
| capabilities        | {u'stor_function': u'monitor'}       |
| config_applied      | None                                 |
| config_status       | Config out-of-date                   |
| config_target       | e514ec48-293f-4bb5-9ea7-a333f37ea8d3 |
| console             | ttyS0,115200                         |
| created_at          | 2019-04-02T11:41:09.555447+00:00     |
| hostname            | controller-1                         |
| id                  | 2                                    |
| install_output      | text                                 |
| install_state       | completed                            |
| install_state_info  | None                                 |
| invprovision        | unprovisioned                        |
| location            | {}                                   |
| mgmt_ip             | 10.10.53.4                           |
| mgmt_mac            | a4:bf:01:55:03:bb                    |
| operational         | disabled                             |
| personality         | controller                           |
| reserved            | False                                |
| rootfs_device       | sda                                  |
| serialid            | None                                 |
| software_load       | 19.01                                |
| subfunction_avail   | online                               |
| subfunction_oper    | disabled                             |
| subfunctions        | controller,worker                    |
| task                | Unlocking                            |
| tboot               | false                                |
| ttys_dcd            | None                                 |
| updated_at          | 2019-04-02T11:50:38.100561+00:00     |
| uptime              | 48                                   |
| uuid                | 7e3e37c8-5ee4-424c-b253-7335a13f97dd |
| vim_progress_status | None                                 |
+---------------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190402 06:01:59.943" starttime="20190402 06:01:59.943"></status>
</kw>
<msg timestamp="20190402 06:01:59.943" level="INFO">${result} = {u'stdout': u"+---------------------+--------------------------------------+\r\n| Property            | Value                                |\r\n+---------------------+-------------------------------...</msg>
<status status="PASS" endtime="20190402 06:01:59.943" starttime="20190402 06:01:54.934"></status>
</kw>
<status status="PASS" endtime="20190402 06:01:59.943" starttime="20190402 06:01:53.931"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>40 min</arg>
<arg>30 sec</arg>
<arg>Check Controller Is Unlocked</arg>
<arg>${controller}</arg>
</arguments>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:59.945" starttime="20190402 06:01:59.945"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:01:59.946" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:01:59.946" starttime="20190402 06:01:59.945"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:59.946" starttime="20190402 06:01:59.946"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:01:59.946" starttime="20190402 06:01:59.946"></status>
</kw>
<msg timestamp="20190402 06:01:59.947" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:01:59.947" starttime="20190402 06:01:59.945"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:01:59.947" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:01:59.947" starttime="20190402 06:01:59.947"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:01:59.951" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 06:01:59.951" starttime="20190402 06:01:59.947"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:02:00.441" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:02:00.441" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:00.441" starttime="20190402 06:01:59.951"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:02:00.442" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:00.442" starttime="20190402 06:02:00.441"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:02:00.442" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190402 06:02:00.442" starttime="20190402 06:02:00.442"></status>
</kw>
<msg timestamp="20190402 06:02:00.442" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190402 06:02:00.442" starttime="20190402 06:02:00.441"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:02:00.444" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:02:00.444" starttime="20190402 06:02:00.443"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:02:00.444" level="INFO">0</msg>
<msg timestamp="20190402 06:02:00.445" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:02:00.445" starttime="20190402 06:02:00.444"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:02:00.445" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:02:00.445" starttime="20190402 06:02:00.445"></status>
</kw>
<msg timestamp="20190402 06:02:00.445" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:02:00.445" starttime="20190402 06:02:00.442"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:00.446" starttime="20190402 06:02:00.446"></status>
</kw>
<status status="PASS" endtime="20190402 06:02:00.446" starttime="20190402 06:02:00.445"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:00.446" starttime="20190402 06:02:00.446"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:02:00.447" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190402 06:02:00.447" starttime="20190402 06:02:00.446"></status>
</kw>
<status status="PASS" endtime="20190402 06:02:00.447" starttime="20190402 06:01:59.944"></status>
</kw>
<status status="PASS" endtime="20190402 06:02:00.447" starttime="20190402 06:01:59.944"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:02:00.448" level="INFO">${system_cmd} = system host-show controller-1|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:02:00.448" starttime="20190402 06:02:00.448"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:00.449" starttime="20190402 06:02:00.448"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:02:00.450" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:02:00.450" starttime="20190402 06:02:00.449"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:00.450" starttime="20190402 06:02:00.450"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:00.450" starttime="20190402 06:02:00.450"></status>
</kw>
<msg timestamp="20190402 06:02:00.451" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:02:00.451" starttime="20190402 06:02:00.449"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:02:00.451" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:00.451" starttime="20190402 06:02:00.451"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:02:00.462" level="INFO">system host-show controller-1|grep -w  administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:02:00.462" starttime="20190402 06:02:00.451"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:02:01.464" level="INFO">unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:02:01.464" level="INFO">${output} = unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:01.464" starttime="20190402 06:02:00.462"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:02:01.465" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:01.465" starttime="20190402 06:02:01.464"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:02:01.465" level="INFO">${clean_out} = unlocked
</msg>
<status status="PASS" endtime="20190402 06:02:01.465" starttime="20190402 06:02:01.465"></status>
</kw>
<msg timestamp="20190402 06:02:01.465" level="INFO">${output} = unlocked
</msg>
<status status="PASS" endtime="20190402 06:02:01.465" starttime="20190402 06:02:01.464"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:02:01.467" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:02:01.467" starttime="20190402 06:02:01.466"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:02:01.467" level="INFO">0</msg>
<msg timestamp="20190402 06:02:01.467" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:02:01.467" starttime="20190402 06:02:01.467"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:02:01.468" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:02:01.468" starttime="20190402 06:02:01.468"></status>
</kw>
<msg timestamp="20190402 06:02:01.468" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:02:01.468" starttime="20190402 06:02:01.465"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:01.469" starttime="20190402 06:02:01.468"></status>
</kw>
<status status="PASS" endtime="20190402 06:02:01.469" starttime="20190402 06:02:01.468"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:01.469" starttime="20190402 06:02:01.469"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:02:01.469" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: unlocked</msg>
<status status="PASS" endtime="20190402 06:02:01.469" starttime="20190402 06:02:01.469"></status>
</kw>
<msg timestamp="20190402 06:02:01.470" level="INFO">${result} = {u'stdout': u'unlocked', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:02:01.470" starttime="20190402 06:02:00.448"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:02:01.470" level="INFO">${value} = unlocked</msg>
<status status="PASS" endtime="20190402 06:02:01.470" starttime="20190402 06:02:01.470"></status>
</kw>
<msg timestamp="20190402 06:02:01.470" level="INFO">${current_value} = unlocked</msg>
<status status="PASS" endtime="20190402 06:02:01.470" starttime="20190402 06:02:00.447"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:01.471" starttime="20190402 06:02:01.470"></status>
</kw>
<status status="PASS" endtime="20190402 06:02:01.471" starttime="20190402 06:02:00.447"></status>
</kw>
<status status="PASS" endtime="20190402 06:02:01.471" starttime="20190402 06:01:59.944"></status>
</kw>
<status status="PASS" endtime="20190402 06:02:01.471" starttime="20190402 06:01:59.944"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>50 min</arg>
<arg>20 sec</arg>
<arg>Check Property Value</arg>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:02:01.472" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:02:01.472" starttime="20190402 06:02:01.472"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:01.473" starttime="20190402 06:02:01.473"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:02:01.473" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:02:01.474" starttime="20190402 06:02:01.473"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:01.474" starttime="20190402 06:02:01.474"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:01.474" starttime="20190402 06:02:01.474"></status>
</kw>
<msg timestamp="20190402 06:02:01.474" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:02:01.474" starttime="20190402 06:02:01.473"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:02:01.475" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:01.475" starttime="20190402 06:02:01.475"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:02:01.477" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:02:01.477" starttime="20190402 06:02:01.475"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:02:02.503" level="INFO">online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:02:02.503" level="INFO">${output} = online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:02.503" starttime="20190402 06:02:01.477"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:02:02.504" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:02.504" starttime="20190402 06:02:02.504"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:02:02.504" level="INFO">${clean_out} = online
</msg>
<status status="PASS" endtime="20190402 06:02:02.504" starttime="20190402 06:02:02.504"></status>
</kw>
<msg timestamp="20190402 06:02:02.505" level="INFO">${output} = online
</msg>
<status status="PASS" endtime="20190402 06:02:02.505" starttime="20190402 06:02:02.504"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:02:02.506" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:02:02.507" starttime="20190402 06:02:02.505"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:02:02.507" level="INFO">0</msg>
<msg timestamp="20190402 06:02:02.507" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:02:02.507" starttime="20190402 06:02:02.507"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:02:02.507" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:02:02.507" starttime="20190402 06:02:02.507"></status>
</kw>
<msg timestamp="20190402 06:02:02.507" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:02:02.508" starttime="20190402 06:02:02.505"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:02.508" starttime="20190402 06:02:02.508"></status>
</kw>
<status status="PASS" endtime="20190402 06:02:02.508" starttime="20190402 06:02:02.508"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:02.509" starttime="20190402 06:02:02.508"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:02:02.509" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: online</msg>
<status status="PASS" endtime="20190402 06:02:02.509" starttime="20190402 06:02:02.509"></status>
</kw>
<msg timestamp="20190402 06:02:02.509" level="INFO">${result} = {u'stdout': u'online', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:02:02.509" starttime="20190402 06:02:01.472"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:02:02.509" level="INFO">${value} = online</msg>
<status status="PASS" endtime="20190402 06:02:02.509" starttime="20190402 06:02:02.509"></status>
</kw>
<msg timestamp="20190402 06:02:02.510" level="INFO">${current_value} = online</msg>
<status status="PASS" endtime="20190402 06:02:02.510" starttime="20190402 06:02:01.472"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:02:02.510" level="FAIL">online != available</msg>
<status status="FAIL" endtime="20190402 06:02:02.510" starttime="20190402 06:02:02.510"></status>
</kw>
<status status="FAIL" endtime="20190402 06:02:02.510" starttime="20190402 06:02:01.471"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:02:22.512" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:02:22.512" starttime="20190402 06:02:22.512"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:22.513" starttime="20190402 06:02:22.513"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:02:22.514" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:02:22.514" starttime="20190402 06:02:22.514"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:22.515" starttime="20190402 06:02:22.515"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:22.516" starttime="20190402 06:02:22.515"></status>
</kw>
<msg timestamp="20190402 06:02:22.516" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:02:22.516" starttime="20190402 06:02:22.514"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:02:22.516" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:22.516" starttime="20190402 06:02:22.516"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:02:22.526" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:02:22.527" starttime="20190402 06:02:22.517"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:02:23.610" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:02:23.610" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:23.610" starttime="20190402 06:02:22.527"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:02:23.611" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:23.611" starttime="20190402 06:02:23.611"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:02:23.611" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:02:23.611" starttime="20190402 06:02:23.611"></status>
</kw>
<msg timestamp="20190402 06:02:23.611" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:02:23.611" starttime="20190402 06:02:23.610"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:02:23.613" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:02:23.613" starttime="20190402 06:02:23.612"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:02:23.614" level="INFO">0</msg>
<msg timestamp="20190402 06:02:23.614" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:02:23.614" starttime="20190402 06:02:23.613"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:02:23.614" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:02:23.614" starttime="20190402 06:02:23.614"></status>
</kw>
<msg timestamp="20190402 06:02:23.614" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:02:23.614" starttime="20190402 06:02:23.611"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:23.615" starttime="20190402 06:02:23.615"></status>
</kw>
<status status="PASS" endtime="20190402 06:02:23.615" starttime="20190402 06:02:23.614"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:23.615" starttime="20190402 06:02:23.615"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:02:23.616" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:02:23.616" starttime="20190402 06:02:23.615"></status>
</kw>
<msg timestamp="20190402 06:02:23.616" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:02:23.616" starttime="20190402 06:02:22.512"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:02:23.616" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:02:23.616" starttime="20190402 06:02:23.616"></status>
</kw>
<msg timestamp="20190402 06:02:23.616" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:02:23.616" starttime="20190402 06:02:22.511"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:02:23.617" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:02:23.617" starttime="20190402 06:02:23.616"></status>
</kw>
<status status="FAIL" endtime="20190402 06:02:23.617" starttime="20190402 06:02:22.511"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:02:43.621" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:02:43.621" starttime="20190402 06:02:43.620"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:43.624" starttime="20190402 06:02:43.623"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:02:43.627" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:02:43.627" starttime="20190402 06:02:43.625"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:43.628" starttime="20190402 06:02:43.627"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:43.629" starttime="20190402 06:02:43.629"></status>
</kw>
<msg timestamp="20190402 06:02:43.630" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:02:43.630" starttime="20190402 06:02:43.625"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:02:43.631" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:43.631" starttime="20190402 06:02:43.631"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:02:43.660" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:02:43.660" starttime="20190402 06:02:43.632"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:02:44.680" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:02:44.681" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:44.681" starttime="20190402 06:02:43.660"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:02:44.681" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:02:44.682" starttime="20190402 06:02:44.681"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:02:44.682" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:02:44.682" starttime="20190402 06:02:44.682"></status>
</kw>
<msg timestamp="20190402 06:02:44.682" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:02:44.682" starttime="20190402 06:02:44.681"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:02:44.684" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:02:44.684" starttime="20190402 06:02:44.683"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:02:44.684" level="INFO">0</msg>
<msg timestamp="20190402 06:02:44.684" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:02:44.684" starttime="20190402 06:02:44.684"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:02:44.685" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:02:44.685" starttime="20190402 06:02:44.685"></status>
</kw>
<msg timestamp="20190402 06:02:44.685" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:02:44.685" starttime="20190402 06:02:44.682"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:44.686" starttime="20190402 06:02:44.685"></status>
</kw>
<status status="PASS" endtime="20190402 06:02:44.686" starttime="20190402 06:02:44.685"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:02:44.686" starttime="20190402 06:02:44.686"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:02:44.686" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:02:44.686" starttime="20190402 06:02:44.686"></status>
</kw>
<msg timestamp="20190402 06:02:44.687" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:02:44.687" starttime="20190402 06:02:43.622"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:02:44.687" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:02:44.687" starttime="20190402 06:02:44.687"></status>
</kw>
<msg timestamp="20190402 06:02:44.687" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:02:44.687" starttime="20190402 06:02:43.619"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:02:44.688" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:02:44.688" starttime="20190402 06:02:44.687"></status>
</kw>
<status status="FAIL" endtime="20190402 06:02:44.688" starttime="20190402 06:02:43.618"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:03:04.692" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:03:04.692" starttime="20190402 06:03:04.691"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:04.695" starttime="20190402 06:03:04.694"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:03:04.698" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:03:04.698" starttime="20190402 06:03:04.696"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:04.699" starttime="20190402 06:03:04.698"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:04.701" starttime="20190402 06:03:04.700"></status>
</kw>
<msg timestamp="20190402 06:03:04.702" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:03:04.702" starttime="20190402 06:03:04.696"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:03:04.702" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:03:04.703" starttime="20190402 06:03:04.702"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:03:04.734" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:03:04.734" starttime="20190402 06:03:04.703"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:03:05.767" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:03:05.767" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:03:05.767" starttime="20190402 06:03:04.734"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:03:05.768" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:03:05.768" starttime="20190402 06:03:05.768"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:03:05.768" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:03:05.768" starttime="20190402 06:03:05.768"></status>
</kw>
<msg timestamp="20190402 06:03:05.768" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:03:05.768" starttime="20190402 06:03:05.767"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:03:05.771" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:03:05.771" starttime="20190402 06:03:05.769"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:03:05.771" level="INFO">0</msg>
<msg timestamp="20190402 06:03:05.771" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:03:05.771" starttime="20190402 06:03:05.771"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:03:05.772" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:03:05.772" starttime="20190402 06:03:05.772"></status>
</kw>
<msg timestamp="20190402 06:03:05.772" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:03:05.772" starttime="20190402 06:03:05.768"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:05.773" starttime="20190402 06:03:05.772"></status>
</kw>
<status status="PASS" endtime="20190402 06:03:05.773" starttime="20190402 06:03:05.772"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:05.773" starttime="20190402 06:03:05.773"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:03:05.773" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:03:05.773" starttime="20190402 06:03:05.773"></status>
</kw>
<msg timestamp="20190402 06:03:05.773" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:03:05.773" starttime="20190402 06:03:04.693"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:03:05.774" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:03:05.774" starttime="20190402 06:03:05.774"></status>
</kw>
<msg timestamp="20190402 06:03:05.774" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:03:05.774" starttime="20190402 06:03:04.690"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:03:05.775" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:03:05.775" starttime="20190402 06:03:05.774"></status>
</kw>
<status status="FAIL" endtime="20190402 06:03:05.775" starttime="20190402 06:03:04.688"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:03:25.779" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:03:25.780" starttime="20190402 06:03:25.778"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:25.783" starttime="20190402 06:03:25.782"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:03:25.785" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:03:25.785" starttime="20190402 06:03:25.784"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:25.787" starttime="20190402 06:03:25.786"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:25.788" starttime="20190402 06:03:25.787"></status>
</kw>
<msg timestamp="20190402 06:03:25.789" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:03:25.789" starttime="20190402 06:03:25.783"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:03:25.790" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:03:25.790" starttime="20190402 06:03:25.789"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:03:25.819" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:03:25.819" starttime="20190402 06:03:25.791"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:03:26.869" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:03:26.869" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:03:26.869" starttime="20190402 06:03:25.819"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:03:26.870" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:03:26.870" starttime="20190402 06:03:26.869"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:03:26.870" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:03:26.870" starttime="20190402 06:03:26.870"></status>
</kw>
<msg timestamp="20190402 06:03:26.870" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:03:26.870" starttime="20190402 06:03:26.869"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:03:26.872" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:03:26.873" starttime="20190402 06:03:26.871"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:03:26.873" level="INFO">0</msg>
<msg timestamp="20190402 06:03:26.873" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:03:26.873" starttime="20190402 06:03:26.873"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:03:26.873" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:03:26.873" starttime="20190402 06:03:26.873"></status>
</kw>
<msg timestamp="20190402 06:03:26.873" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:03:26.873" starttime="20190402 06:03:26.870"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:26.874" starttime="20190402 06:03:26.874"></status>
</kw>
<status status="PASS" endtime="20190402 06:03:26.875" starttime="20190402 06:03:26.874"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:26.875" starttime="20190402 06:03:26.875"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:03:26.875" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:03:26.875" starttime="20190402 06:03:26.875"></status>
</kw>
<msg timestamp="20190402 06:03:26.875" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:03:26.875" starttime="20190402 06:03:25.780"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:03:26.876" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:03:26.876" starttime="20190402 06:03:26.875"></status>
</kw>
<msg timestamp="20190402 06:03:26.876" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:03:26.876" starttime="20190402 06:03:25.777"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:03:26.876" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:03:26.876" starttime="20190402 06:03:26.876"></status>
</kw>
<status status="FAIL" endtime="20190402 06:03:26.876" starttime="20190402 06:03:25.775"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:03:46.881" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:03:46.881" starttime="20190402 06:03:46.880"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:46.884" starttime="20190402 06:03:46.883"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:03:46.887" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:03:46.887" starttime="20190402 06:03:46.885"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:46.888" starttime="20190402 06:03:46.887"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:46.889" starttime="20190402 06:03:46.889"></status>
</kw>
<msg timestamp="20190402 06:03:46.890" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:03:46.890" starttime="20190402 06:03:46.884"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:03:46.891" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:03:46.892" starttime="20190402 06:03:46.891"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:03:46.922" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:03:46.922" starttime="20190402 06:03:46.892"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:03:47.910" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:03:47.910" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:03:47.910" starttime="20190402 06:03:46.922"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:03:47.911" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:03:47.911" starttime="20190402 06:03:47.911"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:03:47.912" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:03:47.912" starttime="20190402 06:03:47.911"></status>
</kw>
<msg timestamp="20190402 06:03:47.912" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:03:47.912" starttime="20190402 06:03:47.911"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:03:47.914" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:03:47.914" starttime="20190402 06:03:47.912"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:03:47.914" level="INFO">0</msg>
<msg timestamp="20190402 06:03:47.914" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:03:47.914" starttime="20190402 06:03:47.914"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:03:47.914" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:03:47.914" starttime="20190402 06:03:47.914"></status>
</kw>
<msg timestamp="20190402 06:03:47.915" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:03:47.915" starttime="20190402 06:03:47.912"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:47.915" starttime="20190402 06:03:47.915"></status>
</kw>
<status status="PASS" endtime="20190402 06:03:47.915" starttime="20190402 06:03:47.915"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:03:47.916" starttime="20190402 06:03:47.915"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:03:47.916" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:03:47.916" starttime="20190402 06:03:47.916"></status>
</kw>
<msg timestamp="20190402 06:03:47.916" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:03:47.916" starttime="20190402 06:03:46.882"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:03:47.917" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:03:47.917" starttime="20190402 06:03:47.916"></status>
</kw>
<msg timestamp="20190402 06:03:47.917" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:03:47.917" starttime="20190402 06:03:46.879"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:03:47.917" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:03:47.917" starttime="20190402 06:03:47.917"></status>
</kw>
<status status="FAIL" endtime="20190402 06:03:47.918" starttime="20190402 06:03:46.877"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:04:07.922" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:04:07.922" starttime="20190402 06:04:07.921"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:07.924" starttime="20190402 06:04:07.923"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:04:07.924" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:04:07.924" starttime="20190402 06:04:07.924"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:07.925" starttime="20190402 06:04:07.925"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:07.925" starttime="20190402 06:04:07.925"></status>
</kw>
<msg timestamp="20190402 06:04:07.925" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:04:07.925" starttime="20190402 06:04:07.924"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:04:07.926" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:04:07.926" starttime="20190402 06:04:07.925"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:04:07.936" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:04:07.936" starttime="20190402 06:04:07.926"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:04:08.947" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:04:08.948" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:04:08.948" starttime="20190402 06:04:07.936"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:04:08.948" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:04:08.948" starttime="20190402 06:04:08.948"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:04:08.949" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:04:08.949" starttime="20190402 06:04:08.949"></status>
</kw>
<msg timestamp="20190402 06:04:08.949" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:04:08.949" starttime="20190402 06:04:08.948"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:04:08.951" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:04:08.951" starttime="20190402 06:04:08.949"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:04:08.951" level="INFO">0</msg>
<msg timestamp="20190402 06:04:08.951" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:04:08.951" starttime="20190402 06:04:08.951"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:04:08.952" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:04:08.952" starttime="20190402 06:04:08.952"></status>
</kw>
<msg timestamp="20190402 06:04:08.952" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:04:08.952" starttime="20190402 06:04:08.949"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:08.953" starttime="20190402 06:04:08.952"></status>
</kw>
<status status="PASS" endtime="20190402 06:04:08.953" starttime="20190402 06:04:08.952"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:08.953" starttime="20190402 06:04:08.953"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:04:08.953" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:04:08.953" starttime="20190402 06:04:08.953"></status>
</kw>
<msg timestamp="20190402 06:04:08.953" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:04:08.953" starttime="20190402 06:04:07.923"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:04:08.954" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:04:08.954" starttime="20190402 06:04:08.954"></status>
</kw>
<msg timestamp="20190402 06:04:08.954" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:04:08.954" starttime="20190402 06:04:07.920"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:04:08.954" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:04:08.955" starttime="20190402 06:04:08.954"></status>
</kw>
<status status="FAIL" endtime="20190402 06:04:08.955" starttime="20190402 06:04:07.918"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:04:28.961" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:04:28.961" starttime="20190402 06:04:28.960"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:28.964" starttime="20190402 06:04:28.963"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:04:28.966" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:04:28.967" starttime="20190402 06:04:28.965"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:28.968" starttime="20190402 06:04:28.967"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:28.969" starttime="20190402 06:04:28.968"></status>
</kw>
<msg timestamp="20190402 06:04:28.970" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:04:28.970" starttime="20190402 06:04:28.964"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:04:28.971" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:04:28.971" starttime="20190402 06:04:28.970"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:04:28.995" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:04:28.995" starttime="20190402 06:04:28.971"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:04:29.985" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:04:29.985" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:04:29.985" starttime="20190402 06:04:28.996"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:04:29.986" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:04:29.986" starttime="20190402 06:04:29.986"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:04:29.986" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:04:29.986" starttime="20190402 06:04:29.986"></status>
</kw>
<msg timestamp="20190402 06:04:29.986" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:04:29.986" starttime="20190402 06:04:29.985"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:04:29.988" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:04:29.988" starttime="20190402 06:04:29.987"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:04:29.989" level="INFO">0</msg>
<msg timestamp="20190402 06:04:29.989" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:04:29.989" starttime="20190402 06:04:29.988"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:04:29.989" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:04:29.989" starttime="20190402 06:04:29.989"></status>
</kw>
<msg timestamp="20190402 06:04:29.989" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:04:29.989" starttime="20190402 06:04:29.986"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:29.990" starttime="20190402 06:04:29.990"></status>
</kw>
<status status="PASS" endtime="20190402 06:04:29.990" starttime="20190402 06:04:29.989"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:29.990" starttime="20190402 06:04:29.990"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:04:29.990" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:04:29.990" starttime="20190402 06:04:29.990"></status>
</kw>
<msg timestamp="20190402 06:04:29.991" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:04:29.991" starttime="20190402 06:04:28.962"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:04:29.991" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:04:29.991" starttime="20190402 06:04:29.991"></status>
</kw>
<msg timestamp="20190402 06:04:29.991" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:04:29.991" starttime="20190402 06:04:28.957"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:04:29.992" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:04:29.992" starttime="20190402 06:04:29.991"></status>
</kw>
<status status="FAIL" endtime="20190402 06:04:29.992" starttime="20190402 06:04:28.955"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:04:49.997" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:04:49.997" starttime="20190402 06:04:49.995"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:49.998" starttime="20190402 06:04:49.998"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:04:49.999" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:04:49.999" starttime="20190402 06:04:49.998"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:49.999" starttime="20190402 06:04:49.999"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:49.999" starttime="20190402 06:04:49.999"></status>
</kw>
<msg timestamp="20190402 06:04:50.000" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:04:50.000" starttime="20190402 06:04:49.998"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:04:50.000" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:04:50.000" starttime="20190402 06:04:50.000"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:04:50.012" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:04:50.012" starttime="20190402 06:04:50.000"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:04:51.006" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:04:51.006" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:04:51.006" starttime="20190402 06:04:50.012"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:04:51.007" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:04:51.007" starttime="20190402 06:04:51.007"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:04:51.007" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:04:51.007" starttime="20190402 06:04:51.007"></status>
</kw>
<msg timestamp="20190402 06:04:51.007" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:04:51.007" starttime="20190402 06:04:51.006"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:04:51.009" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:04:51.010" starttime="20190402 06:04:51.008"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:04:51.010" level="INFO">0</msg>
<msg timestamp="20190402 06:04:51.010" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:04:51.010" starttime="20190402 06:04:51.010"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:04:51.010" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:04:51.010" starttime="20190402 06:04:51.010"></status>
</kw>
<msg timestamp="20190402 06:04:51.011" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:04:51.011" starttime="20190402 06:04:51.007"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:51.011" starttime="20190402 06:04:51.011"></status>
</kw>
<status status="PASS" endtime="20190402 06:04:51.011" starttime="20190402 06:04:51.011"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:04:51.012" starttime="20190402 06:04:51.012"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:04:51.012" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:04:51.012" starttime="20190402 06:04:51.012"></status>
</kw>
<msg timestamp="20190402 06:04:51.012" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:04:51.012" starttime="20190402 06:04:49.997"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:04:51.013" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:04:51.013" starttime="20190402 06:04:51.012"></status>
</kw>
<msg timestamp="20190402 06:04:51.013" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:04:51.013" starttime="20190402 06:04:49.994"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:04:51.013" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:04:51.013" starttime="20190402 06:04:51.013"></status>
</kw>
<status status="FAIL" endtime="20190402 06:04:51.013" starttime="20190402 06:04:49.993"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:05:11.015" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:05:11.015" starttime="20190402 06:05:11.015"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:11.016" starttime="20190402 06:05:11.016"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:05:11.017" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:05:11.017" starttime="20190402 06:05:11.017"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:11.018" starttime="20190402 06:05:11.018"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:11.018" starttime="20190402 06:05:11.018"></status>
</kw>
<msg timestamp="20190402 06:05:11.019" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:05:11.019" starttime="20190402 06:05:11.017"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:05:11.019" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:05:11.019" starttime="20190402 06:05:11.019"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:05:11.029" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:05:11.029" starttime="20190402 06:05:11.019"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:05:12.140" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:05:12.140" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:05:12.140" starttime="20190402 06:05:11.029"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:05:12.141" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:05:12.141" starttime="20190402 06:05:12.141"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:05:12.141" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:05:12.141" starttime="20190402 06:05:12.141"></status>
</kw>
<msg timestamp="20190402 06:05:12.142" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:05:12.142" starttime="20190402 06:05:12.140"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:05:12.143" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:05:12.143" starttime="20190402 06:05:12.142"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:05:12.144" level="INFO">0</msg>
<msg timestamp="20190402 06:05:12.144" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:05:12.144" starttime="20190402 06:05:12.144"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:05:12.144" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:05:12.144" starttime="20190402 06:05:12.144"></status>
</kw>
<msg timestamp="20190402 06:05:12.144" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:05:12.144" starttime="20190402 06:05:12.142"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:12.145" starttime="20190402 06:05:12.145"></status>
</kw>
<status status="PASS" endtime="20190402 06:05:12.145" starttime="20190402 06:05:12.144"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:12.145" starttime="20190402 06:05:12.145"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:05:12.146" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:05:12.146" starttime="20190402 06:05:12.146"></status>
</kw>
<msg timestamp="20190402 06:05:12.146" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:05:12.146" starttime="20190402 06:05:11.015"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:05:12.146" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:05:12.146" starttime="20190402 06:05:12.146"></status>
</kw>
<msg timestamp="20190402 06:05:12.146" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:05:12.147" starttime="20190402 06:05:11.014"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:05:12.147" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:05:12.147" starttime="20190402 06:05:12.147"></status>
</kw>
<status status="FAIL" endtime="20190402 06:05:12.147" starttime="20190402 06:05:11.014"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:05:32.152" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:05:32.152" starttime="20190402 06:05:32.151"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:32.153" starttime="20190402 06:05:32.153"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:05:32.154" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:05:32.154" starttime="20190402 06:05:32.153"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:32.154" starttime="20190402 06:05:32.154"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:32.154" starttime="20190402 06:05:32.154"></status>
</kw>
<msg timestamp="20190402 06:05:32.155" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:05:32.155" starttime="20190402 06:05:32.153"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:05:32.155" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:05:32.155" starttime="20190402 06:05:32.155"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:05:32.157" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:05:32.158" starttime="20190402 06:05:32.155"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:05:33.171" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:05:33.171" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:05:33.172" starttime="20190402 06:05:32.158"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:05:33.172" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:05:33.172" starttime="20190402 06:05:33.172"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:05:33.173" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:05:33.173" starttime="20190402 06:05:33.172"></status>
</kw>
<msg timestamp="20190402 06:05:33.173" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:05:33.173" starttime="20190402 06:05:33.172"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:05:33.174" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:05:33.175" starttime="20190402 06:05:33.173"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:05:33.175" level="INFO">0</msg>
<msg timestamp="20190402 06:05:33.175" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:05:33.175" starttime="20190402 06:05:33.175"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:05:33.175" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:05:33.175" starttime="20190402 06:05:33.175"></status>
</kw>
<msg timestamp="20190402 06:05:33.176" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:05:33.176" starttime="20190402 06:05:33.173"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:33.176" starttime="20190402 06:05:33.176"></status>
</kw>
<status status="PASS" endtime="20190402 06:05:33.176" starttime="20190402 06:05:33.176"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:33.177" starttime="20190402 06:05:33.176"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:05:33.177" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:05:33.177" starttime="20190402 06:05:33.177"></status>
</kw>
<msg timestamp="20190402 06:05:33.177" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:05:33.177" starttime="20190402 06:05:32.152"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:05:33.178" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:05:33.178" starttime="20190402 06:05:33.177"></status>
</kw>
<msg timestamp="20190402 06:05:33.178" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:05:33.178" starttime="20190402 06:05:32.149"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:05:33.178" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:05:33.178" starttime="20190402 06:05:33.178"></status>
</kw>
<status status="FAIL" endtime="20190402 06:05:33.178" starttime="20190402 06:05:32.148"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:05:53.181" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:05:53.182" starttime="20190402 06:05:53.181"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:53.184" starttime="20190402 06:05:53.183"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:05:53.186" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:05:53.186" starttime="20190402 06:05:53.184"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:53.187" starttime="20190402 06:05:53.186"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:53.189" starttime="20190402 06:05:53.187"></status>
</kw>
<msg timestamp="20190402 06:05:53.190" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:05:53.190" starttime="20190402 06:05:53.184"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:05:53.191" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:05:53.191" starttime="20190402 06:05:53.190"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:05:53.221" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:05:53.222" starttime="20190402 06:05:53.191"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:05:54.197" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:05:54.197" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:05:54.197" starttime="20190402 06:05:53.222"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:05:54.198" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:05:54.198" starttime="20190402 06:05:54.198"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:05:54.199" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:05:54.199" starttime="20190402 06:05:54.198"></status>
</kw>
<msg timestamp="20190402 06:05:54.199" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:05:54.199" starttime="20190402 06:05:54.198"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:05:54.202" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:05:54.202" starttime="20190402 06:05:54.199"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:05:54.203" level="INFO">0</msg>
<msg timestamp="20190402 06:05:54.203" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:05:54.204" starttime="20190402 06:05:54.202"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:05:54.204" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:05:54.204" starttime="20190402 06:05:54.204"></status>
</kw>
<msg timestamp="20190402 06:05:54.204" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:05:54.204" starttime="20190402 06:05:54.199"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:54.205" starttime="20190402 06:05:54.205"></status>
</kw>
<status status="PASS" endtime="20190402 06:05:54.205" starttime="20190402 06:05:54.204"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:05:54.205" starttime="20190402 06:05:54.205"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:05:54.206" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:05:54.206" starttime="20190402 06:05:54.205"></status>
</kw>
<msg timestamp="20190402 06:05:54.206" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:05:54.206" starttime="20190402 06:05:53.182"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:05:54.206" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:05:54.206" starttime="20190402 06:05:54.206"></status>
</kw>
<msg timestamp="20190402 06:05:54.206" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:05:54.206" starttime="20190402 06:05:53.180"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:05:54.207" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:05:54.207" starttime="20190402 06:05:54.207"></status>
</kw>
<status status="FAIL" endtime="20190402 06:05:54.207" starttime="20190402 06:05:53.179"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:06:14.212" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:06:14.212" starttime="20190402 06:06:14.211"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:14.215" starttime="20190402 06:06:14.214"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:06:14.219" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:06:14.220" starttime="20190402 06:06:14.217"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:14.221" starttime="20190402 06:06:14.220"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:14.223" starttime="20190402 06:06:14.222"></status>
</kw>
<msg timestamp="20190402 06:06:14.223" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:06:14.224" starttime="20190402 06:06:14.216"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:06:14.224" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:06:14.225" starttime="20190402 06:06:14.224"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:06:14.255" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:06:14.256" starttime="20190402 06:06:14.225"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:06:15.230" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:06:15.230" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:06:15.230" starttime="20190402 06:06:14.256"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:06:15.231" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:06:15.231" starttime="20190402 06:06:15.231"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:06:15.231" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:06:15.231" starttime="20190402 06:06:15.231"></status>
</kw>
<msg timestamp="20190402 06:06:15.232" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:06:15.232" starttime="20190402 06:06:15.230"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:06:15.234" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:06:15.234" starttime="20190402 06:06:15.232"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:06:15.234" level="INFO">0</msg>
<msg timestamp="20190402 06:06:15.234" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:06:15.234" starttime="20190402 06:06:15.234"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:06:15.234" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:06:15.234" starttime="20190402 06:06:15.234"></status>
</kw>
<msg timestamp="20190402 06:06:15.235" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:06:15.235" starttime="20190402 06:06:15.232"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:15.235" starttime="20190402 06:06:15.235"></status>
</kw>
<status status="PASS" endtime="20190402 06:06:15.235" starttime="20190402 06:06:15.235"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:15.236" starttime="20190402 06:06:15.235"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:06:15.236" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:06:15.236" starttime="20190402 06:06:15.236"></status>
</kw>
<msg timestamp="20190402 06:06:15.236" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:06:15.236" starttime="20190402 06:06:14.212"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:06:15.236" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:06:15.237" starttime="20190402 06:06:15.236"></status>
</kw>
<msg timestamp="20190402 06:06:15.237" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:06:15.237" starttime="20190402 06:06:14.209"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:06:15.237" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:06:15.237" starttime="20190402 06:06:15.237"></status>
</kw>
<status status="FAIL" endtime="20190402 06:06:15.237" starttime="20190402 06:06:14.208"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:06:35.242" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:06:35.242" starttime="20190402 06:06:35.241"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:35.244" starttime="20190402 06:06:35.243"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:06:35.244" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:06:35.244" starttime="20190402 06:06:35.244"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:35.245" starttime="20190402 06:06:35.245"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:35.245" starttime="20190402 06:06:35.245"></status>
</kw>
<msg timestamp="20190402 06:06:35.245" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:06:35.245" starttime="20190402 06:06:35.244"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:06:35.246" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:06:35.246" starttime="20190402 06:06:35.245"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:06:35.254" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:06:35.255" starttime="20190402 06:06:35.246"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:06:36.266" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:06:36.266" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:06:36.266" starttime="20190402 06:06:35.255"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:06:36.267" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:06:36.267" starttime="20190402 06:06:36.267"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:06:36.268" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:06:36.268" starttime="20190402 06:06:36.268"></status>
</kw>
<msg timestamp="20190402 06:06:36.268" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:06:36.268" starttime="20190402 06:06:36.267"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:06:36.270" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:06:36.270" starttime="20190402 06:06:36.268"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:06:36.270" level="INFO">0</msg>
<msg timestamp="20190402 06:06:36.270" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:06:36.271" starttime="20190402 06:06:36.270"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:06:36.271" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:06:36.271" starttime="20190402 06:06:36.271"></status>
</kw>
<msg timestamp="20190402 06:06:36.271" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:06:36.271" starttime="20190402 06:06:36.268"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:36.272" starttime="20190402 06:06:36.271"></status>
</kw>
<status status="PASS" endtime="20190402 06:06:36.272" starttime="20190402 06:06:36.271"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:36.272" starttime="20190402 06:06:36.272"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:06:36.272" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:06:36.272" starttime="20190402 06:06:36.272"></status>
</kw>
<msg timestamp="20190402 06:06:36.273" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:06:36.273" starttime="20190402 06:06:35.243"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:06:36.273" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:06:36.273" starttime="20190402 06:06:36.273"></status>
</kw>
<msg timestamp="20190402 06:06:36.273" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:06:36.273" starttime="20190402 06:06:35.240"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:06:36.274" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:06:36.274" starttime="20190402 06:06:36.273"></status>
</kw>
<status status="FAIL" endtime="20190402 06:06:36.274" starttime="20190402 06:06:35.238"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:06:56.278" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:06:56.278" starttime="20190402 06:06:56.277"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:56.280" starttime="20190402 06:06:56.280"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:06:56.280" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:06:56.280" starttime="20190402 06:06:56.280"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:56.281" starttime="20190402 06:06:56.281"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:56.281" starttime="20190402 06:06:56.281"></status>
</kw>
<msg timestamp="20190402 06:06:56.281" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:06:56.281" starttime="20190402 06:06:56.280"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:06:56.282" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:06:56.282" starttime="20190402 06:06:56.281"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:06:56.293" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:06:56.293" starttime="20190402 06:06:56.282"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:06:57.288" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:06:57.289" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:06:57.289" starttime="20190402 06:06:56.293"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:06:57.289" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:06:57.290" starttime="20190402 06:06:57.289"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:06:57.290" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190402 06:06:57.290" starttime="20190402 06:06:57.290"></status>
</kw>
<msg timestamp="20190402 06:06:57.290" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190402 06:06:57.290" starttime="20190402 06:06:57.289"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:06:57.293" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:06:57.293" starttime="20190402 06:06:57.290"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:06:57.293" level="INFO">0</msg>
<msg timestamp="20190402 06:06:57.293" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:06:57.293" starttime="20190402 06:06:57.293"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:06:57.293" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:06:57.294" starttime="20190402 06:06:57.293"></status>
</kw>
<msg timestamp="20190402 06:06:57.294" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:06:57.294" starttime="20190402 06:06:57.290"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:57.294" starttime="20190402 06:06:57.294"></status>
</kw>
<status status="PASS" endtime="20190402 06:06:57.295" starttime="20190402 06:06:57.294"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:06:57.295" starttime="20190402 06:06:57.295"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:06:57.295" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190402 06:06:57.295" starttime="20190402 06:06:57.295"></status>
</kw>
<msg timestamp="20190402 06:06:57.295" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:06:57.295" starttime="20190402 06:06:56.279"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:06:57.296" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190402 06:06:57.296" starttime="20190402 06:06:57.295"></status>
</kw>
<msg timestamp="20190402 06:06:57.296" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190402 06:06:57.296" starttime="20190402 06:06:56.276"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:06:57.296" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190402 06:06:57.296" starttime="20190402 06:06:57.296"></status>
</kw>
<status status="FAIL" endtime="20190402 06:06:57.296" starttime="20190402 06:06:56.275"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:07:17.301" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:07:17.301" starttime="20190402 06:07:17.300"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:17.303" starttime="20190402 06:07:17.303"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:07:17.303" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:07:17.303" starttime="20190402 06:07:17.303"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:17.304" starttime="20190402 06:07:17.304"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:17.304" starttime="20190402 06:07:17.304"></status>
</kw>
<msg timestamp="20190402 06:07:17.304" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:07:17.304" starttime="20190402 06:07:17.303"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:07:17.305" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:07:17.305" starttime="20190402 06:07:17.304"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:07:17.315" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:07:17.315" starttime="20190402 06:07:17.305"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:07:18.397" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:07:18.397" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:07:18.397" starttime="20190402 06:07:17.315"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:07:18.398" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:07:18.398" starttime="20190402 06:07:18.398"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:07:18.398" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:07:18.398" starttime="20190402 06:07:18.398"></status>
</kw>
<msg timestamp="20190402 06:07:18.398" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:07:18.398" starttime="20190402 06:07:18.397"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:07:18.401" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:07:18.401" starttime="20190402 06:07:18.399"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:07:18.401" level="INFO">0</msg>
<msg timestamp="20190402 06:07:18.401" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:07:18.401" starttime="20190402 06:07:18.401"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:07:18.401" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:07:18.401" starttime="20190402 06:07:18.401"></status>
</kw>
<msg timestamp="20190402 06:07:18.402" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:07:18.402" starttime="20190402 06:07:18.399"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:18.403" starttime="20190402 06:07:18.402"></status>
</kw>
<status status="PASS" endtime="20190402 06:07:18.403" starttime="20190402 06:07:18.402"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:18.403" starttime="20190402 06:07:18.403"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:07:18.403" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:07:18.403" starttime="20190402 06:07:18.403"></status>
</kw>
<msg timestamp="20190402 06:07:18.404" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:07:18.404" starttime="20190402 06:07:17.302"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:07:18.404" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:07:18.404" starttime="20190402 06:07:18.404"></status>
</kw>
<msg timestamp="20190402 06:07:18.404" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:07:18.404" starttime="20190402 06:07:17.299"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:07:18.405" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:07:18.405" starttime="20190402 06:07:18.404"></status>
</kw>
<status status="FAIL" endtime="20190402 06:07:18.405" starttime="20190402 06:07:17.297"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:07:38.412" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:07:38.412" starttime="20190402 06:07:38.410"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:38.415" starttime="20190402 06:07:38.414"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:07:38.417" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:07:38.418" starttime="20190402 06:07:38.416"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:38.419" starttime="20190402 06:07:38.418"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:38.420" starttime="20190402 06:07:38.419"></status>
</kw>
<msg timestamp="20190402 06:07:38.421" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:07:38.421" starttime="20190402 06:07:38.415"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:07:38.422" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:07:38.422" starttime="20190402 06:07:38.422"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:07:38.427" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:07:38.427" starttime="20190402 06:07:38.423"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:07:39.439" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:07:39.440" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:07:39.440" starttime="20190402 06:07:38.428"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:07:39.440" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:07:39.440" starttime="20190402 06:07:39.440"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:07:39.441" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:07:39.441" starttime="20190402 06:07:39.440"></status>
</kw>
<msg timestamp="20190402 06:07:39.441" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:07:39.441" starttime="20190402 06:07:39.440"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:07:39.443" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:07:39.443" starttime="20190402 06:07:39.441"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:07:39.443" level="INFO">0</msg>
<msg timestamp="20190402 06:07:39.443" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:07:39.443" starttime="20190402 06:07:39.443"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:07:39.443" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:07:39.444" starttime="20190402 06:07:39.443"></status>
</kw>
<msg timestamp="20190402 06:07:39.444" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:07:39.444" starttime="20190402 06:07:39.441"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:39.444" starttime="20190402 06:07:39.444"></status>
</kw>
<status status="PASS" endtime="20190402 06:07:39.445" starttime="20190402 06:07:39.444"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:39.445" starttime="20190402 06:07:39.445"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:07:39.445" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:07:39.445" starttime="20190402 06:07:39.445"></status>
</kw>
<msg timestamp="20190402 06:07:39.445" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:07:39.445" starttime="20190402 06:07:38.412"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:07:39.446" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:07:39.446" starttime="20190402 06:07:39.445"></status>
</kw>
<msg timestamp="20190402 06:07:39.446" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:07:39.446" starttime="20190402 06:07:38.408"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:07:39.447" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:07:39.447" starttime="20190402 06:07:39.446"></status>
</kw>
<status status="FAIL" endtime="20190402 06:07:39.447" starttime="20190402 06:07:38.405"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:07:59.452" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:07:59.452" starttime="20190402 06:07:59.451"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:59.453" starttime="20190402 06:07:59.453"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:07:59.454" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:07:59.454" starttime="20190402 06:07:59.453"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:59.454" starttime="20190402 06:07:59.454"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:07:59.454" starttime="20190402 06:07:59.454"></status>
</kw>
<msg timestamp="20190402 06:07:59.454" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:07:59.454" starttime="20190402 06:07:59.453"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:07:59.455" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:07:59.455" starttime="20190402 06:07:59.455"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:07:59.466" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:07:59.466" starttime="20190402 06:07:59.455"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:08:00.489" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:08:00.490" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:08:00.490" starttime="20190402 06:07:59.466"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:08:00.490" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:08:00.490" starttime="20190402 06:08:00.490"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:08:00.491" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:08:00.491" starttime="20190402 06:08:00.491"></status>
</kw>
<msg timestamp="20190402 06:08:00.491" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:08:00.491" starttime="20190402 06:08:00.490"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:08:00.493" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:08:00.493" starttime="20190402 06:08:00.491"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:08:00.494" level="INFO">0</msg>
<msg timestamp="20190402 06:08:00.494" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:08:00.494" starttime="20190402 06:08:00.493"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:08:00.494" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:08:00.494" starttime="20190402 06:08:00.494"></status>
</kw>
<msg timestamp="20190402 06:08:00.494" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:08:00.494" starttime="20190402 06:08:00.491"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:00.495" starttime="20190402 06:08:00.495"></status>
</kw>
<status status="PASS" endtime="20190402 06:08:00.495" starttime="20190402 06:08:00.494"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:00.495" starttime="20190402 06:08:00.495"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:08:00.495" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:08:00.496" starttime="20190402 06:08:00.495"></status>
</kw>
<msg timestamp="20190402 06:08:00.496" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:08:00.496" starttime="20190402 06:07:59.452"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:08:00.496" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:08:00.496" starttime="20190402 06:08:00.496"></status>
</kw>
<msg timestamp="20190402 06:08:00.496" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:08:00.496" starttime="20190402 06:07:59.449"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:08:00.497" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:08:00.497" starttime="20190402 06:08:00.496"></status>
</kw>
<status status="FAIL" endtime="20190402 06:08:00.497" starttime="20190402 06:07:59.448"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:08:20.502" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:08:20.502" starttime="20190402 06:08:20.501"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:20.503" starttime="20190402 06:08:20.503"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:08:20.504" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:08:20.504" starttime="20190402 06:08:20.503"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:20.504" starttime="20190402 06:08:20.504"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:20.504" starttime="20190402 06:08:20.504"></status>
</kw>
<msg timestamp="20190402 06:08:20.505" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:08:20.505" starttime="20190402 06:08:20.503"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:08:20.505" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:08:20.505" starttime="20190402 06:08:20.505"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:08:20.515" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:08:20.515" starttime="20190402 06:08:20.505"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:08:21.513" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:08:21.513" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:08:21.513" starttime="20190402 06:08:20.515"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:08:21.514" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:08:21.514" starttime="20190402 06:08:21.514"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:08:21.514" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:08:21.514" starttime="20190402 06:08:21.514"></status>
</kw>
<msg timestamp="20190402 06:08:21.514" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:08:21.514" starttime="20190402 06:08:21.513"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:08:21.516" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:08:21.516" starttime="20190402 06:08:21.515"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:08:21.516" level="INFO">0</msg>
<msg timestamp="20190402 06:08:21.517" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:08:21.517" starttime="20190402 06:08:21.516"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:08:21.517" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:08:21.517" starttime="20190402 06:08:21.517"></status>
</kw>
<msg timestamp="20190402 06:08:21.517" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:08:21.517" starttime="20190402 06:08:21.514"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:21.518" starttime="20190402 06:08:21.518"></status>
</kw>
<status status="PASS" endtime="20190402 06:08:21.518" starttime="20190402 06:08:21.517"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:21.518" starttime="20190402 06:08:21.518"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:08:21.519" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:08:21.519" starttime="20190402 06:08:21.518"></status>
</kw>
<msg timestamp="20190402 06:08:21.519" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:08:21.519" starttime="20190402 06:08:20.503"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:08:21.519" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:08:21.519" starttime="20190402 06:08:21.519"></status>
</kw>
<msg timestamp="20190402 06:08:21.519" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:08:21.519" starttime="20190402 06:08:20.499"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:08:21.520" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:08:21.520" starttime="20190402 06:08:21.519"></status>
</kw>
<status status="FAIL" endtime="20190402 06:08:21.520" starttime="20190402 06:08:20.498"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:08:41.525" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:08:41.525" starttime="20190402 06:08:41.524"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:41.526" starttime="20190402 06:08:41.526"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:08:41.527" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:08:41.527" starttime="20190402 06:08:41.526"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:41.527" starttime="20190402 06:08:41.527"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:41.527" starttime="20190402 06:08:41.527"></status>
</kw>
<msg timestamp="20190402 06:08:41.528" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:08:41.528" starttime="20190402 06:08:41.526"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:08:41.528" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:08:41.528" starttime="20190402 06:08:41.528"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:08:41.538" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:08:41.538" starttime="20190402 06:08:41.528"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:08:42.548" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:08:42.548" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:08:42.549" starttime="20190402 06:08:41.538"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:08:42.549" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:08:42.549" starttime="20190402 06:08:42.549"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:08:42.550" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:08:42.550" starttime="20190402 06:08:42.549"></status>
</kw>
<msg timestamp="20190402 06:08:42.550" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:08:42.550" starttime="20190402 06:08:42.549"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:08:42.552" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:08:42.552" starttime="20190402 06:08:42.550"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:08:42.552" level="INFO">0</msg>
<msg timestamp="20190402 06:08:42.552" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:08:42.552" starttime="20190402 06:08:42.552"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:08:42.553" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:08:42.553" starttime="20190402 06:08:42.553"></status>
</kw>
<msg timestamp="20190402 06:08:42.553" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:08:42.553" starttime="20190402 06:08:42.550"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:42.554" starttime="20190402 06:08:42.554"></status>
</kw>
<status status="PASS" endtime="20190402 06:08:42.554" starttime="20190402 06:08:42.553"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:08:42.554" starttime="20190402 06:08:42.554"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:08:42.554" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:08:42.555" starttime="20190402 06:08:42.554"></status>
</kw>
<msg timestamp="20190402 06:08:42.555" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:08:42.555" starttime="20190402 06:08:41.525"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:08:42.555" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:08:42.555" starttime="20190402 06:08:42.555"></status>
</kw>
<msg timestamp="20190402 06:08:42.555" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:08:42.555" starttime="20190402 06:08:41.522"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:08:42.556" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:08:42.556" starttime="20190402 06:08:42.555"></status>
</kw>
<status status="FAIL" endtime="20190402 06:08:42.556" starttime="20190402 06:08:41.521"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:09:02.561" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:09:02.561" starttime="20190402 06:09:02.560"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:02.562" starttime="20190402 06:09:02.562"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:09:02.563" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:09:02.563" starttime="20190402 06:09:02.563"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:02.564" starttime="20190402 06:09:02.563"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:02.564" starttime="20190402 06:09:02.564"></status>
</kw>
<msg timestamp="20190402 06:09:02.564" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:09:02.564" starttime="20190402 06:09:02.562"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:09:02.564" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:09:02.564" starttime="20190402 06:09:02.564"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:09:02.574" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:09:02.574" starttime="20190402 06:09:02.565"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:09:03.562" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:09:03.563" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:09:03.563" starttime="20190402 06:09:02.574"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:09:03.563" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:09:03.563" starttime="20190402 06:09:03.563"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:09:03.564" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:09:03.564" starttime="20190402 06:09:03.563"></status>
</kw>
<msg timestamp="20190402 06:09:03.564" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:09:03.564" starttime="20190402 06:09:03.563"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:09:03.566" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:09:03.566" starttime="20190402 06:09:03.564"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:09:03.566" level="INFO">0</msg>
<msg timestamp="20190402 06:09:03.566" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:09:03.566" starttime="20190402 06:09:03.566"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:09:03.567" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:09:03.567" starttime="20190402 06:09:03.566"></status>
</kw>
<msg timestamp="20190402 06:09:03.567" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:09:03.567" starttime="20190402 06:09:03.564"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:03.568" starttime="20190402 06:09:03.567"></status>
</kw>
<status status="PASS" endtime="20190402 06:09:03.568" starttime="20190402 06:09:03.567"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:03.568" starttime="20190402 06:09:03.568"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:09:03.568" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:09:03.568" starttime="20190402 06:09:03.568"></status>
</kw>
<msg timestamp="20190402 06:09:03.568" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:09:03.568" starttime="20190402 06:09:02.561"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:09:03.569" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:09:03.569" starttime="20190402 06:09:03.569"></status>
</kw>
<msg timestamp="20190402 06:09:03.569" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:09:03.569" starttime="20190402 06:09:02.558"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:09:03.569" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:09:03.569" starttime="20190402 06:09:03.569"></status>
</kw>
<status status="FAIL" endtime="20190402 06:09:03.570" starttime="20190402 06:09:02.557"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:09:23.574" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:09:23.574" starttime="20190402 06:09:23.573"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:23.576" starttime="20190402 06:09:23.576"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:09:23.577" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:09:23.577" starttime="20190402 06:09:23.576"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:23.577" starttime="20190402 06:09:23.577"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:23.577" starttime="20190402 06:09:23.577"></status>
</kw>
<msg timestamp="20190402 06:09:23.578" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:09:23.578" starttime="20190402 06:09:23.576"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:09:23.578" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:09:23.578" starttime="20190402 06:09:23.578"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:09:23.590" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:09:23.590" starttime="20190402 06:09:23.578"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:09:24.629" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:09:24.629" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:09:24.629" starttime="20190402 06:09:23.590"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:09:24.630" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:09:24.630" starttime="20190402 06:09:24.630"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:09:24.631" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:09:24.631" starttime="20190402 06:09:24.630"></status>
</kw>
<msg timestamp="20190402 06:09:24.631" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:09:24.631" starttime="20190402 06:09:24.630"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:09:24.633" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:09:24.633" starttime="20190402 06:09:24.631"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:09:24.633" level="INFO">0</msg>
<msg timestamp="20190402 06:09:24.633" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:09:24.633" starttime="20190402 06:09:24.633"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:09:24.633" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:09:24.633" starttime="20190402 06:09:24.633"></status>
</kw>
<msg timestamp="20190402 06:09:24.634" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:09:24.634" starttime="20190402 06:09:24.631"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:24.634" starttime="20190402 06:09:24.634"></status>
</kw>
<status status="PASS" endtime="20190402 06:09:24.634" starttime="20190402 06:09:24.634"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:24.635" starttime="20190402 06:09:24.635"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:09:24.635" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:09:24.635" starttime="20190402 06:09:24.635"></status>
</kw>
<msg timestamp="20190402 06:09:24.635" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:09:24.635" starttime="20190402 06:09:23.575"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:09:24.636" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:09:24.636" starttime="20190402 06:09:24.635"></status>
</kw>
<msg timestamp="20190402 06:09:24.636" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:09:24.636" starttime="20190402 06:09:23.572"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:09:24.636" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:09:24.636" starttime="20190402 06:09:24.636"></status>
</kw>
<status status="FAIL" endtime="20190402 06:09:24.636" starttime="20190402 06:09:23.570"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:09:44.641" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:09:44.641" starttime="20190402 06:09:44.640"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:44.643" starttime="20190402 06:09:44.642"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:09:44.643" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:09:44.643" starttime="20190402 06:09:44.643"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:44.644" starttime="20190402 06:09:44.644"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:44.644" starttime="20190402 06:09:44.644"></status>
</kw>
<msg timestamp="20190402 06:09:44.645" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:09:44.645" starttime="20190402 06:09:44.643"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:09:44.645" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:09:44.645" starttime="20190402 06:09:44.645"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:09:44.657" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:09:44.657" starttime="20190402 06:09:44.645"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:09:45.686" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:09:45.686" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:09:45.686" starttime="20190402 06:09:44.657"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:09:45.687" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:09:45.687" starttime="20190402 06:09:45.687"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:09:45.687" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:09:45.687" starttime="20190402 06:09:45.687"></status>
</kw>
<msg timestamp="20190402 06:09:45.688" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:09:45.688" starttime="20190402 06:09:45.687"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:09:45.690" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:09:45.690" starttime="20190402 06:09:45.688"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:09:45.690" level="INFO">0</msg>
<msg timestamp="20190402 06:09:45.690" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:09:45.690" starttime="20190402 06:09:45.690"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:09:45.691" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:09:45.691" starttime="20190402 06:09:45.690"></status>
</kw>
<msg timestamp="20190402 06:09:45.691" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:09:45.691" starttime="20190402 06:09:45.688"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:45.692" starttime="20190402 06:09:45.691"></status>
</kw>
<status status="PASS" endtime="20190402 06:09:45.692" starttime="20190402 06:09:45.691"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:09:45.692" starttime="20190402 06:09:45.692"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:09:45.692" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:09:45.692" starttime="20190402 06:09:45.692"></status>
</kw>
<msg timestamp="20190402 06:09:45.692" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:09:45.692" starttime="20190402 06:09:44.641"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:09:45.693" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:09:45.693" starttime="20190402 06:09:45.693"></status>
</kw>
<msg timestamp="20190402 06:09:45.693" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:09:45.693" starttime="20190402 06:09:44.639"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:09:45.693" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:09:45.693" starttime="20190402 06:09:45.693"></status>
</kw>
<status status="FAIL" endtime="20190402 06:09:45.694" starttime="20190402 06:09:44.637"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:10:05.698" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:10:05.698" starttime="20190402 06:10:05.697"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:05.700" starttime="20190402 06:10:05.699"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:10:05.700" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:10:05.700" starttime="20190402 06:10:05.700"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:05.701" starttime="20190402 06:10:05.700"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:05.701" starttime="20190402 06:10:05.701"></status>
</kw>
<msg timestamp="20190402 06:10:05.701" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:10:05.701" starttime="20190402 06:10:05.700"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:10:05.702" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:10:05.702" starttime="20190402 06:10:05.701"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:10:05.711" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:10:05.712" starttime="20190402 06:10:05.702"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:10:06.715" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:10:06.715" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:10:06.715" starttime="20190402 06:10:05.712"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:10:06.716" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:10:06.716" starttime="20190402 06:10:06.716"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:10:06.717" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:10:06.717" starttime="20190402 06:10:06.716"></status>
</kw>
<msg timestamp="20190402 06:10:06.717" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:10:06.717" starttime="20190402 06:10:06.716"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:10:06.719" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:10:06.719" starttime="20190402 06:10:06.717"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:10:06.719" level="INFO">0</msg>
<msg timestamp="20190402 06:10:06.719" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:10:06.719" starttime="20190402 06:10:06.719"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:10:06.720" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:10:06.720" starttime="20190402 06:10:06.720"></status>
</kw>
<msg timestamp="20190402 06:10:06.720" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:10:06.720" starttime="20190402 06:10:06.717"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:06.721" starttime="20190402 06:10:06.720"></status>
</kw>
<status status="PASS" endtime="20190402 06:10:06.721" starttime="20190402 06:10:06.720"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:06.721" starttime="20190402 06:10:06.721"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:10:06.721" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:10:06.721" starttime="20190402 06:10:06.721"></status>
</kw>
<msg timestamp="20190402 06:10:06.721" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:10:06.722" starttime="20190402 06:10:05.698"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:10:06.722" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:10:06.722" starttime="20190402 06:10:06.722"></status>
</kw>
<msg timestamp="20190402 06:10:06.722" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:10:06.722" starttime="20190402 06:10:05.696"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:10:06.722" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:10:06.723" starttime="20190402 06:10:06.722"></status>
</kw>
<status status="FAIL" endtime="20190402 06:10:06.723" starttime="20190402 06:10:05.694"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:10:26.727" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:10:26.727" starttime="20190402 06:10:26.726"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:26.732" starttime="20190402 06:10:26.730"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:10:26.735" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:10:26.735" starttime="20190402 06:10:26.734"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:26.737" starttime="20190402 06:10:26.736"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:26.738" starttime="20190402 06:10:26.737"></status>
</kw>
<msg timestamp="20190402 06:10:26.739" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:10:26.739" starttime="20190402 06:10:26.733"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:10:26.740" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:10:26.740" starttime="20190402 06:10:26.739"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:10:26.769" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:10:26.769" starttime="20190402 06:10:26.740"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:10:27.744" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:10:27.744" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:10:27.744" starttime="20190402 06:10:26.769"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:10:27.745" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:10:27.746" starttime="20190402 06:10:27.745"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:10:27.746" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:10:27.746" starttime="20190402 06:10:27.746"></status>
</kw>
<msg timestamp="20190402 06:10:27.746" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:10:27.746" starttime="20190402 06:10:27.745"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:10:27.748" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:10:27.748" starttime="20190402 06:10:27.746"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:10:27.749" level="INFO">0</msg>
<msg timestamp="20190402 06:10:27.749" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:10:27.749" starttime="20190402 06:10:27.748"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:10:27.749" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:10:27.749" starttime="20190402 06:10:27.749"></status>
</kw>
<msg timestamp="20190402 06:10:27.749" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:10:27.749" starttime="20190402 06:10:27.746"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:27.750" starttime="20190402 06:10:27.750"></status>
</kw>
<status status="PASS" endtime="20190402 06:10:27.750" starttime="20190402 06:10:27.749"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:27.750" starttime="20190402 06:10:27.750"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:10:27.751" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:10:27.751" starttime="20190402 06:10:27.750"></status>
</kw>
<msg timestamp="20190402 06:10:27.751" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:10:27.751" starttime="20190402 06:10:26.728"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:10:27.751" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:10:27.751" starttime="20190402 06:10:27.751"></status>
</kw>
<msg timestamp="20190402 06:10:27.751" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:10:27.751" starttime="20190402 06:10:26.725"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:10:27.752" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:10:27.752" starttime="20190402 06:10:27.751"></status>
</kw>
<status status="FAIL" endtime="20190402 06:10:27.752" starttime="20190402 06:10:26.723"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:10:47.756" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:10:47.756" starttime="20190402 06:10:47.755"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:47.758" starttime="20190402 06:10:47.758"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:10:47.758" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:10:47.759" starttime="20190402 06:10:47.758"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:47.759" starttime="20190402 06:10:47.759"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:47.759" starttime="20190402 06:10:47.759"></status>
</kw>
<msg timestamp="20190402 06:10:47.759" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:10:47.759" starttime="20190402 06:10:47.758"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:10:47.760" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:10:47.760" starttime="20190402 06:10:47.760"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:10:47.770" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:10:47.770" starttime="20190402 06:10:47.760"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:10:48.837" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:10:48.837" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:10:48.837" starttime="20190402 06:10:47.770"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:10:48.838" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:10:48.838" starttime="20190402 06:10:48.838"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:10:48.838" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:10:48.838" starttime="20190402 06:10:48.838"></status>
</kw>
<msg timestamp="20190402 06:10:48.839" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:10:48.839" starttime="20190402 06:10:48.837"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:10:48.841" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:10:48.841" starttime="20190402 06:10:48.839"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:10:48.842" level="INFO">0</msg>
<msg timestamp="20190402 06:10:48.842" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:10:48.842" starttime="20190402 06:10:48.841"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:10:48.842" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:10:48.842" starttime="20190402 06:10:48.842"></status>
</kw>
<msg timestamp="20190402 06:10:48.842" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:10:48.842" starttime="20190402 06:10:48.839"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:48.843" starttime="20190402 06:10:48.843"></status>
</kw>
<status status="PASS" endtime="20190402 06:10:48.843" starttime="20190402 06:10:48.843"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:10:48.844" starttime="20190402 06:10:48.843"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:10:48.844" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:10:48.844" starttime="20190402 06:10:48.844"></status>
</kw>
<msg timestamp="20190402 06:10:48.844" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:10:48.844" starttime="20190402 06:10:47.757"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:10:48.845" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:10:48.845" starttime="20190402 06:10:48.844"></status>
</kw>
<msg timestamp="20190402 06:10:48.845" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:10:48.845" starttime="20190402 06:10:47.754"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:10:48.845" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:10:48.845" starttime="20190402 06:10:48.845"></status>
</kw>
<status status="FAIL" endtime="20190402 06:10:48.846" starttime="20190402 06:10:47.753"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:11:08.847" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:08.847" starttime="20190402 06:11:08.847"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:08.848" starttime="20190402 06:11:08.848"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:11:08.849" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:11:08.849" starttime="20190402 06:11:08.848"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:08.849" starttime="20190402 06:11:08.849"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:08.849" starttime="20190402 06:11:08.849"></status>
</kw>
<msg timestamp="20190402 06:11:08.850" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:11:08.850" starttime="20190402 06:11:08.848"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:11:08.850" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:08.850" starttime="20190402 06:11:08.850"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:11:08.860" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:08.861" starttime="20190402 06:11:08.850"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:11:09.859" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:11:09.859" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:09.859" starttime="20190402 06:11:08.861"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:11:09.860" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:09.860" starttime="20190402 06:11:09.860"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:11:09.860" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:11:09.860" starttime="20190402 06:11:09.860"></status>
</kw>
<msg timestamp="20190402 06:11:09.861" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:11:09.861" starttime="20190402 06:11:09.859"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:11:09.863" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:11:09.863" starttime="20190402 06:11:09.861"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:11:09.863" level="INFO">0</msg>
<msg timestamp="20190402 06:11:09.863" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:09.863" starttime="20190402 06:11:09.863"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:11:09.864" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:11:09.864" starttime="20190402 06:11:09.863"></status>
</kw>
<msg timestamp="20190402 06:11:09.864" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:09.864" starttime="20190402 06:11:09.861"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:09.865" starttime="20190402 06:11:09.864"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:09.865" starttime="20190402 06:11:09.864"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:09.865" starttime="20190402 06:11:09.865"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:11:09.866" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:11:09.866" starttime="20190402 06:11:09.865"></status>
</kw>
<msg timestamp="20190402 06:11:09.866" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:11:09.866" starttime="20190402 06:11:08.847"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:11:09.866" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:11:09.866" starttime="20190402 06:11:09.866"></status>
</kw>
<msg timestamp="20190402 06:11:09.866" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:11:09.866" starttime="20190402 06:11:08.846"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:11:09.867" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:11:09.867" starttime="20190402 06:11:09.867"></status>
</kw>
<status status="FAIL" endtime="20190402 06:11:09.867" starttime="20190402 06:11:08.846"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:11:29.869" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:29.869" starttime="20190402 06:11:29.868"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:29.869" starttime="20190402 06:11:29.869"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:11:29.870" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:11:29.870" starttime="20190402 06:11:29.870"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:29.870" starttime="20190402 06:11:29.870"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:29.871" starttime="20190402 06:11:29.871"></status>
</kw>
<msg timestamp="20190402 06:11:29.871" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:11:29.871" starttime="20190402 06:11:29.869"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:11:29.871" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:29.871" starttime="20190402 06:11:29.871"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:11:29.880" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:29.880" starttime="20190402 06:11:29.871"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:11:30.873" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:11:30.874" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:30.874" starttime="20190402 06:11:29.881"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:11:30.874" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:30.874" starttime="20190402 06:11:30.874"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:11:30.875" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190402 06:11:30.875" starttime="20190402 06:11:30.874"></status>
</kw>
<msg timestamp="20190402 06:11:30.875" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190402 06:11:30.875" starttime="20190402 06:11:30.874"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:11:30.877" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:11:30.877" starttime="20190402 06:11:30.875"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:11:30.877" level="INFO">0</msg>
<msg timestamp="20190402 06:11:30.878" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:30.878" starttime="20190402 06:11:30.877"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:11:30.878" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:11:30.878" starttime="20190402 06:11:30.878"></status>
</kw>
<msg timestamp="20190402 06:11:30.878" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:30.878" starttime="20190402 06:11:30.875"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:30.879" starttime="20190402 06:11:30.879"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:30.879" starttime="20190402 06:11:30.878"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:30.879" starttime="20190402 06:11:30.879"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:11:30.879" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190402 06:11:30.879" starttime="20190402 06:11:30.879"></status>
</kw>
<msg timestamp="20190402 06:11:30.880" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:11:30.880" starttime="20190402 06:11:29.869"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:11:30.880" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190402 06:11:30.880" starttime="20190402 06:11:30.880"></status>
</kw>
<msg timestamp="20190402 06:11:30.880" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190402 06:11:30.880" starttime="20190402 06:11:29.868"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:11:30.881" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190402 06:11:30.881" starttime="20190402 06:11:30.880"></status>
</kw>
<status status="FAIL" endtime="20190402 06:11:30.881" starttime="20190402 06:11:29.867"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:11:50.885" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:50.885" starttime="20190402 06:11:50.884"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:50.887" starttime="20190402 06:11:50.887"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:11:50.888" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:11:50.888" starttime="20190402 06:11:50.887"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:50.888" starttime="20190402 06:11:50.888"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:50.888" starttime="20190402 06:11:50.888"></status>
</kw>
<msg timestamp="20190402 06:11:50.888" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:11:50.888" starttime="20190402 06:11:50.887"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:11:50.889" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:50.889" starttime="20190402 06:11:50.889"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:11:50.900" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:50.900" starttime="20190402 06:11:50.889"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:11:52.077" level="INFO">available
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:11:52.077" level="INFO">${output} = available
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:52.077" starttime="20190402 06:11:50.900"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:11:52.078" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:52.078" starttime="20190402 06:11:52.078"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:11:52.078" level="INFO">${clean_out} = available
</msg>
<status status="PASS" endtime="20190402 06:11:52.078" starttime="20190402 06:11:52.078"></status>
</kw>
<msg timestamp="20190402 06:11:52.079" level="INFO">${output} = available
</msg>
<status status="PASS" endtime="20190402 06:11:52.079" starttime="20190402 06:11:52.077"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:11:52.081" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:11:52.081" starttime="20190402 06:11:52.079"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:11:52.081" level="INFO">0</msg>
<msg timestamp="20190402 06:11:52.081" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:52.082" starttime="20190402 06:11:52.081"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:11:52.082" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:11:52.082" starttime="20190402 06:11:52.082"></status>
</kw>
<msg timestamp="20190402 06:11:52.082" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:52.082" starttime="20190402 06:11:52.079"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:52.083" starttime="20190402 06:11:52.082"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:52.083" starttime="20190402 06:11:52.082"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:52.083" starttime="20190402 06:11:52.083"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:11:52.083" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: available</msg>
<status status="PASS" endtime="20190402 06:11:52.083" starttime="20190402 06:11:52.083"></status>
</kw>
<msg timestamp="20190402 06:11:52.084" level="INFO">${result} = {u'stdout': u'available', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:11:52.084" starttime="20190402 06:11:50.886"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:11:52.084" level="INFO">${value} = available</msg>
<status status="PASS" endtime="20190402 06:11:52.084" starttime="20190402 06:11:52.084"></status>
</kw>
<msg timestamp="20190402 06:11:52.084" level="INFO">${current_value} = available</msg>
<status status="PASS" endtime="20190402 06:11:52.084" starttime="20190402 06:11:50.883"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:52.085" starttime="20190402 06:11:52.084"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:52.085" starttime="20190402 06:11:50.882"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:52.085" starttime="20190402 06:02:01.471"></status>
</kw>
<kw name="Generate Secondary Controller Connection" library="Utils">
<doc>Establish a SSH connection with the secondary controller
to have it alive.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${controller}'=='controller-0'</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
<arg>${CONFIG.general.IP_UNIT_1_ADDRESS}</arg>
</arguments>
<assign>
<var>${controller_ip}</var>
</assign>
<msg timestamp="20190402 06:11:52.085" level="INFO">${controller_ip} = 192.168.200.77</msg>
<status status="PASS" endtime="20190402 06:11:52.085" starttime="20190402 06:11:52.085"></status>
</kw>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${controller_ip}</arg>
</arguments>
<assign>
<var>${secondary_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190402 06:11:52.086" level="INFO">${controller_connection} = 2</msg>
<status status="PASS" endtime="20190402 06:11:52.087" starttime="20190402 06:11:52.086"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190402 06:11:52.087" level="INFO">Length is 10</msg>
<msg timestamp="20190402 06:11:52.087" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190402 06:11:52.087" starttime="20190402 06:11:52.087"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190402 06:11:52.088" level="INFO">Logging into '192.168.200.77 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190402 06:11:55.799" level="INFO">Read output: /etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.</msg>
<status status="PASS" endtime="20190402 06:11:55.800" starttime="20190402 06:11:52.088"></status>
</kw>
<msg timestamp="20190402 06:11:55.800" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190402 06:11:55.801" starttime="20190402 06:11:52.087"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:55.801" starttime="20190402 06:11:52.087"></status>
</kw>
<msg timestamp="20190402 06:11:55.802" level="INFO">${secondary_controller_connection} = 2</msg>
<status status="PASS" endtime="20190402 06:11:55.802" starttime="20190402 06:11:52.086"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
</arguments>
<msg timestamp="20190402 06:11:55.803" level="INFO">${secondary_controller_connection} = 2</msg>
<status status="PASS" endtime="20190402 06:11:55.803" starttime="20190402 06:11:55.802"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
</arguments>
<msg timestamp="20190402 06:11:55.804" level="INFO">2</msg>
<status status="PASS" endtime="20190402 06:11:55.804" starttime="20190402 06:11:55.803"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${secondary_controller_connection} is not None</arg>
<arg>Switch Controller Connection</arg>
<arg>${master_controller_connection}</arg>
<arg>${secondary_controller_connection}</arg>
</arguments>
<kw name="Switch Controller Connection" library="Utils">
<doc>Enable a SSH connection to the new active controller and
source proper variables.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
<arg>${secondary_controller_connection}</arg>
</arguments>
<kw name="Switch Connection" library="SSHLibrary">
<doc>Switches the active connection by index or alias.</doc>
<arguments>
<arg>${new_idx}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:55.805" starttime="20190402 06:11:55.805"></status>
</kw>
<kw name="Get Connection" library="SSHLibrary">
<doc>Returns information about the connection.</doc>
<arguments>
<arg>${new_idx}</arg>
</arguments>
<msg timestamp="20190402 06:11:55.805" level="INFO">index=1
path_separator=/
prompt=$
width=80
newline=

height=24
encoding=UTF-8
alias=None
host=192.168.200.76 prompt=$
timeout=1 minute
term_type=vt100
port=22</msg>
<status status="PASS" endtime="20190402 06:11:55.806" starttime="20190402 06:11:55.805"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>whoami</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:55.806" starttime="20190402 06:11:55.806"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:11:55.807" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:11:55.807" starttime="20190402 06:11:55.807"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:55.807" starttime="20190402 06:11:55.807"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:55.808" starttime="20190402 06:11:55.807"></status>
</kw>
<msg timestamp="20190402 06:11:55.808" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:11:55.808" starttime="20190402 06:11:55.806"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:11:55.808" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:55.808" starttime="20190402 06:11:55.808"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:11:55.810" level="INFO">whoami</msg>
<status status="PASS" endtime="20190402 06:11:55.811" starttime="20190402 06:11:55.809"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:11:55.812" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:11:55.812" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:55.812" starttime="20190402 06:11:55.811"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:11:55.812" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:55.812" starttime="20190402 06:11:55.812"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:11:55.813" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190402 06:11:55.813" starttime="20190402 06:11:55.812"></status>
</kw>
<msg timestamp="20190402 06:11:55.813" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190402 06:11:55.813" starttime="20190402 06:11:55.812"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:11:55.815" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:11:55.815" starttime="20190402 06:11:55.813"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:11:55.815" level="INFO">0</msg>
<msg timestamp="20190402 06:11:55.815" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:55.815" starttime="20190402 06:11:55.815"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:11:55.816" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:11:55.816" starttime="20190402 06:11:55.815"></status>
</kw>
<msg timestamp="20190402 06:11:55.816" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:55.816" starttime="20190402 06:11:55.813"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:55.817" starttime="20190402 06:11:55.816"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:55.817" starttime="20190402 06:11:55.816"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:55.817" starttime="20190402 06:11:55.817"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:11:55.817" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190402 06:11:55.817" starttime="20190402 06:11:55.817"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:55.818" starttime="20190402 06:11:55.806"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Set Env Vars From Openrc</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:55.819" starttime="20190402 06:11:55.818"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:11:55.819" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:11:55.820" starttime="20190402 06:11:55.819"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:55.820" starttime="20190402 06:11:55.820"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:55.820" starttime="20190402 06:11:55.820"></status>
</kw>
<msg timestamp="20190402 06:11:55.820" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:11:55.820" starttime="20190402 06:11:55.819"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:11:55.821" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:55.821" starttime="20190402 06:11:55.821"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:11:55.826" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 06:11:55.826" starttime="20190402 06:11:55.821"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:11:56.229" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:11:56.230" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:56.230" starttime="20190402 06:11:55.826"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:11:56.231" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:56.231" starttime="20190402 06:11:56.230"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:11:56.231" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190402 06:11:56.231" starttime="20190402 06:11:56.231"></status>
</kw>
<msg timestamp="20190402 06:11:56.231" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190402 06:11:56.231" starttime="20190402 06:11:56.230"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:11:56.233" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:11:56.233" starttime="20190402 06:11:56.231"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:11:56.233" level="INFO">0</msg>
<msg timestamp="20190402 06:11:56.233" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:56.233" starttime="20190402 06:11:56.233"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:11:56.234" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:11:56.234" starttime="20190402 06:11:56.234"></status>
</kw>
<msg timestamp="20190402 06:11:56.234" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:56.234" starttime="20190402 06:11:56.231"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:56.235" starttime="20190402 06:11:56.234"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:56.235" starttime="20190402 06:11:56.234"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:56.235" starttime="20190402 06:11:56.235"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:11:56.235" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190402 06:11:56.235" starttime="20190402 06:11:56.235"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:56.235" starttime="20190402 06:11:55.818"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:56.236" starttime="20190402 06:11:55.818"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:56.236" starttime="20190402 06:11:55.818"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
<arg>${old_idx}</arg>
</arguments>
<msg timestamp="20190402 06:11:56.236" level="INFO">${secondary_controller_connection} = 2</msg>
<status status="PASS" endtime="20190402 06:11:56.236" starttime="20190402 06:11:56.236"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
<arg>${new_idx}</arg>
</arguments>
<msg timestamp="20190402 06:11:56.236" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 06:11:56.236" starttime="20190402 06:11:56.236"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:56.237" starttime="20190402 06:11:55.805"></status>
</kw>
<msg timestamp="20190402 06:11:56.237" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190402 06:11:56.237" starttime="20190402 06:11:55.804"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:56.237" starttime="20190402 06:11:52.085"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:56.237" starttime="20190402 06:01:53.931"></status>
</kw>
<kw name="Check Host Readiness" library="Utils">
<doc>Verify that host is unlocked, enabled and available.</doc>
<arguments>
<arg>${second_controller}</arg>
</arguments>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>40 min</arg>
<arg>5 sec</arg>
<arg>Check Property Value</arg>
<arg>${host}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:11:56.238" level="INFO">${system_cmd} = system host-show controller-1|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:56.238" starttime="20190402 06:11:56.238"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:56.239" starttime="20190402 06:11:56.239"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:11:56.240" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:11:56.240" starttime="20190402 06:11:56.239"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:56.240" starttime="20190402 06:11:56.240"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:56.240" starttime="20190402 06:11:56.240"></status>
</kw>
<msg timestamp="20190402 06:11:56.241" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:11:56.241" starttime="20190402 06:11:56.239"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:11:56.241" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:56.241" starttime="20190402 06:11:56.241"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:11:56.243" level="INFO">system host-show controller-1|grep -w  administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:56.243" starttime="20190402 06:11:56.241"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:11:57.302" level="INFO">unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:11:57.302" level="INFO">${output} = unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:57.302" starttime="20190402 06:11:56.243"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:11:57.303" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:57.303" starttime="20190402 06:11:57.303"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:11:57.303" level="INFO">${clean_out} = unlocked
</msg>
<status status="PASS" endtime="20190402 06:11:57.303" starttime="20190402 06:11:57.303"></status>
</kw>
<msg timestamp="20190402 06:11:57.304" level="INFO">${output} = unlocked
</msg>
<status status="PASS" endtime="20190402 06:11:57.304" starttime="20190402 06:11:57.302"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:11:57.306" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:11:57.306" starttime="20190402 06:11:57.304"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:11:57.306" level="INFO">0</msg>
<msg timestamp="20190402 06:11:57.306" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:57.306" starttime="20190402 06:11:57.306"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:11:57.306" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:11:57.307" starttime="20190402 06:11:57.306"></status>
</kw>
<msg timestamp="20190402 06:11:57.307" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:57.307" starttime="20190402 06:11:57.304"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:57.307" starttime="20190402 06:11:57.307"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:57.308" starttime="20190402 06:11:57.307"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:57.308" starttime="20190402 06:11:57.308"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:11:57.308" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: unlocked</msg>
<status status="PASS" endtime="20190402 06:11:57.308" starttime="20190402 06:11:57.308"></status>
</kw>
<msg timestamp="20190402 06:11:57.308" level="INFO">${result} = {u'stdout': u'unlocked', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:11:57.308" starttime="20190402 06:11:56.239"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:11:57.309" level="INFO">${value} = unlocked</msg>
<status status="PASS" endtime="20190402 06:11:57.309" starttime="20190402 06:11:57.308"></status>
</kw>
<msg timestamp="20190402 06:11:57.309" level="INFO">${current_value} = unlocked</msg>
<status status="PASS" endtime="20190402 06:11:57.309" starttime="20190402 06:11:56.238"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:57.309" starttime="20190402 06:11:57.309"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:57.309" starttime="20190402 06:11:56.238"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:57.309" starttime="20190402 06:11:56.237"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>20 min</arg>
<arg>5 sec</arg>
<arg>Check Property Value</arg>
<arg>${host}</arg>
<arg>operational</arg>
<arg>enabled</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>operational</arg>
<arg>enabled</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:11:57.311" level="INFO">${system_cmd} = system host-show controller-1|grep -w operational|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:57.311" starttime="20190402 06:11:57.310"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:57.311" starttime="20190402 06:11:57.311"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:11:57.312" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:11:57.312" starttime="20190402 06:11:57.312"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:57.312" starttime="20190402 06:11:57.312"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:57.313" starttime="20190402 06:11:57.313"></status>
</kw>
<msg timestamp="20190402 06:11:57.313" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:11:57.313" starttime="20190402 06:11:57.311"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:11:57.313" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:57.313" starttime="20190402 06:11:57.313"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:11:57.315" level="INFO">system host-show controller-1|grep -w  operational|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:57.315" starttime="20190402 06:11:57.313"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:11:58.410" level="INFO">enabled
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:11:58.410" level="INFO">${output} = enabled
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:58.410" starttime="20190402 06:11:57.315"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:11:58.411" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:58.411" starttime="20190402 06:11:58.411"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:11:58.412" level="INFO">${clean_out} = enabled
</msg>
<status status="PASS" endtime="20190402 06:11:58.412" starttime="20190402 06:11:58.411"></status>
</kw>
<msg timestamp="20190402 06:11:58.412" level="INFO">${output} = enabled
</msg>
<status status="PASS" endtime="20190402 06:11:58.412" starttime="20190402 06:11:58.411"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:11:58.413" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:11:58.414" starttime="20190402 06:11:58.412"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:11:58.414" level="INFO">0</msg>
<msg timestamp="20190402 06:11:58.414" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:58.414" starttime="20190402 06:11:58.414"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:11:58.414" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:11:58.414" starttime="20190402 06:11:58.414"></status>
</kw>
<msg timestamp="20190402 06:11:58.414" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:58.414" starttime="20190402 06:11:58.412"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:58.416" starttime="20190402 06:11:58.416"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:58.416" starttime="20190402 06:11:58.415"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:58.416" starttime="20190402 06:11:58.416"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:11:58.417" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: enabled</msg>
<status status="PASS" endtime="20190402 06:11:58.417" starttime="20190402 06:11:58.416"></status>
</kw>
<msg timestamp="20190402 06:11:58.417" level="INFO">${result} = {u'stdout': u'enabled', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:11:58.417" starttime="20190402 06:11:57.311"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:11:58.417" level="INFO">${value} = enabled</msg>
<status status="PASS" endtime="20190402 06:11:58.417" starttime="20190402 06:11:58.417"></status>
</kw>
<msg timestamp="20190402 06:11:58.417" level="INFO">${current_value} = enabled</msg>
<status status="PASS" endtime="20190402 06:11:58.417" starttime="20190402 06:11:57.310"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:58.418" starttime="20190402 06:11:58.418"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:58.418" starttime="20190402 06:11:57.310"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:58.418" starttime="20190402 06:11:57.310"></status>
</kw>
<kw name="Run Keyword And Ignore Error" library="BuiltIn">
<doc>Runs the given keyword with the given arguments and ignores possible error.</doc>
<arguments>
<arg>Check If Host Is In Degraded Mode</arg>
<arg>${host}</arg>
<arg>${wait_time}</arg>
</arguments>
<kw name="Check If Host Is In Degraded Mode" library="Utils">
<doc>Verify if host fall in a degraded mode during a period
of specified time.</doc>
<arguments>
<arg>${host}</arg>
<arg>${wait_time}</arg>
</arguments>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>${timeout} min</arg>
<arg>10 sec</arg>
<arg>Check Property Value</arg>
<arg>${host}</arg>
<arg>availability</arg>
<arg>degraded</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>degraded</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:11:58.420" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:58.420" starttime="20190402 06:11:58.419"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:58.420" starttime="20190402 06:11:58.420"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:11:58.421" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:11:58.421" starttime="20190402 06:11:58.421"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:58.421" starttime="20190402 06:11:58.421"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:58.422" starttime="20190402 06:11:58.421"></status>
</kw>
<msg timestamp="20190402 06:11:58.422" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:11:58.422" starttime="20190402 06:11:58.420"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:11:58.422" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:58.422" starttime="20190402 06:11:58.422"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:11:58.424" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:58.424" starttime="20190402 06:11:58.422"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:11:59.488" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:11:59.488" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:59.489" starttime="20190402 06:11:58.424"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:11:59.489" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:59.489" starttime="20190402 06:11:59.489"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:11:59.490" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:11:59.490" starttime="20190402 06:11:59.489"></status>
</kw>
<msg timestamp="20190402 06:11:59.490" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:11:59.490" starttime="20190402 06:11:59.489"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:11:59.492" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:11:59.492" starttime="20190402 06:11:59.490"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:11:59.492" level="INFO">0</msg>
<msg timestamp="20190402 06:11:59.492" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:59.492" starttime="20190402 06:11:59.492"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:11:59.493" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:11:59.493" starttime="20190402 06:11:59.493"></status>
</kw>
<msg timestamp="20190402 06:11:59.493" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:11:59.493" starttime="20190402 06:11:59.490"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:59.494" starttime="20190402 06:11:59.494"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:59.494" starttime="20190402 06:11:59.493"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:59.494" starttime="20190402 06:11:59.494"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:11:59.495" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:11:59.495" starttime="20190402 06:11:59.494"></status>
</kw>
<msg timestamp="20190402 06:11:59.495" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:11:59.495" starttime="20190402 06:11:58.420"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:11:59.495" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:11:59.495" starttime="20190402 06:11:59.495"></status>
</kw>
<msg timestamp="20190402 06:11:59.495" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:11:59.496" starttime="20190402 06:11:58.419"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:59.496" starttime="20190402 06:11:59.496"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:59.496" starttime="20190402 06:11:58.419"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:59.496" starttime="20190402 06:11:58.419"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:59.496" starttime="20190402 06:11:58.418"></status>
</kw>
<status status="PASS" endtime="20190402 06:11:59.496" starttime="20190402 06:11:58.418"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>60 min</arg>
<arg>5 sec</arg>
<arg>Check Property Value</arg>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:11:59.498" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:59.498" starttime="20190402 06:11:59.497"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:59.498" starttime="20190402 06:11:59.498"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:11:59.499" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:11:59.499" starttime="20190402 06:11:59.499"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:59.499" starttime="20190402 06:11:59.499"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:11:59.500" starttime="20190402 06:11:59.499"></status>
</kw>
<msg timestamp="20190402 06:11:59.500" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:11:59.500" starttime="20190402 06:11:59.498"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:11:59.500" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:11:59.500" starttime="20190402 06:11:59.500"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:11:59.502" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:11:59.502" starttime="20190402 06:11:59.500"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:12:00.589" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:12:00.590" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:00.590" starttime="20190402 06:11:59.502"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:12:00.590" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:00.590" starttime="20190402 06:12:00.590"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:12:00.591" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:00.591" starttime="20190402 06:12:00.590"></status>
</kw>
<msg timestamp="20190402 06:12:00.591" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:00.591" starttime="20190402 06:12:00.590"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:12:00.593" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:12:00.593" starttime="20190402 06:12:00.591"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:12:00.593" level="INFO">0</msg>
<msg timestamp="20190402 06:12:00.593" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:00.593" starttime="20190402 06:12:00.593"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:12:00.594" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:12:00.594" starttime="20190402 06:12:00.593"></status>
</kw>
<msg timestamp="20190402 06:12:00.594" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:00.594" starttime="20190402 06:12:00.591"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:00.595" starttime="20190402 06:12:00.594"></status>
</kw>
<status status="PASS" endtime="20190402 06:12:00.595" starttime="20190402 06:12:00.594"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:00.595" starttime="20190402 06:12:00.595"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:12:00.595" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:12:00.595" starttime="20190402 06:12:00.595"></status>
</kw>
<msg timestamp="20190402 06:12:00.596" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:12:00.596" starttime="20190402 06:11:59.498"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:12:00.596" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:00.596" starttime="20190402 06:12:00.596"></status>
</kw>
<msg timestamp="20190402 06:12:00.596" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:00.596" starttime="20190402 06:11:59.497"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:12:00.597" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:12:00.597" starttime="20190402 06:12:00.596"></status>
</kw>
<status status="FAIL" endtime="20190402 06:12:00.597" starttime="20190402 06:11:59.497"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:12:05.598" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:05.598" starttime="20190402 06:12:05.598"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:05.599" starttime="20190402 06:12:05.599"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:12:05.600" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:12:05.600" starttime="20190402 06:12:05.599"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:05.600" starttime="20190402 06:12:05.600"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:05.600" starttime="20190402 06:12:05.600"></status>
</kw>
<msg timestamp="20190402 06:12:05.601" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:12:05.601" starttime="20190402 06:12:05.599"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:12:05.601" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:05.601" starttime="20190402 06:12:05.601"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:12:05.611" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:05.611" starttime="20190402 06:12:05.601"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:12:06.687" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:12:06.687" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:06.688" starttime="20190402 06:12:05.612"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:12:06.688" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:06.688" starttime="20190402 06:12:06.688"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:12:06.689" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:06.689" starttime="20190402 06:12:06.688"></status>
</kw>
<msg timestamp="20190402 06:12:06.689" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:06.689" starttime="20190402 06:12:06.688"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:12:06.691" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:12:06.691" starttime="20190402 06:12:06.689"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:12:06.691" level="INFO">0</msg>
<msg timestamp="20190402 06:12:06.691" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:06.691" starttime="20190402 06:12:06.691"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:12:06.691" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:12:06.692" starttime="20190402 06:12:06.691"></status>
</kw>
<msg timestamp="20190402 06:12:06.692" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:06.692" starttime="20190402 06:12:06.689"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:06.692" starttime="20190402 06:12:06.692"></status>
</kw>
<status status="PASS" endtime="20190402 06:12:06.692" starttime="20190402 06:12:06.692"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:06.693" starttime="20190402 06:12:06.693"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:12:06.693" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:12:06.693" starttime="20190402 06:12:06.693"></status>
</kw>
<msg timestamp="20190402 06:12:06.693" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:12:06.693" starttime="20190402 06:12:05.598"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:12:06.694" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:06.694" starttime="20190402 06:12:06.693"></status>
</kw>
<msg timestamp="20190402 06:12:06.694" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:06.694" starttime="20190402 06:12:05.598"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:12:06.694" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:12:06.694" starttime="20190402 06:12:06.694"></status>
</kw>
<status status="FAIL" endtime="20190402 06:12:06.695" starttime="20190402 06:12:05.597"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:12:11.696" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:11.696" starttime="20190402 06:12:11.696"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:11.697" starttime="20190402 06:12:11.697"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:12:11.698" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:12:11.698" starttime="20190402 06:12:11.697"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:11.698" starttime="20190402 06:12:11.698"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:11.698" starttime="20190402 06:12:11.698"></status>
</kw>
<msg timestamp="20190402 06:12:11.698" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:12:11.698" starttime="20190402 06:12:11.697"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:12:11.699" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:11.699" starttime="20190402 06:12:11.699"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:12:11.708" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:11.708" starttime="20190402 06:12:11.699"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:12:12.756" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:12:12.756" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:12.756" starttime="20190402 06:12:11.708"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:12:12.757" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:12.757" starttime="20190402 06:12:12.756"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:12:12.757" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:12.757" starttime="20190402 06:12:12.757"></status>
</kw>
<msg timestamp="20190402 06:12:12.757" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:12.757" starttime="20190402 06:12:12.756"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:12:12.759" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:12:12.759" starttime="20190402 06:12:12.757"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:12:12.759" level="INFO">0</msg>
<msg timestamp="20190402 06:12:12.759" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:12.759" starttime="20190402 06:12:12.759"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:12:12.760" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:12:12.760" starttime="20190402 06:12:12.760"></status>
</kw>
<msg timestamp="20190402 06:12:12.760" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:12.760" starttime="20190402 06:12:12.757"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:12.761" starttime="20190402 06:12:12.760"></status>
</kw>
<status status="PASS" endtime="20190402 06:12:12.761" starttime="20190402 06:12:12.760"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:12.761" starttime="20190402 06:12:12.761"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:12:12.761" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:12:12.761" starttime="20190402 06:12:12.761"></status>
</kw>
<msg timestamp="20190402 06:12:12.762" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:12:12.762" starttime="20190402 06:12:11.696"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:12:12.762" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:12.762" starttime="20190402 06:12:12.762"></status>
</kw>
<msg timestamp="20190402 06:12:12.762" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:12.762" starttime="20190402 06:12:11.695"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:12:12.763" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:12:12.763" starttime="20190402 06:12:12.762"></status>
</kw>
<status status="FAIL" endtime="20190402 06:12:12.763" starttime="20190402 06:12:11.695"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:12:17.764" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:17.764" starttime="20190402 06:12:17.764"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:17.765" starttime="20190402 06:12:17.765"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:12:17.766" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:12:17.766" starttime="20190402 06:12:17.765"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:17.766" starttime="20190402 06:12:17.766"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:17.767" starttime="20190402 06:12:17.766"></status>
</kw>
<msg timestamp="20190402 06:12:17.767" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:12:17.767" starttime="20190402 06:12:17.765"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:12:17.767" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:17.767" starttime="20190402 06:12:17.767"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:12:17.777" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:17.777" starttime="20190402 06:12:17.767"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:12:18.836" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:12:18.836" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:18.836" starttime="20190402 06:12:17.777"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:12:18.837" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:18.837" starttime="20190402 06:12:18.837"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:12:18.837" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:18.837" starttime="20190402 06:12:18.837"></status>
</kw>
<msg timestamp="20190402 06:12:18.837" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:18.837" starttime="20190402 06:12:18.836"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:12:18.839" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:12:18.839" starttime="20190402 06:12:18.838"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:12:18.840" level="INFO">0</msg>
<msg timestamp="20190402 06:12:18.840" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:18.840" starttime="20190402 06:12:18.839"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:12:18.840" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:12:18.840" starttime="20190402 06:12:18.840"></status>
</kw>
<msg timestamp="20190402 06:12:18.840" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:18.840" starttime="20190402 06:12:18.837"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:18.841" starttime="20190402 06:12:18.841"></status>
</kw>
<status status="PASS" endtime="20190402 06:12:18.841" starttime="20190402 06:12:18.840"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:18.841" starttime="20190402 06:12:18.841"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:12:18.842" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:12:18.842" starttime="20190402 06:12:18.842"></status>
</kw>
<msg timestamp="20190402 06:12:18.842" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:12:18.842" starttime="20190402 06:12:17.765"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:12:18.842" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:18.842" starttime="20190402 06:12:18.842"></status>
</kw>
<msg timestamp="20190402 06:12:18.842" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:18.842" starttime="20190402 06:12:17.764"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:12:18.843" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:12:18.843" starttime="20190402 06:12:18.843"></status>
</kw>
<status status="FAIL" endtime="20190402 06:12:18.843" starttime="20190402 06:12:17.763"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:12:23.845" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:23.845" starttime="20190402 06:12:23.844"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:23.846" starttime="20190402 06:12:23.845"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:12:23.846" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:12:23.846" starttime="20190402 06:12:23.846"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:23.847" starttime="20190402 06:12:23.846"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:23.847" starttime="20190402 06:12:23.847"></status>
</kw>
<msg timestamp="20190402 06:12:23.847" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:12:23.847" starttime="20190402 06:12:23.846"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:12:23.848" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:23.848" starttime="20190402 06:12:23.847"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:12:23.858" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:23.858" starttime="20190402 06:12:23.848"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:12:24.927" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:12:24.927" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:24.927" starttime="20190402 06:12:23.858"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:12:24.928" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:24.928" starttime="20190402 06:12:24.927"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:12:24.928" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:24.928" starttime="20190402 06:12:24.928"></status>
</kw>
<msg timestamp="20190402 06:12:24.928" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:24.928" starttime="20190402 06:12:24.927"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:12:24.930" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:12:24.930" starttime="20190402 06:12:24.929"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:12:24.931" level="INFO">0</msg>
<msg timestamp="20190402 06:12:24.931" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:24.931" starttime="20190402 06:12:24.930"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:12:24.931" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:12:24.931" starttime="20190402 06:12:24.931"></status>
</kw>
<msg timestamp="20190402 06:12:24.931" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:24.931" starttime="20190402 06:12:24.928"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:24.932" starttime="20190402 06:12:24.932"></status>
</kw>
<status status="PASS" endtime="20190402 06:12:24.932" starttime="20190402 06:12:24.931"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:24.932" starttime="20190402 06:12:24.932"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:12:24.933" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:12:24.933" starttime="20190402 06:12:24.932"></status>
</kw>
<msg timestamp="20190402 06:12:24.933" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:12:24.933" starttime="20190402 06:12:23.845"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:12:24.933" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:24.933" starttime="20190402 06:12:24.933"></status>
</kw>
<msg timestamp="20190402 06:12:24.933" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:24.933" starttime="20190402 06:12:23.844"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:12:24.934" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:12:24.934" starttime="20190402 06:12:24.934"></status>
</kw>
<status status="FAIL" endtime="20190402 06:12:24.934" starttime="20190402 06:12:23.843"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:12:29.935" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:29.935" starttime="20190402 06:12:29.935"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:29.936" starttime="20190402 06:12:29.936"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:12:29.937" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:12:29.937" starttime="20190402 06:12:29.937"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:29.937" starttime="20190402 06:12:29.937"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:29.938" starttime="20190402 06:12:29.938"></status>
</kw>
<msg timestamp="20190402 06:12:29.938" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:12:29.938" starttime="20190402 06:12:29.936"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:12:29.938" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:29.938" starttime="20190402 06:12:29.938"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:12:29.948" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:29.948" starttime="20190402 06:12:29.938"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:12:31.034" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:12:31.035" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:31.035" starttime="20190402 06:12:29.948"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:12:31.035" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:31.035" starttime="20190402 06:12:31.035"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:12:31.036" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:31.036" starttime="20190402 06:12:31.036"></status>
</kw>
<msg timestamp="20190402 06:12:31.036" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:31.036" starttime="20190402 06:12:31.035"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:12:31.038" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:12:31.038" starttime="20190402 06:12:31.036"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:12:31.038" level="INFO">0</msg>
<msg timestamp="20190402 06:12:31.039" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:31.039" starttime="20190402 06:12:31.038"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:12:31.039" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:12:31.039" starttime="20190402 06:12:31.039"></status>
</kw>
<msg timestamp="20190402 06:12:31.039" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:31.039" starttime="20190402 06:12:31.036"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:31.040" starttime="20190402 06:12:31.040"></status>
</kw>
<status status="PASS" endtime="20190402 06:12:31.040" starttime="20190402 06:12:31.039"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:31.040" starttime="20190402 06:12:31.040"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:12:31.040" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:12:31.040" starttime="20190402 06:12:31.040"></status>
</kw>
<msg timestamp="20190402 06:12:31.041" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:12:31.041" starttime="20190402 06:12:29.936"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:12:31.041" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:31.041" starttime="20190402 06:12:31.041"></status>
</kw>
<msg timestamp="20190402 06:12:31.041" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:31.041" starttime="20190402 06:12:29.935"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:12:31.042" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:12:31.042" starttime="20190402 06:12:31.041"></status>
</kw>
<status status="FAIL" endtime="20190402 06:12:31.042" starttime="20190402 06:12:29.934"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:12:36.043" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:36.043" starttime="20190402 06:12:36.043"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:36.044" starttime="20190402 06:12:36.044"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:12:36.045" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:12:36.045" starttime="20190402 06:12:36.044"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:36.045" starttime="20190402 06:12:36.045"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:36.046" starttime="20190402 06:12:36.045"></status>
</kw>
<msg timestamp="20190402 06:12:36.046" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:12:36.046" starttime="20190402 06:12:36.044"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:12:36.046" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:36.046" starttime="20190402 06:12:36.046"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:12:36.056" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:36.056" starttime="20190402 06:12:36.046"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:12:37.148" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:12:37.148" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:37.148" starttime="20190402 06:12:36.056"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:12:37.149" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:37.149" starttime="20190402 06:12:37.148"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:12:37.149" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:37.149" starttime="20190402 06:12:37.149"></status>
</kw>
<msg timestamp="20190402 06:12:37.149" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:37.149" starttime="20190402 06:12:37.148"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:12:37.151" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:12:37.151" starttime="20190402 06:12:37.150"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:12:37.152" level="INFO">0</msg>
<msg timestamp="20190402 06:12:37.152" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:37.152" starttime="20190402 06:12:37.151"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:12:37.152" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:12:37.152" starttime="20190402 06:12:37.152"></status>
</kw>
<msg timestamp="20190402 06:12:37.152" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:37.152" starttime="20190402 06:12:37.149"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:37.153" starttime="20190402 06:12:37.153"></status>
</kw>
<status status="PASS" endtime="20190402 06:12:37.153" starttime="20190402 06:12:37.152"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:37.153" starttime="20190402 06:12:37.153"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:12:37.153" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:12:37.154" starttime="20190402 06:12:37.153"></status>
</kw>
<msg timestamp="20190402 06:12:37.154" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:12:37.154" starttime="20190402 06:12:36.043"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:12:37.154" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:37.154" starttime="20190402 06:12:37.154"></status>
</kw>
<msg timestamp="20190402 06:12:37.154" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:37.154" starttime="20190402 06:12:36.043"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:12:37.155" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:12:37.155" starttime="20190402 06:12:37.154"></status>
</kw>
<status status="FAIL" endtime="20190402 06:12:37.155" starttime="20190402 06:12:36.042"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:12:42.156" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:42.156" starttime="20190402 06:12:42.156"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:42.157" starttime="20190402 06:12:42.157"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:12:42.158" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:12:42.158" starttime="20190402 06:12:42.157"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:42.158" starttime="20190402 06:12:42.158"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:42.158" starttime="20190402 06:12:42.158"></status>
</kw>
<msg timestamp="20190402 06:12:42.159" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:12:42.159" starttime="20190402 06:12:42.157"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:12:42.159" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:42.159" starttime="20190402 06:12:42.159"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:12:42.168" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:42.168" starttime="20190402 06:12:42.159"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:12:43.212" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:12:43.212" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:43.212" starttime="20190402 06:12:42.168"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:12:43.213" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:43.213" starttime="20190402 06:12:43.213"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:12:43.213" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:43.213" starttime="20190402 06:12:43.213"></status>
</kw>
<msg timestamp="20190402 06:12:43.214" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:43.214" starttime="20190402 06:12:43.212"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:12:43.215" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:12:43.215" starttime="20190402 06:12:43.214"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:12:43.217" level="INFO">0</msg>
<msg timestamp="20190402 06:12:43.217" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:43.217" starttime="20190402 06:12:43.215"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:12:43.217" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:12:43.217" starttime="20190402 06:12:43.217"></status>
</kw>
<msg timestamp="20190402 06:12:43.217" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:43.218" starttime="20190402 06:12:43.214"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:43.218" starttime="20190402 06:12:43.218"></status>
</kw>
<status status="PASS" endtime="20190402 06:12:43.218" starttime="20190402 06:12:43.218"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:43.219" starttime="20190402 06:12:43.218"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:12:43.219" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:12:43.219" starttime="20190402 06:12:43.219"></status>
</kw>
<msg timestamp="20190402 06:12:43.219" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:12:43.219" starttime="20190402 06:12:42.156"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:12:43.219" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:43.219" starttime="20190402 06:12:43.219"></status>
</kw>
<msg timestamp="20190402 06:12:43.220" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:43.220" starttime="20190402 06:12:42.156"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:12:43.220" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:12:43.220" starttime="20190402 06:12:43.220"></status>
</kw>
<status status="FAIL" endtime="20190402 06:12:43.220" starttime="20190402 06:12:42.155"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:12:48.222" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:48.222" starttime="20190402 06:12:48.221"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:48.222" starttime="20190402 06:12:48.222"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:12:48.223" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:12:48.223" starttime="20190402 06:12:48.223"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:48.224" starttime="20190402 06:12:48.223"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:48.224" starttime="20190402 06:12:48.224"></status>
</kw>
<msg timestamp="20190402 06:12:48.224" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:12:48.224" starttime="20190402 06:12:48.223"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:12:48.224" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:48.224" starttime="20190402 06:12:48.224"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:12:48.235" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:48.235" starttime="20190402 06:12:48.224"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:12:49.290" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:12:49.290" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:49.290" starttime="20190402 06:12:48.235"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:12:49.291" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:49.291" starttime="20190402 06:12:49.290"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:12:49.291" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:49.291" starttime="20190402 06:12:49.291"></status>
</kw>
<msg timestamp="20190402 06:12:49.291" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:49.291" starttime="20190402 06:12:49.290"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:12:49.295" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:12:49.295" starttime="20190402 06:12:49.292"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:12:49.296" level="INFO">0</msg>
<msg timestamp="20190402 06:12:49.296" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:49.296" starttime="20190402 06:12:49.295"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:12:49.296" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:12:49.296" starttime="20190402 06:12:49.296"></status>
</kw>
<msg timestamp="20190402 06:12:49.296" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:49.297" starttime="20190402 06:12:49.291"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:49.297" starttime="20190402 06:12:49.297"></status>
</kw>
<status status="PASS" endtime="20190402 06:12:49.297" starttime="20190402 06:12:49.297"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:49.298" starttime="20190402 06:12:49.297"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:12:49.298" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:12:49.298" starttime="20190402 06:12:49.298"></status>
</kw>
<msg timestamp="20190402 06:12:49.298" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:12:49.298" starttime="20190402 06:12:48.222"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:12:49.298" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:49.298" starttime="20190402 06:12:49.298"></status>
</kw>
<msg timestamp="20190402 06:12:49.299" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:49.299" starttime="20190402 06:12:48.221"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:12:49.299" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:12:49.299" starttime="20190402 06:12:49.299"></status>
</kw>
<status status="FAIL" endtime="20190402 06:12:49.299" starttime="20190402 06:12:48.221"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:12:54.301" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:54.301" starttime="20190402 06:12:54.300"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:54.302" starttime="20190402 06:12:54.301"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:12:54.302" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:12:54.302" starttime="20190402 06:12:54.302"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:54.303" starttime="20190402 06:12:54.302"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:54.303" starttime="20190402 06:12:54.303"></status>
</kw>
<msg timestamp="20190402 06:12:54.303" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:12:54.303" starttime="20190402 06:12:54.302"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:12:54.303" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:54.304" starttime="20190402 06:12:54.303"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:12:54.315" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:12:54.315" starttime="20190402 06:12:54.304"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:12:55.408" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:12:55.408" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:55.408" starttime="20190402 06:12:54.315"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:12:55.409" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:12:55.409" starttime="20190402 06:12:55.409"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:12:55.409" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:55.409" starttime="20190402 06:12:55.409"></status>
</kw>
<msg timestamp="20190402 06:12:55.410" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:12:55.410" starttime="20190402 06:12:55.408"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:12:55.411" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:12:55.411" starttime="20190402 06:12:55.410"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:12:55.412" level="INFO">0</msg>
<msg timestamp="20190402 06:12:55.412" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:55.412" starttime="20190402 06:12:55.412"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:12:55.412" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:12:55.412" starttime="20190402 06:12:55.412"></status>
</kw>
<msg timestamp="20190402 06:12:55.412" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:12:55.412" starttime="20190402 06:12:55.410"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:55.413" starttime="20190402 06:12:55.413"></status>
</kw>
<status status="PASS" endtime="20190402 06:12:55.413" starttime="20190402 06:12:55.413"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:12:55.413" starttime="20190402 06:12:55.413"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:12:55.414" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:12:55.414" starttime="20190402 06:12:55.414"></status>
</kw>
<msg timestamp="20190402 06:12:55.414" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:12:55.414" starttime="20190402 06:12:54.301"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:12:55.414" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:55.414" starttime="20190402 06:12:55.414"></status>
</kw>
<msg timestamp="20190402 06:12:55.414" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:12:55.415" starttime="20190402 06:12:54.300"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:12:55.415" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:12:55.415" starttime="20190402 06:12:55.415"></status>
</kw>
<status status="FAIL" endtime="20190402 06:12:55.415" starttime="20190402 06:12:54.300"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:13:00.416" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:00.417" starttime="20190402 06:13:00.416"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:00.417" starttime="20190402 06:13:00.417"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:13:00.418" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:13:00.418" starttime="20190402 06:13:00.418"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:00.418" starttime="20190402 06:13:00.418"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:00.419" starttime="20190402 06:13:00.418"></status>
</kw>
<msg timestamp="20190402 06:13:00.419" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:13:00.419" starttime="20190402 06:13:00.417"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:13:00.419" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:00.419" starttime="20190402 06:13:00.419"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:13:00.424" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:00.424" starttime="20190402 06:13:00.419"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:13:01.531" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:13:01.531" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:01.532" starttime="20190402 06:13:00.424"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:13:01.532" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:01.532" starttime="20190402 06:13:01.532"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:13:01.533" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:01.533" starttime="20190402 06:13:01.532"></status>
</kw>
<msg timestamp="20190402 06:13:01.533" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:01.533" starttime="20190402 06:13:01.532"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:13:01.535" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:13:01.535" starttime="20190402 06:13:01.533"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:13:01.535" level="INFO">0</msg>
<msg timestamp="20190402 06:13:01.536" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:01.536" starttime="20190402 06:13:01.535"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:13:01.536" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:13:01.536" starttime="20190402 06:13:01.536"></status>
</kw>
<msg timestamp="20190402 06:13:01.536" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:01.536" starttime="20190402 06:13:01.533"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:01.537" starttime="20190402 06:13:01.537"></status>
</kw>
<status status="PASS" endtime="20190402 06:13:01.537" starttime="20190402 06:13:01.536"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:01.537" starttime="20190402 06:13:01.537"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:13:01.537" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:13:01.537" starttime="20190402 06:13:01.537"></status>
</kw>
<msg timestamp="20190402 06:13:01.538" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:13:01.538" starttime="20190402 06:13:00.417"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:13:01.538" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:01.538" starttime="20190402 06:13:01.538"></status>
</kw>
<msg timestamp="20190402 06:13:01.538" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:01.538" starttime="20190402 06:13:00.416"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:13:01.539" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:13:01.539" starttime="20190402 06:13:01.538"></status>
</kw>
<status status="FAIL" endtime="20190402 06:13:01.539" starttime="20190402 06:13:00.415"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:13:06.541" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:06.541" starttime="20190402 06:13:06.540"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:06.542" starttime="20190402 06:13:06.542"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:13:06.543" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:13:06.543" starttime="20190402 06:13:06.543"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:06.544" starttime="20190402 06:13:06.543"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:06.544" starttime="20190402 06:13:06.544"></status>
</kw>
<msg timestamp="20190402 06:13:06.545" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:13:06.545" starttime="20190402 06:13:06.542"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:13:06.545" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:06.545" starttime="20190402 06:13:06.545"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:13:06.561" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:06.561" starttime="20190402 06:13:06.545"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:13:07.640" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:13:07.640" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:07.640" starttime="20190402 06:13:06.561"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:13:07.641" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:07.641" starttime="20190402 06:13:07.640"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:13:07.641" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:07.641" starttime="20190402 06:13:07.641"></status>
</kw>
<msg timestamp="20190402 06:13:07.641" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:07.641" starttime="20190402 06:13:07.640"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:13:07.642" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:13:07.643" starttime="20190402 06:13:07.641"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:13:07.643" level="INFO">0</msg>
<msg timestamp="20190402 06:13:07.643" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:07.643" starttime="20190402 06:13:07.643"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:13:07.643" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:13:07.644" starttime="20190402 06:13:07.643"></status>
</kw>
<msg timestamp="20190402 06:13:07.644" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:07.644" starttime="20190402 06:13:07.641"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:07.645" starttime="20190402 06:13:07.645"></status>
</kw>
<status status="PASS" endtime="20190402 06:13:07.645" starttime="20190402 06:13:07.644"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:07.645" starttime="20190402 06:13:07.645"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:13:07.646" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:13:07.646" starttime="20190402 06:13:07.645"></status>
</kw>
<msg timestamp="20190402 06:13:07.646" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:13:07.646" starttime="20190402 06:13:06.541"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:13:07.646" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:07.646" starttime="20190402 06:13:07.646"></status>
</kw>
<msg timestamp="20190402 06:13:07.646" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:07.646" starttime="20190402 06:13:06.540"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:13:07.647" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:13:07.647" starttime="20190402 06:13:07.647"></status>
</kw>
<status status="FAIL" endtime="20190402 06:13:07.647" starttime="20190402 06:13:06.539"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:13:12.648" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:12.649" starttime="20190402 06:13:12.648"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:12.649" starttime="20190402 06:13:12.649"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:13:12.650" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:13:12.650" starttime="20190402 06:13:12.650"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:12.650" starttime="20190402 06:13:12.650"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:12.651" starttime="20190402 06:13:12.650"></status>
</kw>
<msg timestamp="20190402 06:13:12.651" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:13:12.651" starttime="20190402 06:13:12.649"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:13:12.651" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:12.651" starttime="20190402 06:13:12.651"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:13:12.662" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:12.662" starttime="20190402 06:13:12.651"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:13:13.717" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:13:13.718" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:13.718" starttime="20190402 06:13:12.663"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:13:13.718" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:13.718" starttime="20190402 06:13:13.718"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:13:13.719" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:13.719" starttime="20190402 06:13:13.719"></status>
</kw>
<msg timestamp="20190402 06:13:13.719" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:13.719" starttime="20190402 06:13:13.718"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:13:13.721" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:13:13.721" starttime="20190402 06:13:13.719"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:13:13.722" level="INFO">0</msg>
<msg timestamp="20190402 06:13:13.722" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:13.722" starttime="20190402 06:13:13.722"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:13:13.722" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:13:13.722" starttime="20190402 06:13:13.722"></status>
</kw>
<msg timestamp="20190402 06:13:13.722" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:13.722" starttime="20190402 06:13:13.719"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:13.723" starttime="20190402 06:13:13.723"></status>
</kw>
<status status="PASS" endtime="20190402 06:13:13.723" starttime="20190402 06:13:13.723"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:13.724" starttime="20190402 06:13:13.723"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:13:13.724" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:13:13.724" starttime="20190402 06:13:13.724"></status>
</kw>
<msg timestamp="20190402 06:13:13.724" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:13:13.724" starttime="20190402 06:13:12.649"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:13:13.725" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:13.725" starttime="20190402 06:13:13.724"></status>
</kw>
<msg timestamp="20190402 06:13:13.725" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:13.725" starttime="20190402 06:13:12.648"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:13:13.725" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:13:13.725" starttime="20190402 06:13:13.725"></status>
</kw>
<status status="FAIL" endtime="20190402 06:13:13.725" starttime="20190402 06:13:12.647"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:13:18.727" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:18.727" starttime="20190402 06:13:18.726"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:18.728" starttime="20190402 06:13:18.727"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:13:18.728" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:13:18.728" starttime="20190402 06:13:18.728"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:18.729" starttime="20190402 06:13:18.728"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:18.729" starttime="20190402 06:13:18.729"></status>
</kw>
<msg timestamp="20190402 06:13:18.729" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:13:18.729" starttime="20190402 06:13:18.728"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:13:18.729" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:18.729" starttime="20190402 06:13:18.729"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:13:18.739" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:18.739" starttime="20190402 06:13:18.730"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:13:19.782" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:13:19.782" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:19.782" starttime="20190402 06:13:18.739"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:13:19.783" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:19.783" starttime="20190402 06:13:19.783"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:13:19.783" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:19.783" starttime="20190402 06:13:19.783"></status>
</kw>
<msg timestamp="20190402 06:13:19.783" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:19.783" starttime="20190402 06:13:19.782"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:13:19.785" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:13:19.785" starttime="20190402 06:13:19.784"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:13:19.786" level="INFO">0</msg>
<msg timestamp="20190402 06:13:19.786" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:19.786" starttime="20190402 06:13:19.785"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:13:19.786" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:13:19.786" starttime="20190402 06:13:19.786"></status>
</kw>
<msg timestamp="20190402 06:13:19.786" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:19.786" starttime="20190402 06:13:19.783"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:19.787" starttime="20190402 06:13:19.787"></status>
</kw>
<status status="PASS" endtime="20190402 06:13:19.787" starttime="20190402 06:13:19.786"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:19.787" starttime="20190402 06:13:19.787"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:13:19.788" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:13:19.788" starttime="20190402 06:13:19.787"></status>
</kw>
<msg timestamp="20190402 06:13:19.788" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:13:19.788" starttime="20190402 06:13:18.727"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:13:19.788" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:19.788" starttime="20190402 06:13:19.788"></status>
</kw>
<msg timestamp="20190402 06:13:19.788" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:19.788" starttime="20190402 06:13:18.726"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:13:19.789" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:13:19.789" starttime="20190402 06:13:19.788"></status>
</kw>
<status status="FAIL" endtime="20190402 06:13:19.789" starttime="20190402 06:13:18.726"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:13:24.791" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:24.791" starttime="20190402 06:13:24.790"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:24.791" starttime="20190402 06:13:24.791"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:13:24.792" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:13:24.792" starttime="20190402 06:13:24.792"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:24.792" starttime="20190402 06:13:24.792"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:24.793" starttime="20190402 06:13:24.792"></status>
</kw>
<msg timestamp="20190402 06:13:24.793" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:13:24.793" starttime="20190402 06:13:24.791"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:13:24.793" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:24.793" starttime="20190402 06:13:24.793"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:13:24.805" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:24.805" starttime="20190402 06:13:24.793"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:13:25.936" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:13:25.936" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:25.936" starttime="20190402 06:13:24.805"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:13:25.937" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:25.937" starttime="20190402 06:13:25.937"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:13:25.938" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:25.938" starttime="20190402 06:13:25.937"></status>
</kw>
<msg timestamp="20190402 06:13:25.938" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:25.938" starttime="20190402 06:13:25.937"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:13:25.940" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:13:25.940" starttime="20190402 06:13:25.938"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:13:25.940" level="INFO">0</msg>
<msg timestamp="20190402 06:13:25.940" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:25.940" starttime="20190402 06:13:25.940"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:13:25.941" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:13:25.941" starttime="20190402 06:13:25.940"></status>
</kw>
<msg timestamp="20190402 06:13:25.941" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:25.941" starttime="20190402 06:13:25.938"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:25.942" starttime="20190402 06:13:25.941"></status>
</kw>
<status status="PASS" endtime="20190402 06:13:25.942" starttime="20190402 06:13:25.941"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:25.942" starttime="20190402 06:13:25.942"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:13:25.942" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:13:25.942" starttime="20190402 06:13:25.942"></status>
</kw>
<msg timestamp="20190402 06:13:25.942" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:13:25.942" starttime="20190402 06:13:24.791"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:13:25.943" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:25.943" starttime="20190402 06:13:25.943"></status>
</kw>
<msg timestamp="20190402 06:13:25.943" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:25.943" starttime="20190402 06:13:24.790"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:13:25.943" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:13:25.943" starttime="20190402 06:13:25.943"></status>
</kw>
<status status="FAIL" endtime="20190402 06:13:25.944" starttime="20190402 06:13:24.789"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:13:30.945" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:30.945" starttime="20190402 06:13:30.945"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:30.946" starttime="20190402 06:13:30.946"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:13:30.947" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:13:30.947" starttime="20190402 06:13:30.946"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:30.947" starttime="20190402 06:13:30.947"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:30.947" starttime="20190402 06:13:30.947"></status>
</kw>
<msg timestamp="20190402 06:13:30.948" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:13:30.948" starttime="20190402 06:13:30.946"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:13:30.948" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:30.948" starttime="20190402 06:13:30.948"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:13:30.959" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:30.959" starttime="20190402 06:13:30.948"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:13:32.094" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:13:32.094" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:32.094" starttime="20190402 06:13:30.959"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:13:32.095" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:32.095" starttime="20190402 06:13:32.095"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:13:32.095" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:32.096" starttime="20190402 06:13:32.095"></status>
</kw>
<msg timestamp="20190402 06:13:32.096" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:32.096" starttime="20190402 06:13:32.095"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:13:32.097" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:13:32.097" starttime="20190402 06:13:32.096"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:13:32.098" level="INFO">0</msg>
<msg timestamp="20190402 06:13:32.098" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:32.098" starttime="20190402 06:13:32.097"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:13:32.098" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:13:32.098" starttime="20190402 06:13:32.098"></status>
</kw>
<msg timestamp="20190402 06:13:32.098" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:32.098" starttime="20190402 06:13:32.096"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:32.099" starttime="20190402 06:13:32.099"></status>
</kw>
<status status="PASS" endtime="20190402 06:13:32.099" starttime="20190402 06:13:32.098"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:32.099" starttime="20190402 06:13:32.099"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:13:32.100" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:13:32.100" starttime="20190402 06:13:32.099"></status>
</kw>
<msg timestamp="20190402 06:13:32.100" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:13:32.100" starttime="20190402 06:13:30.945"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:13:32.100" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:32.100" starttime="20190402 06:13:32.100"></status>
</kw>
<msg timestamp="20190402 06:13:32.100" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:32.100" starttime="20190402 06:13:30.944"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:13:32.101" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:13:32.101" starttime="20190402 06:13:32.100"></status>
</kw>
<status status="FAIL" endtime="20190402 06:13:32.101" starttime="20190402 06:13:30.944"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:13:37.103" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:37.103" starttime="20190402 06:13:37.102"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:37.104" starttime="20190402 06:13:37.104"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:13:37.106" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:13:37.106" starttime="20190402 06:13:37.105"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:37.106" starttime="20190402 06:13:37.106"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:37.107" starttime="20190402 06:13:37.106"></status>
</kw>
<msg timestamp="20190402 06:13:37.107" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:13:37.107" starttime="20190402 06:13:37.105"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:13:37.107" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:37.108" starttime="20190402 06:13:37.107"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:13:37.125" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:37.125" starttime="20190402 06:13:37.108"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:13:38.240" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:13:38.240" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:38.240" starttime="20190402 06:13:37.125"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:13:38.241" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:38.241" starttime="20190402 06:13:38.241"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:13:38.242" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:38.242" starttime="20190402 06:13:38.241"></status>
</kw>
<msg timestamp="20190402 06:13:38.242" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:38.242" starttime="20190402 06:13:38.241"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:13:38.244" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:13:38.244" starttime="20190402 06:13:38.242"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:13:38.244" level="INFO">0</msg>
<msg timestamp="20190402 06:13:38.244" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:38.244" starttime="20190402 06:13:38.244"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:13:38.244" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:13:38.244" starttime="20190402 06:13:38.244"></status>
</kw>
<msg timestamp="20190402 06:13:38.244" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:38.245" starttime="20190402 06:13:38.242"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:38.245" starttime="20190402 06:13:38.245"></status>
</kw>
<status status="PASS" endtime="20190402 06:13:38.245" starttime="20190402 06:13:38.245"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:38.246" starttime="20190402 06:13:38.245"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:13:38.246" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:13:38.246" starttime="20190402 06:13:38.246"></status>
</kw>
<msg timestamp="20190402 06:13:38.246" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:13:38.246" starttime="20190402 06:13:37.103"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:13:38.246" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:38.247" starttime="20190402 06:13:38.246"></status>
</kw>
<msg timestamp="20190402 06:13:38.247" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:38.247" starttime="20190402 06:13:37.102"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:13:38.247" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:13:38.247" starttime="20190402 06:13:38.247"></status>
</kw>
<status status="FAIL" endtime="20190402 06:13:38.247" starttime="20190402 06:13:37.101"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:13:43.249" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:43.249" starttime="20190402 06:13:43.248"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:43.249" starttime="20190402 06:13:43.249"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:13:43.250" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:13:43.250" starttime="20190402 06:13:43.250"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:43.251" starttime="20190402 06:13:43.251"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:43.251" starttime="20190402 06:13:43.251"></status>
</kw>
<msg timestamp="20190402 06:13:43.251" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:13:43.251" starttime="20190402 06:13:43.250"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:13:43.252" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:43.252" starttime="20190402 06:13:43.251"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:13:43.261" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:43.261" starttime="20190402 06:13:43.252"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:13:44.354" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:13:44.354" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:44.355" starttime="20190402 06:13:43.261"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:13:44.355" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:44.355" starttime="20190402 06:13:44.355"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:13:44.356" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:44.356" starttime="20190402 06:13:44.355"></status>
</kw>
<msg timestamp="20190402 06:13:44.356" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:44.356" starttime="20190402 06:13:44.355"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:13:44.358" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:13:44.358" starttime="20190402 06:13:44.356"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:13:44.358" level="INFO">0</msg>
<msg timestamp="20190402 06:13:44.358" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:44.358" starttime="20190402 06:13:44.358"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:13:44.359" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:13:44.359" starttime="20190402 06:13:44.358"></status>
</kw>
<msg timestamp="20190402 06:13:44.359" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:44.359" starttime="20190402 06:13:44.356"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:44.360" starttime="20190402 06:13:44.359"></status>
</kw>
<status status="PASS" endtime="20190402 06:13:44.360" starttime="20190402 06:13:44.359"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:44.360" starttime="20190402 06:13:44.360"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:13:44.360" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:13:44.360" starttime="20190402 06:13:44.360"></status>
</kw>
<msg timestamp="20190402 06:13:44.360" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:13:44.360" starttime="20190402 06:13:43.249"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:13:44.361" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:44.361" starttime="20190402 06:13:44.361"></status>
</kw>
<msg timestamp="20190402 06:13:44.361" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:44.361" starttime="20190402 06:13:43.248"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:13:44.361" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:13:44.362" starttime="20190402 06:13:44.361"></status>
</kw>
<status status="FAIL" endtime="20190402 06:13:44.362" starttime="20190402 06:13:43.248"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:13:49.363" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:49.363" starttime="20190402 06:13:49.363"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:49.364" starttime="20190402 06:13:49.364"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:13:49.365" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:13:49.365" starttime="20190402 06:13:49.364"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:49.365" starttime="20190402 06:13:49.365"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:49.365" starttime="20190402 06:13:49.365"></status>
</kw>
<msg timestamp="20190402 06:13:49.366" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:13:49.366" starttime="20190402 06:13:49.364"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:13:49.366" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:49.366" starttime="20190402 06:13:49.366"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:13:49.375" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:49.375" starttime="20190402 06:13:49.366"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:13:50.436" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:13:50.436" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:50.436" starttime="20190402 06:13:49.375"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:13:50.437" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:50.437" starttime="20190402 06:13:50.436"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:13:50.437" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:50.437" starttime="20190402 06:13:50.437"></status>
</kw>
<msg timestamp="20190402 06:13:50.437" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:50.437" starttime="20190402 06:13:50.436"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:13:50.438" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:13:50.438" starttime="20190402 06:13:50.437"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:13:50.439" level="INFO">0</msg>
<msg timestamp="20190402 06:13:50.439" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:50.439" starttime="20190402 06:13:50.439"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:13:50.440" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:13:50.440" starttime="20190402 06:13:50.439"></status>
</kw>
<msg timestamp="20190402 06:13:50.440" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:50.440" starttime="20190402 06:13:50.437"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:50.441" starttime="20190402 06:13:50.440"></status>
</kw>
<status status="PASS" endtime="20190402 06:13:50.441" starttime="20190402 06:13:50.440"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:50.441" starttime="20190402 06:13:50.441"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:13:50.441" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:13:50.441" starttime="20190402 06:13:50.441"></status>
</kw>
<msg timestamp="20190402 06:13:50.441" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:13:50.441" starttime="20190402 06:13:49.363"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:13:50.442" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:50.442" starttime="20190402 06:13:50.442"></status>
</kw>
<msg timestamp="20190402 06:13:50.442" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:50.442" starttime="20190402 06:13:49.362"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:13:50.442" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:13:50.442" starttime="20190402 06:13:50.442"></status>
</kw>
<status status="FAIL" endtime="20190402 06:13:50.443" starttime="20190402 06:13:49.362"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:13:55.444" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:55.444" starttime="20190402 06:13:55.444"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:55.445" starttime="20190402 06:13:55.445"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:13:55.446" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:13:55.446" starttime="20190402 06:13:55.445"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:55.446" starttime="20190402 06:13:55.446"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:55.446" starttime="20190402 06:13:55.446"></status>
</kw>
<msg timestamp="20190402 06:13:55.446" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:13:55.446" starttime="20190402 06:13:55.445"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:13:55.447" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:55.447" starttime="20190402 06:13:55.447"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:13:55.456" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:13:55.456" starttime="20190402 06:13:55.447"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:13:56.525" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:13:56.525" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:56.525" starttime="20190402 06:13:55.456"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:13:56.526" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:13:56.526" starttime="20190402 06:13:56.526"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:13:56.526" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:56.526" starttime="20190402 06:13:56.526"></status>
</kw>
<msg timestamp="20190402 06:13:56.526" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:13:56.526" starttime="20190402 06:13:56.525"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:13:56.528" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:13:56.528" starttime="20190402 06:13:56.527"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:13:56.528" level="INFO">0</msg>
<msg timestamp="20190402 06:13:56.528" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:56.529" starttime="20190402 06:13:56.528"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:13:56.529" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:13:56.529" starttime="20190402 06:13:56.529"></status>
</kw>
<msg timestamp="20190402 06:13:56.529" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:13:56.529" starttime="20190402 06:13:56.526"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:56.530" starttime="20190402 06:13:56.529"></status>
</kw>
<status status="PASS" endtime="20190402 06:13:56.530" starttime="20190402 06:13:56.529"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:13:56.530" starttime="20190402 06:13:56.530"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:13:56.530" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:13:56.530" starttime="20190402 06:13:56.530"></status>
</kw>
<msg timestamp="20190402 06:13:56.531" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:13:56.531" starttime="20190402 06:13:55.444"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:13:56.531" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:56.531" starttime="20190402 06:13:56.531"></status>
</kw>
<msg timestamp="20190402 06:13:56.531" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:13:56.531" starttime="20190402 06:13:55.443"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:13:56.532" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:13:56.532" starttime="20190402 06:13:56.531"></status>
</kw>
<status status="FAIL" endtime="20190402 06:13:56.532" starttime="20190402 06:13:55.443"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:14:01.533" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:01.533" starttime="20190402 06:14:01.533"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:01.534" starttime="20190402 06:14:01.534"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:14:01.535" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:14:01.535" starttime="20190402 06:14:01.534"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:01.535" starttime="20190402 06:14:01.535"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:01.535" starttime="20190402 06:14:01.535"></status>
</kw>
<msg timestamp="20190402 06:14:01.536" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:14:01.536" starttime="20190402 06:14:01.534"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:14:01.536" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:01.536" starttime="20190402 06:14:01.536"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:14:01.542" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:01.543" starttime="20190402 06:14:01.536"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:14:02.600" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:14:02.601" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:02.601" starttime="20190402 06:14:01.543"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:14:02.602" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:02.602" starttime="20190402 06:14:02.601"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:14:02.602" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:02.602" starttime="20190402 06:14:02.602"></status>
</kw>
<msg timestamp="20190402 06:14:02.602" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:02.602" starttime="20190402 06:14:02.601"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:14:02.604" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:14:02.604" starttime="20190402 06:14:02.603"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:14:02.604" level="INFO">0</msg>
<msg timestamp="20190402 06:14:02.605" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:02.605" starttime="20190402 06:14:02.604"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:14:02.605" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:14:02.605" starttime="20190402 06:14:02.605"></status>
</kw>
<msg timestamp="20190402 06:14:02.605" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:02.605" starttime="20190402 06:14:02.602"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:02.606" starttime="20190402 06:14:02.606"></status>
</kw>
<status status="PASS" endtime="20190402 06:14:02.606" starttime="20190402 06:14:02.605"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:02.606" starttime="20190402 06:14:02.606"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:14:02.606" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:14:02.607" starttime="20190402 06:14:02.606"></status>
</kw>
<msg timestamp="20190402 06:14:02.607" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:14:02.607" starttime="20190402 06:14:01.533"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:14:02.607" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:02.607" starttime="20190402 06:14:02.607"></status>
</kw>
<msg timestamp="20190402 06:14:02.607" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:02.607" starttime="20190402 06:14:01.533"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:14:02.608" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:14:02.608" starttime="20190402 06:14:02.607"></status>
</kw>
<status status="FAIL" endtime="20190402 06:14:02.608" starttime="20190402 06:14:01.532"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:14:07.610" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:07.610" starttime="20190402 06:14:07.609"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:07.611" starttime="20190402 06:14:07.610"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:14:07.611" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:14:07.611" starttime="20190402 06:14:07.611"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:07.612" starttime="20190402 06:14:07.611"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:07.612" starttime="20190402 06:14:07.612"></status>
</kw>
<msg timestamp="20190402 06:14:07.612" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:14:07.612" starttime="20190402 06:14:07.611"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:14:07.612" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:07.613" starttime="20190402 06:14:07.612"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:14:07.622" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:07.622" starttime="20190402 06:14:07.613"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:14:08.679" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:14:08.679" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:08.679" starttime="20190402 06:14:07.622"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:14:08.680" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:08.680" starttime="20190402 06:14:08.679"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:14:08.680" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:08.680" starttime="20190402 06:14:08.680"></status>
</kw>
<msg timestamp="20190402 06:14:08.680" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:08.680" starttime="20190402 06:14:08.679"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:14:08.682" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:14:08.682" starttime="20190402 06:14:08.681"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:14:08.683" level="INFO">0</msg>
<msg timestamp="20190402 06:14:08.683" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:08.683" starttime="20190402 06:14:08.682"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:14:08.683" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:14:08.683" starttime="20190402 06:14:08.683"></status>
</kw>
<msg timestamp="20190402 06:14:08.683" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:08.683" starttime="20190402 06:14:08.680"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:08.684" starttime="20190402 06:14:08.684"></status>
</kw>
<status status="PASS" endtime="20190402 06:14:08.684" starttime="20190402 06:14:08.683"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:08.684" starttime="20190402 06:14:08.684"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:14:08.685" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:14:08.685" starttime="20190402 06:14:08.684"></status>
</kw>
<msg timestamp="20190402 06:14:08.685" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:14:08.685" starttime="20190402 06:14:07.610"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:14:08.685" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:08.685" starttime="20190402 06:14:08.685"></status>
</kw>
<msg timestamp="20190402 06:14:08.685" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:08.685" starttime="20190402 06:14:07.609"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:14:08.686" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:14:08.686" starttime="20190402 06:14:08.686"></status>
</kw>
<status status="FAIL" endtime="20190402 06:14:08.686" starttime="20190402 06:14:07.608"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:14:13.687" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:13.687" starttime="20190402 06:14:13.687"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:13.688" starttime="20190402 06:14:13.688"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:14:13.689" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:14:13.689" starttime="20190402 06:14:13.689"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:13.689" starttime="20190402 06:14:13.689"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:13.690" starttime="20190402 06:14:13.689"></status>
</kw>
<msg timestamp="20190402 06:14:13.690" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:14:13.690" starttime="20190402 06:14:13.688"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:14:13.690" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:13.690" starttime="20190402 06:14:13.690"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:14:13.700" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:13.700" starttime="20190402 06:14:13.690"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:14:14.773" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:14:14.773" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:14.773" starttime="20190402 06:14:13.700"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:14:14.773" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:14.774" starttime="20190402 06:14:14.773"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:14:14.774" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:14.774" starttime="20190402 06:14:14.774"></status>
</kw>
<msg timestamp="20190402 06:14:14.774" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:14.774" starttime="20190402 06:14:14.773"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:14:14.776" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:14:14.776" starttime="20190402 06:14:14.774"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:14:14.776" level="INFO">0</msg>
<msg timestamp="20190402 06:14:14.776" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:14.776" starttime="20190402 06:14:14.776"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:14:14.777" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:14:14.777" starttime="20190402 06:14:14.776"></status>
</kw>
<msg timestamp="20190402 06:14:14.777" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:14.777" starttime="20190402 06:14:14.774"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:14.778" starttime="20190402 06:14:14.777"></status>
</kw>
<status status="PASS" endtime="20190402 06:14:14.778" starttime="20190402 06:14:14.777"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:14.778" starttime="20190402 06:14:14.778"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:14:14.778" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:14:14.779" starttime="20190402 06:14:14.778"></status>
</kw>
<msg timestamp="20190402 06:14:14.779" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:14:14.779" starttime="20190402 06:14:13.688"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:14:14.779" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:14.779" starttime="20190402 06:14:14.779"></status>
</kw>
<msg timestamp="20190402 06:14:14.779" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:14.779" starttime="20190402 06:14:13.687"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:14:14.780" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:14:14.780" starttime="20190402 06:14:14.779"></status>
</kw>
<status status="FAIL" endtime="20190402 06:14:14.780" starttime="20190402 06:14:13.686"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:14:19.781" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:19.781" starttime="20190402 06:14:19.781"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:19.782" starttime="20190402 06:14:19.782"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:14:19.783" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:14:19.783" starttime="20190402 06:14:19.782"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:19.783" starttime="20190402 06:14:19.783"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:19.783" starttime="20190402 06:14:19.783"></status>
</kw>
<msg timestamp="20190402 06:14:19.784" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:14:19.784" starttime="20190402 06:14:19.782"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:14:19.784" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:19.784" starttime="20190402 06:14:19.784"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:14:19.794" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:19.794" starttime="20190402 06:14:19.784"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:14:20.851" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:14:20.851" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:20.851" starttime="20190402 06:14:19.794"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:14:20.852" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:20.852" starttime="20190402 06:14:20.852"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:14:20.852" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:20.852" starttime="20190402 06:14:20.852"></status>
</kw>
<msg timestamp="20190402 06:14:20.852" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:20.852" starttime="20190402 06:14:20.851"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:14:20.854" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:14:20.854" starttime="20190402 06:14:20.853"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:14:20.854" level="INFO">0</msg>
<msg timestamp="20190402 06:14:20.854" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:20.855" starttime="20190402 06:14:20.854"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:14:20.855" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:14:20.855" starttime="20190402 06:14:20.855"></status>
</kw>
<msg timestamp="20190402 06:14:20.855" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:20.855" starttime="20190402 06:14:20.852"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:20.856" starttime="20190402 06:14:20.855"></status>
</kw>
<status status="PASS" endtime="20190402 06:14:20.856" starttime="20190402 06:14:20.855"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:20.856" starttime="20190402 06:14:20.856"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:14:20.856" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:14:20.856" starttime="20190402 06:14:20.856"></status>
</kw>
<msg timestamp="20190402 06:14:20.857" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:14:20.857" starttime="20190402 06:14:19.781"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:14:20.857" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:20.857" starttime="20190402 06:14:20.857"></status>
</kw>
<msg timestamp="20190402 06:14:20.857" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:20.857" starttime="20190402 06:14:19.781"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:14:20.858" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:14:20.858" starttime="20190402 06:14:20.857"></status>
</kw>
<status status="FAIL" endtime="20190402 06:14:20.858" starttime="20190402 06:14:19.780"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:14:25.859" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:25.859" starttime="20190402 06:14:25.859"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:25.860" starttime="20190402 06:14:25.860"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:14:25.861" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:14:25.861" starttime="20190402 06:14:25.860"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:25.861" starttime="20190402 06:14:25.861"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:25.862" starttime="20190402 06:14:25.861"></status>
</kw>
<msg timestamp="20190402 06:14:25.862" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:14:25.862" starttime="20190402 06:14:25.860"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:14:25.862" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:25.862" starttime="20190402 06:14:25.862"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:14:25.872" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:25.872" starttime="20190402 06:14:25.862"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:14:26.948" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:14:26.948" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:26.948" starttime="20190402 06:14:25.873"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:14:26.949" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:26.949" starttime="20190402 06:14:26.949"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:14:26.949" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:26.949" starttime="20190402 06:14:26.949"></status>
</kw>
<msg timestamp="20190402 06:14:26.949" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:26.950" starttime="20190402 06:14:26.948"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:14:26.951" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:14:26.952" starttime="20190402 06:14:26.950"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:14:26.952" level="INFO">0</msg>
<msg timestamp="20190402 06:14:26.952" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:26.952" starttime="20190402 06:14:26.952"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:14:26.952" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:14:26.952" starttime="20190402 06:14:26.952"></status>
</kw>
<msg timestamp="20190402 06:14:26.953" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:26.953" starttime="20190402 06:14:26.950"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:26.953" starttime="20190402 06:14:26.953"></status>
</kw>
<status status="PASS" endtime="20190402 06:14:26.953" starttime="20190402 06:14:26.953"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:26.954" starttime="20190402 06:14:26.954"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:14:26.954" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:14:26.954" starttime="20190402 06:14:26.954"></status>
</kw>
<msg timestamp="20190402 06:14:26.954" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:14:26.954" starttime="20190402 06:14:25.860"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:14:26.955" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:26.955" starttime="20190402 06:14:26.954"></status>
</kw>
<msg timestamp="20190402 06:14:26.955" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:26.955" starttime="20190402 06:14:25.859"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:14:26.955" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:14:26.955" starttime="20190402 06:14:26.955"></status>
</kw>
<status status="FAIL" endtime="20190402 06:14:26.955" starttime="20190402 06:14:25.858"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:14:31.957" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:31.957" starttime="20190402 06:14:31.957"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:31.958" starttime="20190402 06:14:31.958"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:14:31.959" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:14:31.959" starttime="20190402 06:14:31.959"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:31.959" starttime="20190402 06:14:31.959"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:31.960" starttime="20190402 06:14:31.959"></status>
</kw>
<msg timestamp="20190402 06:14:31.960" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:14:31.960" starttime="20190402 06:14:31.958"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:14:31.960" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:31.960" starttime="20190402 06:14:31.960"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:14:31.970" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:31.970" starttime="20190402 06:14:31.960"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:14:33.097" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:14:33.097" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:33.097" starttime="20190402 06:14:31.970"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:14:33.098" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:33.098" starttime="20190402 06:14:33.098"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:14:33.099" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:33.099" starttime="20190402 06:14:33.098"></status>
</kw>
<msg timestamp="20190402 06:14:33.099" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:33.099" starttime="20190402 06:14:33.098"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:14:33.101" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:14:33.101" starttime="20190402 06:14:33.099"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:14:33.101" level="INFO">0</msg>
<msg timestamp="20190402 06:14:33.101" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:33.101" starttime="20190402 06:14:33.101"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:14:33.102" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:14:33.102" starttime="20190402 06:14:33.101"></status>
</kw>
<msg timestamp="20190402 06:14:33.102" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:33.102" starttime="20190402 06:14:33.099"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:33.103" starttime="20190402 06:14:33.102"></status>
</kw>
<status status="PASS" endtime="20190402 06:14:33.103" starttime="20190402 06:14:33.102"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:33.103" starttime="20190402 06:14:33.103"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:14:33.103" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:14:33.103" starttime="20190402 06:14:33.103"></status>
</kw>
<msg timestamp="20190402 06:14:33.103" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:14:33.103" starttime="20190402 06:14:31.958"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:14:33.104" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:33.104" starttime="20190402 06:14:33.104"></status>
</kw>
<msg timestamp="20190402 06:14:33.104" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:33.104" starttime="20190402 06:14:31.956"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:14:33.104" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:14:33.105" starttime="20190402 06:14:33.104"></status>
</kw>
<status status="FAIL" endtime="20190402 06:14:33.105" starttime="20190402 06:14:31.956"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:14:38.106" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:38.106" starttime="20190402 06:14:38.106"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:38.107" starttime="20190402 06:14:38.107"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:14:38.108" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:14:38.108" starttime="20190402 06:14:38.107"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:38.108" starttime="20190402 06:14:38.108"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:38.109" starttime="20190402 06:14:38.108"></status>
</kw>
<msg timestamp="20190402 06:14:38.109" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:14:38.109" starttime="20190402 06:14:38.107"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:14:38.109" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:38.109" starttime="20190402 06:14:38.109"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:14:38.120" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:38.120" starttime="20190402 06:14:38.109"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:14:39.177" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:14:39.177" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:39.177" starttime="20190402 06:14:38.120"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:14:39.178" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:39.178" starttime="20190402 06:14:39.178"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:14:39.179" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:39.179" starttime="20190402 06:14:39.178"></status>
</kw>
<msg timestamp="20190402 06:14:39.179" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:39.179" starttime="20190402 06:14:39.178"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:14:39.181" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:14:39.181" starttime="20190402 06:14:39.179"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:14:39.181" level="INFO">0</msg>
<msg timestamp="20190402 06:14:39.181" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:39.181" starttime="20190402 06:14:39.181"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:14:39.181" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:14:39.181" starttime="20190402 06:14:39.181"></status>
</kw>
<msg timestamp="20190402 06:14:39.182" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:39.182" starttime="20190402 06:14:39.179"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:39.182" starttime="20190402 06:14:39.182"></status>
</kw>
<status status="PASS" endtime="20190402 06:14:39.183" starttime="20190402 06:14:39.182"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:39.183" starttime="20190402 06:14:39.183"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:14:39.183" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:14:39.183" starttime="20190402 06:14:39.183"></status>
</kw>
<msg timestamp="20190402 06:14:39.183" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:14:39.183" starttime="20190402 06:14:38.106"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:14:39.184" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:39.184" starttime="20190402 06:14:39.183"></status>
</kw>
<msg timestamp="20190402 06:14:39.184" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:39.184" starttime="20190402 06:14:38.105"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:14:39.184" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:14:39.184" starttime="20190402 06:14:39.184"></status>
</kw>
<status status="FAIL" endtime="20190402 06:14:39.185" starttime="20190402 06:14:38.105"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:14:44.186" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:44.186" starttime="20190402 06:14:44.186"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:44.187" starttime="20190402 06:14:44.187"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:14:44.188" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:14:44.188" starttime="20190402 06:14:44.187"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:44.188" starttime="20190402 06:14:44.188"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:44.188" starttime="20190402 06:14:44.188"></status>
</kw>
<msg timestamp="20190402 06:14:44.189" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:14:44.189" starttime="20190402 06:14:44.187"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:14:44.189" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:44.189" starttime="20190402 06:14:44.189"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:14:44.199" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:44.199" starttime="20190402 06:14:44.189"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:14:45.297" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:14:45.297" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:45.297" starttime="20190402 06:14:44.199"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:14:45.298" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:45.298" starttime="20190402 06:14:45.298"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:14:45.298" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:45.298" starttime="20190402 06:14:45.298"></status>
</kw>
<msg timestamp="20190402 06:14:45.298" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:45.298" starttime="20190402 06:14:45.297"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:14:45.300" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:14:45.300" starttime="20190402 06:14:45.299"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:14:45.301" level="INFO">0</msg>
<msg timestamp="20190402 06:14:45.301" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:45.301" starttime="20190402 06:14:45.300"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:14:45.301" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:14:45.301" starttime="20190402 06:14:45.301"></status>
</kw>
<msg timestamp="20190402 06:14:45.301" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:45.301" starttime="20190402 06:14:45.298"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:45.302" starttime="20190402 06:14:45.302"></status>
</kw>
<status status="PASS" endtime="20190402 06:14:45.302" starttime="20190402 06:14:45.301"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:45.302" starttime="20190402 06:14:45.302"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:14:45.303" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:14:45.303" starttime="20190402 06:14:45.302"></status>
</kw>
<msg timestamp="20190402 06:14:45.303" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:14:45.303" starttime="20190402 06:14:44.186"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:14:45.303" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:45.303" starttime="20190402 06:14:45.303"></status>
</kw>
<msg timestamp="20190402 06:14:45.303" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:45.303" starttime="20190402 06:14:44.185"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:14:45.304" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:14:45.304" starttime="20190402 06:14:45.304"></status>
</kw>
<status status="FAIL" endtime="20190402 06:14:45.304" starttime="20190402 06:14:44.185"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:14:50.305" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:50.305" starttime="20190402 06:14:50.305"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:50.306" starttime="20190402 06:14:50.306"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:14:50.307" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:14:50.307" starttime="20190402 06:14:50.306"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:50.307" starttime="20190402 06:14:50.307"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:50.308" starttime="20190402 06:14:50.308"></status>
</kw>
<msg timestamp="20190402 06:14:50.308" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:14:50.308" starttime="20190402 06:14:50.306"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:14:50.308" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:50.308" starttime="20190402 06:14:50.308"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:14:50.319" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:50.319" starttime="20190402 06:14:50.308"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:14:51.357" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:14:51.357" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:51.357" starttime="20190402 06:14:50.319"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:14:51.358" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:51.358" starttime="20190402 06:14:51.358"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:14:51.359" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:51.359" starttime="20190402 06:14:51.358"></status>
</kw>
<msg timestamp="20190402 06:14:51.359" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:51.359" starttime="20190402 06:14:51.358"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:14:51.360" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:14:51.361" starttime="20190402 06:14:51.359"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:14:51.361" level="INFO">0</msg>
<msg timestamp="20190402 06:14:51.361" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:51.361" starttime="20190402 06:14:51.361"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:14:51.361" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:14:51.361" starttime="20190402 06:14:51.361"></status>
</kw>
<msg timestamp="20190402 06:14:51.362" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:51.362" starttime="20190402 06:14:51.359"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:51.362" starttime="20190402 06:14:51.362"></status>
</kw>
<status status="PASS" endtime="20190402 06:14:51.362" starttime="20190402 06:14:51.362"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:51.363" starttime="20190402 06:14:51.363"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:14:51.363" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:14:51.363" starttime="20190402 06:14:51.363"></status>
</kw>
<msg timestamp="20190402 06:14:51.363" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:14:51.363" starttime="20190402 06:14:50.306"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:14:51.364" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:51.364" starttime="20190402 06:14:51.363"></status>
</kw>
<msg timestamp="20190402 06:14:51.364" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:51.364" starttime="20190402 06:14:50.305"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:14:51.364" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:14:51.364" starttime="20190402 06:14:51.364"></status>
</kw>
<status status="FAIL" endtime="20190402 06:14:51.364" starttime="20190402 06:14:50.304"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:14:56.366" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:56.366" starttime="20190402 06:14:56.366"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:56.367" starttime="20190402 06:14:56.366"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:14:56.367" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:14:56.367" starttime="20190402 06:14:56.367"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:56.368" starttime="20190402 06:14:56.367"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:56.368" starttime="20190402 06:14:56.368"></status>
</kw>
<msg timestamp="20190402 06:14:56.368" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:14:56.369" starttime="20190402 06:14:56.367"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:14:56.369" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:56.369" starttime="20190402 06:14:56.369"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:14:56.382" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:14:56.382" starttime="20190402 06:14:56.369"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:14:57.452" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:14:57.452" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:57.452" starttime="20190402 06:14:56.382"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:14:57.453" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:14:57.453" starttime="20190402 06:14:57.452"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:14:57.453" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:57.453" starttime="20190402 06:14:57.453"></status>
</kw>
<msg timestamp="20190402 06:14:57.453" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:14:57.453" starttime="20190402 06:14:57.452"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:14:57.455" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:14:57.455" starttime="20190402 06:14:57.453"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:14:57.456" level="INFO">0</msg>
<msg timestamp="20190402 06:14:57.456" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:57.456" starttime="20190402 06:14:57.455"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:14:57.456" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:14:57.456" starttime="20190402 06:14:57.456"></status>
</kw>
<msg timestamp="20190402 06:14:57.456" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:14:57.456" starttime="20190402 06:14:57.453"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:57.457" starttime="20190402 06:14:57.457"></status>
</kw>
<status status="PASS" endtime="20190402 06:14:57.457" starttime="20190402 06:14:57.456"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:14:57.458" starttime="20190402 06:14:57.457"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:14:57.458" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:14:57.458" starttime="20190402 06:14:57.458"></status>
</kw>
<msg timestamp="20190402 06:14:57.458" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:14:57.458" starttime="20190402 06:14:56.366"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:14:57.458" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:57.458" starttime="20190402 06:14:57.458"></status>
</kw>
<msg timestamp="20190402 06:14:57.459" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:14:57.459" starttime="20190402 06:14:56.365"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:14:57.459" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:14:57.459" starttime="20190402 06:14:57.459"></status>
</kw>
<status status="FAIL" endtime="20190402 06:14:57.459" starttime="20190402 06:14:56.365"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:15:02.461" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:02.461" starttime="20190402 06:15:02.461"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:02.462" starttime="20190402 06:15:02.461"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:15:02.462" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:15:02.462" starttime="20190402 06:15:02.462"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:02.463" starttime="20190402 06:15:02.462"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:02.463" starttime="20190402 06:15:02.463"></status>
</kw>
<msg timestamp="20190402 06:15:02.463" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:15:02.463" starttime="20190402 06:15:02.462"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:15:02.463" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:02.464" starttime="20190402 06:15:02.463"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:15:02.474" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:02.475" starttime="20190402 06:15:02.464"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:15:03.549" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:15:03.549" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:03.549" starttime="20190402 06:15:02.475"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:15:03.550" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:03.550" starttime="20190402 06:15:03.550"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:15:03.551" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:03.551" starttime="20190402 06:15:03.550"></status>
</kw>
<msg timestamp="20190402 06:15:03.551" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:03.551" starttime="20190402 06:15:03.550"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:15:03.553" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:15:03.553" starttime="20190402 06:15:03.551"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:15:03.553" level="INFO">0</msg>
<msg timestamp="20190402 06:15:03.554" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:03.554" starttime="20190402 06:15:03.553"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:15:03.554" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:15:03.554" starttime="20190402 06:15:03.554"></status>
</kw>
<msg timestamp="20190402 06:15:03.554" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:03.554" starttime="20190402 06:15:03.551"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:03.555" starttime="20190402 06:15:03.555"></status>
</kw>
<status status="PASS" endtime="20190402 06:15:03.555" starttime="20190402 06:15:03.554"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:03.555" starttime="20190402 06:15:03.555"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:15:03.555" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:15:03.555" starttime="20190402 06:15:03.555"></status>
</kw>
<msg timestamp="20190402 06:15:03.556" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:15:03.556" starttime="20190402 06:15:02.461"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:15:03.556" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:03.556" starttime="20190402 06:15:03.556"></status>
</kw>
<msg timestamp="20190402 06:15:03.556" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:03.556" starttime="20190402 06:15:02.460"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:15:03.557" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:15:03.557" starttime="20190402 06:15:03.556"></status>
</kw>
<status status="FAIL" endtime="20190402 06:15:03.557" starttime="20190402 06:15:02.460"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:15:08.558" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:08.558" starttime="20190402 06:15:08.558"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:08.559" starttime="20190402 06:15:08.559"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:15:08.560" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:15:08.560" starttime="20190402 06:15:08.559"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:08.560" starttime="20190402 06:15:08.560"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:08.560" starttime="20190402 06:15:08.560"></status>
</kw>
<msg timestamp="20190402 06:15:08.561" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:15:08.561" starttime="20190402 06:15:08.559"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:15:08.561" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:08.561" starttime="20190402 06:15:08.561"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:15:08.570" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:08.570" starttime="20190402 06:15:08.561"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:15:09.601" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:15:09.602" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:09.602" starttime="20190402 06:15:08.571"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:15:09.603" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:09.603" starttime="20190402 06:15:09.602"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:15:09.603" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:09.603" starttime="20190402 06:15:09.603"></status>
</kw>
<msg timestamp="20190402 06:15:09.603" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:09.603" starttime="20190402 06:15:09.602"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:15:09.605" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:15:09.605" starttime="20190402 06:15:09.604"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:15:09.606" level="INFO">0</msg>
<msg timestamp="20190402 06:15:09.606" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:09.606" starttime="20190402 06:15:09.605"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:15:09.606" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:15:09.606" starttime="20190402 06:15:09.606"></status>
</kw>
<msg timestamp="20190402 06:15:09.606" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:09.606" starttime="20190402 06:15:09.603"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:09.607" starttime="20190402 06:15:09.607"></status>
</kw>
<status status="PASS" endtime="20190402 06:15:09.607" starttime="20190402 06:15:09.606"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:09.607" starttime="20190402 06:15:09.607"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:15:09.608" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:15:09.608" starttime="20190402 06:15:09.607"></status>
</kw>
<msg timestamp="20190402 06:15:09.608" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:15:09.608" starttime="20190402 06:15:08.558"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:15:09.608" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:09.608" starttime="20190402 06:15:09.608"></status>
</kw>
<msg timestamp="20190402 06:15:09.608" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:09.608" starttime="20190402 06:15:08.558"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:15:09.609" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:15:09.609" starttime="20190402 06:15:09.609"></status>
</kw>
<status status="FAIL" endtime="20190402 06:15:09.609" starttime="20190402 06:15:08.557"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:15:14.614" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:14.614" starttime="20190402 06:15:14.613"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:14.615" starttime="20190402 06:15:14.615"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:15:14.616" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:15:14.616" starttime="20190402 06:15:14.615"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:14.616" starttime="20190402 06:15:14.616"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:14.616" starttime="20190402 06:15:14.616"></status>
</kw>
<msg timestamp="20190402 06:15:14.616" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:15:14.617" starttime="20190402 06:15:14.615"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:15:14.617" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:14.617" starttime="20190402 06:15:14.617"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:15:14.626" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:14.626" starttime="20190402 06:15:14.617"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:15:15.693" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:15:15.693" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:15.693" starttime="20190402 06:15:14.626"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:15:15.694" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:15.694" starttime="20190402 06:15:15.694"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:15:15.694" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:15.694" starttime="20190402 06:15:15.694"></status>
</kw>
<msg timestamp="20190402 06:15:15.694" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:15.694" starttime="20190402 06:15:15.693"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:15:15.696" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:15:15.696" starttime="20190402 06:15:15.695"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:15:15.697" level="INFO">0</msg>
<msg timestamp="20190402 06:15:15.697" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:15.697" starttime="20190402 06:15:15.696"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:15:15.697" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:15:15.697" starttime="20190402 06:15:15.697"></status>
</kw>
<msg timestamp="20190402 06:15:15.698" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:15.698" starttime="20190402 06:15:15.694"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:15.698" starttime="20190402 06:15:15.698"></status>
</kw>
<status status="PASS" endtime="20190402 06:15:15.698" starttime="20190402 06:15:15.698"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:15.699" starttime="20190402 06:15:15.699"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:15:15.699" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:15:15.699" starttime="20190402 06:15:15.699"></status>
</kw>
<msg timestamp="20190402 06:15:15.699" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:15:15.699" starttime="20190402 06:15:14.614"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:15:15.700" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:15.700" starttime="20190402 06:15:15.699"></status>
</kw>
<msg timestamp="20190402 06:15:15.700" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:15.700" starttime="20190402 06:15:14.611"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:15:15.700" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:15:15.700" starttime="20190402 06:15:15.700"></status>
</kw>
<status status="FAIL" endtime="20190402 06:15:15.700" starttime="20190402 06:15:14.610"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:15:20.703" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:20.703" starttime="20190402 06:15:20.702"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:20.704" starttime="20190402 06:15:20.704"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:15:20.706" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:15:20.706" starttime="20190402 06:15:20.705"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:20.706" starttime="20190402 06:15:20.706"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:20.707" starttime="20190402 06:15:20.707"></status>
</kw>
<msg timestamp="20190402 06:15:20.708" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:15:20.708" starttime="20190402 06:15:20.704"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:15:20.708" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:20.708" starttime="20190402 06:15:20.708"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:15:20.731" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:20.732" starttime="20190402 06:15:20.709"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:15:21.786" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:15:21.786" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:21.786" starttime="20190402 06:15:20.732"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:15:21.787" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:21.787" starttime="20190402 06:15:21.787"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:15:21.787" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:21.787" starttime="20190402 06:15:21.787"></status>
</kw>
<msg timestamp="20190402 06:15:21.787" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:21.787" starttime="20190402 06:15:21.786"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:15:21.789" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:15:21.789" starttime="20190402 06:15:21.788"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:15:21.790" level="INFO">0</msg>
<msg timestamp="20190402 06:15:21.790" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:21.790" starttime="20190402 06:15:21.790"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:15:21.790" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:15:21.790" starttime="20190402 06:15:21.790"></status>
</kw>
<msg timestamp="20190402 06:15:21.790" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:21.791" starttime="20190402 06:15:21.788"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:21.792" starttime="20190402 06:15:21.791"></status>
</kw>
<status status="PASS" endtime="20190402 06:15:21.792" starttime="20190402 06:15:21.791"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:21.792" starttime="20190402 06:15:21.792"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:15:21.792" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:15:21.792" starttime="20190402 06:15:21.792"></status>
</kw>
<msg timestamp="20190402 06:15:21.792" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:15:21.792" starttime="20190402 06:15:20.703"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:15:21.793" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:21.793" starttime="20190402 06:15:21.792"></status>
</kw>
<msg timestamp="20190402 06:15:21.793" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:21.793" starttime="20190402 06:15:20.702"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:15:21.793" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:15:21.793" starttime="20190402 06:15:21.793"></status>
</kw>
<status status="FAIL" endtime="20190402 06:15:21.794" starttime="20190402 06:15:20.701"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:15:26.797" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:26.798" starttime="20190402 06:15:26.797"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:26.800" starttime="20190402 06:15:26.799"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:15:26.802" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:15:26.802" starttime="20190402 06:15:26.801"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:26.803" starttime="20190402 06:15:26.802"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:26.804" starttime="20190402 06:15:26.804"></status>
</kw>
<msg timestamp="20190402 06:15:26.805" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:15:26.805" starttime="20190402 06:15:26.800"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:15:26.806" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:26.806" starttime="20190402 06:15:26.805"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:15:26.833" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:26.833" starttime="20190402 06:15:26.806"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:15:27.892" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:15:27.892" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:27.892" starttime="20190402 06:15:26.833"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:15:27.892" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:27.893" starttime="20190402 06:15:27.892"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:15:27.893" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:27.893" starttime="20190402 06:15:27.893"></status>
</kw>
<msg timestamp="20190402 06:15:27.893" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:27.893" starttime="20190402 06:15:27.892"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:15:27.895" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:15:27.895" starttime="20190402 06:15:27.893"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:15:27.895" level="INFO">0</msg>
<msg timestamp="20190402 06:15:27.895" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:27.895" starttime="20190402 06:15:27.895"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:15:27.896" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:15:27.896" starttime="20190402 06:15:27.895"></status>
</kw>
<msg timestamp="20190402 06:15:27.896" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:27.896" starttime="20190402 06:15:27.893"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:27.897" starttime="20190402 06:15:27.896"></status>
</kw>
<status status="PASS" endtime="20190402 06:15:27.897" starttime="20190402 06:15:27.896"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:27.897" starttime="20190402 06:15:27.897"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:15:27.897" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:15:27.897" starttime="20190402 06:15:27.897"></status>
</kw>
<msg timestamp="20190402 06:15:27.897" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:15:27.897" starttime="20190402 06:15:26.798"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:15:27.898" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:27.898" starttime="20190402 06:15:27.898"></status>
</kw>
<msg timestamp="20190402 06:15:27.898" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:27.898" starttime="20190402 06:15:26.796"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:15:27.899" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:15:27.899" starttime="20190402 06:15:27.898"></status>
</kw>
<status status="FAIL" endtime="20190402 06:15:27.899" starttime="20190402 06:15:26.794"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:15:32.903" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:32.903" starttime="20190402 06:15:32.902"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:32.906" starttime="20190402 06:15:32.905"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:15:32.909" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:15:32.909" starttime="20190402 06:15:32.907"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:32.911" starttime="20190402 06:15:32.910"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:32.912" starttime="20190402 06:15:32.911"></status>
</kw>
<msg timestamp="20190402 06:15:32.913" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:15:32.913" starttime="20190402 06:15:32.907"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:15:32.914" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:32.914" starttime="20190402 06:15:32.913"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:15:32.943" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:32.943" starttime="20190402 06:15:32.914"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:15:33.969" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:15:33.970" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:33.970" starttime="20190402 06:15:32.943"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:15:33.970" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:33.971" starttime="20190402 06:15:33.970"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:15:33.971" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:33.971" starttime="20190402 06:15:33.971"></status>
</kw>
<msg timestamp="20190402 06:15:33.971" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:33.971" starttime="20190402 06:15:33.970"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:15:33.973" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:15:33.973" starttime="20190402 06:15:33.971"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:15:33.973" level="INFO">0</msg>
<msg timestamp="20190402 06:15:33.973" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:33.973" starttime="20190402 06:15:33.973"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:15:33.974" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:15:33.974" starttime="20190402 06:15:33.973"></status>
</kw>
<msg timestamp="20190402 06:15:33.974" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:33.974" starttime="20190402 06:15:33.971"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:33.975" starttime="20190402 06:15:33.974"></status>
</kw>
<status status="PASS" endtime="20190402 06:15:33.975" starttime="20190402 06:15:33.974"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:33.975" starttime="20190402 06:15:33.975"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:15:33.975" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:15:33.975" starttime="20190402 06:15:33.975"></status>
</kw>
<msg timestamp="20190402 06:15:33.976" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:15:33.976" starttime="20190402 06:15:32.904"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:15:33.976" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:33.976" starttime="20190402 06:15:33.976"></status>
</kw>
<msg timestamp="20190402 06:15:33.976" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:33.976" starttime="20190402 06:15:32.901"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:15:33.977" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:15:33.977" starttime="20190402 06:15:33.976"></status>
</kw>
<status status="FAIL" endtime="20190402 06:15:33.977" starttime="20190402 06:15:32.900"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:15:38.981" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:38.982" starttime="20190402 06:15:38.980"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:38.984" starttime="20190402 06:15:38.983"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:15:38.987" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:15:38.987" starttime="20190402 06:15:38.985"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:38.988" starttime="20190402 06:15:38.987"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:38.989" starttime="20190402 06:15:38.988"></status>
</kw>
<msg timestamp="20190402 06:15:38.990" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:15:38.990" starttime="20190402 06:15:38.984"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:15:38.991" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:38.991" starttime="20190402 06:15:38.990"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:15:39.016" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:39.016" starttime="20190402 06:15:38.991"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:15:40.057" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:15:40.057" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:40.057" starttime="20190402 06:15:39.016"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:15:40.058" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:40.058" starttime="20190402 06:15:40.058"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:15:40.058" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:40.059" starttime="20190402 06:15:40.058"></status>
</kw>
<msg timestamp="20190402 06:15:40.059" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:40.059" starttime="20190402 06:15:40.058"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:15:40.062" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:15:40.062" starttime="20190402 06:15:40.059"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:15:40.062" level="INFO">0</msg>
<msg timestamp="20190402 06:15:40.063" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:40.063" starttime="20190402 06:15:40.062"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:15:40.063" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:15:40.063" starttime="20190402 06:15:40.063"></status>
</kw>
<msg timestamp="20190402 06:15:40.063" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:40.063" starttime="20190402 06:15:40.059"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:40.064" starttime="20190402 06:15:40.064"></status>
</kw>
<status status="PASS" endtime="20190402 06:15:40.064" starttime="20190402 06:15:40.063"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:40.064" starttime="20190402 06:15:40.064"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:15:40.064" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:15:40.064" starttime="20190402 06:15:40.064"></status>
</kw>
<msg timestamp="20190402 06:15:40.065" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:15:40.065" starttime="20190402 06:15:38.982"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:15:40.065" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:40.065" starttime="20190402 06:15:40.065"></status>
</kw>
<msg timestamp="20190402 06:15:40.065" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:40.065" starttime="20190402 06:15:38.979"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:15:40.066" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:15:40.066" starttime="20190402 06:15:40.065"></status>
</kw>
<status status="FAIL" endtime="20190402 06:15:40.066" starttime="20190402 06:15:38.977"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:15:45.071" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:45.071" starttime="20190402 06:15:45.069"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:45.072" starttime="20190402 06:15:45.072"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:15:45.073" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:15:45.073" starttime="20190402 06:15:45.073"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:45.073" starttime="20190402 06:15:45.073"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:45.074" starttime="20190402 06:15:45.073"></status>
</kw>
<msg timestamp="20190402 06:15:45.074" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:15:45.074" starttime="20190402 06:15:45.072"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:15:45.074" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:45.074" starttime="20190402 06:15:45.074"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:15:45.083" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:45.083" starttime="20190402 06:15:45.074"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:15:46.210" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:15:46.210" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:46.211" starttime="20190402 06:15:45.083"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:15:46.211" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:46.211" starttime="20190402 06:15:46.211"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:15:46.212" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:46.212" starttime="20190402 06:15:46.211"></status>
</kw>
<msg timestamp="20190402 06:15:46.212" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:46.212" starttime="20190402 06:15:46.211"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:15:46.214" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:15:46.214" starttime="20190402 06:15:46.212"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:15:46.214" level="INFO">0</msg>
<msg timestamp="20190402 06:15:46.214" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:46.214" starttime="20190402 06:15:46.214"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:15:46.215" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:15:46.215" starttime="20190402 06:15:46.215"></status>
</kw>
<msg timestamp="20190402 06:15:46.215" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:46.215" starttime="20190402 06:15:46.212"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:46.216" starttime="20190402 06:15:46.215"></status>
</kw>
<status status="PASS" endtime="20190402 06:15:46.216" starttime="20190402 06:15:46.215"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:46.216" starttime="20190402 06:15:46.216"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:15:46.216" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:15:46.216" starttime="20190402 06:15:46.216"></status>
</kw>
<msg timestamp="20190402 06:15:46.216" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:15:46.216" starttime="20190402 06:15:45.071"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:15:46.217" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:46.217" starttime="20190402 06:15:46.217"></status>
</kw>
<msg timestamp="20190402 06:15:46.217" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:46.217" starttime="20190402 06:15:45.068"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:15:46.217" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:15:46.218" starttime="20190402 06:15:46.217"></status>
</kw>
<status status="FAIL" endtime="20190402 06:15:46.218" starttime="20190402 06:15:45.067"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:15:51.222" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:51.222" starttime="20190402 06:15:51.221"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:51.224" starttime="20190402 06:15:51.224"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:15:51.225" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:15:51.225" starttime="20190402 06:15:51.225"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:51.226" starttime="20190402 06:15:51.225"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:51.226" starttime="20190402 06:15:51.226"></status>
</kw>
<msg timestamp="20190402 06:15:51.226" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:15:51.226" starttime="20190402 06:15:51.224"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:15:51.227" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:51.227" starttime="20190402 06:15:51.226"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:15:51.237" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:51.237" starttime="20190402 06:15:51.227"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:15:52.325" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:15:52.326" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:52.326" starttime="20190402 06:15:51.237"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:15:52.326" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:52.326" starttime="20190402 06:15:52.326"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:15:52.327" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:52.327" starttime="20190402 06:15:52.326"></status>
</kw>
<msg timestamp="20190402 06:15:52.327" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:52.327" starttime="20190402 06:15:52.326"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:15:52.329" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:15:52.329" starttime="20190402 06:15:52.327"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:15:52.329" level="INFO">0</msg>
<msg timestamp="20190402 06:15:52.329" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:52.329" starttime="20190402 06:15:52.329"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:15:52.329" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:15:52.329" starttime="20190402 06:15:52.329"></status>
</kw>
<msg timestamp="20190402 06:15:52.330" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:52.330" starttime="20190402 06:15:52.327"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:52.330" starttime="20190402 06:15:52.330"></status>
</kw>
<status status="PASS" endtime="20190402 06:15:52.330" starttime="20190402 06:15:52.330"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:52.331" starttime="20190402 06:15:52.330"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:15:52.331" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:15:52.331" starttime="20190402 06:15:52.331"></status>
</kw>
<msg timestamp="20190402 06:15:52.331" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:15:52.331" starttime="20190402 06:15:51.223"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:15:52.332" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:52.332" starttime="20190402 06:15:52.331"></status>
</kw>
<msg timestamp="20190402 06:15:52.332" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:52.332" starttime="20190402 06:15:51.220"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:15:52.332" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:15:52.332" starttime="20190402 06:15:52.332"></status>
</kw>
<status status="FAIL" endtime="20190402 06:15:52.332" starttime="20190402 06:15:51.218"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:15:57.337" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:57.337" starttime="20190402 06:15:57.336"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:57.339" starttime="20190402 06:15:57.339"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:15:57.340" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:15:57.340" starttime="20190402 06:15:57.339"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:57.340" starttime="20190402 06:15:57.340"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:57.340" starttime="20190402 06:15:57.340"></status>
</kw>
<msg timestamp="20190402 06:15:57.341" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:15:57.341" starttime="20190402 06:15:57.339"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:15:57.341" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:57.341" starttime="20190402 06:15:57.341"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:15:57.343" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:15:57.343" starttime="20190402 06:15:57.341"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:15:58.418" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:15:58.418" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:58.418" starttime="20190402 06:15:57.343"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:15:58.419" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:15:58.419" starttime="20190402 06:15:58.419"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:15:58.419" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:58.419" starttime="20190402 06:15:58.419"></status>
</kw>
<msg timestamp="20190402 06:15:58.420" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:15:58.420" starttime="20190402 06:15:58.418"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:15:58.422" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:15:58.422" starttime="20190402 06:15:58.420"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:15:58.422" level="INFO">0</msg>
<msg timestamp="20190402 06:15:58.422" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:58.422" starttime="20190402 06:15:58.422"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:15:58.422" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:15:58.422" starttime="20190402 06:15:58.422"></status>
</kw>
<msg timestamp="20190402 06:15:58.423" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:15:58.423" starttime="20190402 06:15:58.420"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:58.424" starttime="20190402 06:15:58.423"></status>
</kw>
<status status="PASS" endtime="20190402 06:15:58.424" starttime="20190402 06:15:58.423"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:15:58.424" starttime="20190402 06:15:58.424"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:15:58.424" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:15:58.424" starttime="20190402 06:15:58.424"></status>
</kw>
<msg timestamp="20190402 06:15:58.424" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:15:58.424" starttime="20190402 06:15:57.338"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:15:58.425" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:58.425" starttime="20190402 06:15:58.425"></status>
</kw>
<msg timestamp="20190402 06:15:58.425" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:15:58.425" starttime="20190402 06:15:57.335"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:15:58.425" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:15:58.425" starttime="20190402 06:15:58.425"></status>
</kw>
<status status="FAIL" endtime="20190402 06:15:58.426" starttime="20190402 06:15:57.333"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:16:03.430" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:03.430" starttime="20190402 06:16:03.429"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:03.432" starttime="20190402 06:16:03.432"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:16:03.432" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:16:03.433" starttime="20190402 06:16:03.432"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:03.433" starttime="20190402 06:16:03.433"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:03.433" starttime="20190402 06:16:03.433"></status>
</kw>
<msg timestamp="20190402 06:16:03.434" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:16:03.434" starttime="20190402 06:16:03.432"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:16:03.434" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:03.434" starttime="20190402 06:16:03.434"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:16:03.443" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:03.443" starttime="20190402 06:16:03.434"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:16:04.573" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:16:04.573" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:04.573" starttime="20190402 06:16:03.443"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:16:04.574" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:04.574" starttime="20190402 06:16:04.574"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:16:04.574" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:04.574" starttime="20190402 06:16:04.574"></status>
</kw>
<msg timestamp="20190402 06:16:04.575" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:04.575" starttime="20190402 06:16:04.574"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:16:04.577" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:16:04.577" starttime="20190402 06:16:04.575"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:16:04.580" level="INFO">0</msg>
<msg timestamp="20190402 06:16:04.580" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:04.580" starttime="20190402 06:16:04.577"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:16:04.580" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:16:04.580" starttime="20190402 06:16:04.580"></status>
</kw>
<msg timestamp="20190402 06:16:04.580" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:04.580" starttime="20190402 06:16:04.575"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:04.581" starttime="20190402 06:16:04.581"></status>
</kw>
<status status="PASS" endtime="20190402 06:16:04.581" starttime="20190402 06:16:04.580"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:04.581" starttime="20190402 06:16:04.581"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:16:04.581" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:16:04.582" starttime="20190402 06:16:04.581"></status>
</kw>
<msg timestamp="20190402 06:16:04.582" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:16:04.582" starttime="20190402 06:16:03.431"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:16:04.582" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:04.582" starttime="20190402 06:16:04.582"></status>
</kw>
<msg timestamp="20190402 06:16:04.582" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:04.582" starttime="20190402 06:16:03.428"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:16:04.583" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:16:04.583" starttime="20190402 06:16:04.582"></status>
</kw>
<status status="FAIL" endtime="20190402 06:16:04.583" starttime="20190402 06:16:03.426"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:16:09.587" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:09.587" starttime="20190402 06:16:09.586"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:09.587" starttime="20190402 06:16:09.587"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:16:09.588" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:16:09.588" starttime="20190402 06:16:09.588"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:09.588" starttime="20190402 06:16:09.588"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:09.589" starttime="20190402 06:16:09.589"></status>
</kw>
<msg timestamp="20190402 06:16:09.589" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:16:09.589" starttime="20190402 06:16:09.587"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:16:09.589" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:09.589" starttime="20190402 06:16:09.589"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:16:09.599" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:09.599" starttime="20190402 06:16:09.589"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:16:10.630" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:16:10.630" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:10.630" starttime="20190402 06:16:09.599"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:16:10.631" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:10.631" starttime="20190402 06:16:10.630"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:16:10.631" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:10.631" starttime="20190402 06:16:10.631"></status>
</kw>
<msg timestamp="20190402 06:16:10.631" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:10.631" starttime="20190402 06:16:10.630"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:16:10.633" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:16:10.633" starttime="20190402 06:16:10.632"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:16:10.633" level="INFO">0</msg>
<msg timestamp="20190402 06:16:10.633" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:10.633" starttime="20190402 06:16:10.633"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:16:10.634" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:16:10.634" starttime="20190402 06:16:10.634"></status>
</kw>
<msg timestamp="20190402 06:16:10.634" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:10.634" starttime="20190402 06:16:10.631"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:10.635" starttime="20190402 06:16:10.634"></status>
</kw>
<status status="PASS" endtime="20190402 06:16:10.635" starttime="20190402 06:16:10.634"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:10.635" starttime="20190402 06:16:10.635"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:16:10.635" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:16:10.635" starttime="20190402 06:16:10.635"></status>
</kw>
<msg timestamp="20190402 06:16:10.635" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:16:10.635" starttime="20190402 06:16:09.587"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:16:10.636" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:10.636" starttime="20190402 06:16:10.636"></status>
</kw>
<msg timestamp="20190402 06:16:10.636" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:10.636" starttime="20190402 06:16:09.585"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:16:10.636" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:16:10.637" starttime="20190402 06:16:10.636"></status>
</kw>
<status status="FAIL" endtime="20190402 06:16:10.637" starttime="20190402 06:16:09.584"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:16:15.641" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:15.642" starttime="20190402 06:16:15.640"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:15.643" starttime="20190402 06:16:15.643"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:16:15.644" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:16:15.644" starttime="20190402 06:16:15.643"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:15.644" starttime="20190402 06:16:15.644"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:15.644" starttime="20190402 06:16:15.644"></status>
</kw>
<msg timestamp="20190402 06:16:15.645" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:16:15.645" starttime="20190402 06:16:15.643"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:16:15.645" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:15.645" starttime="20190402 06:16:15.645"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:16:15.659" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:15.659" starttime="20190402 06:16:15.645"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:16:16.714" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:16:16.714" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:16.714" starttime="20190402 06:16:15.659"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:16:16.715" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:16.715" starttime="20190402 06:16:16.715"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:16:16.716" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:16.716" starttime="20190402 06:16:16.715"></status>
</kw>
<msg timestamp="20190402 06:16:16.716" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:16.716" starttime="20190402 06:16:16.714"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:16:16.718" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:16:16.718" starttime="20190402 06:16:16.716"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:16:16.719" level="INFO">0</msg>
<msg timestamp="20190402 06:16:16.719" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:16.719" starttime="20190402 06:16:16.718"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:16:16.719" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:16:16.719" starttime="20190402 06:16:16.719"></status>
</kw>
<msg timestamp="20190402 06:16:16.719" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:16.719" starttime="20190402 06:16:16.716"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:16.720" starttime="20190402 06:16:16.720"></status>
</kw>
<status status="PASS" endtime="20190402 06:16:16.720" starttime="20190402 06:16:16.719"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:16.720" starttime="20190402 06:16:16.720"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:16:16.720" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:16:16.721" starttime="20190402 06:16:16.720"></status>
</kw>
<msg timestamp="20190402 06:16:16.721" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:16:16.721" starttime="20190402 06:16:15.642"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:16:16.721" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:16.721" starttime="20190402 06:16:16.721"></status>
</kw>
<msg timestamp="20190402 06:16:16.721" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:16.721" starttime="20190402 06:16:15.639"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:16:16.722" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:16:16.722" starttime="20190402 06:16:16.721"></status>
</kw>
<status status="FAIL" endtime="20190402 06:16:16.722" starttime="20190402 06:16:15.637"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:16:21.727" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:21.727" starttime="20190402 06:16:21.726"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:21.728" starttime="20190402 06:16:21.728"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:16:21.729" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:16:21.729" starttime="20190402 06:16:21.728"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:21.729" starttime="20190402 06:16:21.729"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:21.729" starttime="20190402 06:16:21.729"></status>
</kw>
<msg timestamp="20190402 06:16:21.729" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:16:21.730" starttime="20190402 06:16:21.728"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:16:21.730" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:21.730" starttime="20190402 06:16:21.730"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:16:21.741" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:21.741" starttime="20190402 06:16:21.730"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:16:22.825" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:16:22.826" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:22.826" starttime="20190402 06:16:21.741"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:16:22.826" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:22.826" starttime="20190402 06:16:22.826"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:16:22.827" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:22.827" starttime="20190402 06:16:22.826"></status>
</kw>
<msg timestamp="20190402 06:16:22.827" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:22.827" starttime="20190402 06:16:22.826"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:16:22.829" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:16:22.829" starttime="20190402 06:16:22.827"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:16:22.829" level="INFO">0</msg>
<msg timestamp="20190402 06:16:22.829" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:22.829" starttime="20190402 06:16:22.829"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:16:22.830" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:16:22.830" starttime="20190402 06:16:22.830"></status>
</kw>
<msg timestamp="20190402 06:16:22.830" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:22.830" starttime="20190402 06:16:22.827"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:22.831" starttime="20190402 06:16:22.831"></status>
</kw>
<status status="PASS" endtime="20190402 06:16:22.831" starttime="20190402 06:16:22.830"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:22.831" starttime="20190402 06:16:22.831"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:16:22.832" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:16:22.832" starttime="20190402 06:16:22.831"></status>
</kw>
<msg timestamp="20190402 06:16:22.832" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:16:22.832" starttime="20190402 06:16:21.727"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:16:22.832" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:22.832" starttime="20190402 06:16:22.832"></status>
</kw>
<msg timestamp="20190402 06:16:22.832" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:22.832" starttime="20190402 06:16:21.724"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:16:22.833" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:16:22.833" starttime="20190402 06:16:22.833"></status>
</kw>
<status status="FAIL" endtime="20190402 06:16:22.833" starttime="20190402 06:16:21.723"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:16:27.838" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:27.838" starttime="20190402 06:16:27.836"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:27.839" starttime="20190402 06:16:27.839"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:16:27.840" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:16:27.840" starttime="20190402 06:16:27.839"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:27.840" starttime="20190402 06:16:27.840"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:27.840" starttime="20190402 06:16:27.840"></status>
</kw>
<msg timestamp="20190402 06:16:27.840" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:16:27.840" starttime="20190402 06:16:27.839"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:16:27.841" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:27.841" starttime="20190402 06:16:27.841"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:16:27.851" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:27.851" starttime="20190402 06:16:27.841"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:16:28.929" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:16:28.930" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:28.930" starttime="20190402 06:16:27.852"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:16:28.930" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:28.930" starttime="20190402 06:16:28.930"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:16:28.931" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:28.931" starttime="20190402 06:16:28.931"></status>
</kw>
<msg timestamp="20190402 06:16:28.931" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:28.931" starttime="20190402 06:16:28.930"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:16:28.933" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:16:28.933" starttime="20190402 06:16:28.931"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:16:28.933" level="INFO">0</msg>
<msg timestamp="20190402 06:16:28.933" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:28.933" starttime="20190402 06:16:28.933"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:16:28.934" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:16:28.934" starttime="20190402 06:16:28.934"></status>
</kw>
<msg timestamp="20190402 06:16:28.934" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:28.934" starttime="20190402 06:16:28.931"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:28.935" starttime="20190402 06:16:28.935"></status>
</kw>
<status status="PASS" endtime="20190402 06:16:28.935" starttime="20190402 06:16:28.934"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:28.935" starttime="20190402 06:16:28.935"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:16:28.936" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:16:28.936" starttime="20190402 06:16:28.936"></status>
</kw>
<msg timestamp="20190402 06:16:28.936" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:16:28.936" starttime="20190402 06:16:27.838"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:16:28.936" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:28.936" starttime="20190402 06:16:28.936"></status>
</kw>
<msg timestamp="20190402 06:16:28.937" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:28.937" starttime="20190402 06:16:27.835"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:16:28.937" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:16:28.937" starttime="20190402 06:16:28.937"></status>
</kw>
<status status="FAIL" endtime="20190402 06:16:28.937" starttime="20190402 06:16:27.834"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:16:33.942" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:33.942" starttime="20190402 06:16:33.941"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:33.943" starttime="20190402 06:16:33.943"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:16:33.944" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:16:33.944" starttime="20190402 06:16:33.943"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:33.944" starttime="20190402 06:16:33.944"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:33.944" starttime="20190402 06:16:33.944"></status>
</kw>
<msg timestamp="20190402 06:16:33.944" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:16:33.945" starttime="20190402 06:16:33.943"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:16:33.945" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:33.945" starttime="20190402 06:16:33.945"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:16:33.955" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:33.955" starttime="20190402 06:16:33.945"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:16:35.055" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:16:35.055" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:35.055" starttime="20190402 06:16:33.955"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:16:35.055" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:35.056" starttime="20190402 06:16:35.055"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:16:35.056" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:35.056" starttime="20190402 06:16:35.056"></status>
</kw>
<msg timestamp="20190402 06:16:35.056" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:35.056" starttime="20190402 06:16:35.055"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:16:35.058" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:16:35.058" starttime="20190402 06:16:35.056"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:16:35.058" level="INFO">0</msg>
<msg timestamp="20190402 06:16:35.058" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:35.058" starttime="20190402 06:16:35.058"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:16:35.059" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:16:35.059" starttime="20190402 06:16:35.058"></status>
</kw>
<msg timestamp="20190402 06:16:35.059" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:35.059" starttime="20190402 06:16:35.056"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:35.060" starttime="20190402 06:16:35.059"></status>
</kw>
<status status="PASS" endtime="20190402 06:16:35.060" starttime="20190402 06:16:35.059"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:35.060" starttime="20190402 06:16:35.060"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:16:35.060" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:16:35.060" starttime="20190402 06:16:35.060"></status>
</kw>
<msg timestamp="20190402 06:16:35.060" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:16:35.060" starttime="20190402 06:16:33.942"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:16:35.061" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:35.061" starttime="20190402 06:16:35.060"></status>
</kw>
<msg timestamp="20190402 06:16:35.061" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:35.061" starttime="20190402 06:16:33.939"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:16:35.062" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:16:35.062" starttime="20190402 06:16:35.061"></status>
</kw>
<status status="FAIL" endtime="20190402 06:16:35.062" starttime="20190402 06:16:33.938"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:16:40.066" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:40.067" starttime="20190402 06:16:40.065"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:40.068" starttime="20190402 06:16:40.068"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:16:40.069" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:16:40.069" starttime="20190402 06:16:40.068"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:40.069" starttime="20190402 06:16:40.069"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:40.069" starttime="20190402 06:16:40.069"></status>
</kw>
<msg timestamp="20190402 06:16:40.069" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:16:40.069" starttime="20190402 06:16:40.068"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:16:40.070" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:40.070" starttime="20190402 06:16:40.070"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:16:40.080" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:40.080" starttime="20190402 06:16:40.070"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:16:41.111" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:16:41.111" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:41.111" starttime="20190402 06:16:40.080"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:16:41.112" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:41.112" starttime="20190402 06:16:41.111"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:16:41.112" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:41.112" starttime="20190402 06:16:41.112"></status>
</kw>
<msg timestamp="20190402 06:16:41.112" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:41.112" starttime="20190402 06:16:41.111"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:16:41.114" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:16:41.114" starttime="20190402 06:16:41.112"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:16:41.114" level="INFO">0</msg>
<msg timestamp="20190402 06:16:41.114" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:41.114" starttime="20190402 06:16:41.114"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:16:41.114" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:16:41.114" starttime="20190402 06:16:41.114"></status>
</kw>
<msg timestamp="20190402 06:16:41.115" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:41.115" starttime="20190402 06:16:41.112"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:41.115" starttime="20190402 06:16:41.115"></status>
</kw>
<status status="PASS" endtime="20190402 06:16:41.115" starttime="20190402 06:16:41.115"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:41.116" starttime="20190402 06:16:41.116"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:16:41.116" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:16:41.116" starttime="20190402 06:16:41.116"></status>
</kw>
<msg timestamp="20190402 06:16:41.116" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:16:41.116" starttime="20190402 06:16:40.067"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:16:41.117" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:41.117" starttime="20190402 06:16:41.116"></status>
</kw>
<msg timestamp="20190402 06:16:41.117" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:41.117" starttime="20190402 06:16:40.064"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:16:41.117" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:16:41.117" starttime="20190402 06:16:41.117"></status>
</kw>
<status status="FAIL" endtime="20190402 06:16:41.117" starttime="20190402 06:16:40.063"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:16:46.123" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:46.123" starttime="20190402 06:16:46.122"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:46.124" starttime="20190402 06:16:46.124"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:16:46.125" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:16:46.125" starttime="20190402 06:16:46.124"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:46.125" starttime="20190402 06:16:46.125"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:46.125" starttime="20190402 06:16:46.125"></status>
</kw>
<msg timestamp="20190402 06:16:46.126" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:16:46.126" starttime="20190402 06:16:46.124"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:16:46.126" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:46.126" starttime="20190402 06:16:46.126"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:16:46.136" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:46.136" starttime="20190402 06:16:46.126"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:16:47.178" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:16:47.178" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:47.178" starttime="20190402 06:16:46.136"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:16:47.179" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:47.179" starttime="20190402 06:16:47.179"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:16:47.179" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:47.179" starttime="20190402 06:16:47.179"></status>
</kw>
<msg timestamp="20190402 06:16:47.179" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:47.179" starttime="20190402 06:16:47.178"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:16:47.181" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:16:47.181" starttime="20190402 06:16:47.180"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:16:47.181" level="INFO">0</msg>
<msg timestamp="20190402 06:16:47.182" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:47.182" starttime="20190402 06:16:47.181"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:16:47.182" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:16:47.182" starttime="20190402 06:16:47.182"></status>
</kw>
<msg timestamp="20190402 06:16:47.182" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:47.182" starttime="20190402 06:16:47.179"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:47.183" starttime="20190402 06:16:47.183"></status>
</kw>
<status status="PASS" endtime="20190402 06:16:47.183" starttime="20190402 06:16:47.182"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:47.183" starttime="20190402 06:16:47.183"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:16:47.183" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:16:47.184" starttime="20190402 06:16:47.183"></status>
</kw>
<msg timestamp="20190402 06:16:47.184" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:16:47.184" starttime="20190402 06:16:46.123"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:16:47.184" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:47.184" starttime="20190402 06:16:47.184"></status>
</kw>
<msg timestamp="20190402 06:16:47.184" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:47.184" starttime="20190402 06:16:46.120"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:16:47.185" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:16:47.185" starttime="20190402 06:16:47.184"></status>
</kw>
<status status="FAIL" endtime="20190402 06:16:47.185" starttime="20190402 06:16:46.118"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:16:52.189" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:52.189" starttime="20190402 06:16:52.188"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:52.191" starttime="20190402 06:16:52.191"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:16:52.192" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:16:52.192" starttime="20190402 06:16:52.192"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:52.192" starttime="20190402 06:16:52.192"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:52.193" starttime="20190402 06:16:52.192"></status>
</kw>
<msg timestamp="20190402 06:16:52.193" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:16:52.193" starttime="20190402 06:16:52.191"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:16:52.193" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:52.193" starttime="20190402 06:16:52.193"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:16:52.202" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:52.202" starttime="20190402 06:16:52.193"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:16:53.271" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:16:53.272" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:53.272" starttime="20190402 06:16:52.202"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:16:53.272" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:53.272" starttime="20190402 06:16:53.272"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:16:53.273" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:53.273" starttime="20190402 06:16:53.273"></status>
</kw>
<msg timestamp="20190402 06:16:53.273" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:53.273" starttime="20190402 06:16:53.272"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:16:53.275" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:16:53.275" starttime="20190402 06:16:53.273"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:16:53.275" level="INFO">0</msg>
<msg timestamp="20190402 06:16:53.275" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:53.275" starttime="20190402 06:16:53.275"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:16:53.276" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:16:53.276" starttime="20190402 06:16:53.275"></status>
</kw>
<msg timestamp="20190402 06:16:53.276" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:53.276" starttime="20190402 06:16:53.273"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:53.277" starttime="20190402 06:16:53.276"></status>
</kw>
<status status="PASS" endtime="20190402 06:16:53.277" starttime="20190402 06:16:53.276"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:53.277" starttime="20190402 06:16:53.277"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:16:53.277" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:16:53.277" starttime="20190402 06:16:53.277"></status>
</kw>
<msg timestamp="20190402 06:16:53.277" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:16:53.278" starttime="20190402 06:16:52.190"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:16:53.278" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:53.278" starttime="20190402 06:16:53.278"></status>
</kw>
<msg timestamp="20190402 06:16:53.278" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:53.278" starttime="20190402 06:16:52.187"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:16:53.278" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:16:53.279" starttime="20190402 06:16:53.278"></status>
</kw>
<status status="FAIL" endtime="20190402 06:16:53.279" starttime="20190402 06:16:52.186"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:16:58.283" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:58.283" starttime="20190402 06:16:58.282"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:58.286" starttime="20190402 06:16:58.285"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:16:58.290" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:16:58.290" starttime="20190402 06:16:58.288"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:58.291" starttime="20190402 06:16:58.290"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:58.293" starttime="20190402 06:16:58.292"></status>
</kw>
<msg timestamp="20190402 06:16:58.295" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:16:58.295" starttime="20190402 06:16:58.287"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:16:58.296" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:58.297" starttime="20190402 06:16:58.296"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:16:58.309" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:16:58.309" starttime="20190402 06:16:58.297"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:16:59.386" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:16:59.387" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:59.387" starttime="20190402 06:16:58.309"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:16:59.387" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:16:59.387" starttime="20190402 06:16:59.387"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:16:59.388" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:59.388" starttime="20190402 06:16:59.388"></status>
</kw>
<msg timestamp="20190402 06:16:59.388" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:16:59.388" starttime="20190402 06:16:59.387"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:16:59.390" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:16:59.390" starttime="20190402 06:16:59.388"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:16:59.390" level="INFO">0</msg>
<msg timestamp="20190402 06:16:59.391" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:59.391" starttime="20190402 06:16:59.390"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:16:59.391" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:16:59.391" starttime="20190402 06:16:59.391"></status>
</kw>
<msg timestamp="20190402 06:16:59.391" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:16:59.391" starttime="20190402 06:16:59.388"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:59.392" starttime="20190402 06:16:59.392"></status>
</kw>
<status status="PASS" endtime="20190402 06:16:59.392" starttime="20190402 06:16:59.391"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:16:59.392" starttime="20190402 06:16:59.392"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:16:59.392" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:16:59.393" starttime="20190402 06:16:59.392"></status>
</kw>
<msg timestamp="20190402 06:16:59.393" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:16:59.393" starttime="20190402 06:16:58.284"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:16:59.393" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:59.393" starttime="20190402 06:16:59.393"></status>
</kw>
<msg timestamp="20190402 06:16:59.393" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:16:59.393" starttime="20190402 06:16:58.281"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:16:59.394" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:16:59.394" starttime="20190402 06:16:59.393"></status>
</kw>
<status status="FAIL" endtime="20190402 06:16:59.394" starttime="20190402 06:16:58.279"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:17:04.398" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:17:04.398" starttime="20190402 06:17:04.397"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:04.400" starttime="20190402 06:17:04.400"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:17:04.401" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:17:04.401" starttime="20190402 06:17:04.400"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:04.401" starttime="20190402 06:17:04.401"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:04.401" starttime="20190402 06:17:04.401"></status>
</kw>
<msg timestamp="20190402 06:17:04.402" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:17:04.402" starttime="20190402 06:17:04.400"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:17:04.402" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:04.402" starttime="20190402 06:17:04.402"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:17:04.411" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:17:04.411" starttime="20190402 06:17:04.402"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:17:05.490" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:17:05.491" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:05.491" starttime="20190402 06:17:04.411"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:17:05.491" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:05.491" starttime="20190402 06:17:05.491"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:17:05.492" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:17:05.492" starttime="20190402 06:17:05.492"></status>
</kw>
<msg timestamp="20190402 06:17:05.492" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:17:05.492" starttime="20190402 06:17:05.491"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:17:05.494" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:17:05.494" starttime="20190402 06:17:05.492"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:17:05.494" level="INFO">0</msg>
<msg timestamp="20190402 06:17:05.495" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:05.495" starttime="20190402 06:17:05.494"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:17:05.495" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:17:05.495" starttime="20190402 06:17:05.495"></status>
</kw>
<msg timestamp="20190402 06:17:05.495" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:05.495" starttime="20190402 06:17:05.492"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:05.496" starttime="20190402 06:17:05.496"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:05.496" starttime="20190402 06:17:05.495"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:05.496" starttime="20190402 06:17:05.496"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:17:05.496" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:17:05.496" starttime="20190402 06:17:05.496"></status>
</kw>
<msg timestamp="20190402 06:17:05.497" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:17:05.497" starttime="20190402 06:17:04.399"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:17:05.497" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:17:05.497" starttime="20190402 06:17:05.497"></status>
</kw>
<msg timestamp="20190402 06:17:05.497" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:17:05.497" starttime="20190402 06:17:04.396"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:17:05.498" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:17:05.498" starttime="20190402 06:17:05.497"></status>
</kw>
<status status="FAIL" endtime="20190402 06:17:05.498" starttime="20190402 06:17:04.395"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:17:10.503" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:17:10.503" starttime="20190402 06:17:10.501"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:10.504" starttime="20190402 06:17:10.504"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:17:10.505" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:17:10.505" starttime="20190402 06:17:10.504"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:10.505" starttime="20190402 06:17:10.505"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:10.506" starttime="20190402 06:17:10.505"></status>
</kw>
<msg timestamp="20190402 06:17:10.506" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:17:10.506" starttime="20190402 06:17:10.504"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:17:10.506" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:10.506" starttime="20190402 06:17:10.506"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:17:10.519" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:17:10.519" starttime="20190402 06:17:10.507"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:17:11.670" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:17:11.670" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:11.670" starttime="20190402 06:17:10.519"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:17:11.671" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:11.671" starttime="20190402 06:17:11.671"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:17:11.672" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190402 06:17:11.672" starttime="20190402 06:17:11.671"></status>
</kw>
<msg timestamp="20190402 06:17:11.672" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190402 06:17:11.672" starttime="20190402 06:17:11.671"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:17:11.674" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:17:11.674" starttime="20190402 06:17:11.672"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:17:11.674" level="INFO">0</msg>
<msg timestamp="20190402 06:17:11.675" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:11.675" starttime="20190402 06:17:11.674"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:17:11.675" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:17:11.675" starttime="20190402 06:17:11.675"></status>
</kw>
<msg timestamp="20190402 06:17:11.675" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:11.675" starttime="20190402 06:17:11.672"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:11.676" starttime="20190402 06:17:11.676"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:11.676" starttime="20190402 06:17:11.675"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:11.676" starttime="20190402 06:17:11.676"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:17:11.676" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190402 06:17:11.676" starttime="20190402 06:17:11.676"></status>
</kw>
<msg timestamp="20190402 06:17:11.677" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:17:11.677" starttime="20190402 06:17:10.503"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:17:11.677" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190402 06:17:11.677" starttime="20190402 06:17:11.677"></status>
</kw>
<msg timestamp="20190402 06:17:11.677" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190402 06:17:11.677" starttime="20190402 06:17:10.500"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190402 06:17:11.678" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190402 06:17:11.678" starttime="20190402 06:17:11.677"></status>
</kw>
<status status="FAIL" endtime="20190402 06:17:11.678" starttime="20190402 06:17:10.499"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:17:16.683" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:17:16.683" starttime="20190402 06:17:16.682"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:16.684" starttime="20190402 06:17:16.684"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:17:16.685" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:17:16.685" starttime="20190402 06:17:16.684"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:16.685" starttime="20190402 06:17:16.685"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:16.686" starttime="20190402 06:17:16.685"></status>
</kw>
<msg timestamp="20190402 06:17:16.686" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:17:16.686" starttime="20190402 06:17:16.684"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:17:16.686" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:16.686" starttime="20190402 06:17:16.686"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:17:16.697" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190402 06:17:16.697" starttime="20190402 06:17:16.686"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:17:17.697" level="INFO">available
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:17:17.697" level="INFO">${output} = available
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:17.697" starttime="20190402 06:17:16.697"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:17:17.698" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:17.698" starttime="20190402 06:17:17.697"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:17:17.698" level="INFO">${clean_out} = available
</msg>
<status status="PASS" endtime="20190402 06:17:17.698" starttime="20190402 06:17:17.698"></status>
</kw>
<msg timestamp="20190402 06:17:17.698" level="INFO">${output} = available
</msg>
<status status="PASS" endtime="20190402 06:17:17.698" starttime="20190402 06:17:17.697"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:17:17.700" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:17:17.701" starttime="20190402 06:17:17.698"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:17:17.701" level="INFO">0</msg>
<msg timestamp="20190402 06:17:17.701" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:17.701" starttime="20190402 06:17:17.701"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:17:17.701" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:17:17.701" starttime="20190402 06:17:17.701"></status>
</kw>
<msg timestamp="20190402 06:17:17.701" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:17.701" starttime="20190402 06:17:17.698"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:17.702" starttime="20190402 06:17:17.702"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:17.702" starttime="20190402 06:17:17.702"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:17.703" starttime="20190402 06:17:17.702"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:17:17.703" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: available</msg>
<status status="PASS" endtime="20190402 06:17:17.703" starttime="20190402 06:17:17.703"></status>
</kw>
<msg timestamp="20190402 06:17:17.703" level="INFO">${result} = {u'stdout': u'available', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 06:17:17.703" starttime="20190402 06:17:16.683"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:17:17.703" level="INFO">${value} = available</msg>
<status status="PASS" endtime="20190402 06:17:17.703" starttime="20190402 06:17:17.703"></status>
</kw>
<msg timestamp="20190402 06:17:17.704" level="INFO">${current_value} = available</msg>
<status status="PASS" endtime="20190402 06:17:17.704" starttime="20190402 06:17:16.681"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:17.704" starttime="20190402 06:17:17.704"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:17.704" starttime="20190402 06:17:16.679"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:17.704" starttime="20190402 06:11:59.496"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:17.704" starttime="20190402 06:11:56.237"></status>
</kw>
<kw name="Generate Secondary Controller Connection" library="Utils">
<doc>Establish a SSH connection with the secondary controller
to have it alive.</doc>
<arguments>
<arg>${second_controller}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${controller}'=='controller-0'</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
<arg>${CONFIG.general.IP_UNIT_1_ADDRESS}</arg>
</arguments>
<assign>
<var>${controller_ip}</var>
</assign>
<msg timestamp="20190402 06:17:17.705" level="INFO">${controller_ip} = 192.168.200.77</msg>
<status status="PASS" endtime="20190402 06:17:17.705" starttime="20190402 06:17:17.705"></status>
</kw>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${controller_ip}</arg>
</arguments>
<assign>
<var>${secondary_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190402 06:17:17.706" level="INFO">${controller_connection} = 3</msg>
<status status="PASS" endtime="20190402 06:17:17.706" starttime="20190402 06:17:17.705"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190402 06:17:17.706" level="INFO">Length is 10</msg>
<msg timestamp="20190402 06:17:17.706" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190402 06:17:17.707" starttime="20190402 06:17:17.706"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190402 06:17:17.707" level="INFO">Logging into '192.168.200.77 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190402 06:17:18.795" level="INFO">Read output: Last login: Tue Apr  2 12:00:39 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-1:~$</msg>
<status status="PASS" endtime="20190402 06:17:18.796" starttime="20190402 06:17:17.707"></status>
</kw>
<msg timestamp="20190402 06:17:18.796" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190402 06:17:18.796" starttime="20190402 06:17:17.707"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:18.797" starttime="20190402 06:17:17.706"></status>
</kw>
<msg timestamp="20190402 06:17:18.797" level="INFO">${secondary_controller_connection} = 3</msg>
<status status="PASS" endtime="20190402 06:17:18.797" starttime="20190402 06:17:17.705"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
</arguments>
<msg timestamp="20190402 06:17:18.799" level="INFO">${secondary_controller_connection} = 3</msg>
<status status="PASS" endtime="20190402 06:17:18.799" starttime="20190402 06:17:18.798"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
</arguments>
<msg timestamp="20190402 06:17:18.800" level="INFO">3</msg>
<status status="PASS" endtime="20190402 06:17:18.800" starttime="20190402 06:17:18.799"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${secondary_controller_connection} is not None</arg>
<arg>Switch Controller Connection</arg>
<arg>${master_controller_connection}</arg>
<arg>${secondary_controller_connection}</arg>
</arguments>
<kw name="Switch Controller Connection" library="Utils">
<doc>Enable a SSH connection to the new active controller and
source proper variables.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
<arg>${secondary_controller_connection}</arg>
</arguments>
<kw name="Switch Connection" library="SSHLibrary">
<doc>Switches the active connection by index or alias.</doc>
<arguments>
<arg>${new_idx}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:18.801" starttime="20190402 06:17:18.801"></status>
</kw>
<kw name="Get Connection" library="SSHLibrary">
<doc>Returns information about the connection.</doc>
<arguments>
<arg>${new_idx}</arg>
</arguments>
<msg timestamp="20190402 06:17:18.801" level="INFO">index=1
path_separator=/
prompt=$
width=80
newline=

height=24
encoding=UTF-8
alias=None
host=192.168.200.76 prompt=$
timeout=1 minute
term_type=vt100
port=22</msg>
<status status="PASS" endtime="20190402 06:17:18.802" starttime="20190402 06:17:18.801"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>whoami</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:18.802" starttime="20190402 06:17:18.802"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:17:18.803" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:17:18.803" starttime="20190402 06:17:18.802"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:18.803" starttime="20190402 06:17:18.803"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:18.804" starttime="20190402 06:17:18.803"></status>
</kw>
<msg timestamp="20190402 06:17:18.804" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:17:18.804" starttime="20190402 06:17:18.802"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:17:18.804" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:18.804" starttime="20190402 06:17:18.804"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:17:18.806" level="INFO">whoami</msg>
<status status="PASS" endtime="20190402 06:17:18.806" starttime="20190402 06:17:18.804"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:17:18.807" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:17:18.807" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:18.807" starttime="20190402 06:17:18.806"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:17:18.808" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:18.808" starttime="20190402 06:17:18.808"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:17:18.808" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190402 06:17:18.808" starttime="20190402 06:17:18.808"></status>
</kw>
<msg timestamp="20190402 06:17:18.808" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190402 06:17:18.808" starttime="20190402 06:17:18.807"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:17:18.810" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:17:18.810" starttime="20190402 06:17:18.809"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:17:18.811" level="INFO">0</msg>
<msg timestamp="20190402 06:17:18.811" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:18.811" starttime="20190402 06:17:18.811"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:17:18.811" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:17:18.811" starttime="20190402 06:17:18.811"></status>
</kw>
<msg timestamp="20190402 06:17:18.812" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:18.812" starttime="20190402 06:17:18.808"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:18.812" starttime="20190402 06:17:18.812"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:18.812" starttime="20190402 06:17:18.812"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:18.813" starttime="20190402 06:17:18.812"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:17:18.813" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190402 06:17:18.813" starttime="20190402 06:17:18.813"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:18.813" starttime="20190402 06:17:18.802"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Set Env Vars From Openrc</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:18.814" starttime="20190402 06:17:18.814"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:17:18.815" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:17:18.815" starttime="20190402 06:17:18.815"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:18.815" starttime="20190402 06:17:18.815"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:18.816" starttime="20190402 06:17:18.815"></status>
</kw>
<msg timestamp="20190402 06:17:18.816" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:17:18.816" starttime="20190402 06:17:18.814"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:17:18.816" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:18.816" starttime="20190402 06:17:18.816"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:17:18.822" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 06:17:18.822" starttime="20190402 06:17:18.816"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:17:19.187" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:17:19.188" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:19.188" starttime="20190402 06:17:18.822"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:17:19.189" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:19.189" starttime="20190402 06:17:19.188"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:17:19.189" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190402 06:17:19.189" starttime="20190402 06:17:19.189"></status>
</kw>
<msg timestamp="20190402 06:17:19.189" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190402 06:17:19.189" starttime="20190402 06:17:19.188"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:17:19.191" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:17:19.191" starttime="20190402 06:17:19.190"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:17:19.191" level="INFO">0</msg>
<msg timestamp="20190402 06:17:19.192" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:19.192" starttime="20190402 06:17:19.191"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.192" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:17:19.192" starttime="20190402 06:17:19.192"></status>
</kw>
<msg timestamp="20190402 06:17:19.192" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:19.192" starttime="20190402 06:17:19.189"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.193" starttime="20190402 06:17:19.193"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.193" starttime="20190402 06:17:19.192"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.193" starttime="20190402 06:17:19.193"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.194" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190402 06:17:19.194" starttime="20190402 06:17:19.193"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.194" starttime="20190402 06:17:18.814"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.194" starttime="20190402 06:17:18.813"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.194" starttime="20190402 06:17:18.813"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
<arg>${old_idx}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.194" level="INFO">${secondary_controller_connection} = 3</msg>
<status status="PASS" endtime="20190402 06:17:19.194" starttime="20190402 06:17:19.194"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
<arg>${new_idx}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.195" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 06:17:19.195" starttime="20190402 06:17:19.195"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.195" starttime="20190402 06:17:18.801"></status>
</kw>
<msg timestamp="20190402 06:17:19.195" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190402 06:17:19.195" starttime="20190402 06:17:18.800"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.195" starttime="20190402 06:17:17.704"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Check Ceph Status</arg>
<arg>HEALTH_OK</arg>
</arguments>
<kw name="Check Ceph Status" library="Utils">
<doc>Verifies the status of the CEPH feature.</doc>
<arguments>
<arg>HEALTH_OK</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph -s</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.197" starttime="20190402 06:17:19.196"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:17:19.197" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:17:19.197" starttime="20190402 06:17:19.197"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.198" starttime="20190402 06:17:19.197"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.198" starttime="20190402 06:17:19.198"></status>
</kw>
<msg timestamp="20190402 06:17:19.198" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:17:19.198" starttime="20190402 06:17:19.197"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:17:19.199" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:19.199" starttime="20190402 06:17:19.198"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.200" level="INFO">ceph -s</msg>
<status status="PASS" endtime="20190402 06:17:19.200" starttime="20190402 06:17:19.199"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:17:19.338" level="INFO">cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_OK
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e28: 2 osds: 2 up, 2 in
            flags sortbitwise,require_jewel_osds
      pgmap v67: 384 pgs, 6 pools, 1588 bytes data, 1116 objects
            87720 kB used, 891 GB / 891 GB avail
                 384 active+clean
  client io 413 kB/s rd, 0 B/s wr, 413 op/s rd, 275 op/s wr
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:17:19.338" level="INFO">${output} =     cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_OK
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e28: 2...</msg>
<status status="PASS" endtime="20190402 06:17:19.338" starttime="20190402 06:17:19.200"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:17:19.338" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:19.338" starttime="20190402 06:17:19.338"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:17:19.339" level="INFO">${clean_out} =     cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_OK
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e28: 2...</msg>
<status status="PASS" endtime="20190402 06:17:19.339" starttime="20190402 06:17:19.339"></status>
</kw>
<msg timestamp="20190402 06:17:19.339" level="INFO">${output} =     cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_OK
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e28: 2...</msg>
<status status="PASS" endtime="20190402 06:17:19.339" starttime="20190402 06:17:19.338"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:17:19.341" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:17:19.341" starttime="20190402 06:17:19.339"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:17:19.341" level="INFO">0</msg>
<msg timestamp="20190402 06:17:19.341" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:19.342" starttime="20190402 06:17:19.341"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.342" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:17:19.342" starttime="20190402 06:17:19.342"></status>
</kw>
<msg timestamp="20190402 06:17:19.342" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:19.342" starttime="20190402 06:17:19.339"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.343" starttime="20190402 06:17:19.343"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.343" starttime="20190402 06:17:19.342"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.343" starttime="20190402 06:17:19.343"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.343" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7
     health HEALTH_OK
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e28: 2 osds: 2 up, 2 in
            flags sortbitwise,require_jewel_osds
      pgmap v67: 384 pgs, 6 pools, 1588 bytes data, 1116 objects
            87720 kB used, 891 GB / 891 GB avail
                 384 active+clean
  client io 413 kB/s rd, 0 B/s wr, 413 op/s rd, 275 op/s wr</msg>
<status status="PASS" endtime="20190402 06:17:19.344" starttime="20190402 06:17:19.343"></status>
</kw>
<msg timestamp="20190402 06:17:19.344" level="INFO">${result} = {u'stdout': u'cluster 01a284a3-ed7f-4eff-bec7-9da4becd87e7\r\n     health HEALTH_OK\r\n     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}\r\n            election epoch 4, quorum 0 controller\r\n...</msg>
<status status="PASS" endtime="20190402 06:17:19.344" starttime="20190402 06:17:19.196"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${result.stdout}</arg>
<arg>${status}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.344" starttime="20190402 06:17:19.344"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd tree</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.345" starttime="20190402 06:17:19.345"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:17:19.345" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:17:19.345" starttime="20190402 06:17:19.345"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.346" starttime="20190402 06:17:19.346"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.346" starttime="20190402 06:17:19.346"></status>
</kw>
<msg timestamp="20190402 06:17:19.346" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:17:19.346" starttime="20190402 06:17:19.345"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:17:19.347" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:19.347" starttime="20190402 06:17:19.346"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.349" level="INFO">ceph osd tree</msg>
<status status="PASS" endtime="20190402 06:17:19.349" starttime="20190402 06:17:19.347"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:17:19.481" level="INFO">ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.87097 root storage-tier                                           
-2 0.87097     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3 0.43549         host controller-1                                   
 1 0.43549             osd.1              up  1.00000          1.00000 
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:17:19.482" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.87097 root storage-tier                                           
-2 0.87097     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190402 06:17:19.482" starttime="20190402 06:17:19.350"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:17:19.482" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:17:19.482" starttime="20190402 06:17:19.482"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:17:19.483" level="INFO">${clean_out} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.87097 root storage-tier                                           
-2 0.87097     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190402 06:17:19.483" starttime="20190402 06:17:19.482"></status>
</kw>
<msg timestamp="20190402 06:17:19.483" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.87097 root storage-tier                                           
-2 0.87097     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190402 06:17:19.483" starttime="20190402 06:17:19.482"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:17:19.485" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:17:19.485" starttime="20190402 06:17:19.483"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:17:19.485" level="INFO">0</msg>
<msg timestamp="20190402 06:17:19.486" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:19.486" starttime="20190402 06:17:19.485"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.486" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:17:19.486" starttime="20190402 06:17:19.486"></status>
</kw>
<msg timestamp="20190402 06:17:19.486" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:17:19.486" starttime="20190402 06:17:19.483"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.487" starttime="20190402 06:17:19.487"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.487" starttime="20190402 06:17:19.486"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:17:19.487" starttime="20190402 06:17:19.487"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.487" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.87097 root storage-tier                                           
-2 0.87097     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3 0.43549         host controller-1                                   
 1 0.43549             osd.1              up  1.00000          1.00000</msg>
<status status="PASS" endtime="20190402 06:17:19.488" starttime="20190402 06:17:19.487"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.488" starttime="20190402 06:17:19.344"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.488" starttime="20190402 06:17:19.196"></status>
</kw>
<status status="PASS" endtime="20190402 06:17:19.488" starttime="20190402 06:17:19.195"></status>
</kw>
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/${chart_manifest}</arg>
<arg>${host_image_path}/${chart_manifest}</arg>
</arguments>
<msg timestamp="20190402 06:17:19.496" level="INFO">[chan 1] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190402 06:17:19.503" level="INFO">[chan 2] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190402 06:17:19.504" level="FAIL">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/helm-charts-manifest.tgz'.</msg>
<status status="FAIL" endtime="20190402 06:17:19.504" starttime="20190402 06:17:19.488"></status>
</kw>
<doc>Validates provisioning of a duplex configuration
according to steps defined at
"https://wiki.openstack.org/wiki/StarlingX/Containers/
InstallationOnAIODX"</doc>
<tags>
<tag>Duplex</tag>
</tags>
<status status="FAIL" endtime="20190402 06:17:19.505" critical="yes" starttime="20190402 05:34:57.607">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/helm-charts-manifest.tgz'.</status>
</test>
<doc>Tests for provisioning and unlocking controllers, computes and
storage hosts.
Author(s):
- Jose Perez Carranza &lt;jose.perez.carranza@intel.com&gt;
- Juan Carlos Alonso &lt;juan.carlos.alonso@intel.com&gt;</doc>
<metadata>
<item name="ISO">bootimage.iso</item>
<item name="System">duplex</item>
</metadata>
<status status="FAIL" endtime="20190402 06:17:19.505" starttime="20190402 05:34:55.921"></status>
</suite>
<statistics>
<total>
<stat fail="1" pass="0">Critical Tests</stat>
<stat fail="1" pass="0">All Tests</stat>
</total>
<tag>
<stat fail="1" pass="0">Duplex</stat>
</tag>
<suite>
<stat fail="1" id="s1" name="Provision-Containers" pass="0">Provision-Containers</stat>
</suite>
</statistics>
<errors>
</errors>
</robot>
