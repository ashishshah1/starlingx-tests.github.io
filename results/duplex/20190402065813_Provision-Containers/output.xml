<?xml version="1.0" encoding="UTF-8"?>
<robot rpa="false" generated="20190402 06:58:13.039" generator="Robot 3.1.1 (Python 2.7.15 on linux2)">
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Provision-Containers.robot" id="s1" name="Provision-Containers">
<kw type="setup" name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Utils.Stx Suite Setup</arg>
<arg>provisioning.Assign Data Interfaces</arg>
</arguments>
<kw name="Stx Suite Setup" library="Utils">
<doc>Wrapper to setup the environment needed for exercise
StarlingX features</doc>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190402 06:58:13.178" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 06:58:13.178" starttime="20190402 06:58:13.177"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190402 06:58:13.178" level="INFO">Length is 10</msg>
<msg timestamp="20190402 06:58:13.178" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190402 06:58:13.178" starttime="20190402 06:58:13.178"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190402 06:58:13.179" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190402 06:58:14.285" level="INFO">Read output: Last login: Tue Apr  2 12:39:56 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<msg timestamp="20190402 06:58:14.285" level="INFO">/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:39: CryptographyDeprecationWarning: encode_point has been deprecated on EllipticCurvePublicNumbers and will be removed in a future version. Please use EllipticCurvePublicKey.public_bytes to obtain both compressed and uncompressed point encoding.
  m.add_string(self.Q_C.public_numbers().encode_point())
/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:96: CryptographyDeprecationWarning: Support for unsafe construction of public numbers from encoded data will be removed in a future version. Please use EllipticCurvePublicKey.from_encoded_point
  self.curve, Q_S_bytes
/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:111: CryptographyDeprecationWarning: encode_point has been deprecated on EllipticCurvePublicNumbers and will be removed in a future version. Please use EllipticCurvePublicKey.public_bytes to obtain both compressed and uncompressed point encoding.
  hm.add_string(self.Q_C.public_numbers().encode_point())</msg>
<status status="PASS" endtime="20190402 06:58:14.286" starttime="20190402 06:58:13.179"></status>
</kw>
<msg timestamp="20190402 06:58:14.286" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190402 06:58:14.287" starttime="20190402 06:58:13.178"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:14.287" starttime="20190402 06:58:13.178"></status>
</kw>
<msg timestamp="20190402 06:58:14.288" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 06:58:14.288" starttime="20190402 06:58:13.177"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190402 06:58:14.289" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190402 06:58:14.289" starttime="20190402 06:58:14.288"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190402 06:58:14.290" level="INFO">1</msg>
<status status="PASS" endtime="20190402 06:58:14.290" starttime="20190402 06:58:14.289"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:14.290" starttime="20190402 06:58:13.177"></status>
</kw>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:14.293" starttime="20190402 06:58:14.293"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:14.296" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:14.296" starttime="20190402 06:58:14.294"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:14.297" starttime="20190402 06:58:14.296"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:14.298" starttime="20190402 06:58:14.297"></status>
</kw>
<msg timestamp="20190402 06:58:14.298" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:14.299" starttime="20190402 06:58:14.294"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190402 06:58:14.299" starttime="20190402 06:58:14.299"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:14.309" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190402 06:58:14.309" starttime="20190402 06:58:14.300"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:14.668" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:14.668" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:14.668" starttime="20190402 06:58:14.309"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:14.669" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:14.669" starttime="20190402 06:58:14.669"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:14.669" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190402 06:58:14.669" starttime="20190402 06:58:14.669"></status>
</kw>
<msg timestamp="20190402 06:58:14.670" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190402 06:58:14.670" starttime="20190402 06:58:14.668"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:14.671" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:14.671" starttime="20190402 06:58:14.670"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:14.672" level="INFO">0</msg>
<msg timestamp="20190402 06:58:14.672" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:14.672" starttime="20190402 06:58:14.672"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:14.672" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:14.672" starttime="20190402 06:58:14.672"></status>
</kw>
<msg timestamp="20190402 06:58:14.672" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:14.673" starttime="20190402 06:58:14.670"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:14.673" starttime="20190402 06:58:14.673"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:14.673" starttime="20190402 06:58:14.673"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:14.674" starttime="20190402 06:58:14.673"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:14.674" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190402 06:58:14.674" starttime="20190402 06:58:14.674"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:14.674" starttime="20190402 06:58:14.291"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:14.674" starttime="20190402 06:58:14.291"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:14.674" starttime="20190402 06:58:13.176"></status>
</kw>
<kw name="Assign Data Interfaces" library="provisioning">
<doc>Set variables for Data interfaces according to the
configuration selected</doc>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${ENVIRONMENT}'=='virtual'</arg>
<arg>Create List</arg>
<arg>eth1000</arg>
<arg>eth1001</arg>
<arg>ELSE</arg>
<arg>Create List</arg>
<arg>enp24s0f0</arg>
<arg>enp24s0f1</arg>
</arguments>
<assign>
<var>@{data_interfaces}</var>
</assign>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<arguments>
<arg>enp24s0f0</arg>
<arg>enp24s0f1</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:14.675" starttime="20190402 06:58:14.675"></status>
</kw>
<msg timestamp="20190402 06:58:14.675" level="INFO">@{data_interfaces} = [ enp24s0f0 | enp24s0f1 ]</msg>
<status status="PASS" endtime="20190402 06:58:14.675" starttime="20190402 06:58:14.675"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${data_interfaces}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data0if}</var>
</assign>
<msg timestamp="20190402 06:58:14.675" level="INFO">${data0if} = enp24s0f0</msg>
<status status="PASS" endtime="20190402 06:58:14.675" starttime="20190402 06:58:14.675"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${data_interfaces}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data1if}</var>
</assign>
<msg timestamp="20190402 06:58:14.676" level="INFO">${data1if} = enp24s0f1</msg>
<status status="PASS" endtime="20190402 06:58:14.676" starttime="20190402 06:58:14.676"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${data0if}</arg>
</arguments>
<msg timestamp="20190402 06:58:14.676" level="INFO">${data0if} = enp24s0f0</msg>
<status status="PASS" endtime="20190402 06:58:14.676" starttime="20190402 06:58:14.676"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${data1if}</arg>
</arguments>
<msg timestamp="20190402 06:58:14.677" level="INFO">${data1if} = enp24s0f1</msg>
<status status="PASS" endtime="20190402 06:58:14.677" starttime="20190402 06:58:14.676"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:14.677" starttime="20190402 06:58:14.674"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:14.677" starttime="20190402 06:58:13.176"></status>
</kw>
<test id="s1-t1" name="Provisioning Duplex System">
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/${chart_manifest}</arg>
<arg>${host_image_path}/${chart_manifest}</arg>
</arguments>
<msg timestamp="20190402 06:58:14.685" level="INFO">[chan 1] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190402 06:58:14.692" level="INFO">[chan 2] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190402 06:58:14.729" level="INFO">'/home/mgperezi/duplex/stx-test-suite/helm-charts-manifest.tgz' -&gt; '/home/wrsroot//helm-charts-manifest.tgz'</msg>
<status status="PASS" endtime="20190402 06:58:14.729" starttime="20190402 06:58:14.677"></status>
</kw>
<kw name="Stage Application Deployment" library="Utils">
<doc>Use sysinv to upload the application tarball.</doc>
<arguments>
<arg>stx-openstack</arg>
<arg>${chart_manifest}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>system application-upload</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190402 06:58:14.730" level="INFO">${system_cmd} = system application-upload</msg>
<status status="PASS" endtime="20190402 06:58:14.730" starttime="20190402 06:58:14.730"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${system_cmd}</arg>
<arg>${application}</arg>
<arg>${chart_manifest}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:58:14.730" level="INFO">${cmd} = system application-upload stx-openstack helm-charts-manifest.tgz</msg>
<status status="PASS" endtime="20190402 06:58:14.730" starttime="20190402 06:58:14.730"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:14.731" starttime="20190402 06:58:14.731"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:14.732" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:14.732" starttime="20190402 06:58:14.731"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:14.732" starttime="20190402 06:58:14.732"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:14.732" starttime="20190402 06:58:14.732"></status>
</kw>
<msg timestamp="20190402 06:58:14.733" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:14.733" starttime="20190402 06:58:14.731"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:58:14.733" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:14.733" starttime="20190402 06:58:14.733"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:14.742" level="INFO">system application-upload stx-openstac k helm-charts-manifest.tgz</msg>
<status status="PASS" endtime="20190402 06:58:14.742" starttime="20190402 06:58:14.733"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:16.376" level="INFO">+---------------+----------------------------------+
| Property      | Value                            |
+---------------+----------------------------------+
| created_at    | 2019-04-02T12:47:00.451151+00:00 |
| manifest_file | manifest.yaml                    |
| manifest_name | armada-manifest                  |
| name          | stx-openstack                    |
| progress      | None                             |
| status        | uploading                        |
| updated_at    | None                             |
+---------------+----------------------------------+
Please use 'system application-list' or 'system application-show stx-openstack' to view the current progress.
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:16.376" level="INFO">${output} = +---------------+----------------------------------+
| Property      | Value                            |
+---------------+----------------------------------+
| created_at    | 2019-04-02T12:47:00....</msg>
<status status="PASS" endtime="20190402 06:58:16.376" starttime="20190402 06:58:14.743"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:16.377" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:16.377" starttime="20190402 06:58:16.377"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:16.378" level="INFO">${clean_out} = +---------------+----------------------------------+
| Property      | Value                            |
+---------------+----------------------------------+
| created_at    | 2019-04-02T12:47:00....</msg>
<status status="PASS" endtime="20190402 06:58:16.378" starttime="20190402 06:58:16.377"></status>
</kw>
<msg timestamp="20190402 06:58:16.378" level="INFO">${output} = +---------------+----------------------------------+
| Property      | Value                            |
+---------------+----------------------------------+
| created_at    | 2019-04-02T12:47:00....</msg>
<status status="PASS" endtime="20190402 06:58:16.378" starttime="20190402 06:58:16.376"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:16.380" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:16.380" starttime="20190402 06:58:16.378"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:16.380" level="INFO">0</msg>
<msg timestamp="20190402 06:58:16.380" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:16.380" starttime="20190402 06:58:16.380"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:16.381" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:16.381" starttime="20190402 06:58:16.380"></status>
</kw>
<msg timestamp="20190402 06:58:16.381" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:16.381" starttime="20190402 06:58:16.378"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:16.382" starttime="20190402 06:58:16.382"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:16.382" starttime="20190402 06:58:16.381"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:16.382" starttime="20190402 06:58:16.382"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:16.382" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +---------------+----------------------------------+
| Property      | Value                            |
+---------------+----------------------------------+
| created_at    | 2019-04-02T12:47:00.451151+00:00 |
| manifest_file | manifest.yaml                    |
| manifest_name | armada-manifest                  |
| name          | stx-openstack                    |
| progress      | None                             |
| status        | uploading                        |
| updated_at    | None                             |
+---------------+----------------------------------+
Please use 'system application-list' or 'system application-show stx-openstack' to view the current progress.</msg>
<status status="PASS" endtime="20190402 06:58:16.383" starttime="20190402 06:58:16.382"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:16.383" starttime="20190402 06:58:14.730"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Check System Application Status</arg>
<arg>${application}</arg>
<arg>uploaded</arg>
</arguments>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>uploaded</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:58:16.384" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:16.384" starttime="20190402 06:58:16.383"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:16.384" starttime="20190402 06:58:16.384"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:16.385" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:16.385" starttime="20190402 06:58:16.385"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:16.385" starttime="20190402 06:58:16.385"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:16.386" starttime="20190402 06:58:16.385"></status>
</kw>
<msg timestamp="20190402 06:58:16.386" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:16.386" starttime="20190402 06:58:16.384"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:58:16.386" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:16.386" starttime="20190402 06:58:16.386"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:16.388" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:16.388" starttime="20190402 06:58:16.386"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:17.464" level="INFO">uploading
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:17.464" level="INFO">${output} = uploading
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:17.464" starttime="20190402 06:58:16.388"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:17.465" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:17.465" starttime="20190402 06:58:17.465"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:17.465" level="INFO">${clean_out} = uploading
</msg>
<status status="PASS" endtime="20190402 06:58:17.465" starttime="20190402 06:58:17.465"></status>
</kw>
<msg timestamp="20190402 06:58:17.465" level="INFO">${output} = uploading
</msg>
<status status="PASS" endtime="20190402 06:58:17.465" starttime="20190402 06:58:17.464"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:17.467" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:17.468" starttime="20190402 06:58:17.466"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:17.468" level="INFO">0</msg>
<msg timestamp="20190402 06:58:17.468" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:17.468" starttime="20190402 06:58:17.468"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:17.468" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:17.468" starttime="20190402 06:58:17.468"></status>
</kw>
<msg timestamp="20190402 06:58:17.468" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:17.469" starttime="20190402 06:58:17.465"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:17.469" starttime="20190402 06:58:17.469"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:17.469" starttime="20190402 06:58:17.469"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:17.470" starttime="20190402 06:58:17.469"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:17.470" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: uploading</msg>
<status status="PASS" endtime="20190402 06:58:17.470" starttime="20190402 06:58:17.470"></status>
</kw>
<msg timestamp="20190402 06:58:17.470" level="INFO">&amp;{result} = { stdout=uploading | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:58:17.470" starttime="20190402 06:58:16.384"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:58:17.470" level="INFO">${value} = uploading</msg>
<status status="PASS" endtime="20190402 06:58:17.471" starttime="20190402 06:58:17.470"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:58:17.471" level="FAIL">uploading != uploaded</msg>
<status status="FAIL" endtime="20190402 06:58:17.471" starttime="20190402 06:58:17.471"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:17.471" starttime="20190402 06:58:17.471"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:17.471" starttime="20190402 06:58:16.383"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>uploaded</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:58:22.474" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:22.475" starttime="20190402 06:58:22.473"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:22.477" starttime="20190402 06:58:22.476"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:22.478" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:22.478" starttime="20190402 06:58:22.477"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:22.478" starttime="20190402 06:58:22.478"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:22.478" starttime="20190402 06:58:22.478"></status>
</kw>
<msg timestamp="20190402 06:58:22.478" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:22.479" starttime="20190402 06:58:22.477"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:58:22.479" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:22.479" starttime="20190402 06:58:22.479"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:22.481" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:22.481" starttime="20190402 06:58:22.479"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:23.625" level="INFO">uploading
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:23.625" level="INFO">${output} = uploading
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:23.625" starttime="20190402 06:58:22.481"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:23.626" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:23.626" starttime="20190402 06:58:23.625"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:23.626" level="INFO">${clean_out} = uploading
</msg>
<status status="PASS" endtime="20190402 06:58:23.626" starttime="20190402 06:58:23.626"></status>
</kw>
<msg timestamp="20190402 06:58:23.626" level="INFO">${output} = uploading
</msg>
<status status="PASS" endtime="20190402 06:58:23.626" starttime="20190402 06:58:23.625"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:23.629" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:23.629" starttime="20190402 06:58:23.626"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:23.629" level="INFO">0</msg>
<msg timestamp="20190402 06:58:23.629" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:23.629" starttime="20190402 06:58:23.629"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:23.630" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:23.630" starttime="20190402 06:58:23.630"></status>
</kw>
<msg timestamp="20190402 06:58:23.630" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:23.630" starttime="20190402 06:58:23.626"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:23.631" starttime="20190402 06:58:23.630"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:23.631" starttime="20190402 06:58:23.630"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:23.631" starttime="20190402 06:58:23.631"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:23.631" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: uploading</msg>
<status status="PASS" endtime="20190402 06:58:23.631" starttime="20190402 06:58:23.631"></status>
</kw>
<msg timestamp="20190402 06:58:23.632" level="INFO">&amp;{result} = { stdout=uploading | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:58:23.632" starttime="20190402 06:58:22.475"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:58:23.632" level="INFO">${value} = uploading</msg>
<status status="PASS" endtime="20190402 06:58:23.632" starttime="20190402 06:58:23.632"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:58:23.633" level="FAIL">uploading != uploaded</msg>
<status status="FAIL" endtime="20190402 06:58:23.633" starttime="20190402 06:58:23.632"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:23.633" starttime="20190402 06:58:23.632"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:23.633" starttime="20190402 06:58:22.472"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>uploaded</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:58:28.636" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:28.636" starttime="20190402 06:58:28.635"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:28.639" starttime="20190402 06:58:28.638"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:28.642" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:28.643" starttime="20190402 06:58:28.641"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:28.644" starttime="20190402 06:58:28.643"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:28.645" starttime="20190402 06:58:28.644"></status>
</kw>
<msg timestamp="20190402 06:58:28.646" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:28.646" starttime="20190402 06:58:28.640"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:58:28.647" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:28.647" starttime="20190402 06:58:28.646"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:28.673" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:28.673" starttime="20190402 06:58:28.647"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:29.802" level="INFO">uploading
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:29.802" level="INFO">${output} = uploading
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:29.802" starttime="20190402 06:58:28.674"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:29.803" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:29.803" starttime="20190402 06:58:29.803"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:29.804" level="INFO">${clean_out} = uploading
</msg>
<status status="PASS" endtime="20190402 06:58:29.804" starttime="20190402 06:58:29.803"></status>
</kw>
<msg timestamp="20190402 06:58:29.804" level="INFO">${output} = uploading
</msg>
<status status="PASS" endtime="20190402 06:58:29.804" starttime="20190402 06:58:29.803"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:29.805" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:29.806" starttime="20190402 06:58:29.804"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:29.806" level="INFO">0</msg>
<msg timestamp="20190402 06:58:29.806" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:29.806" starttime="20190402 06:58:29.806"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:29.806" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:29.806" starttime="20190402 06:58:29.806"></status>
</kw>
<msg timestamp="20190402 06:58:29.807" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:29.807" starttime="20190402 06:58:29.804"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:29.808" starttime="20190402 06:58:29.808"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:29.808" starttime="20190402 06:58:29.807"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:29.809" starttime="20190402 06:58:29.808"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:29.809" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: uploading</msg>
<status status="PASS" endtime="20190402 06:58:29.809" starttime="20190402 06:58:29.809"></status>
</kw>
<msg timestamp="20190402 06:58:29.809" level="INFO">&amp;{result} = { stdout=uploading | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:58:29.809" starttime="20190402 06:58:28.637"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:58:29.810" level="INFO">${value} = uploading</msg>
<status status="PASS" endtime="20190402 06:58:29.810" starttime="20190402 06:58:29.809"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:58:29.810" level="FAIL">uploading != uploaded</msg>
<status status="FAIL" endtime="20190402 06:58:29.810" starttime="20190402 06:58:29.810"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:29.810" starttime="20190402 06:58:29.810"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:29.810" starttime="20190402 06:58:28.634"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>uploaded</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:58:34.813" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:34.814" starttime="20190402 06:58:34.813"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:34.816" starttime="20190402 06:58:34.815"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:34.817" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:34.817" starttime="20190402 06:58:34.816"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:34.817" starttime="20190402 06:58:34.817"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:34.817" starttime="20190402 06:58:34.817"></status>
</kw>
<msg timestamp="20190402 06:58:34.818" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:34.818" starttime="20190402 06:58:34.816"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:58:34.818" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:34.818" starttime="20190402 06:58:34.818"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:34.827" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:34.827" starttime="20190402 06:58:34.818"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:35.820" level="INFO">uploaded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:35.821" level="INFO">${output} = uploaded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:35.821" starttime="20190402 06:58:34.827"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:35.821" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:35.821" starttime="20190402 06:58:35.821"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:35.822" level="INFO">${clean_out} = uploaded
</msg>
<status status="PASS" endtime="20190402 06:58:35.822" starttime="20190402 06:58:35.822"></status>
</kw>
<msg timestamp="20190402 06:58:35.822" level="INFO">${output} = uploaded
</msg>
<status status="PASS" endtime="20190402 06:58:35.822" starttime="20190402 06:58:35.821"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:35.824" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:35.824" starttime="20190402 06:58:35.822"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:35.824" level="INFO">0</msg>
<msg timestamp="20190402 06:58:35.824" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:35.824" starttime="20190402 06:58:35.824"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:35.825" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:35.825" starttime="20190402 06:58:35.824"></status>
</kw>
<msg timestamp="20190402 06:58:35.825" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:35.825" starttime="20190402 06:58:35.822"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:35.826" starttime="20190402 06:58:35.825"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:35.826" starttime="20190402 06:58:35.825"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:35.826" starttime="20190402 06:58:35.826"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:35.826" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: uploaded</msg>
<status status="PASS" endtime="20190402 06:58:35.826" starttime="20190402 06:58:35.826"></status>
</kw>
<msg timestamp="20190402 06:58:35.826" level="INFO">&amp;{result} = { stdout=uploaded | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:58:35.826" starttime="20190402 06:58:34.814"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:58:35.827" level="INFO">${value} = uploaded</msg>
<status status="PASS" endtime="20190402 06:58:35.827" starttime="20190402 06:58:35.827"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:35.828" starttime="20190402 06:58:35.827"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:35.828" starttime="20190402 06:58:35.827"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:35.828" starttime="20190402 06:58:34.811"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:35.828" starttime="20190402 06:58:16.383"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:35.828" starttime="20190402 06:58:14.729"></status>
</kw>
<kw name="Bring Up Services" library="Utils">
<doc>Use sysinv to apply the application.</doc>
<arguments>
<arg>stx-openstack</arg>
</arguments>
<kw name="System Application Apply" library="Utils">
<doc>Run the system aplication apply</doc>
<arguments>
<arg>${application}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system application-apply ${application}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:35.829" starttime="20190402 06:58:35.829"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:35.830" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:35.830" starttime="20190402 06:58:35.829"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:35.830" starttime="20190402 06:58:35.830"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:35.830" starttime="20190402 06:58:35.830"></status>
</kw>
<msg timestamp="20190402 06:58:35.831" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:35.831" starttime="20190402 06:58:35.829"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:58:35.831" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:35.831" starttime="20190402 06:58:35.831"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:35.839" level="INFO">system application-apply stx-openstack [A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Kk</msg>
<status status="PASS" endtime="20190402 06:58:35.839" starttime="20190402 06:58:35.831"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:36.836" level="INFO">+---------------+----------------------------------+
| Property      | Value                            |
+---------------+----------------------------------+
| created_at    | 2019-04-02T12:47:00.451151+00:00 |
| manifest_file | manifest.yaml                    |
| manifest_name | armada-manifest                  |
| name          | stx-openstack                    |
| progress      | None                             |
| status        | applying                         |
| updated_at    | 2019-04-02T12:47:17.734713+00:00 |
+---------------+----------------------------------+
Please use 'system application-list' or 'system application-show stx-openstack' to view the current progress.
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:36.836" level="INFO">${output} = +---------------+----------------------------------+
| Property      | Value                            |
+---------------+----------------------------------+
| created_at    | 2019-04-02T12:47:00....</msg>
<status status="PASS" endtime="20190402 06:58:36.836" starttime="20190402 06:58:35.839"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:36.837" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:36.837" starttime="20190402 06:58:36.836"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:36.837" level="INFO">${clean_out} = +---------------+----------------------------------+
| Property      | Value                            |
+---------------+----------------------------------+
| created_at    | 2019-04-02T12:47:00....</msg>
<status status="PASS" endtime="20190402 06:58:36.837" starttime="20190402 06:58:36.837"></status>
</kw>
<msg timestamp="20190402 06:58:36.837" level="INFO">${output} = +---------------+----------------------------------+
| Property      | Value                            |
+---------------+----------------------------------+
| created_at    | 2019-04-02T12:47:00....</msg>
<status status="PASS" endtime="20190402 06:58:36.837" starttime="20190402 06:58:36.836"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:36.839" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:36.839" starttime="20190402 06:58:36.837"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:36.840" level="INFO">0</msg>
<msg timestamp="20190402 06:58:36.840" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:36.840" starttime="20190402 06:58:36.839"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:36.840" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:36.840" starttime="20190402 06:58:36.840"></status>
</kw>
<msg timestamp="20190402 06:58:36.840" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:36.840" starttime="20190402 06:58:36.837"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:36.841" starttime="20190402 06:58:36.841"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:36.841" starttime="20190402 06:58:36.840"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:36.841" starttime="20190402 06:58:36.841"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:36.842" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +---------------+----------------------------------+
| Property      | Value                            |
+---------------+----------------------------------+
| created_at    | 2019-04-02T12:47:00.451151+00:00 |
| manifest_file | manifest.yaml                    |
| manifest_name | armada-manifest                  |
| name          | stx-openstack                    |
| progress      | None                             |
| status        | applying                         |
| updated_at    | 2019-04-02T12:47:17.734713+00:00 |
+---------------+----------------------------------+
Please use 'system application-list' or 'system application-show stx-openstack' to view the current progress.</msg>
<status status="PASS" endtime="20190402 06:58:36.842" starttime="20190402 06:58:36.841"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:36.842" starttime="20190402 06:58:35.829"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>90 min</arg>
<arg>5 sec</arg>
<arg>Check System Application Status</arg>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:58:36.843" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:36.843" starttime="20190402 06:58:36.842"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:36.843" starttime="20190402 06:58:36.843"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:36.844" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:36.844" starttime="20190402 06:58:36.844"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:36.844" starttime="20190402 06:58:36.844"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:36.845" starttime="20190402 06:58:36.845"></status>
</kw>
<msg timestamp="20190402 06:58:36.845" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:36.845" starttime="20190402 06:58:36.844"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:58:36.845" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:36.845" starttime="20190402 06:58:36.845"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:36.847" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:36.847" starttime="20190402 06:58:36.845"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:37.930" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:37.930" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:37.930" starttime="20190402 06:58:36.847"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:37.931" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:37.931" starttime="20190402 06:58:37.931"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:37.931" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:58:37.931" starttime="20190402 06:58:37.931"></status>
</kw>
<msg timestamp="20190402 06:58:37.931" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:58:37.931" starttime="20190402 06:58:37.930"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:37.933" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:37.934" starttime="20190402 06:58:37.932"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:37.934" level="INFO">0</msg>
<msg timestamp="20190402 06:58:37.934" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:37.934" starttime="20190402 06:58:37.934"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:37.934" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:37.934" starttime="20190402 06:58:37.934"></status>
</kw>
<msg timestamp="20190402 06:58:37.934" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:37.934" starttime="20190402 06:58:37.931"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:37.935" starttime="20190402 06:58:37.935"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:37.935" starttime="20190402 06:58:37.935"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:37.936" starttime="20190402 06:58:37.935"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:37.936" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:58:37.936" starttime="20190402 06:58:37.936"></status>
</kw>
<msg timestamp="20190402 06:58:37.936" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:58:37.936" starttime="20190402 06:58:36.843"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:58:37.936" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:58:37.936" starttime="20190402 06:58:37.936"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:58:37.937" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:58:37.937" starttime="20190402 06:58:37.937"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:37.937" starttime="20190402 06:58:37.937"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:37.937" starttime="20190402 06:58:36.842"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:58:42.940" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:42.940" starttime="20190402 06:58:42.939"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:42.944" starttime="20190402 06:58:42.942"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:42.947" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:42.947" starttime="20190402 06:58:42.945"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:42.948" starttime="20190402 06:58:42.947"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:42.949" starttime="20190402 06:58:42.948"></status>
</kw>
<msg timestamp="20190402 06:58:42.950" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:42.950" starttime="20190402 06:58:42.944"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:58:42.951" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:42.951" starttime="20190402 06:58:42.950"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:42.979" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:42.979" starttime="20190402 06:58:42.951"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:45.817" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:45.817" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:45.817" starttime="20190402 06:58:42.979"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:45.818" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:45.818" starttime="20190402 06:58:45.818"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:45.819" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:58:45.819" starttime="20190402 06:58:45.818"></status>
</kw>
<msg timestamp="20190402 06:58:45.819" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:58:45.819" starttime="20190402 06:58:45.818"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:45.821" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:45.821" starttime="20190402 06:58:45.819"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:45.825" level="INFO">0</msg>
<msg timestamp="20190402 06:58:45.825" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:45.825" starttime="20190402 06:58:45.821"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:45.826" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:45.826" starttime="20190402 06:58:45.825"></status>
</kw>
<msg timestamp="20190402 06:58:45.826" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:45.826" starttime="20190402 06:58:45.819"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:45.827" starttime="20190402 06:58:45.826"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:45.827" starttime="20190402 06:58:45.826"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:45.827" starttime="20190402 06:58:45.827"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:45.827" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:58:45.827" starttime="20190402 06:58:45.827"></status>
</kw>
<msg timestamp="20190402 06:58:45.828" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:58:45.828" starttime="20190402 06:58:42.941"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:58:45.828" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:58:45.828" starttime="20190402 06:58:45.828"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:58:45.829" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:58:45.829" starttime="20190402 06:58:45.828"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:45.829" starttime="20190402 06:58:45.828"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:45.829" starttime="20190402 06:58:42.938"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:58:50.830" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:50.830" starttime="20190402 06:58:50.830"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:50.831" starttime="20190402 06:58:50.831"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:50.832" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:50.832" starttime="20190402 06:58:50.831"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:50.832" starttime="20190402 06:58:50.832"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:50.833" starttime="20190402 06:58:50.832"></status>
</kw>
<msg timestamp="20190402 06:58:50.833" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:50.833" starttime="20190402 06:58:50.831"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:58:50.833" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:50.833" starttime="20190402 06:58:50.833"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:50.849" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:50.849" starttime="20190402 06:58:50.833"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:52.423" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:52.424" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:52.424" starttime="20190402 06:58:50.849"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:52.424" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:52.424" starttime="20190402 06:58:52.424"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:52.425" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:58:52.425" starttime="20190402 06:58:52.425"></status>
</kw>
<msg timestamp="20190402 06:58:52.425" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:58:52.425" starttime="20190402 06:58:52.424"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:52.427" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:52.427" starttime="20190402 06:58:52.425"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:52.431" level="INFO">0</msg>
<msg timestamp="20190402 06:58:52.431" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:52.431" starttime="20190402 06:58:52.427"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:52.431" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:52.431" starttime="20190402 06:58:52.431"></status>
</kw>
<msg timestamp="20190402 06:58:52.431" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:52.431" starttime="20190402 06:58:52.425"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:52.432" starttime="20190402 06:58:52.432"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:52.432" starttime="20190402 06:58:52.432"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:52.433" starttime="20190402 06:58:52.432"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:52.433" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:58:52.433" starttime="20190402 06:58:52.433"></status>
</kw>
<msg timestamp="20190402 06:58:52.433" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:58:52.433" starttime="20190402 06:58:50.830"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:58:52.433" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:58:52.434" starttime="20190402 06:58:52.433"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:58:52.434" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:58:52.434" starttime="20190402 06:58:52.434"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:52.434" starttime="20190402 06:58:52.434"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:52.434" starttime="20190402 06:58:50.829"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:58:57.436" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:57.436" starttime="20190402 06:58:57.435"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:57.436" starttime="20190402 06:58:57.436"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:58:57.437" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:58:57.437" starttime="20190402 06:58:57.437"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:57.437" starttime="20190402 06:58:57.437"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:57.438" starttime="20190402 06:58:57.437"></status>
</kw>
<msg timestamp="20190402 06:58:57.438" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:58:57.438" starttime="20190402 06:58:57.436"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:58:57.438" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:57.438" starttime="20190402 06:58:57.438"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:58:57.450" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:58:57.450" starttime="20190402 06:58:57.439"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:58:58.987" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:58:58.987" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:58.987" starttime="20190402 06:58:57.450"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:58:58.988" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:58:58.988" starttime="20190402 06:58:58.987"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:58:58.988" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:58:58.988" starttime="20190402 06:58:58.988"></status>
</kw>
<msg timestamp="20190402 06:58:58.988" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:58:58.988" starttime="20190402 06:58:58.987"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:58:58.990" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:58:58.990" starttime="20190402 06:58:58.989"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:58:58.995" level="INFO">0</msg>
<msg timestamp="20190402 06:58:58.995" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:58.995" starttime="20190402 06:58:58.990"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:58:58.995" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:58:58.996" starttime="20190402 06:58:58.995"></status>
</kw>
<msg timestamp="20190402 06:58:58.996" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:58:58.996" starttime="20190402 06:58:58.988"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:58.997" starttime="20190402 06:58:58.996"></status>
</kw>
<status status="PASS" endtime="20190402 06:58:58.997" starttime="20190402 06:58:58.996"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:58:58.997" starttime="20190402 06:58:58.997"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:58:58.997" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:58:58.997" starttime="20190402 06:58:58.997"></status>
</kw>
<msg timestamp="20190402 06:58:58.998" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:58:58.998" starttime="20190402 06:58:57.436"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:58:58.998" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:58:58.998" starttime="20190402 06:58:58.998"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:58:58.999" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:58:58.999" starttime="20190402 06:58:58.998"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:58.999" starttime="20190402 06:58:58.998"></status>
</kw>
<status status="FAIL" endtime="20190402 06:58:58.999" starttime="20190402 06:58:57.435"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:59:04.000" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:04.000" starttime="20190402 06:59:04.000"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:04.001" starttime="20190402 06:59:04.001"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:59:04.002" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:59:04.002" starttime="20190402 06:59:04.002"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:04.002" starttime="20190402 06:59:04.002"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:04.003" starttime="20190402 06:59:04.003"></status>
</kw>
<msg timestamp="20190402 06:59:04.003" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:59:04.003" starttime="20190402 06:59:04.001"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:59:04.004" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:04.004" starttime="20190402 06:59:04.003"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:59:04.012" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:04.013" starttime="20190402 06:59:04.004"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:59:05.579" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:59:05.579" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:05.579" starttime="20190402 06:59:04.013"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:59:05.580" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:05.580" starttime="20190402 06:59:05.580"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:59:05.580" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:05.580" starttime="20190402 06:59:05.580"></status>
</kw>
<msg timestamp="20190402 06:59:05.580" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:05.580" starttime="20190402 06:59:05.579"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:59:05.582" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:59:05.582" starttime="20190402 06:59:05.581"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:59:05.585" level="INFO">0</msg>
<msg timestamp="20190402 06:59:05.585" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:05.585" starttime="20190402 06:59:05.583"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:59:05.585" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:59:05.585" starttime="20190402 06:59:05.585"></status>
</kw>
<msg timestamp="20190402 06:59:05.586" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:05.586" starttime="20190402 06:59:05.581"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:05.586" starttime="20190402 06:59:05.586"></status>
</kw>
<status status="PASS" endtime="20190402 06:59:05.587" starttime="20190402 06:59:05.586"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:05.587" starttime="20190402 06:59:05.587"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:59:05.587" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:59:05.587" starttime="20190402 06:59:05.587"></status>
</kw>
<msg timestamp="20190402 06:59:05.587" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:59:05.587" starttime="20190402 06:59:04.000"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:59:05.588" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:59:05.588" starttime="20190402 06:59:05.588"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:59:05.588" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:59:05.589" starttime="20190402 06:59:05.588"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:05.589" starttime="20190402 06:59:05.588"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:05.589" starttime="20190402 06:59:03.999"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:59:10.590" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:10.590" starttime="20190402 06:59:10.590"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:10.591" starttime="20190402 06:59:10.591"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:59:10.592" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:59:10.592" starttime="20190402 06:59:10.591"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:10.592" starttime="20190402 06:59:10.592"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:10.593" starttime="20190402 06:59:10.593"></status>
</kw>
<msg timestamp="20190402 06:59:10.593" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:59:10.593" starttime="20190402 06:59:10.591"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:59:10.594" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:10.594" starttime="20190402 06:59:10.594"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:59:10.608" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:10.608" starttime="20190402 06:59:10.594"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:59:12.186" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:59:12.186" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:12.186" starttime="20190402 06:59:10.608"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:59:12.187" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:12.187" starttime="20190402 06:59:12.187"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:59:12.188" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:12.188" starttime="20190402 06:59:12.187"></status>
</kw>
<msg timestamp="20190402 06:59:12.188" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:12.188" starttime="20190402 06:59:12.186"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:59:12.190" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:59:12.190" starttime="20190402 06:59:12.188"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:59:12.196" level="INFO">0</msg>
<msg timestamp="20190402 06:59:12.196" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:12.197" starttime="20190402 06:59:12.190"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:59:12.197" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:59:12.197" starttime="20190402 06:59:12.197"></status>
</kw>
<msg timestamp="20190402 06:59:12.197" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:12.197" starttime="20190402 06:59:12.188"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:12.198" starttime="20190402 06:59:12.198"></status>
</kw>
<status status="PASS" endtime="20190402 06:59:12.198" starttime="20190402 06:59:12.197"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:12.198" starttime="20190402 06:59:12.198"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:59:12.199" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:59:12.199" starttime="20190402 06:59:12.198"></status>
</kw>
<msg timestamp="20190402 06:59:12.199" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:59:12.199" starttime="20190402 06:59:10.590"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:59:12.199" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:59:12.199" starttime="20190402 06:59:12.199"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:59:12.200" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:59:12.200" starttime="20190402 06:59:12.200"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:12.200" starttime="20190402 06:59:12.199"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:12.200" starttime="20190402 06:59:10.589"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:59:17.202" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:17.203" starttime="20190402 06:59:17.202"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:17.204" starttime="20190402 06:59:17.204"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:59:17.206" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:59:17.206" starttime="20190402 06:59:17.205"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:17.207" starttime="20190402 06:59:17.207"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:17.208" starttime="20190402 06:59:17.207"></status>
</kw>
<msg timestamp="20190402 06:59:17.209" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:59:17.209" starttime="20190402 06:59:17.205"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:59:17.210" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:17.210" starttime="20190402 06:59:17.209"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:59:17.234" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:17.234" starttime="20190402 06:59:17.210"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:59:18.440" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:59:18.440" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:18.440" starttime="20190402 06:59:17.234"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:59:18.441" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:18.441" starttime="20190402 06:59:18.440"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:59:18.441" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:18.441" starttime="20190402 06:59:18.441"></status>
</kw>
<msg timestamp="20190402 06:59:18.441" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:18.441" starttime="20190402 06:59:18.440"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:59:18.446" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:59:18.446" starttime="20190402 06:59:18.442"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:59:18.450" level="INFO">0</msg>
<msg timestamp="20190402 06:59:18.450" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:18.450" starttime="20190402 06:59:18.446"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:59:18.451" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:59:18.451" starttime="20190402 06:59:18.451"></status>
</kw>
<msg timestamp="20190402 06:59:18.451" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:18.451" starttime="20190402 06:59:18.441"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:18.452" starttime="20190402 06:59:18.452"></status>
</kw>
<status status="PASS" endtime="20190402 06:59:18.452" starttime="20190402 06:59:18.451"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:18.452" starttime="20190402 06:59:18.452"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:59:18.453" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:59:18.453" starttime="20190402 06:59:18.453"></status>
</kw>
<msg timestamp="20190402 06:59:18.453" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:59:18.453" starttime="20190402 06:59:17.203"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:59:18.453" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:59:18.453" starttime="20190402 06:59:18.453"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:59:18.454" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:59:18.454" starttime="20190402 06:59:18.454"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:18.454" starttime="20190402 06:59:18.453"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:18.454" starttime="20190402 06:59:17.201"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:59:23.457" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:23.458" starttime="20190402 06:59:23.456"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:23.460" starttime="20190402 06:59:23.459"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:59:23.461" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:59:23.461" starttime="20190402 06:59:23.460"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:23.461" starttime="20190402 06:59:23.461"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:23.461" starttime="20190402 06:59:23.461"></status>
</kw>
<msg timestamp="20190402 06:59:23.462" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:59:23.462" starttime="20190402 06:59:23.460"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:59:23.462" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:23.462" starttime="20190402 06:59:23.462"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:59:23.470" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:23.470" starttime="20190402 06:59:23.462"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:59:24.913" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:59:24.914" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:24.914" starttime="20190402 06:59:23.470"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:59:24.914" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:24.914" starttime="20190402 06:59:24.914"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:59:24.915" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:24.915" starttime="20190402 06:59:24.914"></status>
</kw>
<msg timestamp="20190402 06:59:24.915" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:24.915" starttime="20190402 06:59:24.914"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:59:24.916" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:59:24.917" starttime="20190402 06:59:24.915"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:59:24.922" level="INFO">0</msg>
<msg timestamp="20190402 06:59:24.922" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:24.922" starttime="20190402 06:59:24.917"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:59:24.922" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:59:24.922" starttime="20190402 06:59:24.922"></status>
</kw>
<msg timestamp="20190402 06:59:24.923" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:24.923" starttime="20190402 06:59:24.915"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:24.924" starttime="20190402 06:59:24.923"></status>
</kw>
<status status="PASS" endtime="20190402 06:59:24.924" starttime="20190402 06:59:24.923"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:24.924" starttime="20190402 06:59:24.924"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:59:24.924" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:59:24.924" starttime="20190402 06:59:24.924"></status>
</kw>
<msg timestamp="20190402 06:59:24.925" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:59:24.925" starttime="20190402 06:59:23.458"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:59:24.925" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:59:24.925" starttime="20190402 06:59:24.925"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:59:24.926" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:59:24.926" starttime="20190402 06:59:24.925"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:24.926" starttime="20190402 06:59:24.925"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:24.926" starttime="20190402 06:59:23.455"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:59:29.929" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:29.929" starttime="20190402 06:59:29.928"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:29.932" starttime="20190402 06:59:29.931"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:59:29.934" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:59:29.935" starttime="20190402 06:59:29.933"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:29.936" starttime="20190402 06:59:29.935"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:29.937" starttime="20190402 06:59:29.936"></status>
</kw>
<msg timestamp="20190402 06:59:29.938" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:59:29.938" starttime="20190402 06:59:29.932"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:59:29.939" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:29.940" starttime="20190402 06:59:29.939"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:59:29.966" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:29.967" starttime="20190402 06:59:29.940"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:59:31.494" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:59:31.494" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:31.494" starttime="20190402 06:59:29.967"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:59:31.495" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:31.495" starttime="20190402 06:59:31.494"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:59:31.495" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:31.495" starttime="20190402 06:59:31.495"></status>
</kw>
<msg timestamp="20190402 06:59:31.495" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:31.495" starttime="20190402 06:59:31.494"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:59:31.497" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:59:31.497" starttime="20190402 06:59:31.495"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:59:31.500" level="INFO">0</msg>
<msg timestamp="20190402 06:59:31.500" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:31.500" starttime="20190402 06:59:31.497"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:59:31.500" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:59:31.500" starttime="20190402 06:59:31.500"></status>
</kw>
<msg timestamp="20190402 06:59:31.500" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:31.500" starttime="20190402 06:59:31.495"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:31.501" starttime="20190402 06:59:31.501"></status>
</kw>
<status status="PASS" endtime="20190402 06:59:31.501" starttime="20190402 06:59:31.501"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:31.502" starttime="20190402 06:59:31.501"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:59:31.502" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:59:31.502" starttime="20190402 06:59:31.502"></status>
</kw>
<msg timestamp="20190402 06:59:31.502" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:59:31.502" starttime="20190402 06:59:29.929"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:59:31.503" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:59:31.503" starttime="20190402 06:59:31.502"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:59:31.503" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:59:31.504" starttime="20190402 06:59:31.503"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:31.504" starttime="20190402 06:59:31.503"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:31.504" starttime="20190402 06:59:29.927"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:59:36.505" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:36.505" starttime="20190402 06:59:36.505"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:36.506" starttime="20190402 06:59:36.505"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:59:36.506" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:59:36.506" starttime="20190402 06:59:36.506"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:36.507" starttime="20190402 06:59:36.506"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:36.507" starttime="20190402 06:59:36.507"></status>
</kw>
<msg timestamp="20190402 06:59:36.507" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:59:36.507" starttime="20190402 06:59:36.506"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:59:36.507" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:36.507" starttime="20190402 06:59:36.507"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:59:36.516" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:36.517" starttime="20190402 06:59:36.508"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:59:38.132" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:59:38.132" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:38.132" starttime="20190402 06:59:36.517"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:59:38.133" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:38.133" starttime="20190402 06:59:38.132"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:59:38.133" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:38.133" starttime="20190402 06:59:38.133"></status>
</kw>
<msg timestamp="20190402 06:59:38.133" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:38.133" starttime="20190402 06:59:38.132"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:59:38.135" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:59:38.135" starttime="20190402 06:59:38.133"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:59:38.138" level="INFO">0</msg>
<msg timestamp="20190402 06:59:38.138" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:38.138" starttime="20190402 06:59:38.135"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:59:38.138" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:59:38.138" starttime="20190402 06:59:38.138"></status>
</kw>
<msg timestamp="20190402 06:59:38.138" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:38.138" starttime="20190402 06:59:38.133"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:38.139" starttime="20190402 06:59:38.139"></status>
</kw>
<status status="PASS" endtime="20190402 06:59:38.139" starttime="20190402 06:59:38.138"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:38.139" starttime="20190402 06:59:38.139"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:59:38.140" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:59:38.140" starttime="20190402 06:59:38.139"></status>
</kw>
<msg timestamp="20190402 06:59:38.140" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:59:38.140" starttime="20190402 06:59:36.505"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:59:38.140" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:59:38.140" starttime="20190402 06:59:38.140"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:59:38.141" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:59:38.141" starttime="20190402 06:59:38.141"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:38.141" starttime="20190402 06:59:38.140"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:38.141" starttime="20190402 06:59:36.504"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:59:43.144" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:43.144" starttime="20190402 06:59:43.143"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:43.147" starttime="20190402 06:59:43.146"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:59:43.149" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:59:43.149" starttime="20190402 06:59:43.148"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:43.150" starttime="20190402 06:59:43.150"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:43.152" starttime="20190402 06:59:43.151"></status>
</kw>
<msg timestamp="20190402 06:59:43.153" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:59:43.153" starttime="20190402 06:59:43.147"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:59:43.153" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:43.154" starttime="20190402 06:59:43.153"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:59:43.164" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:43.164" starttime="20190402 06:59:43.154"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:59:44.590" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:59:44.590" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:44.590" starttime="20190402 06:59:43.164"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:59:44.591" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:44.591" starttime="20190402 06:59:44.590"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:59:44.591" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:44.591" starttime="20190402 06:59:44.591"></status>
</kw>
<msg timestamp="20190402 06:59:44.591" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:44.591" starttime="20190402 06:59:44.590"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:59:44.593" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:59:44.593" starttime="20190402 06:59:44.591"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:59:44.598" level="INFO">0</msg>
<msg timestamp="20190402 06:59:44.598" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:44.598" starttime="20190402 06:59:44.593"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:59:44.598" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:59:44.598" starttime="20190402 06:59:44.598"></status>
</kw>
<msg timestamp="20190402 06:59:44.598" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:44.599" starttime="20190402 06:59:44.591"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:44.599" starttime="20190402 06:59:44.599"></status>
</kw>
<status status="PASS" endtime="20190402 06:59:44.599" starttime="20190402 06:59:44.599"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:44.600" starttime="20190402 06:59:44.599"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:59:44.600" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:59:44.600" starttime="20190402 06:59:44.600"></status>
</kw>
<msg timestamp="20190402 06:59:44.600" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:59:44.600" starttime="20190402 06:59:43.145"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:59:44.601" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:59:44.601" starttime="20190402 06:59:44.600"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:59:44.601" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:59:44.601" starttime="20190402 06:59:44.601"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:44.601" starttime="20190402 06:59:44.601"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:44.602" starttime="20190402 06:59:43.142"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:59:49.605" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:49.605" starttime="20190402 06:59:49.604"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:49.608" starttime="20190402 06:59:49.607"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:59:49.608" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:59:49.609" starttime="20190402 06:59:49.608"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:49.609" starttime="20190402 06:59:49.609"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:49.609" starttime="20190402 06:59:49.609"></status>
</kw>
<msg timestamp="20190402 06:59:49.609" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:59:49.609" starttime="20190402 06:59:49.608"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:59:49.610" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:49.610" starttime="20190402 06:59:49.610"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:59:49.619" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:49.619" starttime="20190402 06:59:49.610"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:59:51.188" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:59:51.189" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:51.189" starttime="20190402 06:59:49.619"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:59:51.189" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:51.189" starttime="20190402 06:59:51.189"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:59:51.190" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:51.190" starttime="20190402 06:59:51.190"></status>
</kw>
<msg timestamp="20190402 06:59:51.190" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:51.190" starttime="20190402 06:59:51.189"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:59:51.192" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:59:51.192" starttime="20190402 06:59:51.190"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:59:51.195" level="INFO">0</msg>
<msg timestamp="20190402 06:59:51.195" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:51.195" starttime="20190402 06:59:51.192"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:59:51.195" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:59:51.195" starttime="20190402 06:59:51.195"></status>
</kw>
<msg timestamp="20190402 06:59:51.195" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:51.195" starttime="20190402 06:59:51.190"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:51.196" starttime="20190402 06:59:51.196"></status>
</kw>
<status status="PASS" endtime="20190402 06:59:51.196" starttime="20190402 06:59:51.196"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:51.197" starttime="20190402 06:59:51.196"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:59:51.197" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:59:51.197" starttime="20190402 06:59:51.197"></status>
</kw>
<msg timestamp="20190402 06:59:51.197" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:59:51.197" starttime="20190402 06:59:49.606"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:59:51.197" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:59:51.197" starttime="20190402 06:59:51.197"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:59:51.198" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:59:51.198" starttime="20190402 06:59:51.198"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:51.198" starttime="20190402 06:59:51.198"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:51.198" starttime="20190402 06:59:49.603"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 06:59:56.200" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:56.200" starttime="20190402 06:59:56.199"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:56.202" starttime="20190402 06:59:56.201"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 06:59:56.203" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 06:59:56.203" starttime="20190402 06:59:56.202"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:56.203" starttime="20190402 06:59:56.203"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:56.204" starttime="20190402 06:59:56.204"></status>
</kw>
<msg timestamp="20190402 06:59:56.204" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 06:59:56.204" starttime="20190402 06:59:56.202"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 06:59:56.204" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:56.205" starttime="20190402 06:59:56.204"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 06:59:56.217" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 06:59:56.217" starttime="20190402 06:59:56.205"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 06:59:57.654" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 06:59:57.654" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:57.654" starttime="20190402 06:59:56.217"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 06:59:57.655" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 06:59:57.655" starttime="20190402 06:59:57.655"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 06:59:57.655" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:57.655" starttime="20190402 06:59:57.655"></status>
</kw>
<msg timestamp="20190402 06:59:57.656" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 06:59:57.656" starttime="20190402 06:59:57.655"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 06:59:57.658" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 06:59:57.658" starttime="20190402 06:59:57.656"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 06:59:57.661" level="INFO">0</msg>
<msg timestamp="20190402 06:59:57.661" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:57.661" starttime="20190402 06:59:57.658"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 06:59:57.662" level="INFO">0</msg>
<status status="PASS" endtime="20190402 06:59:57.662" starttime="20190402 06:59:57.662"></status>
</kw>
<msg timestamp="20190402 06:59:57.662" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 06:59:57.662" starttime="20190402 06:59:57.656"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:57.663" starttime="20190402 06:59:57.662"></status>
</kw>
<status status="PASS" endtime="20190402 06:59:57.663" starttime="20190402 06:59:57.662"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 06:59:57.663" starttime="20190402 06:59:57.663"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 06:59:57.663" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 06:59:57.663" starttime="20190402 06:59:57.663"></status>
</kw>
<msg timestamp="20190402 06:59:57.664" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 06:59:57.664" starttime="20190402 06:59:56.201"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 06:59:57.664" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 06:59:57.664" starttime="20190402 06:59:57.664"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 06:59:57.665" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 06:59:57.665" starttime="20190402 06:59:57.664"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:57.665" starttime="20190402 06:59:57.664"></status>
</kw>
<status status="FAIL" endtime="20190402 06:59:57.665" starttime="20190402 06:59:56.199"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:00:02.668" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:02.668" starttime="20190402 07:00:02.667"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:02.671" starttime="20190402 07:00:02.670"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:00:02.672" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:00:02.672" starttime="20190402 07:00:02.671"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:02.672" starttime="20190402 07:00:02.672"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:02.672" starttime="20190402 07:00:02.672"></status>
</kw>
<msg timestamp="20190402 07:00:02.673" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:00:02.673" starttime="20190402 07:00:02.671"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:00:02.673" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:02.673" starttime="20190402 07:00:02.673"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:00:02.682" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:02.682" starttime="20190402 07:00:02.673"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:00:03.895" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:00:03.896" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:03.896" starttime="20190402 07:00:02.682"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:00:03.896" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:03.896" starttime="20190402 07:00:03.896"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:00:03.897" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:03.897" starttime="20190402 07:00:03.897"></status>
</kw>
<msg timestamp="20190402 07:00:03.897" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:03.897" starttime="20190402 07:00:03.896"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:00:03.899" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:00:03.899" starttime="20190402 07:00:03.897"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:00:03.906" level="INFO">0</msg>
<msg timestamp="20190402 07:00:03.906" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:03.906" starttime="20190402 07:00:03.899"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:00:03.906" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:00:03.907" starttime="20190402 07:00:03.906"></status>
</kw>
<msg timestamp="20190402 07:00:03.907" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:03.907" starttime="20190402 07:00:03.897"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:03.908" starttime="20190402 07:00:03.907"></status>
</kw>
<status status="PASS" endtime="20190402 07:00:03.908" starttime="20190402 07:00:03.907"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:03.908" starttime="20190402 07:00:03.908"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:00:03.908" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:00:03.908" starttime="20190402 07:00:03.908"></status>
</kw>
<msg timestamp="20190402 07:00:03.908" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:00:03.909" starttime="20190402 07:00:02.669"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:00:03.909" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:00:03.909" starttime="20190402 07:00:03.909"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:00:03.910" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:00:03.910" starttime="20190402 07:00:03.909"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:03.910" starttime="20190402 07:00:03.909"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:03.910" starttime="20190402 07:00:02.666"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:00:08.913" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:08.913" starttime="20190402 07:00:08.912"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:08.916" starttime="20190402 07:00:08.915"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:00:08.917" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:00:08.917" starttime="20190402 07:00:08.916"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:08.917" starttime="20190402 07:00:08.917"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:08.917" starttime="20190402 07:00:08.917"></status>
</kw>
<msg timestamp="20190402 07:00:08.918" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:00:08.918" starttime="20190402 07:00:08.916"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:00:08.918" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:08.918" starttime="20190402 07:00:08.918"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:00:08.927" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:08.927" starttime="20190402 07:00:08.918"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:00:10.393" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:00:10.394" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:10.394" starttime="20190402 07:00:08.927"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:00:10.394" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:10.394" starttime="20190402 07:00:10.394"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:00:10.395" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:10.395" starttime="20190402 07:00:10.395"></status>
</kw>
<msg timestamp="20190402 07:00:10.395" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:10.395" starttime="20190402 07:00:10.394"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:00:10.396" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:00:10.396" starttime="20190402 07:00:10.395"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:00:10.402" level="INFO">0</msg>
<msg timestamp="20190402 07:00:10.402" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:10.402" starttime="20190402 07:00:10.397"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:00:10.402" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:00:10.403" starttime="20190402 07:00:10.402"></status>
</kw>
<msg timestamp="20190402 07:00:10.403" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:10.403" starttime="20190402 07:00:10.395"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:10.404" starttime="20190402 07:00:10.403"></status>
</kw>
<status status="PASS" endtime="20190402 07:00:10.404" starttime="20190402 07:00:10.403"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:10.404" starttime="20190402 07:00:10.404"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:00:10.404" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:00:10.404" starttime="20190402 07:00:10.404"></status>
</kw>
<msg timestamp="20190402 07:00:10.405" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:00:10.405" starttime="20190402 07:00:08.914"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:00:10.405" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:00:10.405" starttime="20190402 07:00:10.405"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:00:10.406" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:00:10.406" starttime="20190402 07:00:10.405"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:10.406" starttime="20190402 07:00:10.405"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:10.406" starttime="20190402 07:00:08.911"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:00:15.409" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:15.409" starttime="20190402 07:00:15.408"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:15.412" starttime="20190402 07:00:15.411"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:00:15.412" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:00:15.413" starttime="20190402 07:00:15.412"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:15.413" starttime="20190402 07:00:15.413"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:15.413" starttime="20190402 07:00:15.413"></status>
</kw>
<msg timestamp="20190402 07:00:15.414" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:00:15.414" starttime="20190402 07:00:15.412"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:00:15.414" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:15.414" starttime="20190402 07:00:15.414"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:00:15.420" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:15.420" starttime="20190402 07:00:15.414"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:00:16.924" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:00:16.924" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:16.924" starttime="20190402 07:00:15.420"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:00:16.925" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:16.925" starttime="20190402 07:00:16.925"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:00:16.925" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:16.925" starttime="20190402 07:00:16.925"></status>
</kw>
<msg timestamp="20190402 07:00:16.925" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:16.926" starttime="20190402 07:00:16.924"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:00:16.927" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:00:16.927" starttime="20190402 07:00:16.926"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:00:16.930" level="INFO">0</msg>
<msg timestamp="20190402 07:00:16.930" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:16.930" starttime="20190402 07:00:16.927"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:00:16.930" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:00:16.931" starttime="20190402 07:00:16.930"></status>
</kw>
<msg timestamp="20190402 07:00:16.931" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:16.931" starttime="20190402 07:00:16.926"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:16.931" starttime="20190402 07:00:16.931"></status>
</kw>
<status status="PASS" endtime="20190402 07:00:16.931" starttime="20190402 07:00:16.931"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:16.932" starttime="20190402 07:00:16.932"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:00:16.932" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:00:16.932" starttime="20190402 07:00:16.932"></status>
</kw>
<msg timestamp="20190402 07:00:16.932" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:00:16.932" starttime="20190402 07:00:15.409"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:00:16.933" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:00:16.933" starttime="20190402 07:00:16.933"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:00:16.933" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:00:16.934" starttime="20190402 07:00:16.933"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:16.934" starttime="20190402 07:00:16.933"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:16.934" starttime="20190402 07:00:15.407"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:00:21.937" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:21.937" starttime="20190402 07:00:21.936"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:21.940" starttime="20190402 07:00:21.939"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:00:21.942" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:00:21.943" starttime="20190402 07:00:21.941"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:21.944" starttime="20190402 07:00:21.943"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:21.945" starttime="20190402 07:00:21.944"></status>
</kw>
<msg timestamp="20190402 07:00:21.946" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:00:21.946" starttime="20190402 07:00:21.940"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:00:21.947" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:21.947" starttime="20190402 07:00:21.946"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:00:21.971" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:21.971" starttime="20190402 07:00:21.947"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:00:23.844" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:00:23.844" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:23.844" starttime="20190402 07:00:21.971"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:00:23.845" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:23.845" starttime="20190402 07:00:23.845"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:00:23.846" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:23.846" starttime="20190402 07:00:23.845"></status>
</kw>
<msg timestamp="20190402 07:00:23.846" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:23.846" starttime="20190402 07:00:23.844"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:00:23.848" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:00:23.848" starttime="20190402 07:00:23.846"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:00:23.852" level="INFO">0</msg>
<msg timestamp="20190402 07:00:23.852" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:23.853" starttime="20190402 07:00:23.848"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:00:23.853" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:00:23.853" starttime="20190402 07:00:23.853"></status>
</kw>
<msg timestamp="20190402 07:00:23.853" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:23.853" starttime="20190402 07:00:23.846"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:23.854" starttime="20190402 07:00:23.853"></status>
</kw>
<status status="PASS" endtime="20190402 07:00:23.854" starttime="20190402 07:00:23.853"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:23.854" starttime="20190402 07:00:23.854"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:00:23.854" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:00:23.854" starttime="20190402 07:00:23.854"></status>
</kw>
<msg timestamp="20190402 07:00:23.855" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:00:23.855" starttime="20190402 07:00:21.937"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:00:23.855" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:00:23.855" starttime="20190402 07:00:23.855"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:00:23.856" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:00:23.856" starttime="20190402 07:00:23.855"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:23.856" starttime="20190402 07:00:23.855"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:23.856" starttime="20190402 07:00:21.934"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:00:28.859" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:28.859" starttime="20190402 07:00:28.858"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:28.862" starttime="20190402 07:00:28.861"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:00:28.862" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:00:28.863" starttime="20190402 07:00:28.862"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:28.863" starttime="20190402 07:00:28.863"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:28.863" starttime="20190402 07:00:28.863"></status>
</kw>
<msg timestamp="20190402 07:00:28.863" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:00:28.863" starttime="20190402 07:00:28.862"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:00:28.864" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:28.864" starttime="20190402 07:00:28.864"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:00:28.872" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:28.872" starttime="20190402 07:00:28.864"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:00:30.468" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:00:30.468" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:30.468" starttime="20190402 07:00:28.872"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:00:30.469" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:30.469" starttime="20190402 07:00:30.469"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:00:30.469" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:30.469" starttime="20190402 07:00:30.469"></status>
</kw>
<msg timestamp="20190402 07:00:30.469" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:30.470" starttime="20190402 07:00:30.468"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:00:30.471" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:00:30.471" starttime="20190402 07:00:30.470"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:00:30.472" level="INFO">0</msg>
<msg timestamp="20190402 07:00:30.472" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:30.472" starttime="20190402 07:00:30.472"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:00:30.472" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:00:30.472" starttime="20190402 07:00:30.472"></status>
</kw>
<msg timestamp="20190402 07:00:30.472" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:30.472" starttime="20190402 07:00:30.470"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:30.473" starttime="20190402 07:00:30.473"></status>
</kw>
<status status="PASS" endtime="20190402 07:00:30.473" starttime="20190402 07:00:30.472"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:30.473" starttime="20190402 07:00:30.473"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:00:30.474" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:00:30.474" starttime="20190402 07:00:30.474"></status>
</kw>
<msg timestamp="20190402 07:00:30.474" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:00:30.474" starttime="20190402 07:00:28.860"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:00:30.474" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:00:30.474" starttime="20190402 07:00:30.474"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:00:30.475" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:00:30.475" starttime="20190402 07:00:30.475"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:30.475" starttime="20190402 07:00:30.475"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:30.475" starttime="20190402 07:00:28.857"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:00:35.478" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:35.478" starttime="20190402 07:00:35.477"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:35.480" starttime="20190402 07:00:35.479"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:00:35.482" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:00:35.483" starttime="20190402 07:00:35.481"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:35.484" starttime="20190402 07:00:35.483"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:35.485" starttime="20190402 07:00:35.484"></status>
</kw>
<msg timestamp="20190402 07:00:35.486" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:00:35.486" starttime="20190402 07:00:35.481"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:00:35.486" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:35.487" starttime="20190402 07:00:35.486"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:00:35.510" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:35.510" starttime="20190402 07:00:35.487"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:00:37.145" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:00:37.145" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:37.145" starttime="20190402 07:00:35.511"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:00:37.146" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:37.146" starttime="20190402 07:00:37.145"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:00:37.146" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:37.146" starttime="20190402 07:00:37.146"></status>
</kw>
<msg timestamp="20190402 07:00:37.146" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:37.146" starttime="20190402 07:00:37.145"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:00:37.148" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:00:37.148" starttime="20190402 07:00:37.147"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:00:37.156" level="INFO">0</msg>
<msg timestamp="20190402 07:00:37.156" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:37.156" starttime="20190402 07:00:37.149"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:00:37.156" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:00:37.156" starttime="20190402 07:00:37.156"></status>
</kw>
<msg timestamp="20190402 07:00:37.157" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:37.157" starttime="20190402 07:00:37.146"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:37.158" starttime="20190402 07:00:37.157"></status>
</kw>
<status status="PASS" endtime="20190402 07:00:37.158" starttime="20190402 07:00:37.157"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:37.158" starttime="20190402 07:00:37.158"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:00:37.158" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:00:37.158" starttime="20190402 07:00:37.158"></status>
</kw>
<msg timestamp="20190402 07:00:37.158" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:00:37.158" starttime="20190402 07:00:35.478"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:00:37.159" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:00:37.159" starttime="20190402 07:00:37.159"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:00:37.160" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:00:37.160" starttime="20190402 07:00:37.159"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:37.160" starttime="20190402 07:00:37.159"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:37.160" starttime="20190402 07:00:35.476"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:00:42.163" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:42.163" starttime="20190402 07:00:42.162"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:42.166" starttime="20190402 07:00:42.165"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:00:42.166" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:00:42.167" starttime="20190402 07:00:42.166"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:42.167" starttime="20190402 07:00:42.167"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:42.167" starttime="20190402 07:00:42.167"></status>
</kw>
<msg timestamp="20190402 07:00:42.167" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:00:42.167" starttime="20190402 07:00:42.166"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:00:42.168" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:42.168" starttime="20190402 07:00:42.168"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:00:42.177" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:42.177" starttime="20190402 07:00:42.168"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:00:43.872" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:00:43.872" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:43.872" starttime="20190402 07:00:42.178"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:00:43.873" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:43.873" starttime="20190402 07:00:43.873"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:00:43.874" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:43.874" starttime="20190402 07:00:43.873"></status>
</kw>
<msg timestamp="20190402 07:00:43.874" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:43.874" starttime="20190402 07:00:43.873"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:00:43.875" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:00:43.875" starttime="20190402 07:00:43.874"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:00:43.883" level="INFO">0</msg>
<msg timestamp="20190402 07:00:43.883" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:43.883" starttime="20190402 07:00:43.876"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:00:43.883" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:00:43.883" starttime="20190402 07:00:43.883"></status>
</kw>
<msg timestamp="20190402 07:00:43.883" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:43.883" starttime="20190402 07:00:43.874"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:43.884" starttime="20190402 07:00:43.884"></status>
</kw>
<status status="PASS" endtime="20190402 07:00:43.884" starttime="20190402 07:00:43.884"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:43.885" starttime="20190402 07:00:43.884"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:00:43.885" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:00:43.885" starttime="20190402 07:00:43.885"></status>
</kw>
<msg timestamp="20190402 07:00:43.885" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:00:43.885" starttime="20190402 07:00:42.164"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:00:43.886" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:00:43.886" starttime="20190402 07:00:43.885"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:00:43.886" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:00:43.886" starttime="20190402 07:00:43.886"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:43.886" starttime="20190402 07:00:43.886"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:43.887" starttime="20190402 07:00:42.160"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:00:48.888" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:48.888" starttime="20190402 07:00:48.887"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:48.888" starttime="20190402 07:00:48.888"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:00:48.889" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:00:48.889" starttime="20190402 07:00:48.889"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:48.889" starttime="20190402 07:00:48.889"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:48.890" starttime="20190402 07:00:48.890"></status>
</kw>
<msg timestamp="20190402 07:00:48.890" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:00:48.890" starttime="20190402 07:00:48.888"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:00:48.890" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:48.890" starttime="20190402 07:00:48.890"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:00:48.899" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:48.899" starttime="20190402 07:00:48.890"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:00:50.671" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:00:50.671" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:50.672" starttime="20190402 07:00:48.899"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:00:50.672" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:50.672" starttime="20190402 07:00:50.672"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:00:50.673" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:50.673" starttime="20190402 07:00:50.672"></status>
</kw>
<msg timestamp="20190402 07:00:50.673" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:50.673" starttime="20190402 07:00:50.672"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:00:50.675" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:00:50.675" starttime="20190402 07:00:50.673"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:00:50.680" level="INFO">0</msg>
<msg timestamp="20190402 07:00:50.680" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:50.680" starttime="20190402 07:00:50.675"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:00:50.681" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:00:50.681" starttime="20190402 07:00:50.680"></status>
</kw>
<msg timestamp="20190402 07:00:50.681" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:50.681" starttime="20190402 07:00:50.673"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:50.682" starttime="20190402 07:00:50.681"></status>
</kw>
<status status="PASS" endtime="20190402 07:00:50.682" starttime="20190402 07:00:50.681"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:50.682" starttime="20190402 07:00:50.682"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:00:50.682" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:00:50.682" starttime="20190402 07:00:50.682"></status>
</kw>
<msg timestamp="20190402 07:00:50.683" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:00:50.683" starttime="20190402 07:00:48.888"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:00:50.683" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:00:50.683" starttime="20190402 07:00:50.683"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:00:50.684" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:00:50.684" starttime="20190402 07:00:50.684"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:50.684" starttime="20190402 07:00:50.683"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:50.684" starttime="20190402 07:00:48.887"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:00:55.685" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:55.685" starttime="20190402 07:00:55.685"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:55.686" starttime="20190402 07:00:55.686"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:00:55.687" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:00:55.687" starttime="20190402 07:00:55.686"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:55.687" starttime="20190402 07:00:55.687"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:55.687" starttime="20190402 07:00:55.687"></status>
</kw>
<msg timestamp="20190402 07:00:55.687" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:00:55.688" starttime="20190402 07:00:55.686"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:00:55.688" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:55.688" starttime="20190402 07:00:55.688"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:00:55.697" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:00:55.697" starttime="20190402 07:00:55.688"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:00:57.507" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:00:57.507" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:57.507" starttime="20190402 07:00:55.697"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:00:57.508" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:00:57.508" starttime="20190402 07:00:57.508"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:00:57.508" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:57.508" starttime="20190402 07:00:57.508"></status>
</kw>
<msg timestamp="20190402 07:00:57.508" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:00:57.508" starttime="20190402 07:00:57.507"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:00:57.512" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:00:57.512" starttime="20190402 07:00:57.509"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:00:57.518" level="INFO">0</msg>
<msg timestamp="20190402 07:00:57.518" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:57.518" starttime="20190402 07:00:57.512"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:00:57.518" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:00:57.518" starttime="20190402 07:00:57.518"></status>
</kw>
<msg timestamp="20190402 07:00:57.518" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:00:57.518" starttime="20190402 07:00:57.509"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:57.519" starttime="20190402 07:00:57.519"></status>
</kw>
<status status="PASS" endtime="20190402 07:00:57.519" starttime="20190402 07:00:57.519"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:00:57.520" starttime="20190402 07:00:57.519"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:00:57.520" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:00:57.520" starttime="20190402 07:00:57.520"></status>
</kw>
<msg timestamp="20190402 07:00:57.520" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:00:57.520" starttime="20190402 07:00:55.685"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:00:57.521" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:00:57.521" starttime="20190402 07:00:57.520"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:00:57.522" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:00:57.522" starttime="20190402 07:00:57.521"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:57.522" starttime="20190402 07:00:57.521"></status>
</kw>
<status status="FAIL" endtime="20190402 07:00:57.522" starttime="20190402 07:00:55.684"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:01:02.523" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:02.523" starttime="20190402 07:01:02.523"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:02.524" starttime="20190402 07:01:02.523"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:01:02.524" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:01:02.524" starttime="20190402 07:01:02.524"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:02.525" starttime="20190402 07:01:02.524"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:02.525" starttime="20190402 07:01:02.525"></status>
</kw>
<msg timestamp="20190402 07:01:02.525" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:01:02.525" starttime="20190402 07:01:02.524"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:01:02.525" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:02.526" starttime="20190402 07:01:02.525"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:01:02.534" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:02.534" starttime="20190402 07:01:02.526"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:01:04.112" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:01:04.112" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:04.112" starttime="20190402 07:01:02.534"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:01:04.113" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:04.113" starttime="20190402 07:01:04.113"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:01:04.113" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:04.114" starttime="20190402 07:01:04.113"></status>
</kw>
<msg timestamp="20190402 07:01:04.114" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:04.114" starttime="20190402 07:01:04.112"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:01:04.116" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:01:04.116" starttime="20190402 07:01:04.114"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:01:04.122" level="INFO">0</msg>
<msg timestamp="20190402 07:01:04.123" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:04.123" starttime="20190402 07:01:04.116"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:01:04.123" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:01:04.123" starttime="20190402 07:01:04.123"></status>
</kw>
<msg timestamp="20190402 07:01:04.123" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:04.123" starttime="20190402 07:01:04.114"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:04.124" starttime="20190402 07:01:04.124"></status>
</kw>
<status status="PASS" endtime="20190402 07:01:04.124" starttime="20190402 07:01:04.123"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:04.124" starttime="20190402 07:01:04.124"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:01:04.125" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:01:04.125" starttime="20190402 07:01:04.125"></status>
</kw>
<msg timestamp="20190402 07:01:04.125" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:01:04.125" starttime="20190402 07:01:02.523"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:01:04.125" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:01:04.125" starttime="20190402 07:01:04.125"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:01:04.126" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:01:04.126" starttime="20190402 07:01:04.126"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:04.126" starttime="20190402 07:01:04.126"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:04.127" starttime="20190402 07:01:02.522"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:01:09.128" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:09.128" starttime="20190402 07:01:09.127"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:09.128" starttime="20190402 07:01:09.128"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:01:09.129" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:01:09.129" starttime="20190402 07:01:09.129"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:09.130" starttime="20190402 07:01:09.129"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:09.130" starttime="20190402 07:01:09.130"></status>
</kw>
<msg timestamp="20190402 07:01:09.130" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:01:09.130" starttime="20190402 07:01:09.129"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:01:09.130" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:09.130" starttime="20190402 07:01:09.130"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:01:09.139" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:09.139" starttime="20190402 07:01:09.130"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:01:10.935" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:01:10.935" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:10.935" starttime="20190402 07:01:09.140"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:01:10.936" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:10.936" starttime="20190402 07:01:10.936"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:01:10.936" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:10.936" starttime="20190402 07:01:10.936"></status>
</kw>
<msg timestamp="20190402 07:01:10.936" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:10.936" starttime="20190402 07:01:10.935"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:01:10.938" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:01:10.938" starttime="20190402 07:01:10.937"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:01:10.946" level="INFO">0</msg>
<msg timestamp="20190402 07:01:10.946" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:10.946" starttime="20190402 07:01:10.938"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:01:10.947" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:01:10.947" starttime="20190402 07:01:10.947"></status>
</kw>
<msg timestamp="20190402 07:01:10.947" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:10.947" starttime="20190402 07:01:10.937"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:10.948" starttime="20190402 07:01:10.948"></status>
</kw>
<status status="PASS" endtime="20190402 07:01:10.948" starttime="20190402 07:01:10.947"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:10.948" starttime="20190402 07:01:10.948"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:01:10.948" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:01:10.949" starttime="20190402 07:01:10.948"></status>
</kw>
<msg timestamp="20190402 07:01:10.949" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:01:10.949" starttime="20190402 07:01:09.128"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:01:10.949" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:01:10.949" starttime="20190402 07:01:10.949"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:01:10.950" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:01:10.950" starttime="20190402 07:01:10.950"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:10.950" starttime="20190402 07:01:10.949"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:10.951" starttime="20190402 07:01:09.127"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:01:15.952" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:15.952" starttime="20190402 07:01:15.951"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:15.952" starttime="20190402 07:01:15.952"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:01:15.953" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:01:15.953" starttime="20190402 07:01:15.953"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:15.953" starttime="20190402 07:01:15.953"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:15.954" starttime="20190402 07:01:15.954"></status>
</kw>
<msg timestamp="20190402 07:01:15.954" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:01:15.954" starttime="20190402 07:01:15.952"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:01:15.954" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:15.954" starttime="20190402 07:01:15.954"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:01:15.962" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:15.962" starttime="20190402 07:01:15.955"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:01:17.726" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:01:17.726" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:17.726" starttime="20190402 07:01:15.962"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:01:17.727" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:17.727" starttime="20190402 07:01:17.726"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:01:17.727" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:17.727" starttime="20190402 07:01:17.727"></status>
</kw>
<msg timestamp="20190402 07:01:17.727" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:17.727" starttime="20190402 07:01:17.726"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:01:17.730" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:01:17.730" starttime="20190402 07:01:17.728"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:01:17.736" level="INFO">0</msg>
<msg timestamp="20190402 07:01:17.736" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:17.736" starttime="20190402 07:01:17.730"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:01:17.737" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:01:17.737" starttime="20190402 07:01:17.736"></status>
</kw>
<msg timestamp="20190402 07:01:17.737" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:17.737" starttime="20190402 07:01:17.727"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:17.738" starttime="20190402 07:01:17.737"></status>
</kw>
<status status="PASS" endtime="20190402 07:01:17.738" starttime="20190402 07:01:17.737"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:17.738" starttime="20190402 07:01:17.738"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:01:17.738" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:01:17.738" starttime="20190402 07:01:17.738"></status>
</kw>
<msg timestamp="20190402 07:01:17.739" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:01:17.739" starttime="20190402 07:01:15.952"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:01:17.739" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:01:17.739" starttime="20190402 07:01:17.739"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:01:17.740" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:01:17.740" starttime="20190402 07:01:17.739"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:17.740" starttime="20190402 07:01:17.739"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:17.740" starttime="20190402 07:01:15.951"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:01:22.741" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:22.741" starttime="20190402 07:01:22.741"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:22.742" starttime="20190402 07:01:22.742"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:01:22.743" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:01:22.743" starttime="20190402 07:01:22.742"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:22.743" starttime="20190402 07:01:22.743"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:22.743" starttime="20190402 07:01:22.743"></status>
</kw>
<msg timestamp="20190402 07:01:22.744" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:01:22.744" starttime="20190402 07:01:22.742"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:01:22.744" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:22.744" starttime="20190402 07:01:22.744"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:01:22.754" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:22.755" starttime="20190402 07:01:22.744"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:01:24.775" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:01:24.776" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:24.776" starttime="20190402 07:01:22.755"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:01:24.776" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:24.776" starttime="20190402 07:01:24.776"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:01:24.777" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:24.777" starttime="20190402 07:01:24.776"></status>
</kw>
<msg timestamp="20190402 07:01:24.777" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:24.777" starttime="20190402 07:01:24.776"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:01:24.779" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:01:24.779" starttime="20190402 07:01:24.777"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:01:24.785" level="INFO">0</msg>
<msg timestamp="20190402 07:01:24.785" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:24.785" starttime="20190402 07:01:24.779"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:01:24.785" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:01:24.785" starttime="20190402 07:01:24.785"></status>
</kw>
<msg timestamp="20190402 07:01:24.785" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:24.786" starttime="20190402 07:01:24.777"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:24.786" starttime="20190402 07:01:24.786"></status>
</kw>
<status status="PASS" endtime="20190402 07:01:24.786" starttime="20190402 07:01:24.786"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:24.787" starttime="20190402 07:01:24.786"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:01:24.787" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:01:24.787" starttime="20190402 07:01:24.787"></status>
</kw>
<msg timestamp="20190402 07:01:24.787" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:01:24.787" starttime="20190402 07:01:22.741"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:01:24.788" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:01:24.788" starttime="20190402 07:01:24.787"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:01:24.788" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:01:24.788" starttime="20190402 07:01:24.788"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:24.788" starttime="20190402 07:01:24.788"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:24.789" starttime="20190402 07:01:22.740"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:01:29.791" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:29.791" starttime="20190402 07:01:29.790"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:29.794" starttime="20190402 07:01:29.793"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:01:29.795" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:01:29.795" starttime="20190402 07:01:29.794"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:29.795" starttime="20190402 07:01:29.795"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:29.795" starttime="20190402 07:01:29.795"></status>
</kw>
<msg timestamp="20190402 07:01:29.796" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:01:29.796" starttime="20190402 07:01:29.794"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:01:29.796" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:29.796" starttime="20190402 07:01:29.796"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:01:29.805" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:29.806" starttime="20190402 07:01:29.796"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:01:31.651" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:01:31.652" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:31.652" starttime="20190402 07:01:29.806"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:01:31.652" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:31.652" starttime="20190402 07:01:31.652"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:01:31.653" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:31.653" starttime="20190402 07:01:31.653"></status>
</kw>
<msg timestamp="20190402 07:01:31.653" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:31.653" starttime="20190402 07:01:31.652"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:01:31.655" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:01:31.655" starttime="20190402 07:01:31.653"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:01:31.663" level="INFO">0</msg>
<msg timestamp="20190402 07:01:31.664" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:31.664" starttime="20190402 07:01:31.655"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:01:31.664" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:01:31.664" starttime="20190402 07:01:31.664"></status>
</kw>
<msg timestamp="20190402 07:01:31.664" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:31.664" starttime="20190402 07:01:31.653"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:31.665" starttime="20190402 07:01:31.665"></status>
</kw>
<status status="PASS" endtime="20190402 07:01:31.665" starttime="20190402 07:01:31.664"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:31.665" starttime="20190402 07:01:31.665"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:01:31.666" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:01:31.666" starttime="20190402 07:01:31.665"></status>
</kw>
<msg timestamp="20190402 07:01:31.666" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:01:31.666" starttime="20190402 07:01:29.792"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:01:31.666" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:01:31.666" starttime="20190402 07:01:31.666"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:01:31.667" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:01:31.667" starttime="20190402 07:01:31.667"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:31.667" starttime="20190402 07:01:31.666"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:31.667" starttime="20190402 07:01:29.789"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:01:36.670" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:36.670" starttime="20190402 07:01:36.669"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:36.672" starttime="20190402 07:01:36.672"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:01:36.675" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:01:36.675" starttime="20190402 07:01:36.673"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:36.676" starttime="20190402 07:01:36.675"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:36.677" starttime="20190402 07:01:36.676"></status>
</kw>
<msg timestamp="20190402 07:01:36.678" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:01:36.678" starttime="20190402 07:01:36.673"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:01:36.678" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:36.678" starttime="20190402 07:01:36.678"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:01:36.692" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:36.693" starttime="20190402 07:01:36.679"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:01:38.354" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:01:38.354" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:38.354" starttime="20190402 07:01:36.693"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:01:38.355" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:38.355" starttime="20190402 07:01:38.355"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:01:38.355" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:38.355" starttime="20190402 07:01:38.355"></status>
</kw>
<msg timestamp="20190402 07:01:38.355" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:38.355" starttime="20190402 07:01:38.354"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:01:38.358" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:01:38.358" starttime="20190402 07:01:38.356"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:01:38.362" level="INFO">0</msg>
<msg timestamp="20190402 07:01:38.362" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:38.362" starttime="20190402 07:01:38.358"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:01:38.362" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:01:38.362" starttime="20190402 07:01:38.362"></status>
</kw>
<msg timestamp="20190402 07:01:38.362" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:38.362" starttime="20190402 07:01:38.355"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:38.363" starttime="20190402 07:01:38.363"></status>
</kw>
<status status="PASS" endtime="20190402 07:01:38.363" starttime="20190402 07:01:38.363"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:38.364" starttime="20190402 07:01:38.364"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:01:38.364" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:01:38.364" starttime="20190402 07:01:38.364"></status>
</kw>
<msg timestamp="20190402 07:01:38.364" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:01:38.364" starttime="20190402 07:01:36.670"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:01:38.365" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:01:38.365" starttime="20190402 07:01:38.364"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:01:38.365" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:01:38.365" starttime="20190402 07:01:38.365"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:38.365" starttime="20190402 07:01:38.365"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:38.366" starttime="20190402 07:01:36.668"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:01:43.369" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:43.369" starttime="20190402 07:01:43.368"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:43.371" starttime="20190402 07:01:43.371"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:01:43.374" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:01:43.374" starttime="20190402 07:01:43.373"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:43.375" starttime="20190402 07:01:43.374"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:43.377" starttime="20190402 07:01:43.376"></status>
</kw>
<msg timestamp="20190402 07:01:43.378" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:01:43.378" starttime="20190402 07:01:43.372"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:01:43.379" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:43.379" starttime="20190402 07:01:43.379"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:01:43.406" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:43.406" starttime="20190402 07:01:43.380"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:01:45.175" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:01:45.175" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:45.175" starttime="20190402 07:01:43.406"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:01:45.176" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:45.176" starttime="20190402 07:01:45.176"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:01:45.176" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:45.176" starttime="20190402 07:01:45.176"></status>
</kw>
<msg timestamp="20190402 07:01:45.176" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:45.176" starttime="20190402 07:01:45.175"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:01:45.179" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:01:45.179" starttime="20190402 07:01:45.177"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:01:45.187" level="INFO">0</msg>
<msg timestamp="20190402 07:01:45.187" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:45.187" starttime="20190402 07:01:45.179"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:01:45.187" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:01:45.187" starttime="20190402 07:01:45.187"></status>
</kw>
<msg timestamp="20190402 07:01:45.187" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:45.187" starttime="20190402 07:01:45.176"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:45.188" starttime="20190402 07:01:45.188"></status>
</kw>
<status status="PASS" endtime="20190402 07:01:45.188" starttime="20190402 07:01:45.187"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:45.188" starttime="20190402 07:01:45.188"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:01:45.189" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:01:45.189" starttime="20190402 07:01:45.189"></status>
</kw>
<msg timestamp="20190402 07:01:45.189" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:01:45.189" starttime="20190402 07:01:43.369"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:01:45.189" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:01:45.189" starttime="20190402 07:01:45.189"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:01:45.190" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:01:45.190" starttime="20190402 07:01:45.190"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:45.190" starttime="20190402 07:01:45.190"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:45.190" starttime="20190402 07:01:43.366"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:01:50.194" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:50.194" starttime="20190402 07:01:50.193"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:50.196" starttime="20190402 07:01:50.196"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:01:50.197" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:01:50.197" starttime="20190402 07:01:50.196"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:50.197" starttime="20190402 07:01:50.197"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:50.198" starttime="20190402 07:01:50.198"></status>
</kw>
<msg timestamp="20190402 07:01:50.198" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:01:50.198" starttime="20190402 07:01:50.196"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:01:50.198" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:50.198" starttime="20190402 07:01:50.198"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:01:50.208" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:50.208" starttime="20190402 07:01:50.199"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:01:51.946" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:01:51.946" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:51.946" starttime="20190402 07:01:50.208"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:01:51.947" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:51.947" starttime="20190402 07:01:51.947"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:01:51.948" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:51.948" starttime="20190402 07:01:51.947"></status>
</kw>
<msg timestamp="20190402 07:01:51.948" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:51.948" starttime="20190402 07:01:51.946"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:01:51.950" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:01:51.950" starttime="20190402 07:01:51.948"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:01:51.958" level="INFO">0</msg>
<msg timestamp="20190402 07:01:51.959" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:51.959" starttime="20190402 07:01:51.950"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:01:51.959" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:01:51.959" starttime="20190402 07:01:51.959"></status>
</kw>
<msg timestamp="20190402 07:01:51.959" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:51.959" starttime="20190402 07:01:51.948"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:51.960" starttime="20190402 07:01:51.960"></status>
</kw>
<status status="PASS" endtime="20190402 07:01:51.960" starttime="20190402 07:01:51.959"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:51.960" starttime="20190402 07:01:51.960"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:01:51.961" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:01:51.961" starttime="20190402 07:01:51.961"></status>
</kw>
<msg timestamp="20190402 07:01:51.961" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:01:51.961" starttime="20190402 07:01:50.194"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:01:51.961" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:01:51.961" starttime="20190402 07:01:51.961"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:01:51.962" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:01:51.962" starttime="20190402 07:01:51.962"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:51.962" starttime="20190402 07:01:51.961"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:51.962" starttime="20190402 07:01:50.191"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:01:56.965" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:56.965" starttime="20190402 07:01:56.964"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:56.968" starttime="20190402 07:01:56.967"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:01:56.971" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:01:56.971" starttime="20190402 07:01:56.969"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:56.972" starttime="20190402 07:01:56.971"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:56.973" starttime="20190402 07:01:56.973"></status>
</kw>
<msg timestamp="20190402 07:01:56.974" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:01:56.974" starttime="20190402 07:01:56.969"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:01:56.975" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:56.975" starttime="20190402 07:01:56.975"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:01:57.001" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:01:57.001" starttime="20190402 07:01:56.976"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:01:58.894" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:01:58.894" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:58.894" starttime="20190402 07:01:57.001"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:01:58.895" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:01:58.895" starttime="20190402 07:01:58.895"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:01:58.896" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:58.896" starttime="20190402 07:01:58.895"></status>
</kw>
<msg timestamp="20190402 07:01:58.896" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:01:58.896" starttime="20190402 07:01:58.895"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:01:58.898" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:01:58.898" starttime="20190402 07:01:58.896"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:01:58.904" level="INFO">0</msg>
<msg timestamp="20190402 07:01:58.904" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:58.904" starttime="20190402 07:01:58.898"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:01:58.904" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:01:58.904" starttime="20190402 07:01:58.904"></status>
</kw>
<msg timestamp="20190402 07:01:58.904" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:01:58.904" starttime="20190402 07:01:58.896"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:58.905" starttime="20190402 07:01:58.905"></status>
</kw>
<status status="PASS" endtime="20190402 07:01:58.905" starttime="20190402 07:01:58.904"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:01:58.905" starttime="20190402 07:01:58.905"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:01:58.906" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:01:58.906" starttime="20190402 07:01:58.906"></status>
</kw>
<msg timestamp="20190402 07:01:58.906" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:01:58.906" starttime="20190402 07:01:56.966"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:01:58.906" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:01:58.906" starttime="20190402 07:01:58.906"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:01:58.907" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:01:58.907" starttime="20190402 07:01:58.907"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:58.907" starttime="20190402 07:01:58.906"></status>
</kw>
<status status="FAIL" endtime="20190402 07:01:58.907" starttime="20190402 07:01:56.963"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:02:03.908" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:03.908" starttime="20190402 07:02:03.908"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:03.909" starttime="20190402 07:02:03.909"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:02:03.910" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:02:03.910" starttime="20190402 07:02:03.909"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:03.910" starttime="20190402 07:02:03.910"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:03.910" starttime="20190402 07:02:03.910"></status>
</kw>
<msg timestamp="20190402 07:02:03.911" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:02:03.911" starttime="20190402 07:02:03.909"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:02:03.911" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:03.911" starttime="20190402 07:02:03.911"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:02:03.914" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:03.914" starttime="20190402 07:02:03.911"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:02:05.616" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:02:05.616" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:05.616" starttime="20190402 07:02:03.915"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:02:05.617" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:05.617" starttime="20190402 07:02:05.617"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:02:05.617" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:05.617" starttime="20190402 07:02:05.617"></status>
</kw>
<msg timestamp="20190402 07:02:05.617" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:05.617" starttime="20190402 07:02:05.616"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:02:05.638" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:02:05.639" starttime="20190402 07:02:05.618"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:02:05.645" level="INFO">0</msg>
<msg timestamp="20190402 07:02:05.645" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:05.645" starttime="20190402 07:02:05.639"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:02:05.645" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:02:05.646" starttime="20190402 07:02:05.645"></status>
</kw>
<msg timestamp="20190402 07:02:05.646" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:05.646" starttime="20190402 07:02:05.617"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:05.646" starttime="20190402 07:02:05.646"></status>
</kw>
<status status="PASS" endtime="20190402 07:02:05.647" starttime="20190402 07:02:05.646"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:05.647" starttime="20190402 07:02:05.647"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:02:05.647" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:02:05.647" starttime="20190402 07:02:05.647"></status>
</kw>
<msg timestamp="20190402 07:02:05.647" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:02:05.647" starttime="20190402 07:02:03.908"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:02:05.648" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:02:05.648" starttime="20190402 07:02:05.648"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:02:05.649" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:02:05.649" starttime="20190402 07:02:05.648"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:05.649" starttime="20190402 07:02:05.648"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:05.649" starttime="20190402 07:02:03.908"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:02:10.652" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:10.652" starttime="20190402 07:02:10.651"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:10.654" starttime="20190402 07:02:10.653"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:02:10.656" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:02:10.656" starttime="20190402 07:02:10.655"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:10.658" starttime="20190402 07:02:10.657"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:10.659" starttime="20190402 07:02:10.658"></status>
</kw>
<msg timestamp="20190402 07:02:10.659" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:02:10.659" starttime="20190402 07:02:10.654"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:02:10.660" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:10.660" starttime="20190402 07:02:10.660"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:02:10.685" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:10.685" starttime="20190402 07:02:10.661"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:02:12.571" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:02:12.571" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:12.571" starttime="20190402 07:02:10.685"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:02:12.572" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:12.572" starttime="20190402 07:02:12.572"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:02:12.572" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:12.572" starttime="20190402 07:02:12.572"></status>
</kw>
<msg timestamp="20190402 07:02:12.572" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:12.572" starttime="20190402 07:02:12.571"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:02:12.577" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:02:12.577" starttime="20190402 07:02:12.573"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:02:12.582" level="INFO">0</msg>
<msg timestamp="20190402 07:02:12.582" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:12.583" starttime="20190402 07:02:12.577"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:02:12.583" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:02:12.583" starttime="20190402 07:02:12.583"></status>
</kw>
<msg timestamp="20190402 07:02:12.583" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:12.583" starttime="20190402 07:02:12.573"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:12.584" starttime="20190402 07:02:12.584"></status>
</kw>
<status status="PASS" endtime="20190402 07:02:12.584" starttime="20190402 07:02:12.583"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:12.585" starttime="20190402 07:02:12.584"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:02:12.585" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:02:12.585" starttime="20190402 07:02:12.585"></status>
</kw>
<msg timestamp="20190402 07:02:12.585" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:02:12.585" starttime="20190402 07:02:10.652"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:02:12.585" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:02:12.585" starttime="20190402 07:02:12.585"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:02:12.586" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:02:12.586" starttime="20190402 07:02:12.586"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:12.586" starttime="20190402 07:02:12.586"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:12.586" starttime="20190402 07:02:10.649"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:02:17.590" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:17.590" starttime="20190402 07:02:17.589"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:17.592" starttime="20190402 07:02:17.592"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:02:17.595" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:02:17.595" starttime="20190402 07:02:17.594"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:17.597" starttime="20190402 07:02:17.596"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:17.598" starttime="20190402 07:02:17.597"></status>
</kw>
<msg timestamp="20190402 07:02:17.599" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:02:17.599" starttime="20190402 07:02:17.593"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:02:17.600" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:17.600" starttime="20190402 07:02:17.599"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:02:17.624" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:17.624" starttime="20190402 07:02:17.600"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:02:19.301" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:02:19.301" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:19.301" starttime="20190402 07:02:17.624"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:02:19.302" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:19.302" starttime="20190402 07:02:19.301"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:02:19.302" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:19.302" starttime="20190402 07:02:19.302"></status>
</kw>
<msg timestamp="20190402 07:02:19.302" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:19.302" starttime="20190402 07:02:19.301"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:02:19.304" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:02:19.304" starttime="20190402 07:02:19.302"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:02:19.312" level="INFO">0</msg>
<msg timestamp="20190402 07:02:19.312" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:19.312" starttime="20190402 07:02:19.304"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:02:19.312" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:02:19.312" starttime="20190402 07:02:19.312"></status>
</kw>
<msg timestamp="20190402 07:02:19.313" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:19.313" starttime="20190402 07:02:19.302"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:19.313" starttime="20190402 07:02:19.313"></status>
</kw>
<status status="PASS" endtime="20190402 07:02:19.313" starttime="20190402 07:02:19.313"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:19.314" starttime="20190402 07:02:19.313"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:02:19.314" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:02:19.314" starttime="20190402 07:02:19.314"></status>
</kw>
<msg timestamp="20190402 07:02:19.314" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:02:19.314" starttime="20190402 07:02:17.590"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:02:19.315" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:02:19.315" starttime="20190402 07:02:19.314"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:02:19.315" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:02:19.316" starttime="20190402 07:02:19.315"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:19.316" starttime="20190402 07:02:19.315"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:19.316" starttime="20190402 07:02:17.587"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:02:24.319" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:24.319" starttime="20190402 07:02:24.318"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:24.321" starttime="20190402 07:02:24.320"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:02:24.322" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:02:24.322" starttime="20190402 07:02:24.321"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:24.322" starttime="20190402 07:02:24.322"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:24.322" starttime="20190402 07:02:24.322"></status>
</kw>
<msg timestamp="20190402 07:02:24.323" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:02:24.323" starttime="20190402 07:02:24.321"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:02:24.323" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:24.323" starttime="20190402 07:02:24.323"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:02:24.331" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:24.331" starttime="20190402 07:02:24.323"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:02:26.348" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:02:26.348" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:26.348" starttime="20190402 07:02:24.332"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:02:26.349" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:26.349" starttime="20190402 07:02:26.349"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:02:26.349" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:26.349" starttime="20190402 07:02:26.349"></status>
</kw>
<msg timestamp="20190402 07:02:26.350" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:26.350" starttime="20190402 07:02:26.349"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:02:26.351" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:02:26.351" starttime="20190402 07:02:26.350"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:02:26.360" level="INFO">0</msg>
<msg timestamp="20190402 07:02:26.360" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:26.360" starttime="20190402 07:02:26.352"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:02:26.360" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:02:26.360" starttime="20190402 07:02:26.360"></status>
</kw>
<msg timestamp="20190402 07:02:26.360" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:26.360" starttime="20190402 07:02:26.350"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:26.361" starttime="20190402 07:02:26.361"></status>
</kw>
<status status="PASS" endtime="20190402 07:02:26.361" starttime="20190402 07:02:26.361"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:26.362" starttime="20190402 07:02:26.361"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:02:26.362" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:02:26.362" starttime="20190402 07:02:26.362"></status>
</kw>
<msg timestamp="20190402 07:02:26.362" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:02:26.362" starttime="20190402 07:02:24.319"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:02:26.362" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:02:26.363" starttime="20190402 07:02:26.362"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:02:26.363" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:02:26.363" starttime="20190402 07:02:26.363"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:26.364" starttime="20190402 07:02:26.363"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:26.364" starttime="20190402 07:02:24.316"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:02:31.367" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:31.367" starttime="20190402 07:02:31.366"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:31.369" starttime="20190402 07:02:31.369"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:02:31.370" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:02:31.370" starttime="20190402 07:02:31.369"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:31.370" starttime="20190402 07:02:31.370"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:31.370" starttime="20190402 07:02:31.370"></status>
</kw>
<msg timestamp="20190402 07:02:31.371" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:02:31.371" starttime="20190402 07:02:31.369"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:02:31.371" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:31.371" starttime="20190402 07:02:31.371"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:02:31.380" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:31.381" starttime="20190402 07:02:31.371"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:02:33.165" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:02:33.166" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:33.166" starttime="20190402 07:02:31.381"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:02:33.166" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:33.166" starttime="20190402 07:02:33.166"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:02:33.167" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:33.167" starttime="20190402 07:02:33.166"></status>
</kw>
<msg timestamp="20190402 07:02:33.167" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:33.167" starttime="20190402 07:02:33.166"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:02:33.169" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:02:33.169" starttime="20190402 07:02:33.167"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:02:33.171" level="INFO">0</msg>
<msg timestamp="20190402 07:02:33.171" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:33.171" starttime="20190402 07:02:33.169"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:02:33.171" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:02:33.172" starttime="20190402 07:02:33.171"></status>
</kw>
<msg timestamp="20190402 07:02:33.172" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:33.172" starttime="20190402 07:02:33.167"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:33.173" starttime="20190402 07:02:33.172"></status>
</kw>
<status status="PASS" endtime="20190402 07:02:33.173" starttime="20190402 07:02:33.172"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:33.173" starttime="20190402 07:02:33.173"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:02:33.173" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:02:33.173" starttime="20190402 07:02:33.173"></status>
</kw>
<msg timestamp="20190402 07:02:33.174" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:02:33.174" starttime="20190402 07:02:31.367"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:02:33.174" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:02:33.174" starttime="20190402 07:02:33.174"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:02:33.175" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:02:33.175" starttime="20190402 07:02:33.174"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:33.175" starttime="20190402 07:02:33.174"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:33.175" starttime="20190402 07:02:31.364"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:02:38.178" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:38.178" starttime="20190402 07:02:38.177"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:38.181" starttime="20190402 07:02:38.180"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:02:38.181" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:02:38.181" starttime="20190402 07:02:38.181"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:38.182" starttime="20190402 07:02:38.182"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:38.182" starttime="20190402 07:02:38.182"></status>
</kw>
<msg timestamp="20190402 07:02:38.182" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:02:38.182" starttime="20190402 07:02:38.181"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:02:38.183" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:38.183" starttime="20190402 07:02:38.183"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:02:38.191" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:38.192" starttime="20190402 07:02:38.183"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:02:40.164" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:02:40.164" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:40.164" starttime="20190402 07:02:38.192"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:02:40.165" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:40.165" starttime="20190402 07:02:40.165"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:02:40.165" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:40.165" starttime="20190402 07:02:40.165"></status>
</kw>
<msg timestamp="20190402 07:02:40.165" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:40.165" starttime="20190402 07:02:40.164"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:02:40.167" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:02:40.167" starttime="20190402 07:02:40.166"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:02:40.172" level="INFO">0</msg>
<msg timestamp="20190402 07:02:40.172" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:40.172" starttime="20190402 07:02:40.167"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:02:40.172" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:02:40.172" starttime="20190402 07:02:40.172"></status>
</kw>
<msg timestamp="20190402 07:02:40.173" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:40.173" starttime="20190402 07:02:40.166"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:40.173" starttime="20190402 07:02:40.173"></status>
</kw>
<status status="PASS" endtime="20190402 07:02:40.173" starttime="20190402 07:02:40.173"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:40.174" starttime="20190402 07:02:40.174"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:02:40.174" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:02:40.174" starttime="20190402 07:02:40.174"></status>
</kw>
<msg timestamp="20190402 07:02:40.174" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:02:40.174" starttime="20190402 07:02:38.179"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:02:40.175" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:02:40.175" starttime="20190402 07:02:40.174"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:02:40.175" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:02:40.175" starttime="20190402 07:02:40.175"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:40.176" starttime="20190402 07:02:40.175"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:40.176" starttime="20190402 07:02:38.176"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:02:45.179" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:45.179" starttime="20190402 07:02:45.178"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:45.182" starttime="20190402 07:02:45.181"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:02:45.182" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:02:45.183" starttime="20190402 07:02:45.182"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:45.183" starttime="20190402 07:02:45.183"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:45.183" starttime="20190402 07:02:45.183"></status>
</kw>
<msg timestamp="20190402 07:02:45.183" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:02:45.183" starttime="20190402 07:02:45.182"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:02:45.184" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:45.184" starttime="20190402 07:02:45.184"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:02:45.194" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:45.194" starttime="20190402 07:02:45.184"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:02:47.586" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:02:47.586" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:47.586" starttime="20190402 07:02:45.194"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:02:47.587" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:47.587" starttime="20190402 07:02:47.587"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:02:47.587" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:47.587" starttime="20190402 07:02:47.587"></status>
</kw>
<msg timestamp="20190402 07:02:47.587" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:47.587" starttime="20190402 07:02:47.586"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:02:47.589" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:02:47.589" starttime="20190402 07:02:47.588"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:02:47.592" level="INFO">0</msg>
<msg timestamp="20190402 07:02:47.593" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:47.593" starttime="20190402 07:02:47.589"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:02:47.593" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:02:47.593" starttime="20190402 07:02:47.593"></status>
</kw>
<msg timestamp="20190402 07:02:47.593" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:47.593" starttime="20190402 07:02:47.587"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:47.594" starttime="20190402 07:02:47.594"></status>
</kw>
<status status="PASS" endtime="20190402 07:02:47.594" starttime="20190402 07:02:47.593"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:47.594" starttime="20190402 07:02:47.594"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:02:47.595" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:02:47.595" starttime="20190402 07:02:47.595"></status>
</kw>
<msg timestamp="20190402 07:02:47.595" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:02:47.595" starttime="20190402 07:02:45.180"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:02:47.595" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:02:47.595" starttime="20190402 07:02:47.595"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:02:47.596" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:02:47.596" starttime="20190402 07:02:47.596"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:47.596" starttime="20190402 07:02:47.595"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:47.596" starttime="20190402 07:02:45.177"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:02:52.598" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:52.598" starttime="20190402 07:02:52.597"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:52.598" starttime="20190402 07:02:52.598"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:02:52.599" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:02:52.599" starttime="20190402 07:02:52.599"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:52.599" starttime="20190402 07:02:52.599"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:52.600" starttime="20190402 07:02:52.600"></status>
</kw>
<msg timestamp="20190402 07:02:52.600" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:02:52.600" starttime="20190402 07:02:52.598"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:02:52.600" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:52.600" starttime="20190402 07:02:52.600"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:02:52.612" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:52.612" starttime="20190402 07:02:52.600"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:02:54.892" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:02:54.892" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:54.892" starttime="20190402 07:02:52.612"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:02:54.893" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:54.893" starttime="20190402 07:02:54.893"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:02:54.894" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:54.894" starttime="20190402 07:02:54.893"></status>
</kw>
<msg timestamp="20190402 07:02:54.894" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:02:54.894" starttime="20190402 07:02:54.893"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:02:54.896" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:02:54.896" starttime="20190402 07:02:54.894"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:02:54.901" level="INFO">0</msg>
<msg timestamp="20190402 07:02:54.901" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:54.901" starttime="20190402 07:02:54.896"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:02:54.902" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:02:54.902" starttime="20190402 07:02:54.902"></status>
</kw>
<msg timestamp="20190402 07:02:54.902" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:02:54.902" starttime="20190402 07:02:54.894"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:54.903" starttime="20190402 07:02:54.903"></status>
</kw>
<status status="PASS" endtime="20190402 07:02:54.903" starttime="20190402 07:02:54.902"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:54.903" starttime="20190402 07:02:54.903"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:02:54.903" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:02:54.904" starttime="20190402 07:02:54.903"></status>
</kw>
<msg timestamp="20190402 07:02:54.904" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:02:54.904" starttime="20190402 07:02:52.598"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:02:54.904" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:02:54.904" starttime="20190402 07:02:54.904"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:02:54.905" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:02:54.905" starttime="20190402 07:02:54.905"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:54.905" starttime="20190402 07:02:54.904"></status>
</kw>
<status status="FAIL" endtime="20190402 07:02:54.905" starttime="20190402 07:02:52.597"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:02:59.906" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:59.906" starttime="20190402 07:02:59.906"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:59.907" starttime="20190402 07:02:59.907"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:02:59.908" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:02:59.908" starttime="20190402 07:02:59.908"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:59.909" starttime="20190402 07:02:59.908"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:02:59.909" starttime="20190402 07:02:59.909"></status>
</kw>
<msg timestamp="20190402 07:02:59.909" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:02:59.909" starttime="20190402 07:02:59.907"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:02:59.910" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:02:59.910" starttime="20190402 07:02:59.909"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:02:59.918" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:02:59.919" starttime="20190402 07:02:59.910"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:03:01.910" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:03:01.910" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:01.911" starttime="20190402 07:02:59.919"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:03:01.911" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:01.912" starttime="20190402 07:03:01.911"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:03:01.912" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:01.912" starttime="20190402 07:03:01.912"></status>
</kw>
<msg timestamp="20190402 07:03:01.912" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:01.912" starttime="20190402 07:03:01.911"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:03:01.915" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:03:01.915" starttime="20190402 07:03:01.913"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:03:01.919" level="INFO">0</msg>
<msg timestamp="20190402 07:03:01.919" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:01.919" starttime="20190402 07:03:01.915"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:03:01.919" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:03:01.920" starttime="20190402 07:03:01.919"></status>
</kw>
<msg timestamp="20190402 07:03:01.920" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:01.920" starttime="20190402 07:03:01.912"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:01.921" starttime="20190402 07:03:01.920"></status>
</kw>
<status status="PASS" endtime="20190402 07:03:01.921" starttime="20190402 07:03:01.920"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:01.921" starttime="20190402 07:03:01.921"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:03:01.921" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:03:01.921" starttime="20190402 07:03:01.921"></status>
</kw>
<msg timestamp="20190402 07:03:01.922" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:03:01.922" starttime="20190402 07:02:59.906"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:03:01.922" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:03:01.922" starttime="20190402 07:03:01.922"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:03:01.923" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:03:01.923" starttime="20190402 07:03:01.922"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:01.923" starttime="20190402 07:03:01.922"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:01.923" starttime="20190402 07:02:59.905"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:03:06.924" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:06.924" starttime="20190402 07:03:06.924"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:06.925" starttime="20190402 07:03:06.925"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:03:06.926" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:03:06.926" starttime="20190402 07:03:06.925"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:06.926" starttime="20190402 07:03:06.926"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:06.927" starttime="20190402 07:03:06.927"></status>
</kw>
<msg timestamp="20190402 07:03:06.927" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:03:06.927" starttime="20190402 07:03:06.925"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:03:06.927" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:06.927" starttime="20190402 07:03:06.927"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:03:06.938" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:06.938" starttime="20190402 07:03:06.928"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:03:08.468" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:03:08.469" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:08.469" starttime="20190402 07:03:06.938"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:03:08.469" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:08.469" starttime="20190402 07:03:08.469"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:03:08.470" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:08.470" starttime="20190402 07:03:08.469"></status>
</kw>
<msg timestamp="20190402 07:03:08.470" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:08.470" starttime="20190402 07:03:08.469"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:03:08.477" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:03:08.477" starttime="20190402 07:03:08.470"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:03:08.483" level="INFO">0</msg>
<msg timestamp="20190402 07:03:08.483" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:08.483" starttime="20190402 07:03:08.477"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:03:08.483" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:03:08.483" starttime="20190402 07:03:08.483"></status>
</kw>
<msg timestamp="20190402 07:03:08.484" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:08.484" starttime="20190402 07:03:08.470"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:08.485" starttime="20190402 07:03:08.484"></status>
</kw>
<status status="PASS" endtime="20190402 07:03:08.485" starttime="20190402 07:03:08.484"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:08.485" starttime="20190402 07:03:08.485"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:03:08.485" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:03:08.485" starttime="20190402 07:03:08.485"></status>
</kw>
<msg timestamp="20190402 07:03:08.485" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:03:08.485" starttime="20190402 07:03:06.924"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:03:08.486" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:03:08.486" starttime="20190402 07:03:08.486"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:03:08.487" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:03:08.487" starttime="20190402 07:03:08.486"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:08.487" starttime="20190402 07:03:08.486"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:08.487" starttime="20190402 07:03:06.923"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:03:13.489" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:13.490" starttime="20190402 07:03:13.489"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:13.492" starttime="20190402 07:03:13.491"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:03:13.493" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:03:13.493" starttime="20190402 07:03:13.493"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:13.494" starttime="20190402 07:03:13.493"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:13.494" starttime="20190402 07:03:13.494"></status>
</kw>
<msg timestamp="20190402 07:03:13.495" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:03:13.495" starttime="20190402 07:03:13.492"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:03:13.495" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:13.495" starttime="20190402 07:03:13.495"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:03:13.503" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:13.503" starttime="20190402 07:03:13.495"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:03:15.125" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:03:15.126" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:15.126" starttime="20190402 07:03:13.503"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:03:15.126" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:15.126" starttime="20190402 07:03:15.126"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:03:15.127" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:15.127" starttime="20190402 07:03:15.126"></status>
</kw>
<msg timestamp="20190402 07:03:15.127" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:15.127" starttime="20190402 07:03:15.126"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:03:15.129" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:03:15.129" starttime="20190402 07:03:15.127"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:03:15.135" level="INFO">0</msg>
<msg timestamp="20190402 07:03:15.135" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:15.135" starttime="20190402 07:03:15.129"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:03:15.136" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:03:15.136" starttime="20190402 07:03:15.136"></status>
</kw>
<msg timestamp="20190402 07:03:15.136" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:15.136" starttime="20190402 07:03:15.127"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:15.137" starttime="20190402 07:03:15.136"></status>
</kw>
<status status="PASS" endtime="20190402 07:03:15.137" starttime="20190402 07:03:15.136"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:15.137" starttime="20190402 07:03:15.137"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:03:15.137" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:03:15.137" starttime="20190402 07:03:15.137"></status>
</kw>
<msg timestamp="20190402 07:03:15.138" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:03:15.138" starttime="20190402 07:03:13.490"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:03:15.138" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:03:15.138" starttime="20190402 07:03:15.138"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:03:15.139" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:03:15.139" starttime="20190402 07:03:15.138"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:15.139" starttime="20190402 07:03:15.138"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:15.139" starttime="20190402 07:03:13.487"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:03:20.142" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:20.142" starttime="20190402 07:03:20.141"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:20.145" starttime="20190402 07:03:20.144"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:03:20.146" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:03:20.146" starttime="20190402 07:03:20.145"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:20.146" starttime="20190402 07:03:20.146"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:20.146" starttime="20190402 07:03:20.146"></status>
</kw>
<msg timestamp="20190402 07:03:20.146" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:03:20.146" starttime="20190402 07:03:20.145"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:03:20.147" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:20.147" starttime="20190402 07:03:20.147"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:03:20.156" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:20.156" starttime="20190402 07:03:20.147"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:03:21.600" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:03:21.600" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:21.600" starttime="20190402 07:03:20.156"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:03:21.601" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:21.601" starttime="20190402 07:03:21.601"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:03:21.602" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:21.602" starttime="20190402 07:03:21.602"></status>
</kw>
<msg timestamp="20190402 07:03:21.602" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:21.602" starttime="20190402 07:03:21.601"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:03:21.604" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:03:21.604" starttime="20190402 07:03:21.602"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:03:21.605" level="INFO">0</msg>
<msg timestamp="20190402 07:03:21.605" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:21.605" starttime="20190402 07:03:21.604"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:03:21.606" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:03:21.606" starttime="20190402 07:03:21.605"></status>
</kw>
<msg timestamp="20190402 07:03:21.606" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:21.606" starttime="20190402 07:03:21.602"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:21.607" starttime="20190402 07:03:21.606"></status>
</kw>
<status status="PASS" endtime="20190402 07:03:21.607" starttime="20190402 07:03:21.606"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:21.607" starttime="20190402 07:03:21.607"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:03:21.607" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:03:21.607" starttime="20190402 07:03:21.607"></status>
</kw>
<msg timestamp="20190402 07:03:21.608" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:03:21.608" starttime="20190402 07:03:20.142"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:03:21.608" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:03:21.608" starttime="20190402 07:03:21.608"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:03:21.609" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:03:21.609" starttime="20190402 07:03:21.608"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:21.609" starttime="20190402 07:03:21.608"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:21.609" starttime="20190402 07:03:20.140"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:03:26.612" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:26.612" starttime="20190402 07:03:26.611"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:26.615" starttime="20190402 07:03:26.614"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:03:26.616" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:03:26.616" starttime="20190402 07:03:26.615"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:26.616" starttime="20190402 07:03:26.616"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:26.616" starttime="20190402 07:03:26.616"></status>
</kw>
<msg timestamp="20190402 07:03:26.616" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:03:26.616" starttime="20190402 07:03:26.615"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:03:26.617" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:26.617" starttime="20190402 07:03:26.617"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:03:26.625" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:26.625" starttime="20190402 07:03:26.617"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:03:28.361" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:03:28.361" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:28.361" starttime="20190402 07:03:26.625"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:03:28.362" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:28.362" starttime="20190402 07:03:28.362"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:03:28.362" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:28.362" starttime="20190402 07:03:28.362"></status>
</kw>
<msg timestamp="20190402 07:03:28.363" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:28.363" starttime="20190402 07:03:28.361"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:03:28.367" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:03:28.367" starttime="20190402 07:03:28.363"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:03:28.378" level="INFO">0</msg>
<msg timestamp="20190402 07:03:28.378" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:28.378" starttime="20190402 07:03:28.367"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:03:28.378" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:03:28.378" starttime="20190402 07:03:28.378"></status>
</kw>
<msg timestamp="20190402 07:03:28.379" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:28.379" starttime="20190402 07:03:28.363"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:28.379" starttime="20190402 07:03:28.379"></status>
</kw>
<status status="PASS" endtime="20190402 07:03:28.379" starttime="20190402 07:03:28.379"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:28.380" starttime="20190402 07:03:28.380"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:03:28.380" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:03:28.380" starttime="20190402 07:03:28.380"></status>
</kw>
<msg timestamp="20190402 07:03:28.380" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:03:28.380" starttime="20190402 07:03:26.613"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:03:28.381" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:03:28.381" starttime="20190402 07:03:28.381"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:03:28.381" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:03:28.382" starttime="20190402 07:03:28.381"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:28.382" starttime="20190402 07:03:28.381"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:28.382" starttime="20190402 07:03:26.609"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:03:33.385" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:33.385" starttime="20190402 07:03:33.384"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:33.387" starttime="20190402 07:03:33.387"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:03:33.388" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:03:33.388" starttime="20190402 07:03:33.387"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:33.388" starttime="20190402 07:03:33.388"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:33.388" starttime="20190402 07:03:33.388"></status>
</kw>
<msg timestamp="20190402 07:03:33.389" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:03:33.389" starttime="20190402 07:03:33.387"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:03:33.389" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:33.389" starttime="20190402 07:03:33.389"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:03:33.399" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:33.399" starttime="20190402 07:03:33.389"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:03:34.971" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:03:34.971" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:34.972" starttime="20190402 07:03:33.399"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:03:34.972" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:34.972" starttime="20190402 07:03:34.972"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:03:34.973" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:34.973" starttime="20190402 07:03:34.972"></status>
</kw>
<msg timestamp="20190402 07:03:34.973" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:34.973" starttime="20190402 07:03:34.972"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:03:34.975" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:03:34.975" starttime="20190402 07:03:34.973"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:03:34.981" level="INFO">0</msg>
<msg timestamp="20190402 07:03:34.981" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:34.981" starttime="20190402 07:03:34.975"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:03:34.981" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:03:34.981" starttime="20190402 07:03:34.981"></status>
</kw>
<msg timestamp="20190402 07:03:34.981" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:34.981" starttime="20190402 07:03:34.973"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:34.982" starttime="20190402 07:03:34.982"></status>
</kw>
<status status="PASS" endtime="20190402 07:03:34.982" starttime="20190402 07:03:34.981"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:34.983" starttime="20190402 07:03:34.982"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:03:34.983" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:03:34.983" starttime="20190402 07:03:34.983"></status>
</kw>
<msg timestamp="20190402 07:03:34.983" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:03:34.983" starttime="20190402 07:03:33.385"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:03:34.983" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:03:34.983" starttime="20190402 07:03:34.983"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:03:34.984" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:03:34.984" starttime="20190402 07:03:34.984"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:34.984" starttime="20190402 07:03:34.984"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:34.984" starttime="20190402 07:03:33.382"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:03:39.988" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:39.988" starttime="20190402 07:03:39.987"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:39.989" starttime="20190402 07:03:39.989"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:03:39.990" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:03:39.990" starttime="20190402 07:03:39.990"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:39.990" starttime="20190402 07:03:39.990"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:39.991" starttime="20190402 07:03:39.991"></status>
</kw>
<msg timestamp="20190402 07:03:39.991" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:03:39.991" starttime="20190402 07:03:39.989"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:03:39.991" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:39.991" starttime="20190402 07:03:39.991"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:03:40.001" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:40.001" starttime="20190402 07:03:39.992"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:03:41.455" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:03:41.455" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:41.455" starttime="20190402 07:03:40.001"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:03:41.456" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:41.456" starttime="20190402 07:03:41.456"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:03:41.456" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:41.456" starttime="20190402 07:03:41.456"></status>
</kw>
<msg timestamp="20190402 07:03:41.456" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:41.457" starttime="20190402 07:03:41.455"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:03:41.458" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:03:41.458" starttime="20190402 07:03:41.457"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:03:41.460" level="INFO">0</msg>
<msg timestamp="20190402 07:03:41.460" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:41.460" starttime="20190402 07:03:41.458"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:03:41.460" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:03:41.460" starttime="20190402 07:03:41.460"></status>
</kw>
<msg timestamp="20190402 07:03:41.461" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:41.461" starttime="20190402 07:03:41.457"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:41.462" starttime="20190402 07:03:41.461"></status>
</kw>
<status status="PASS" endtime="20190402 07:03:41.462" starttime="20190402 07:03:41.461"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:41.462" starttime="20190402 07:03:41.462"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:03:41.462" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:03:41.462" starttime="20190402 07:03:41.462"></status>
</kw>
<msg timestamp="20190402 07:03:41.463" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:03:41.463" starttime="20190402 07:03:39.988"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:03:41.463" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:03:41.463" starttime="20190402 07:03:41.463"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:03:41.464" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:03:41.464" starttime="20190402 07:03:41.463"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:41.464" starttime="20190402 07:03:41.463"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:41.464" starttime="20190402 07:03:39.985"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:03:46.467" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:46.467" starttime="20190402 07:03:46.466"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:46.470" starttime="20190402 07:03:46.469"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:03:46.471" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:03:46.471" starttime="20190402 07:03:46.470"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:46.471" starttime="20190402 07:03:46.471"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:46.471" starttime="20190402 07:03:46.471"></status>
</kw>
<msg timestamp="20190402 07:03:46.471" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:03:46.471" starttime="20190402 07:03:46.470"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:03:46.472" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:46.472" starttime="20190402 07:03:46.472"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:03:46.481" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:46.481" starttime="20190402 07:03:46.472"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:03:48.062" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:03:48.062" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:48.062" starttime="20190402 07:03:46.481"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:03:48.063" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:48.063" starttime="20190402 07:03:48.063"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:03:48.063" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:48.063" starttime="20190402 07:03:48.063"></status>
</kw>
<msg timestamp="20190402 07:03:48.063" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:48.063" starttime="20190402 07:03:48.062"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:03:48.065" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:03:48.065" starttime="20190402 07:03:48.064"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:03:48.068" level="INFO">0</msg>
<msg timestamp="20190402 07:03:48.068" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:48.068" starttime="20190402 07:03:48.065"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:03:48.068" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:03:48.068" starttime="20190402 07:03:48.068"></status>
</kw>
<msg timestamp="20190402 07:03:48.068" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:48.068" starttime="20190402 07:03:48.063"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:48.069" starttime="20190402 07:03:48.069"></status>
</kw>
<status status="PASS" endtime="20190402 07:03:48.069" starttime="20190402 07:03:48.068"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:48.069" starttime="20190402 07:03:48.069"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:03:48.070" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:03:48.070" starttime="20190402 07:03:48.070"></status>
</kw>
<msg timestamp="20190402 07:03:48.070" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:03:48.070" starttime="20190402 07:03:46.468"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:03:48.071" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:03:48.071" starttime="20190402 07:03:48.070"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:03:48.071" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:03:48.072" starttime="20190402 07:03:48.071"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:48.072" starttime="20190402 07:03:48.071"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:48.072" starttime="20190402 07:03:46.465"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:03:53.073" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:53.073" starttime="20190402 07:03:53.073"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:53.074" starttime="20190402 07:03:53.074"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:03:53.075" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:03:53.076" starttime="20190402 07:03:53.075"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:53.076" starttime="20190402 07:03:53.076"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:53.077" starttime="20190402 07:03:53.076"></status>
</kw>
<msg timestamp="20190402 07:03:53.077" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:03:53.077" starttime="20190402 07:03:53.074"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:03:53.077" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:53.078" starttime="20190402 07:03:53.077"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:03:53.092" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:53.092" starttime="20190402 07:03:53.078"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:03:54.659" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:03:54.659" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:54.659" starttime="20190402 07:03:53.092"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:03:54.660" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:54.660" starttime="20190402 07:03:54.659"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:03:54.660" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:54.660" starttime="20190402 07:03:54.660"></status>
</kw>
<msg timestamp="20190402 07:03:54.660" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:03:54.660" starttime="20190402 07:03:54.659"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:03:54.662" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:03:54.663" starttime="20190402 07:03:54.660"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:03:54.669" level="INFO">0</msg>
<msg timestamp="20190402 07:03:54.669" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:54.669" starttime="20190402 07:03:54.663"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:03:54.670" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:03:54.670" starttime="20190402 07:03:54.670"></status>
</kw>
<msg timestamp="20190402 07:03:54.670" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:03:54.670" starttime="20190402 07:03:54.660"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:54.671" starttime="20190402 07:03:54.671"></status>
</kw>
<status status="PASS" endtime="20190402 07:03:54.671" starttime="20190402 07:03:54.670"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:54.671" starttime="20190402 07:03:54.671"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:03:54.672" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:03:54.672" starttime="20190402 07:03:54.671"></status>
</kw>
<msg timestamp="20190402 07:03:54.672" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:03:54.672" starttime="20190402 07:03:53.073"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:03:54.672" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:03:54.672" starttime="20190402 07:03:54.672"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:03:54.673" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:03:54.673" starttime="20190402 07:03:54.673"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:54.673" starttime="20190402 07:03:54.672"></status>
</kw>
<status status="FAIL" endtime="20190402 07:03:54.673" starttime="20190402 07:03:53.072"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:03:59.675" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:59.675" starttime="20190402 07:03:59.674"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:59.676" starttime="20190402 07:03:59.676"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:03:59.677" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:03:59.677" starttime="20190402 07:03:59.676"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:59.678" starttime="20190402 07:03:59.677"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:03:59.678" starttime="20190402 07:03:59.678"></status>
</kw>
<msg timestamp="20190402 07:03:59.679" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:03:59.679" starttime="20190402 07:03:59.676"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:03:59.679" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:03:59.679" starttime="20190402 07:03:59.679"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:03:59.694" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:03:59.694" starttime="20190402 07:03:59.679"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:04:01.645" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:04:01.646" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:01.646" starttime="20190402 07:03:59.694"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:04:01.646" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:01.646" starttime="20190402 07:04:01.646"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:04:01.647" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:01.647" starttime="20190402 07:04:01.647"></status>
</kw>
<msg timestamp="20190402 07:04:01.647" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:01.647" starttime="20190402 07:04:01.646"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:04:01.649" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:04:01.649" starttime="20190402 07:04:01.647"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:04:01.652" level="INFO">0</msg>
<msg timestamp="20190402 07:04:01.652" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:01.652" starttime="20190402 07:04:01.649"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:04:01.652" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:04:01.652" starttime="20190402 07:04:01.652"></status>
</kw>
<msg timestamp="20190402 07:04:01.652" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:01.652" starttime="20190402 07:04:01.647"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:01.653" starttime="20190402 07:04:01.653"></status>
</kw>
<status status="PASS" endtime="20190402 07:04:01.653" starttime="20190402 07:04:01.653"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:01.654" starttime="20190402 07:04:01.653"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:04:01.654" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:04:01.654" starttime="20190402 07:04:01.654"></status>
</kw>
<msg timestamp="20190402 07:04:01.654" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:04:01.654" starttime="20190402 07:03:59.675"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:04:01.654" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:04:01.655" starttime="20190402 07:04:01.654"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:04:01.655" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:04:01.655" starttime="20190402 07:04:01.655"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:01.655" starttime="20190402 07:04:01.655"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:01.656" starttime="20190402 07:03:59.674"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:04:06.658" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:06.658" starttime="20190402 07:04:06.658"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:06.661" starttime="20190402 07:04:06.660"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:04:06.662" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:04:06.662" starttime="20190402 07:04:06.661"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:06.662" starttime="20190402 07:04:06.662"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:06.662" starttime="20190402 07:04:06.662"></status>
</kw>
<msg timestamp="20190402 07:04:06.662" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:04:06.662" starttime="20190402 07:04:06.661"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:04:06.663" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:06.663" starttime="20190402 07:04:06.663"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:04:06.675" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:06.676" starttime="20190402 07:04:06.663"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:04:08.404" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:04:08.404" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:08.404" starttime="20190402 07:04:06.676"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:04:08.405" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:08.405" starttime="20190402 07:04:08.405"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:04:08.405" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:08.406" starttime="20190402 07:04:08.405"></status>
</kw>
<msg timestamp="20190402 07:04:08.406" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:08.406" starttime="20190402 07:04:08.405"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:04:08.408" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:04:08.408" starttime="20190402 07:04:08.406"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:04:08.414" level="INFO">0</msg>
<msg timestamp="20190402 07:04:08.414" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:08.414" starttime="20190402 07:04:08.408"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:04:08.415" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:04:08.415" starttime="20190402 07:04:08.414"></status>
</kw>
<msg timestamp="20190402 07:04:08.415" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:08.415" starttime="20190402 07:04:08.406"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:08.416" starttime="20190402 07:04:08.415"></status>
</kw>
<status status="PASS" endtime="20190402 07:04:08.416" starttime="20190402 07:04:08.415"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:08.416" starttime="20190402 07:04:08.416"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:04:08.416" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:04:08.416" starttime="20190402 07:04:08.416"></status>
</kw>
<msg timestamp="20190402 07:04:08.417" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:04:08.417" starttime="20190402 07:04:06.659"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:04:08.417" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:04:08.417" starttime="20190402 07:04:08.417"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:04:08.418" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:04:08.418" starttime="20190402 07:04:08.417"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:08.418" starttime="20190402 07:04:08.417"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:08.418" starttime="20190402 07:04:06.656"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:04:13.421" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:13.421" starttime="20190402 07:04:13.420"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:13.424" starttime="20190402 07:04:13.423"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:04:13.425" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:04:13.425" starttime="20190402 07:04:13.424"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:13.425" starttime="20190402 07:04:13.425"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:13.425" starttime="20190402 07:04:13.425"></status>
</kw>
<msg timestamp="20190402 07:04:13.425" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:04:13.425" starttime="20190402 07:04:13.424"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:04:13.426" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:13.426" starttime="20190402 07:04:13.426"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:04:13.435" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:13.435" starttime="20190402 07:04:13.426"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:04:15.097" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:04:15.098" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:15.098" starttime="20190402 07:04:13.435"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:04:15.098" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:15.098" starttime="20190402 07:04:15.098"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:04:15.099" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:15.099" starttime="20190402 07:04:15.099"></status>
</kw>
<msg timestamp="20190402 07:04:15.099" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:15.099" starttime="20190402 07:04:15.098"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:04:15.101" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:04:15.101" starttime="20190402 07:04:15.099"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:04:15.112" level="INFO">0</msg>
<msg timestamp="20190402 07:04:15.112" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:15.112" starttime="20190402 07:04:15.101"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:04:15.112" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:04:15.112" starttime="20190402 07:04:15.112"></status>
</kw>
<msg timestamp="20190402 07:04:15.113" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:15.113" starttime="20190402 07:04:15.099"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:15.114" starttime="20190402 07:04:15.113"></status>
</kw>
<status status="PASS" endtime="20190402 07:04:15.114" starttime="20190402 07:04:15.113"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:15.114" starttime="20190402 07:04:15.114"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:04:15.114" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:04:15.114" starttime="20190402 07:04:15.114"></status>
</kw>
<msg timestamp="20190402 07:04:15.115" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:04:15.115" starttime="20190402 07:04:13.422"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:04:15.115" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:04:15.115" starttime="20190402 07:04:15.115"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:04:15.116" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:04:15.116" starttime="20190402 07:04:15.115"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:15.116" starttime="20190402 07:04:15.115"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:15.116" starttime="20190402 07:04:13.419"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:04:20.119" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:20.120" starttime="20190402 07:04:20.118"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:20.122" starttime="20190402 07:04:20.121"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:04:20.123" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:04:20.123" starttime="20190402 07:04:20.122"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:20.123" starttime="20190402 07:04:20.123"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:20.123" starttime="20190402 07:04:20.123"></status>
</kw>
<msg timestamp="20190402 07:04:20.124" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:04:20.124" starttime="20190402 07:04:20.122"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:04:20.124" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:20.124" starttime="20190402 07:04:20.124"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:04:20.133" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:20.133" starttime="20190402 07:04:20.124"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:04:21.764" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:04:21.764" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:21.764" starttime="20190402 07:04:20.133"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:04:21.765" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:21.765" starttime="20190402 07:04:21.765"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:04:21.766" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:21.766" starttime="20190402 07:04:21.765"></status>
</kw>
<msg timestamp="20190402 07:04:21.766" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:21.766" starttime="20190402 07:04:21.765"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:04:21.767" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:04:21.767" starttime="20190402 07:04:21.766"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:04:21.771" level="INFO">0</msg>
<msg timestamp="20190402 07:04:21.771" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:21.771" starttime="20190402 07:04:21.768"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:04:21.771" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:04:21.771" starttime="20190402 07:04:21.771"></status>
</kw>
<msg timestamp="20190402 07:04:21.771" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:21.771" starttime="20190402 07:04:21.766"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:21.772" starttime="20190402 07:04:21.772"></status>
</kw>
<status status="PASS" endtime="20190402 07:04:21.772" starttime="20190402 07:04:21.772"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:21.773" starttime="20190402 07:04:21.772"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:04:21.773" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:04:21.773" starttime="20190402 07:04:21.773"></status>
</kw>
<msg timestamp="20190402 07:04:21.773" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:04:21.773" starttime="20190402 07:04:20.120"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:04:21.773" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:04:21.773" starttime="20190402 07:04:21.773"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:04:21.774" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:04:21.774" starttime="20190402 07:04:21.774"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:21.774" starttime="20190402 07:04:21.774"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:21.774" starttime="20190402 07:04:20.116"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:04:26.777" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:26.778" starttime="20190402 07:04:26.776"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:26.780" starttime="20190402 07:04:26.779"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:04:26.781" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:04:26.781" starttime="20190402 07:04:26.780"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:26.781" starttime="20190402 07:04:26.781"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:26.782" starttime="20190402 07:04:26.781"></status>
</kw>
<msg timestamp="20190402 07:04:26.782" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:04:26.782" starttime="20190402 07:04:26.780"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:04:26.782" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:26.782" starttime="20190402 07:04:26.782"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:04:26.791" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:26.791" starttime="20190402 07:04:26.782"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:04:28.056" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:04:28.056" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:28.056" starttime="20190402 07:04:26.791"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:04:28.057" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:28.057" starttime="20190402 07:04:28.057"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:04:28.058" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:28.058" starttime="20190402 07:04:28.057"></status>
</kw>
<msg timestamp="20190402 07:04:28.058" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:28.058" starttime="20190402 07:04:28.057"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:04:28.060" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:04:28.060" starttime="20190402 07:04:28.058"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:04:28.060" level="INFO">0</msg>
<msg timestamp="20190402 07:04:28.060" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:28.060" starttime="20190402 07:04:28.060"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:04:28.061" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:04:28.061" starttime="20190402 07:04:28.060"></status>
</kw>
<msg timestamp="20190402 07:04:28.061" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:28.061" starttime="20190402 07:04:28.058"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:28.062" starttime="20190402 07:04:28.061"></status>
</kw>
<status status="PASS" endtime="20190402 07:04:28.062" starttime="20190402 07:04:28.061"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:28.062" starttime="20190402 07:04:28.062"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:04:28.062" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:04:28.062" starttime="20190402 07:04:28.062"></status>
</kw>
<msg timestamp="20190402 07:04:28.063" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:04:28.063" starttime="20190402 07:04:26.778"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:04:28.063" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:04:28.063" starttime="20190402 07:04:28.063"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:04:28.064" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:04:28.064" starttime="20190402 07:04:28.063"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:28.064" starttime="20190402 07:04:28.063"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:28.064" starttime="20190402 07:04:26.775"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:04:33.066" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:33.066" starttime="20190402 07:04:33.065"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:33.068" starttime="20190402 07:04:33.068"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:04:33.071" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:04:33.071" starttime="20190402 07:04:33.069"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:33.072" starttime="20190402 07:04:33.071"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:33.073" starttime="20190402 07:04:33.073"></status>
</kw>
<msg timestamp="20190402 07:04:33.074" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:04:33.074" starttime="20190402 07:04:33.069"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:04:33.075" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:33.075" starttime="20190402 07:04:33.074"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:04:33.103" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:33.104" starttime="20190402 07:04:33.075"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:04:34.246" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:04:34.246" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:34.246" starttime="20190402 07:04:33.104"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:04:34.247" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:34.247" starttime="20190402 07:04:34.247"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:04:34.248" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:34.248" starttime="20190402 07:04:34.247"></status>
</kw>
<msg timestamp="20190402 07:04:34.248" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:34.248" starttime="20190402 07:04:34.247"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:04:34.249" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:04:34.250" starttime="20190402 07:04:34.248"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:04:34.250" level="INFO">0</msg>
<msg timestamp="20190402 07:04:34.250" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:34.250" starttime="20190402 07:04:34.250"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:04:34.250" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:04:34.250" starttime="20190402 07:04:34.250"></status>
</kw>
<msg timestamp="20190402 07:04:34.251" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:34.251" starttime="20190402 07:04:34.248"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:34.251" starttime="20190402 07:04:34.251"></status>
</kw>
<status status="PASS" endtime="20190402 07:04:34.251" starttime="20190402 07:04:34.251"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:34.252" starttime="20190402 07:04:34.252"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:04:34.252" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:04:34.252" starttime="20190402 07:04:34.252"></status>
</kw>
<msg timestamp="20190402 07:04:34.252" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:04:34.252" starttime="20190402 07:04:33.067"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:04:34.253" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:04:34.253" starttime="20190402 07:04:34.252"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:04:34.253" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:04:34.253" starttime="20190402 07:04:34.253"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:34.253" starttime="20190402 07:04:34.253"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:34.254" starttime="20190402 07:04:33.064"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:04:39.257" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:39.257" starttime="20190402 07:04:39.256"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:39.259" starttime="20190402 07:04:39.259"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:04:39.262" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:04:39.263" starttime="20190402 07:04:39.261"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:39.264" starttime="20190402 07:04:39.263"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:39.265" starttime="20190402 07:04:39.264"></status>
</kw>
<msg timestamp="20190402 07:04:39.266" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:04:39.267" starttime="20190402 07:04:39.260"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:04:39.267" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:39.268" starttime="20190402 07:04:39.267"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:04:39.292" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:39.293" starttime="20190402 07:04:39.268"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:04:40.378" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:04:40.378" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:40.378" starttime="20190402 07:04:39.293"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:04:40.379" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:40.379" starttime="20190402 07:04:40.379"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:04:40.379" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:40.379" starttime="20190402 07:04:40.379"></status>
</kw>
<msg timestamp="20190402 07:04:40.379" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:40.379" starttime="20190402 07:04:40.378"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:04:40.381" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:04:40.382" starttime="20190402 07:04:40.380"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:04:40.382" level="INFO">0</msg>
<msg timestamp="20190402 07:04:40.382" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:40.382" starttime="20190402 07:04:40.382"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:04:40.382" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:04:40.382" starttime="20190402 07:04:40.382"></status>
</kw>
<msg timestamp="20190402 07:04:40.382" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:40.383" starttime="20190402 07:04:40.379"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:40.383" starttime="20190402 07:04:40.383"></status>
</kw>
<status status="PASS" endtime="20190402 07:04:40.383" starttime="20190402 07:04:40.383"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:40.384" starttime="20190402 07:04:40.383"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:04:40.384" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:04:40.384" starttime="20190402 07:04:40.384"></status>
</kw>
<msg timestamp="20190402 07:04:40.384" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:04:40.384" starttime="20190402 07:04:39.257"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:04:40.385" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:04:40.385" starttime="20190402 07:04:40.384"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:04:40.385" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:04:40.385" starttime="20190402 07:04:40.385"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:40.385" starttime="20190402 07:04:40.385"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:40.385" starttime="20190402 07:04:39.254"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:04:45.388" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:45.389" starttime="20190402 07:04:45.388"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:45.391" starttime="20190402 07:04:45.390"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:04:45.392" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:04:45.392" starttime="20190402 07:04:45.391"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:45.392" starttime="20190402 07:04:45.392"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:45.392" starttime="20190402 07:04:45.392"></status>
</kw>
<msg timestamp="20190402 07:04:45.393" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:04:45.393" starttime="20190402 07:04:45.391"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:04:45.393" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:45.393" starttime="20190402 07:04:45.393"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:04:45.404" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:45.404" starttime="20190402 07:04:45.393"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:04:46.787" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:04:46.788" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:46.788" starttime="20190402 07:04:45.404"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:04:46.789" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:46.789" starttime="20190402 07:04:46.788"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:04:46.789" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:46.789" starttime="20190402 07:04:46.789"></status>
</kw>
<msg timestamp="20190402 07:04:46.789" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:46.789" starttime="20190402 07:04:46.788"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:04:46.791" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:04:46.791" starttime="20190402 07:04:46.790"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:04:46.792" level="INFO">0</msg>
<msg timestamp="20190402 07:04:46.792" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:46.792" starttime="20190402 07:04:46.791"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:04:46.792" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:04:46.792" starttime="20190402 07:04:46.792"></status>
</kw>
<msg timestamp="20190402 07:04:46.792" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:46.792" starttime="20190402 07:04:46.789"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:46.793" starttime="20190402 07:04:46.793"></status>
</kw>
<status status="PASS" endtime="20190402 07:04:46.793" starttime="20190402 07:04:46.792"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:46.793" starttime="20190402 07:04:46.793"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:04:46.794" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:04:46.794" starttime="20190402 07:04:46.793"></status>
</kw>
<msg timestamp="20190402 07:04:46.794" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:04:46.794" starttime="20190402 07:04:45.389"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:04:46.795" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:04:46.795" starttime="20190402 07:04:46.794"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:04:46.795" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:04:46.795" starttime="20190402 07:04:46.795"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:46.795" starttime="20190402 07:04:46.795"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:46.796" starttime="20190402 07:04:45.386"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:04:51.797" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:51.797" starttime="20190402 07:04:51.797"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:51.798" starttime="20190402 07:04:51.798"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:04:51.799" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:04:51.799" starttime="20190402 07:04:51.798"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:51.799" starttime="20190402 07:04:51.799"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:51.800" starttime="20190402 07:04:51.799"></status>
</kw>
<msg timestamp="20190402 07:04:51.800" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:04:51.800" starttime="20190402 07:04:51.798"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:04:51.800" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:51.800" starttime="20190402 07:04:51.800"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:04:51.809" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:51.810" starttime="20190402 07:04:51.800"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:04:52.874" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:04:52.875" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:52.875" starttime="20190402 07:04:51.810"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:04:52.875" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:52.875" starttime="20190402 07:04:52.875"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:04:52.876" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:52.876" starttime="20190402 07:04:52.875"></status>
</kw>
<msg timestamp="20190402 07:04:52.876" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:52.876" starttime="20190402 07:04:52.875"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:04:52.878" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:04:52.878" starttime="20190402 07:04:52.876"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:04:52.879" level="INFO">0</msg>
<msg timestamp="20190402 07:04:52.879" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:52.879" starttime="20190402 07:04:52.878"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:04:52.879" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:04:52.879" starttime="20190402 07:04:52.879"></status>
</kw>
<msg timestamp="20190402 07:04:52.879" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:52.879" starttime="20190402 07:04:52.876"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:52.880" starttime="20190402 07:04:52.880"></status>
</kw>
<status status="PASS" endtime="20190402 07:04:52.880" starttime="20190402 07:04:52.879"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:52.880" starttime="20190402 07:04:52.880"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:04:52.881" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:04:52.881" starttime="20190402 07:04:52.880"></status>
</kw>
<msg timestamp="20190402 07:04:52.881" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:04:52.881" starttime="20190402 07:04:51.797"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:04:52.881" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:04:52.881" starttime="20190402 07:04:52.881"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:04:52.882" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:04:52.882" starttime="20190402 07:04:52.882"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:52.882" starttime="20190402 07:04:52.881"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:52.882" starttime="20190402 07:04:51.796"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:04:57.885" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:57.885" starttime="20190402 07:04:57.884"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:57.888" starttime="20190402 07:04:57.887"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:04:57.889" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:04:57.889" starttime="20190402 07:04:57.888"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:57.889" starttime="20190402 07:04:57.889"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:57.889" starttime="20190402 07:04:57.889"></status>
</kw>
<msg timestamp="20190402 07:04:57.890" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:04:57.890" starttime="20190402 07:04:57.888"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:04:57.890" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:57.890" starttime="20190402 07:04:57.890"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:04:57.899" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:04:57.899" starttime="20190402 07:04:57.890"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:04:58.932" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:04:58.933" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:58.933" starttime="20190402 07:04:57.899"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:04:58.933" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:04:58.933" starttime="20190402 07:04:58.933"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:04:58.934" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:58.934" starttime="20190402 07:04:58.934"></status>
</kw>
<msg timestamp="20190402 07:04:58.934" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:04:58.934" starttime="20190402 07:04:58.933"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:04:58.936" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:04:58.936" starttime="20190402 07:04:58.934"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:04:58.936" level="INFO">0</msg>
<msg timestamp="20190402 07:04:58.937" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:58.937" starttime="20190402 07:04:58.936"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:04:58.937" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:04:58.937" starttime="20190402 07:04:58.937"></status>
</kw>
<msg timestamp="20190402 07:04:58.937" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:04:58.937" starttime="20190402 07:04:58.934"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:58.938" starttime="20190402 07:04:58.937"></status>
</kw>
<status status="PASS" endtime="20190402 07:04:58.938" starttime="20190402 07:04:58.937"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:04:58.938" starttime="20190402 07:04:58.938"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:04:58.938" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:04:58.938" starttime="20190402 07:04:58.938"></status>
</kw>
<msg timestamp="20190402 07:04:58.939" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:04:58.939" starttime="20190402 07:04:57.886"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:04:58.939" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:04:58.939" starttime="20190402 07:04:58.939"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:04:58.940" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:04:58.940" starttime="20190402 07:04:58.939"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:58.940" starttime="20190402 07:04:58.939"></status>
</kw>
<status status="FAIL" endtime="20190402 07:04:58.940" starttime="20190402 07:04:57.883"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:05:03.943" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:03.943" starttime="20190402 07:05:03.942"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:03.946" starttime="20190402 07:05:03.945"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:05:03.947" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:05:03.947" starttime="20190402 07:05:03.946"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:03.947" starttime="20190402 07:05:03.947"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:03.947" starttime="20190402 07:05:03.947"></status>
</kw>
<msg timestamp="20190402 07:05:03.947" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:05:03.948" starttime="20190402 07:05:03.946"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:05:03.948" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:03.948" starttime="20190402 07:05:03.948"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:05:03.957" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:03.957" starttime="20190402 07:05:03.948"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:05:04.988" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:05:04.988" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:04.988" starttime="20190402 07:05:03.957"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:05:04.989" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:04.989" starttime="20190402 07:05:04.989"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:05:04.989" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:04.989" starttime="20190402 07:05:04.989"></status>
</kw>
<msg timestamp="20190402 07:05:04.990" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:04.990" starttime="20190402 07:05:04.988"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:05:04.991" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:05:04.992" starttime="20190402 07:05:04.990"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:05:04.992" level="INFO">0</msg>
<msg timestamp="20190402 07:05:04.992" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:04.992" starttime="20190402 07:05:04.992"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:05:04.992" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:05:04.992" starttime="20190402 07:05:04.992"></status>
</kw>
<msg timestamp="20190402 07:05:04.993" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:04.993" starttime="20190402 07:05:04.990"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:04.994" starttime="20190402 07:05:04.993"></status>
</kw>
<status status="PASS" endtime="20190402 07:05:04.994" starttime="20190402 07:05:04.993"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:04.994" starttime="20190402 07:05:04.994"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:05:04.994" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:05:04.994" starttime="20190402 07:05:04.994"></status>
</kw>
<msg timestamp="20190402 07:05:04.994" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:05:04.995" starttime="20190402 07:05:03.944"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:05:04.995" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:05:04.995" starttime="20190402 07:05:04.995"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:05:04.996" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:05:04.996" starttime="20190402 07:05:04.995"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:04.996" starttime="20190402 07:05:04.995"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:04.996" starttime="20190402 07:05:03.941"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:05:09.999" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:09.999" starttime="20190402 07:05:09.998"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:10.002" starttime="20190402 07:05:10.001"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:05:10.003" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:05:10.003" starttime="20190402 07:05:10.002"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:10.003" starttime="20190402 07:05:10.003"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:10.003" starttime="20190402 07:05:10.003"></status>
</kw>
<msg timestamp="20190402 07:05:10.003" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:05:10.003" starttime="20190402 07:05:10.002"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:05:10.004" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:10.004" starttime="20190402 07:05:10.004"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:05:10.013" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:10.013" starttime="20190402 07:05:10.004"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:05:11.048" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:05:11.048" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:11.048" starttime="20190402 07:05:10.013"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:05:11.049" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:11.049" starttime="20190402 07:05:11.049"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:05:11.049" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:11.049" starttime="20190402 07:05:11.049"></status>
</kw>
<msg timestamp="20190402 07:05:11.049" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:11.049" starttime="20190402 07:05:11.048"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:05:11.051" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:05:11.051" starttime="20190402 07:05:11.050"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:05:11.051" level="INFO">0</msg>
<msg timestamp="20190402 07:05:11.052" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:11.052" starttime="20190402 07:05:11.051"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:05:11.052" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:05:11.052" starttime="20190402 07:05:11.052"></status>
</kw>
<msg timestamp="20190402 07:05:11.052" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:11.052" starttime="20190402 07:05:11.049"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:11.053" starttime="20190402 07:05:11.053"></status>
</kw>
<status status="PASS" endtime="20190402 07:05:11.053" starttime="20190402 07:05:11.052"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:11.053" starttime="20190402 07:05:11.053"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:05:11.053" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:05:11.053" starttime="20190402 07:05:11.053"></status>
</kw>
<msg timestamp="20190402 07:05:11.054" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:05:11.054" starttime="20190402 07:05:09.999"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:05:11.054" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:05:11.054" starttime="20190402 07:05:11.054"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:05:11.055" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:05:11.055" starttime="20190402 07:05:11.055"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:11.055" starttime="20190402 07:05:11.054"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:11.055" starttime="20190402 07:05:09.997"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:05:16.058" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:16.058" starttime="20190402 07:05:16.057"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:16.061" starttime="20190402 07:05:16.060"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:05:16.064" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:05:16.064" starttime="20190402 07:05:16.062"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:16.065" starttime="20190402 07:05:16.064"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:16.066" starttime="20190402 07:05:16.065"></status>
</kw>
<msg timestamp="20190402 07:05:16.067" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:05:16.067" starttime="20190402 07:05:16.061"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:05:16.068" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:16.068" starttime="20190402 07:05:16.067"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:05:16.091" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:16.091" starttime="20190402 07:05:16.068"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:05:17.083" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:05:17.084" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:17.084" starttime="20190402 07:05:16.091"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:05:17.084" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:17.084" starttime="20190402 07:05:17.084"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:05:17.085" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:17.085" starttime="20190402 07:05:17.085"></status>
</kw>
<msg timestamp="20190402 07:05:17.085" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:17.085" starttime="20190402 07:05:17.084"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:05:17.087" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:05:17.087" starttime="20190402 07:05:17.085"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:05:17.087" level="INFO">0</msg>
<msg timestamp="20190402 07:05:17.087" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:17.087" starttime="20190402 07:05:17.087"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:05:17.087" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:05:17.088" starttime="20190402 07:05:17.087"></status>
</kw>
<msg timestamp="20190402 07:05:17.088" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:17.088" starttime="20190402 07:05:17.085"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:17.088" starttime="20190402 07:05:17.088"></status>
</kw>
<status status="PASS" endtime="20190402 07:05:17.088" starttime="20190402 07:05:17.088"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:17.089" starttime="20190402 07:05:17.089"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:05:17.089" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:05:17.089" starttime="20190402 07:05:17.089"></status>
</kw>
<msg timestamp="20190402 07:05:17.089" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:05:17.089" starttime="20190402 07:05:16.059"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:05:17.090" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:05:17.090" starttime="20190402 07:05:17.089"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:05:17.091" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:05:17.091" starttime="20190402 07:05:17.090"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:17.091" starttime="20190402 07:05:17.090"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:17.091" starttime="20190402 07:05:16.056"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:05:22.094" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:22.094" starttime="20190402 07:05:22.093"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:22.097" starttime="20190402 07:05:22.096"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:05:22.098" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:05:22.098" starttime="20190402 07:05:22.097"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:22.098" starttime="20190402 07:05:22.098"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:22.098" starttime="20190402 07:05:22.098"></status>
</kw>
<msg timestamp="20190402 07:05:22.099" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:05:22.099" starttime="20190402 07:05:22.097"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:05:22.099" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:22.099" starttime="20190402 07:05:22.099"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:05:22.107" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:22.107" starttime="20190402 07:05:22.099"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:05:23.171" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:05:23.172" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:23.172" starttime="20190402 07:05:22.107"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:05:23.172" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:23.172" starttime="20190402 07:05:23.172"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:05:23.173" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:23.173" starttime="20190402 07:05:23.172"></status>
</kw>
<msg timestamp="20190402 07:05:23.173" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:23.173" starttime="20190402 07:05:23.172"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:05:23.175" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:05:23.175" starttime="20190402 07:05:23.173"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:05:23.175" level="INFO">0</msg>
<msg timestamp="20190402 07:05:23.175" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:23.175" starttime="20190402 07:05:23.175"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:05:23.176" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:05:23.176" starttime="20190402 07:05:23.175"></status>
</kw>
<msg timestamp="20190402 07:05:23.176" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:23.176" starttime="20190402 07:05:23.173"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:23.177" starttime="20190402 07:05:23.176"></status>
</kw>
<status status="PASS" endtime="20190402 07:05:23.177" starttime="20190402 07:05:23.176"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:23.177" starttime="20190402 07:05:23.177"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:05:23.177" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:05:23.177" starttime="20190402 07:05:23.177"></status>
</kw>
<msg timestamp="20190402 07:05:23.177" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:05:23.177" starttime="20190402 07:05:22.095"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:05:23.178" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:05:23.178" starttime="20190402 07:05:23.178"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:05:23.179" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:05:23.179" starttime="20190402 07:05:23.178"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:23.179" starttime="20190402 07:05:23.178"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:23.179" starttime="20190402 07:05:22.092"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:05:28.182" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:28.182" starttime="20190402 07:05:28.181"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:28.184" starttime="20190402 07:05:28.184"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:05:28.185" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:05:28.185" starttime="20190402 07:05:28.185"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:28.186" starttime="20190402 07:05:28.185"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:28.186" starttime="20190402 07:05:28.186"></status>
</kw>
<msg timestamp="20190402 07:05:28.186" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:05:28.186" starttime="20190402 07:05:28.185"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:05:28.187" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:28.187" starttime="20190402 07:05:28.186"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:05:28.198" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:28.198" starttime="20190402 07:05:28.187"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:05:29.452" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:05:29.452" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:29.452" starttime="20190402 07:05:28.198"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:05:29.453" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:29.453" starttime="20190402 07:05:29.453"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:05:29.453" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:29.453" starttime="20190402 07:05:29.453"></status>
</kw>
<msg timestamp="20190402 07:05:29.453" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:29.453" starttime="20190402 07:05:29.452"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:05:29.455" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:05:29.455" starttime="20190402 07:05:29.454"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:05:29.455" level="INFO">0</msg>
<msg timestamp="20190402 07:05:29.456" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:29.456" starttime="20190402 07:05:29.455"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:05:29.456" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:05:29.456" starttime="20190402 07:05:29.456"></status>
</kw>
<msg timestamp="20190402 07:05:29.456" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:29.456" starttime="20190402 07:05:29.453"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:29.457" starttime="20190402 07:05:29.456"></status>
</kw>
<status status="PASS" endtime="20190402 07:05:29.457" starttime="20190402 07:05:29.456"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:29.457" starttime="20190402 07:05:29.457"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:05:29.457" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:05:29.457" starttime="20190402 07:05:29.457"></status>
</kw>
<msg timestamp="20190402 07:05:29.458" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:05:29.458" starttime="20190402 07:05:28.182"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:05:29.458" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:05:29.458" starttime="20190402 07:05:29.458"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:05:29.459" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:05:29.459" starttime="20190402 07:05:29.458"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:29.459" starttime="20190402 07:05:29.458"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:29.459" starttime="20190402 07:05:28.180"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:05:34.462" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:34.463" starttime="20190402 07:05:34.461"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:34.465" starttime="20190402 07:05:34.464"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:05:34.466" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:05:34.466" starttime="20190402 07:05:34.465"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:34.466" starttime="20190402 07:05:34.466"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:34.466" starttime="20190402 07:05:34.466"></status>
</kw>
<msg timestamp="20190402 07:05:34.467" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:05:34.467" starttime="20190402 07:05:34.465"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:05:34.467" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:34.467" starttime="20190402 07:05:34.467"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:05:34.476" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:34.476" starttime="20190402 07:05:34.467"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:05:35.650" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:05:35.650" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:35.651" starttime="20190402 07:05:34.477"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:05:35.651" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:35.651" starttime="20190402 07:05:35.651"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:05:35.652" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:35.652" starttime="20190402 07:05:35.651"></status>
</kw>
<msg timestamp="20190402 07:05:35.652" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:35.652" starttime="20190402 07:05:35.651"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:05:35.654" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:05:35.654" starttime="20190402 07:05:35.652"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:05:35.654" level="INFO">0</msg>
<msg timestamp="20190402 07:05:35.654" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:35.654" starttime="20190402 07:05:35.654"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:05:35.654" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:05:35.655" starttime="20190402 07:05:35.654"></status>
</kw>
<msg timestamp="20190402 07:05:35.655" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:35.655" starttime="20190402 07:05:35.652"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:35.655" starttime="20190402 07:05:35.655"></status>
</kw>
<status status="PASS" endtime="20190402 07:05:35.656" starttime="20190402 07:05:35.655"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:35.656" starttime="20190402 07:05:35.656"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:05:35.656" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:05:35.656" starttime="20190402 07:05:35.656"></status>
</kw>
<msg timestamp="20190402 07:05:35.656" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:05:35.656" starttime="20190402 07:05:34.463"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:05:35.657" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:05:35.657" starttime="20190402 07:05:35.657"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:05:35.657" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:05:35.658" starttime="20190402 07:05:35.657"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:35.658" starttime="20190402 07:05:35.657"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:35.658" starttime="20190402 07:05:34.460"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:05:40.661" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:40.661" starttime="20190402 07:05:40.660"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:40.663" starttime="20190402 07:05:40.663"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:05:40.664" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:05:40.664" starttime="20190402 07:05:40.663"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:40.664" starttime="20190402 07:05:40.664"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:40.664" starttime="20190402 07:05:40.664"></status>
</kw>
<msg timestamp="20190402 07:05:40.665" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:05:40.665" starttime="20190402 07:05:40.663"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:05:40.665" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:40.665" starttime="20190402 07:05:40.665"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:05:40.674" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:40.674" starttime="20190402 07:05:40.665"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:05:41.684" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:05:41.684" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:41.684" starttime="20190402 07:05:40.674"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:05:41.685" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:41.685" starttime="20190402 07:05:41.685"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:05:41.686" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:41.686" starttime="20190402 07:05:41.685"></status>
</kw>
<msg timestamp="20190402 07:05:41.686" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:41.686" starttime="20190402 07:05:41.685"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:05:41.687" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:05:41.687" starttime="20190402 07:05:41.686"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:05:41.688" level="INFO">0</msg>
<msg timestamp="20190402 07:05:41.688" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:41.688" starttime="20190402 07:05:41.687"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:05:41.688" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:05:41.688" starttime="20190402 07:05:41.688"></status>
</kw>
<msg timestamp="20190402 07:05:41.688" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:41.688" starttime="20190402 07:05:41.686"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:41.689" starttime="20190402 07:05:41.689"></status>
</kw>
<status status="PASS" endtime="20190402 07:05:41.689" starttime="20190402 07:05:41.688"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:41.689" starttime="20190402 07:05:41.689"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:05:41.690" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:05:41.690" starttime="20190402 07:05:41.690"></status>
</kw>
<msg timestamp="20190402 07:05:41.690" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:05:41.690" starttime="20190402 07:05:40.662"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:05:41.690" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:05:41.690" starttime="20190402 07:05:41.690"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:05:41.691" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:05:41.691" starttime="20190402 07:05:41.691"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:41.691" starttime="20190402 07:05:41.690"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:41.691" starttime="20190402 07:05:40.658"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:05:46.695" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:46.695" starttime="20190402 07:05:46.694"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:46.697" starttime="20190402 07:05:46.697"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:05:46.698" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:05:46.698" starttime="20190402 07:05:46.698"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:46.698" starttime="20190402 07:05:46.698"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:46.699" starttime="20190402 07:05:46.698"></status>
</kw>
<msg timestamp="20190402 07:05:46.699" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:05:46.699" starttime="20190402 07:05:46.697"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:05:46.699" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:46.699" starttime="20190402 07:05:46.699"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:05:46.709" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:46.709" starttime="20190402 07:05:46.699"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:05:47.722" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:05:47.722" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:47.722" starttime="20190402 07:05:46.709"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:05:47.723" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:47.723" starttime="20190402 07:05:47.723"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:05:47.724" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:47.724" starttime="20190402 07:05:47.723"></status>
</kw>
<msg timestamp="20190402 07:05:47.724" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:47.724" starttime="20190402 07:05:47.723"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:05:47.725" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:05:47.725" starttime="20190402 07:05:47.724"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:05:47.726" level="INFO">0</msg>
<msg timestamp="20190402 07:05:47.726" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:47.726" starttime="20190402 07:05:47.725"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:05:47.726" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:05:47.726" starttime="20190402 07:05:47.726"></status>
</kw>
<msg timestamp="20190402 07:05:47.726" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:47.726" starttime="20190402 07:05:47.724"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:47.727" starttime="20190402 07:05:47.727"></status>
</kw>
<status status="PASS" endtime="20190402 07:05:47.727" starttime="20190402 07:05:47.727"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:47.728" starttime="20190402 07:05:47.727"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:05:47.728" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:05:47.728" starttime="20190402 07:05:47.728"></status>
</kw>
<msg timestamp="20190402 07:05:47.728" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:05:47.728" starttime="20190402 07:05:46.695"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:05:47.728" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:05:47.728" starttime="20190402 07:05:47.728"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:05:47.729" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:05:47.729" starttime="20190402 07:05:47.729"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:47.729" starttime="20190402 07:05:47.729"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:47.729" starttime="20190402 07:05:46.692"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:05:52.732" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:52.732" starttime="20190402 07:05:52.731"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:52.734" starttime="20190402 07:05:52.734"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:05:52.736" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:05:52.736" starttime="20190402 07:05:52.735"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:52.736" starttime="20190402 07:05:52.736"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:52.736" starttime="20190402 07:05:52.736"></status>
</kw>
<msg timestamp="20190402 07:05:52.737" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:05:52.737" starttime="20190402 07:05:52.735"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:05:52.737" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:52.737" starttime="20190402 07:05:52.737"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:05:52.747" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:52.747" starttime="20190402 07:05:52.737"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:05:53.868" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:05:53.868" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:53.868" starttime="20190402 07:05:52.747"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:05:53.869" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:53.869" starttime="20190402 07:05:53.869"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:05:53.870" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:53.870" starttime="20190402 07:05:53.869"></status>
</kw>
<msg timestamp="20190402 07:05:53.870" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:53.870" starttime="20190402 07:05:53.869"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:05:53.872" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:05:53.872" starttime="20190402 07:05:53.870"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:05:53.872" level="INFO">0</msg>
<msg timestamp="20190402 07:05:53.872" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:53.872" starttime="20190402 07:05:53.872"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:05:53.872" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:05:53.872" starttime="20190402 07:05:53.872"></status>
</kw>
<msg timestamp="20190402 07:05:53.873" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:53.873" starttime="20190402 07:05:53.870"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:53.873" starttime="20190402 07:05:53.873"></status>
</kw>
<status status="PASS" endtime="20190402 07:05:53.873" starttime="20190402 07:05:53.873"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:53.874" starttime="20190402 07:05:53.873"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:05:53.874" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:05:53.874" starttime="20190402 07:05:53.874"></status>
</kw>
<msg timestamp="20190402 07:05:53.874" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:05:53.874" starttime="20190402 07:05:52.733"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:05:53.875" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:05:53.875" starttime="20190402 07:05:53.874"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:05:53.875" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:05:53.875" starttime="20190402 07:05:53.875"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:53.875" starttime="20190402 07:05:53.875"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:53.876" starttime="20190402 07:05:52.730"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:05:58.879" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:58.879" starttime="20190402 07:05:58.878"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:58.881" starttime="20190402 07:05:58.881"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:05:58.882" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:05:58.882" starttime="20190402 07:05:58.881"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:58.882" starttime="20190402 07:05:58.882"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:58.882" starttime="20190402 07:05:58.882"></status>
</kw>
<msg timestamp="20190402 07:05:58.883" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:05:58.883" starttime="20190402 07:05:58.881"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:05:58.883" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:58.883" starttime="20190402 07:05:58.883"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:05:58.893" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:05:58.893" starttime="20190402 07:05:58.883"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:05:59.959" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:05:59.959" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:59.959" starttime="20190402 07:05:58.893"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:05:59.960" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:05:59.960" starttime="20190402 07:05:59.960"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:05:59.960" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:59.960" starttime="20190402 07:05:59.960"></status>
</kw>
<msg timestamp="20190402 07:05:59.960" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:05:59.960" starttime="20190402 07:05:59.959"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:05:59.962" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:05:59.962" starttime="20190402 07:05:59.961"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:05:59.963" level="INFO">0</msg>
<msg timestamp="20190402 07:05:59.963" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:59.963" starttime="20190402 07:05:59.962"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:05:59.963" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:05:59.963" starttime="20190402 07:05:59.963"></status>
</kw>
<msg timestamp="20190402 07:05:59.963" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:05:59.963" starttime="20190402 07:05:59.960"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:59.964" starttime="20190402 07:05:59.964"></status>
</kw>
<status status="PASS" endtime="20190402 07:05:59.964" starttime="20190402 07:05:59.963"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:05:59.964" starttime="20190402 07:05:59.964"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:05:59.964" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:05:59.965" starttime="20190402 07:05:59.964"></status>
</kw>
<msg timestamp="20190402 07:05:59.965" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:05:59.965" starttime="20190402 07:05:58.879"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:05:59.965" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:05:59.965" starttime="20190402 07:05:59.965"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:05:59.966" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:05:59.966" starttime="20190402 07:05:59.966"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:59.966" starttime="20190402 07:05:59.965"></status>
</kw>
<status status="FAIL" endtime="20190402 07:05:59.966" starttime="20190402 07:05:58.876"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:06:04.969" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:04.969" starttime="20190402 07:06:04.968"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:04.972" starttime="20190402 07:06:04.971"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:06:04.973" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:06:04.973" starttime="20190402 07:06:04.972"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:04.973" starttime="20190402 07:06:04.973"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:04.973" starttime="20190402 07:06:04.973"></status>
</kw>
<msg timestamp="20190402 07:06:04.973" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:06:04.973" starttime="20190402 07:06:04.972"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:06:04.974" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:04.974" starttime="20190402 07:06:04.974"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:06:04.984" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:04.984" starttime="20190402 07:06:04.974"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:06:06.037" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:06:06.037" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:06.037" starttime="20190402 07:06:04.984"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:06:06.038" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:06.038" starttime="20190402 07:06:06.038"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:06:06.038" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:06.038" starttime="20190402 07:06:06.038"></status>
</kw>
<msg timestamp="20190402 07:06:06.039" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:06.039" starttime="20190402 07:06:06.037"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:06:06.040" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:06:06.041" starttime="20190402 07:06:06.039"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:06:06.041" level="INFO">0</msg>
<msg timestamp="20190402 07:06:06.041" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:06.041" starttime="20190402 07:06:06.041"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:06:06.041" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:06:06.041" starttime="20190402 07:06:06.041"></status>
</kw>
<msg timestamp="20190402 07:06:06.041" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:06.041" starttime="20190402 07:06:06.039"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:06.042" starttime="20190402 07:06:06.042"></status>
</kw>
<status status="PASS" endtime="20190402 07:06:06.042" starttime="20190402 07:06:06.042"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:06.042" starttime="20190402 07:06:06.042"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:06:06.043" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:06:06.043" starttime="20190402 07:06:06.043"></status>
</kw>
<msg timestamp="20190402 07:06:06.043" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:06:06.043" starttime="20190402 07:06:04.970"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:06:06.043" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:06:06.043" starttime="20190402 07:06:06.043"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:06:06.044" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:06:06.044" starttime="20190402 07:06:06.044"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:06.044" starttime="20190402 07:06:06.044"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:06.044" starttime="20190402 07:06:04.967"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:06:11.047" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:11.047" starttime="20190402 07:06:11.046"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:11.050" starttime="20190402 07:06:11.049"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:06:11.051" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:06:11.051" starttime="20190402 07:06:11.050"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:11.051" starttime="20190402 07:06:11.051"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:11.051" starttime="20190402 07:06:11.051"></status>
</kw>
<msg timestamp="20190402 07:06:11.052" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:06:11.052" starttime="20190402 07:06:11.050"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:06:11.052" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:11.052" starttime="20190402 07:06:11.052"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:06:11.062" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:11.062" starttime="20190402 07:06:11.052"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:06:12.092" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:06:12.092" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:12.092" starttime="20190402 07:06:11.062"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:06:12.093" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:12.093" starttime="20190402 07:06:12.092"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:06:12.093" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:12.093" starttime="20190402 07:06:12.093"></status>
</kw>
<msg timestamp="20190402 07:06:12.093" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:12.093" starttime="20190402 07:06:12.092"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:06:12.096" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:06:12.096" starttime="20190402 07:06:12.094"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:06:12.096" level="INFO">0</msg>
<msg timestamp="20190402 07:06:12.096" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:12.096" starttime="20190402 07:06:12.096"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:06:12.097" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:06:12.097" starttime="20190402 07:06:12.096"></status>
</kw>
<msg timestamp="20190402 07:06:12.097" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:12.097" starttime="20190402 07:06:12.094"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:12.098" starttime="20190402 07:06:12.097"></status>
</kw>
<status status="PASS" endtime="20190402 07:06:12.098" starttime="20190402 07:06:12.097"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:12.098" starttime="20190402 07:06:12.098"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:06:12.098" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:06:12.098" starttime="20190402 07:06:12.098"></status>
</kw>
<msg timestamp="20190402 07:06:12.098" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:06:12.098" starttime="20190402 07:06:11.048"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:06:12.099" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:06:12.099" starttime="20190402 07:06:12.099"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:06:12.100" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:06:12.100" starttime="20190402 07:06:12.099"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:12.100" starttime="20190402 07:06:12.099"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:12.100" starttime="20190402 07:06:11.045"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:06:17.103" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:17.103" starttime="20190402 07:06:17.102"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:17.106" starttime="20190402 07:06:17.105"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:06:17.107" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:06:17.107" starttime="20190402 07:06:17.106"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:17.107" starttime="20190402 07:06:17.107"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:17.107" starttime="20190402 07:06:17.107"></status>
</kw>
<msg timestamp="20190402 07:06:17.108" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:06:17.108" starttime="20190402 07:06:17.106"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:06:17.108" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:17.108" starttime="20190402 07:06:17.108"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:06:17.118" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:17.118" starttime="20190402 07:06:17.108"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:06:18.153" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:06:18.153" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:18.154" starttime="20190402 07:06:17.118"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:06:18.154" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:18.154" starttime="20190402 07:06:18.154"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:06:18.155" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:18.155" starttime="20190402 07:06:18.154"></status>
</kw>
<msg timestamp="20190402 07:06:18.155" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:18.155" starttime="20190402 07:06:18.154"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:06:18.156" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:06:18.157" starttime="20190402 07:06:18.155"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:06:18.157" level="INFO">0</msg>
<msg timestamp="20190402 07:06:18.157" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:18.157" starttime="20190402 07:06:18.157"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:06:18.157" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:06:18.157" starttime="20190402 07:06:18.157"></status>
</kw>
<msg timestamp="20190402 07:06:18.158" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:18.158" starttime="20190402 07:06:18.155"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:18.158" starttime="20190402 07:06:18.158"></status>
</kw>
<status status="PASS" endtime="20190402 07:06:18.158" starttime="20190402 07:06:18.158"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:18.159" starttime="20190402 07:06:18.158"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:06:18.159" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:06:18.159" starttime="20190402 07:06:18.159"></status>
</kw>
<msg timestamp="20190402 07:06:18.159" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:06:18.159" starttime="20190402 07:06:17.104"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:06:18.160" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:06:18.160" starttime="20190402 07:06:18.159"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:06:18.160" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:06:18.160" starttime="20190402 07:06:18.160"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:18.160" starttime="20190402 07:06:18.160"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:18.160" starttime="20190402 07:06:17.100"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:06:23.161" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:23.162" starttime="20190402 07:06:23.161"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:23.162" starttime="20190402 07:06:23.162"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:06:23.163" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:06:23.163" starttime="20190402 07:06:23.163"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:23.163" starttime="20190402 07:06:23.163"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:23.164" starttime="20190402 07:06:23.163"></status>
</kw>
<msg timestamp="20190402 07:06:23.164" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:06:23.164" starttime="20190402 07:06:23.162"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:06:23.164" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:23.164" starttime="20190402 07:06:23.164"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:06:23.172" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:23.172" starttime="20190402 07:06:23.164"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:06:24.276" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:06:24.276" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:24.276" starttime="20190402 07:06:23.172"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:06:24.277" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:24.277" starttime="20190402 07:06:24.277"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:06:24.277" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:24.277" starttime="20190402 07:06:24.277"></status>
</kw>
<msg timestamp="20190402 07:06:24.278" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:24.278" starttime="20190402 07:06:24.277"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:06:24.279" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:06:24.280" starttime="20190402 07:06:24.278"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:06:24.280" level="INFO">0</msg>
<msg timestamp="20190402 07:06:24.280" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:24.280" starttime="20190402 07:06:24.280"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:06:24.280" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:06:24.280" starttime="20190402 07:06:24.280"></status>
</kw>
<msg timestamp="20190402 07:06:24.280" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:24.280" starttime="20190402 07:06:24.278"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:24.281" starttime="20190402 07:06:24.281"></status>
</kw>
<status status="PASS" endtime="20190402 07:06:24.281" starttime="20190402 07:06:24.281"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:24.282" starttime="20190402 07:06:24.282"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:06:24.282" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:06:24.282" starttime="20190402 07:06:24.282"></status>
</kw>
<msg timestamp="20190402 07:06:24.282" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:06:24.282" starttime="20190402 07:06:23.162"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:06:24.283" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:06:24.283" starttime="20190402 07:06:24.283"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:06:24.283" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:06:24.283" starttime="20190402 07:06:24.283"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:24.284" starttime="20190402 07:06:24.283"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:24.284" starttime="20190402 07:06:23.161"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:06:29.286" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:29.286" starttime="20190402 07:06:29.285"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:29.288" starttime="20190402 07:06:29.287"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:06:29.289" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:06:29.290" starttime="20190402 07:06:29.289"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:29.290" starttime="20190402 07:06:29.290"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:29.291" starttime="20190402 07:06:29.291"></status>
</kw>
<msg timestamp="20190402 07:06:29.292" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:06:29.292" starttime="20190402 07:06:29.288"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:06:29.293" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:29.293" starttime="20190402 07:06:29.292"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:06:29.314" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:29.314" starttime="20190402 07:06:29.293"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:06:30.332" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:06:30.332" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:30.332" starttime="20190402 07:06:29.314"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:06:30.333" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:30.333" starttime="20190402 07:06:30.333"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:06:30.333" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:30.334" starttime="20190402 07:06:30.333"></status>
</kw>
<msg timestamp="20190402 07:06:30.334" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:30.334" starttime="20190402 07:06:30.333"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:06:30.335" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:06:30.335" starttime="20190402 07:06:30.334"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:06:30.336" level="INFO">0</msg>
<msg timestamp="20190402 07:06:30.336" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:30.336" starttime="20190402 07:06:30.336"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:06:30.336" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:06:30.336" starttime="20190402 07:06:30.336"></status>
</kw>
<msg timestamp="20190402 07:06:30.337" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:30.337" starttime="20190402 07:06:30.334"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:30.337" starttime="20190402 07:06:30.337"></status>
</kw>
<status status="PASS" endtime="20190402 07:06:30.337" starttime="20190402 07:06:30.337"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:30.338" starttime="20190402 07:06:30.337"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:06:30.338" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:06:30.338" starttime="20190402 07:06:30.338"></status>
</kw>
<msg timestamp="20190402 07:06:30.338" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:06:30.338" starttime="20190402 07:06:29.286"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:06:30.339" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:06:30.339" starttime="20190402 07:06:30.338"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:06:30.339" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:06:30.340" starttime="20190402 07:06:30.339"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:30.340" starttime="20190402 07:06:30.339"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:30.340" starttime="20190402 07:06:29.284"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:06:35.342" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:35.342" starttime="20190402 07:06:35.341"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:35.344" starttime="20190402 07:06:35.344"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:06:35.345" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:06:35.345" starttime="20190402 07:06:35.345"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:35.346" starttime="20190402 07:06:35.345"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:35.346" starttime="20190402 07:06:35.346"></status>
</kw>
<msg timestamp="20190402 07:06:35.346" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:06:35.346" starttime="20190402 07:06:35.344"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:06:35.346" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:35.346" starttime="20190402 07:06:35.346"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:06:35.355" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:35.355" starttime="20190402 07:06:35.347"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:06:36.443" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:06:36.444" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:36.444" starttime="20190402 07:06:35.356"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:06:36.444" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:36.444" starttime="20190402 07:06:36.444"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:06:36.445" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:36.445" starttime="20190402 07:06:36.445"></status>
</kw>
<msg timestamp="20190402 07:06:36.445" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:36.445" starttime="20190402 07:06:36.444"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:06:36.447" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:06:36.447" starttime="20190402 07:06:36.445"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:06:36.447" level="INFO">0</msg>
<msg timestamp="20190402 07:06:36.447" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:36.447" starttime="20190402 07:06:36.447"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:06:36.448" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:06:36.448" starttime="20190402 07:06:36.448"></status>
</kw>
<msg timestamp="20190402 07:06:36.448" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:36.448" starttime="20190402 07:06:36.445"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:36.449" starttime="20190402 07:06:36.448"></status>
</kw>
<status status="PASS" endtime="20190402 07:06:36.449" starttime="20190402 07:06:36.448"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:36.449" starttime="20190402 07:06:36.449"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:06:36.449" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:06:36.449" starttime="20190402 07:06:36.449"></status>
</kw>
<msg timestamp="20190402 07:06:36.450" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:06:36.450" starttime="20190402 07:06:35.342"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:06:36.450" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:06:36.450" starttime="20190402 07:06:36.450"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:06:36.451" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:06:36.451" starttime="20190402 07:06:36.450"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:36.451" starttime="20190402 07:06:36.450"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:36.451" starttime="20190402 07:06:35.340"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:06:41.454" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:41.454" starttime="20190402 07:06:41.453"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:41.457" starttime="20190402 07:06:41.456"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:06:41.458" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:06:41.458" starttime="20190402 07:06:41.457"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:41.458" starttime="20190402 07:06:41.458"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:41.458" starttime="20190402 07:06:41.458"></status>
</kw>
<msg timestamp="20190402 07:06:41.459" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:06:41.459" starttime="20190402 07:06:41.457"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:06:41.459" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:41.459" starttime="20190402 07:06:41.459"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:06:41.467" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:41.467" starttime="20190402 07:06:41.459"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:06:42.509" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:06:42.509" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:42.509" starttime="20190402 07:06:41.467"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:06:42.510" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:42.510" starttime="20190402 07:06:42.509"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:06:42.510" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:42.510" starttime="20190402 07:06:42.510"></status>
</kw>
<msg timestamp="20190402 07:06:42.510" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:42.510" starttime="20190402 07:06:42.509"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:06:42.512" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:06:42.512" starttime="20190402 07:06:42.511"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:06:42.513" level="INFO">0</msg>
<msg timestamp="20190402 07:06:42.513" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:42.513" starttime="20190402 07:06:42.512"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:06:42.513" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:06:42.513" starttime="20190402 07:06:42.513"></status>
</kw>
<msg timestamp="20190402 07:06:42.513" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:42.513" starttime="20190402 07:06:42.510"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:42.514" starttime="20190402 07:06:42.514"></status>
</kw>
<status status="PASS" endtime="20190402 07:06:42.514" starttime="20190402 07:06:42.513"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:42.514" starttime="20190402 07:06:42.514"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:06:42.514" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:06:42.514" starttime="20190402 07:06:42.514"></status>
</kw>
<msg timestamp="20190402 07:06:42.515" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:06:42.515" starttime="20190402 07:06:41.455"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:06:42.515" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:06:42.515" starttime="20190402 07:06:42.515"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:06:42.516" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:06:42.516" starttime="20190402 07:06:42.516"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:42.516" starttime="20190402 07:06:42.515"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:42.516" starttime="20190402 07:06:41.452"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:06:47.519" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:47.519" starttime="20190402 07:06:47.518"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:47.522" starttime="20190402 07:06:47.521"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:06:47.523" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:06:47.523" starttime="20190402 07:06:47.522"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:47.523" starttime="20190402 07:06:47.523"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:47.523" starttime="20190402 07:06:47.523"></status>
</kw>
<msg timestamp="20190402 07:06:47.524" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:06:47.524" starttime="20190402 07:06:47.522"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:06:47.524" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:47.524" starttime="20190402 07:06:47.524"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:06:47.532" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:47.532" starttime="20190402 07:06:47.524"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:06:48.662" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:06:48.662" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:48.662" starttime="20190402 07:06:47.532"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:06:48.663" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:48.663" starttime="20190402 07:06:48.662"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:06:48.663" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:48.663" starttime="20190402 07:06:48.663"></status>
</kw>
<msg timestamp="20190402 07:06:48.663" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:48.663" starttime="20190402 07:06:48.662"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:06:48.665" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:06:48.665" starttime="20190402 07:06:48.663"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:06:48.665" level="INFO">0</msg>
<msg timestamp="20190402 07:06:48.665" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:48.665" starttime="20190402 07:06:48.665"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:06:48.666" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:06:48.666" starttime="20190402 07:06:48.666"></status>
</kw>
<msg timestamp="20190402 07:06:48.666" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:48.666" starttime="20190402 07:06:48.663"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:48.667" starttime="20190402 07:06:48.666"></status>
</kw>
<status status="PASS" endtime="20190402 07:06:48.667" starttime="20190402 07:06:48.666"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:48.667" starttime="20190402 07:06:48.667"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:06:48.667" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:06:48.667" starttime="20190402 07:06:48.667"></status>
</kw>
<msg timestamp="20190402 07:06:48.668" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:06:48.668" starttime="20190402 07:06:47.520"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:06:48.668" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:06:48.668" starttime="20190402 07:06:48.668"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:06:48.669" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:06:48.669" starttime="20190402 07:06:48.668"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:48.669" starttime="20190402 07:06:48.668"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:48.669" starttime="20190402 07:06:47.517"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:06:53.672" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:53.673" starttime="20190402 07:06:53.671"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:53.675" starttime="20190402 07:06:53.675"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:06:53.676" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:06:53.676" starttime="20190402 07:06:53.675"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:53.676" starttime="20190402 07:06:53.676"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:53.676" starttime="20190402 07:06:53.676"></status>
</kw>
<msg timestamp="20190402 07:06:53.677" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:06:53.677" starttime="20190402 07:06:53.675"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:06:53.677" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:53.677" starttime="20190402 07:06:53.677"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:06:53.686" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:53.687" starttime="20190402 07:06:53.677"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:06:54.725" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:06:54.725" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:54.725" starttime="20190402 07:06:53.687"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:06:54.726" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:54.726" starttime="20190402 07:06:54.725"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:06:54.726" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:54.726" starttime="20190402 07:06:54.726"></status>
</kw>
<msg timestamp="20190402 07:06:54.726" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:06:54.726" starttime="20190402 07:06:54.725"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:06:54.728" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:06:54.728" starttime="20190402 07:06:54.726"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:06:54.728" level="INFO">0</msg>
<msg timestamp="20190402 07:06:54.728" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:54.728" starttime="20190402 07:06:54.728"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:06:54.729" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:06:54.729" starttime="20190402 07:06:54.728"></status>
</kw>
<msg timestamp="20190402 07:06:54.729" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:06:54.729" starttime="20190402 07:06:54.726"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:54.729" starttime="20190402 07:06:54.729"></status>
</kw>
<status status="PASS" endtime="20190402 07:06:54.730" starttime="20190402 07:06:54.729"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:54.730" starttime="20190402 07:06:54.730"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:06:54.730" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:06:54.730" starttime="20190402 07:06:54.730"></status>
</kw>
<msg timestamp="20190402 07:06:54.730" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:06:54.730" starttime="20190402 07:06:53.673"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:06:54.731" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:06:54.731" starttime="20190402 07:06:54.731"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:06:54.731" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:06:54.732" starttime="20190402 07:06:54.731"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:54.732" starttime="20190402 07:06:54.731"></status>
</kw>
<status status="FAIL" endtime="20190402 07:06:54.732" starttime="20190402 07:06:53.670"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:06:59.733" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:59.733" starttime="20190402 07:06:59.732"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:59.734" starttime="20190402 07:06:59.733"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:06:59.734" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:06:59.734" starttime="20190402 07:06:59.734"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:59.735" starttime="20190402 07:06:59.735"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:06:59.735" starttime="20190402 07:06:59.735"></status>
</kw>
<msg timestamp="20190402 07:06:59.735" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:06:59.735" starttime="20190402 07:06:59.734"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:06:59.736" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:06:59.736" starttime="20190402 07:06:59.735"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:06:59.745" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:06:59.745" starttime="20190402 07:06:59.736"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:07:00.781" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:07:00.781" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:00.781" starttime="20190402 07:06:59.745"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:07:00.782" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:00.782" starttime="20190402 07:07:00.782"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:07:00.783" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:00.783" starttime="20190402 07:07:00.782"></status>
</kw>
<msg timestamp="20190402 07:07:00.783" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:00.783" starttime="20190402 07:07:00.782"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:07:00.785" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:07:00.785" starttime="20190402 07:07:00.783"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:07:00.785" level="INFO">0</msg>
<msg timestamp="20190402 07:07:00.785" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:00.785" starttime="20190402 07:07:00.785"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:07:00.786" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:07:00.786" starttime="20190402 07:07:00.785"></status>
</kw>
<msg timestamp="20190402 07:07:00.786" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:00.786" starttime="20190402 07:07:00.783"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:00.787" starttime="20190402 07:07:00.786"></status>
</kw>
<status status="PASS" endtime="20190402 07:07:00.787" starttime="20190402 07:07:00.786"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:00.787" starttime="20190402 07:07:00.787"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:07:00.787" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:07:00.787" starttime="20190402 07:07:00.787"></status>
</kw>
<msg timestamp="20190402 07:07:00.787" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:07:00.787" starttime="20190402 07:06:59.733"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:07:00.788" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:07:00.788" starttime="20190402 07:07:00.788"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:07:00.788" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:07:00.789" starttime="20190402 07:07:00.788"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:00.789" starttime="20190402 07:07:00.788"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:00.789" starttime="20190402 07:06:59.732"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:07:05.790" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:05.790" starttime="20190402 07:07:05.789"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:05.791" starttime="20190402 07:07:05.790"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:07:05.791" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:07:05.791" starttime="20190402 07:07:05.791"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:05.792" starttime="20190402 07:07:05.792"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:05.792" starttime="20190402 07:07:05.792"></status>
</kw>
<msg timestamp="20190402 07:07:05.792" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:07:05.792" starttime="20190402 07:07:05.791"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:07:05.793" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:05.793" starttime="20190402 07:07:05.793"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:07:05.802" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:05.802" starttime="20190402 07:07:05.793"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:07:06.858" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:07:06.858" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:06.858" starttime="20190402 07:07:05.802"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:07:06.859" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:06.859" starttime="20190402 07:07:06.859"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:07:06.859" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:06.859" starttime="20190402 07:07:06.859"></status>
</kw>
<msg timestamp="20190402 07:07:06.859" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:06.859" starttime="20190402 07:07:06.858"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:07:06.861" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:07:06.861" starttime="20190402 07:07:06.860"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:07:06.862" level="INFO">0</msg>
<msg timestamp="20190402 07:07:06.862" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:06.862" starttime="20190402 07:07:06.861"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:07:06.862" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:07:06.862" starttime="20190402 07:07:06.862"></status>
</kw>
<msg timestamp="20190402 07:07:06.862" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:06.862" starttime="20190402 07:07:06.860"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:06.863" starttime="20190402 07:07:06.863"></status>
</kw>
<status status="PASS" endtime="20190402 07:07:06.863" starttime="20190402 07:07:06.863"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:06.864" starttime="20190402 07:07:06.863"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:07:06.864" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:07:06.864" starttime="20190402 07:07:06.864"></status>
</kw>
<msg timestamp="20190402 07:07:06.864" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:07:06.864" starttime="20190402 07:07:05.790"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:07:06.865" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:07:06.865" starttime="20190402 07:07:06.864"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:07:06.865" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:07:06.865" starttime="20190402 07:07:06.865"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:06.865" starttime="20190402 07:07:06.865"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:06.865" starttime="20190402 07:07:05.789"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:07:11.867" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:11.867" starttime="20190402 07:07:11.866"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:11.867" starttime="20190402 07:07:11.867"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:07:11.868" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:07:11.868" starttime="20190402 07:07:11.868"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:11.869" starttime="20190402 07:07:11.868"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:11.869" starttime="20190402 07:07:11.869"></status>
</kw>
<msg timestamp="20190402 07:07:11.869" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:07:11.869" starttime="20190402 07:07:11.867"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:07:11.869" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:11.870" starttime="20190402 07:07:11.869"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:07:11.878" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:11.878" starttime="20190402 07:07:11.870"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:07:12.907" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:07:12.907" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:12.907" starttime="20190402 07:07:11.878"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:07:12.908" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:12.908" starttime="20190402 07:07:12.907"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:07:12.908" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:12.908" starttime="20190402 07:07:12.908"></status>
</kw>
<msg timestamp="20190402 07:07:12.908" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:12.908" starttime="20190402 07:07:12.907"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:07:12.910" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:07:12.910" starttime="20190402 07:07:12.909"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:07:12.910" level="INFO">0</msg>
<msg timestamp="20190402 07:07:12.910" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:12.911" starttime="20190402 07:07:12.910"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:07:12.911" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:07:12.911" starttime="20190402 07:07:12.911"></status>
</kw>
<msg timestamp="20190402 07:07:12.911" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:12.911" starttime="20190402 07:07:12.908"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:12.912" starttime="20190402 07:07:12.912"></status>
</kw>
<status status="PASS" endtime="20190402 07:07:12.912" starttime="20190402 07:07:12.911"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:12.913" starttime="20190402 07:07:12.912"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:07:12.913" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:07:12.913" starttime="20190402 07:07:12.913"></status>
</kw>
<msg timestamp="20190402 07:07:12.913" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:07:12.913" starttime="20190402 07:07:11.867"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:07:12.913" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:07:12.914" starttime="20190402 07:07:12.913"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:07:12.914" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:07:12.914" starttime="20190402 07:07:12.914"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:12.914" starttime="20190402 07:07:12.914"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:12.914" starttime="20190402 07:07:11.866"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:07:17.915" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:17.915" starttime="20190402 07:07:17.915"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:17.916" starttime="20190402 07:07:17.916"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:07:17.917" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:07:17.917" starttime="20190402 07:07:17.917"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:17.917" starttime="20190402 07:07:17.917"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:17.918" starttime="20190402 07:07:17.917"></status>
</kw>
<msg timestamp="20190402 07:07:17.918" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:07:17.918" starttime="20190402 07:07:17.916"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:07:17.918" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:17.918" starttime="20190402 07:07:17.918"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:07:17.927" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:17.927" starttime="20190402 07:07:17.918"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:07:19.030" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:07:19.031" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:19.031" starttime="20190402 07:07:17.927"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:07:19.031" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:19.031" starttime="20190402 07:07:19.031"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:07:19.032" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:19.032" starttime="20190402 07:07:19.031"></status>
</kw>
<msg timestamp="20190402 07:07:19.032" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:19.032" starttime="20190402 07:07:19.031"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:07:19.034" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:07:19.034" starttime="20190402 07:07:19.032"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:07:19.034" level="INFO">0</msg>
<msg timestamp="20190402 07:07:19.034" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:19.034" starttime="20190402 07:07:19.034"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:07:19.035" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:07:19.035" starttime="20190402 07:07:19.035"></status>
</kw>
<msg timestamp="20190402 07:07:19.035" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:19.035" starttime="20190402 07:07:19.032"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:19.036" starttime="20190402 07:07:19.035"></status>
</kw>
<status status="PASS" endtime="20190402 07:07:19.036" starttime="20190402 07:07:19.035"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:19.036" starttime="20190402 07:07:19.036"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:07:19.036" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:07:19.036" starttime="20190402 07:07:19.036"></status>
</kw>
<msg timestamp="20190402 07:07:19.037" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:07:19.037" starttime="20190402 07:07:17.916"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:07:19.037" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:07:19.037" starttime="20190402 07:07:19.037"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:07:19.038" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:07:19.038" starttime="20190402 07:07:19.037"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:19.038" starttime="20190402 07:07:19.037"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:19.038" starttime="20190402 07:07:17.915"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:07:24.039" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:24.039" starttime="20190402 07:07:24.039"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:24.041" starttime="20190402 07:07:24.040"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:07:24.042" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:07:24.042" starttime="20190402 07:07:24.041"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:24.043" starttime="20190402 07:07:24.042"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:24.043" starttime="20190402 07:07:24.043"></status>
</kw>
<msg timestamp="20190402 07:07:24.043" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:07:24.044" starttime="20190402 07:07:24.041"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:07:24.044" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:24.044" starttime="20190402 07:07:24.044"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:07:24.059" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:24.059" starttime="20190402 07:07:24.044"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:07:25.077" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:07:25.078" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:25.078" starttime="20190402 07:07:24.059"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:07:25.079" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:25.079" starttime="20190402 07:07:25.078"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:07:25.079" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:25.079" starttime="20190402 07:07:25.079"></status>
</kw>
<msg timestamp="20190402 07:07:25.079" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:25.079" starttime="20190402 07:07:25.078"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:07:25.081" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:07:25.081" starttime="20190402 07:07:25.079"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:07:25.082" level="INFO">0</msg>
<msg timestamp="20190402 07:07:25.082" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:25.082" starttime="20190402 07:07:25.081"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:07:25.082" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:07:25.082" starttime="20190402 07:07:25.082"></status>
</kw>
<msg timestamp="20190402 07:07:25.082" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:25.082" starttime="20190402 07:07:25.079"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:25.083" starttime="20190402 07:07:25.083"></status>
</kw>
<status status="PASS" endtime="20190402 07:07:25.083" starttime="20190402 07:07:25.082"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:25.083" starttime="20190402 07:07:25.083"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:07:25.084" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:07:25.084" starttime="20190402 07:07:25.084"></status>
</kw>
<msg timestamp="20190402 07:07:25.084" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:07:25.084" starttime="20190402 07:07:24.040"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:07:25.084" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:07:25.084" starttime="20190402 07:07:25.084"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:07:25.085" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:07:25.085" starttime="20190402 07:07:25.085"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:25.085" starttime="20190402 07:07:25.085"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:25.085" starttime="20190402 07:07:24.038"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:07:30.086" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:30.086" starttime="20190402 07:07:30.086"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:30.087" starttime="20190402 07:07:30.087"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:07:30.088" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:07:30.088" starttime="20190402 07:07:30.087"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:30.088" starttime="20190402 07:07:30.088"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:30.088" starttime="20190402 07:07:30.088"></status>
</kw>
<msg timestamp="20190402 07:07:30.089" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:07:30.089" starttime="20190402 07:07:30.087"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:07:30.089" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:30.089" starttime="20190402 07:07:30.089"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:07:30.098" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:30.098" starttime="20190402 07:07:30.089"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:07:31.118" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:07:31.119" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:31.119" starttime="20190402 07:07:30.098"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:07:31.119" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:31.119" starttime="20190402 07:07:31.119"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:07:31.120" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:31.120" starttime="20190402 07:07:31.119"></status>
</kw>
<msg timestamp="20190402 07:07:31.120" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:31.120" starttime="20190402 07:07:31.119"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:07:31.122" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:07:31.122" starttime="20190402 07:07:31.120"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:07:31.122" level="INFO">0</msg>
<msg timestamp="20190402 07:07:31.123" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:31.123" starttime="20190402 07:07:31.122"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:07:31.123" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:07:31.123" starttime="20190402 07:07:31.123"></status>
</kw>
<msg timestamp="20190402 07:07:31.123" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:31.123" starttime="20190402 07:07:31.120"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:31.124" starttime="20190402 07:07:31.123"></status>
</kw>
<status status="PASS" endtime="20190402 07:07:31.124" starttime="20190402 07:07:31.123"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:31.124" starttime="20190402 07:07:31.124"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:07:31.125" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:07:31.125" starttime="20190402 07:07:31.124"></status>
</kw>
<msg timestamp="20190402 07:07:31.125" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:07:31.125" starttime="20190402 07:07:30.086"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:07:31.125" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:07:31.125" starttime="20190402 07:07:31.125"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:07:31.126" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:07:31.126" starttime="20190402 07:07:31.126"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:31.126" starttime="20190402 07:07:31.125"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:31.126" starttime="20190402 07:07:30.086"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:07:36.129" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:36.129" starttime="20190402 07:07:36.128"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:36.131" starttime="20190402 07:07:36.130"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:07:36.133" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:07:36.133" starttime="20190402 07:07:36.132"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:36.134" starttime="20190402 07:07:36.133"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:36.135" starttime="20190402 07:07:36.134"></status>
</kw>
<msg timestamp="20190402 07:07:36.135" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:07:36.135" starttime="20190402 07:07:36.131"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:07:36.136" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:36.136" starttime="20190402 07:07:36.136"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:07:36.146" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:36.146" starttime="20190402 07:07:36.136"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:07:37.196" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:07:37.196" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:37.196" starttime="20190402 07:07:36.146"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:07:37.197" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:37.197" starttime="20190402 07:07:37.197"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:07:37.198" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:37.198" starttime="20190402 07:07:37.197"></status>
</kw>
<msg timestamp="20190402 07:07:37.198" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:37.198" starttime="20190402 07:07:37.197"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:07:37.199" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:07:37.200" starttime="20190402 07:07:37.198"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:07:37.200" level="INFO">0</msg>
<msg timestamp="20190402 07:07:37.200" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:37.200" starttime="20190402 07:07:37.200"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:07:37.200" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:07:37.201" starttime="20190402 07:07:37.200"></status>
</kw>
<msg timestamp="20190402 07:07:37.201" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:37.201" starttime="20190402 07:07:37.198"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:37.201" starttime="20190402 07:07:37.201"></status>
</kw>
<status status="PASS" endtime="20190402 07:07:37.201" starttime="20190402 07:07:37.201"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:37.202" starttime="20190402 07:07:37.202"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:07:37.202" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:07:37.202" starttime="20190402 07:07:37.202"></status>
</kw>
<msg timestamp="20190402 07:07:37.202" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:07:37.202" starttime="20190402 07:07:36.129"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:07:37.203" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:07:37.203" starttime="20190402 07:07:37.202"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:07:37.203" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:07:37.203" starttime="20190402 07:07:37.203"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:37.204" starttime="20190402 07:07:37.203"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:37.204" starttime="20190402 07:07:36.127"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:07:42.206" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:42.206" starttime="20190402 07:07:42.205"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:42.209" starttime="20190402 07:07:42.208"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:07:42.209" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:07:42.210" starttime="20190402 07:07:42.209"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:42.210" starttime="20190402 07:07:42.210"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:42.210" starttime="20190402 07:07:42.210"></status>
</kw>
<msg timestamp="20190402 07:07:42.210" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:07:42.210" starttime="20190402 07:07:42.209"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:07:42.211" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:42.211" starttime="20190402 07:07:42.211"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:07:42.220" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:42.220" starttime="20190402 07:07:42.211"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:07:43.249" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:07:43.249" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:43.249" starttime="20190402 07:07:42.220"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:07:43.250" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:43.250" starttime="20190402 07:07:43.250"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:07:43.250" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:43.250" starttime="20190402 07:07:43.250"></status>
</kw>
<msg timestamp="20190402 07:07:43.250" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:43.250" starttime="20190402 07:07:43.249"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:07:43.252" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:07:43.252" starttime="20190402 07:07:43.251"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:07:43.252" level="INFO">0</msg>
<msg timestamp="20190402 07:07:43.252" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:43.252" starttime="20190402 07:07:43.252"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:07:43.253" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:07:43.253" starttime="20190402 07:07:43.252"></status>
</kw>
<msg timestamp="20190402 07:07:43.253" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:43.253" starttime="20190402 07:07:43.250"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:43.254" starttime="20190402 07:07:43.253"></status>
</kw>
<status status="PASS" endtime="20190402 07:07:43.254" starttime="20190402 07:07:43.253"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:43.254" starttime="20190402 07:07:43.254"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:07:43.254" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:07:43.254" starttime="20190402 07:07:43.254"></status>
</kw>
<msg timestamp="20190402 07:07:43.255" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:07:43.255" starttime="20190402 07:07:42.207"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:07:43.255" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:07:43.255" starttime="20190402 07:07:43.255"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:07:43.256" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:07:43.256" starttime="20190402 07:07:43.255"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:43.256" starttime="20190402 07:07:43.255"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:43.256" starttime="20190402 07:07:42.204"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:07:48.259" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:48.259" starttime="20190402 07:07:48.258"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:48.261" starttime="20190402 07:07:48.260"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:07:48.262" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:07:48.262" starttime="20190402 07:07:48.262"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:48.263" starttime="20190402 07:07:48.262"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:48.263" starttime="20190402 07:07:48.263"></status>
</kw>
<msg timestamp="20190402 07:07:48.263" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:07:48.263" starttime="20190402 07:07:48.262"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:07:48.264" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:48.264" starttime="20190402 07:07:48.263"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:07:48.272" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:48.273" starttime="20190402 07:07:48.264"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:07:49.371" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:07:49.371" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:49.371" starttime="20190402 07:07:48.273"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:07:49.372" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:49.372" starttime="20190402 07:07:49.372"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:07:49.372" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:49.372" starttime="20190402 07:07:49.372"></status>
</kw>
<msg timestamp="20190402 07:07:49.373" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:49.373" starttime="20190402 07:07:49.372"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:07:49.374" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:07:49.374" starttime="20190402 07:07:49.373"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:07:49.375" level="INFO">0</msg>
<msg timestamp="20190402 07:07:49.375" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:49.375" starttime="20190402 07:07:49.374"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:07:49.375" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:07:49.375" starttime="20190402 07:07:49.375"></status>
</kw>
<msg timestamp="20190402 07:07:49.375" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:49.375" starttime="20190402 07:07:49.373"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:49.376" starttime="20190402 07:07:49.376"></status>
</kw>
<status status="PASS" endtime="20190402 07:07:49.376" starttime="20190402 07:07:49.375"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:49.376" starttime="20190402 07:07:49.376"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:07:49.377" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:07:49.377" starttime="20190402 07:07:49.376"></status>
</kw>
<msg timestamp="20190402 07:07:49.377" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:07:49.377" starttime="20190402 07:07:48.259"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:07:49.377" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:07:49.377" starttime="20190402 07:07:49.377"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:07:49.378" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:07:49.378" starttime="20190402 07:07:49.378"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:49.378" starttime="20190402 07:07:49.378"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:49.378" starttime="20190402 07:07:48.257"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:07:54.381" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:54.381" starttime="20190402 07:07:54.380"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:54.384" starttime="20190402 07:07:54.383"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:07:54.385" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:07:54.385" starttime="20190402 07:07:54.384"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:54.385" starttime="20190402 07:07:54.385"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:54.385" starttime="20190402 07:07:54.385"></status>
</kw>
<msg timestamp="20190402 07:07:54.385" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:07:54.385" starttime="20190402 07:07:54.384"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:07:54.386" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:54.386" starttime="20190402 07:07:54.386"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:07:54.396" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:07:54.396" starttime="20190402 07:07:54.386"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:07:55.437" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:07:55.437" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:55.437" starttime="20190402 07:07:54.396"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:07:55.438" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:07:55.438" starttime="20190402 07:07:55.438"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:07:55.438" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:55.438" starttime="20190402 07:07:55.438"></status>
</kw>
<msg timestamp="20190402 07:07:55.439" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:07:55.439" starttime="20190402 07:07:55.437"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:07:55.440" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:07:55.440" starttime="20190402 07:07:55.439"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:07:55.441" level="INFO">0</msg>
<msg timestamp="20190402 07:07:55.441" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:55.441" starttime="20190402 07:07:55.440"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:07:55.441" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:07:55.441" starttime="20190402 07:07:55.441"></status>
</kw>
<msg timestamp="20190402 07:07:55.441" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:07:55.441" starttime="20190402 07:07:55.439"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:55.442" starttime="20190402 07:07:55.442"></status>
</kw>
<status status="PASS" endtime="20190402 07:07:55.442" starttime="20190402 07:07:55.442"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:07:55.443" starttime="20190402 07:07:55.442"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:07:55.443" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:07:55.443" starttime="20190402 07:07:55.443"></status>
</kw>
<msg timestamp="20190402 07:07:55.443" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:07:55.443" starttime="20190402 07:07:54.382"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:07:55.444" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:07:55.444" starttime="20190402 07:07:55.443"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:07:55.444" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:07:55.445" starttime="20190402 07:07:55.444"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:55.445" starttime="20190402 07:07:55.444"></status>
</kw>
<status status="FAIL" endtime="20190402 07:07:55.445" starttime="20190402 07:07:54.379"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:08:00.448" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:00.448" starttime="20190402 07:08:00.447"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:00.450" starttime="20190402 07:08:00.450"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:08:00.451" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:08:00.451" starttime="20190402 07:08:00.450"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:00.451" starttime="20190402 07:08:00.451"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:00.451" starttime="20190402 07:08:00.451"></status>
</kw>
<msg timestamp="20190402 07:08:00.452" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:08:00.452" starttime="20190402 07:08:00.450"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:08:00.452" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:00.452" starttime="20190402 07:08:00.452"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:08:00.461" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:00.461" starttime="20190402 07:08:00.452"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:08:01.484" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:08:01.485" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:01.485" starttime="20190402 07:08:00.461"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:08:01.485" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:01.485" starttime="20190402 07:08:01.485"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:08:01.486" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:01.486" starttime="20190402 07:08:01.486"></status>
</kw>
<msg timestamp="20190402 07:08:01.486" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:01.486" starttime="20190402 07:08:01.485"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:08:01.488" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:08:01.488" starttime="20190402 07:08:01.486"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:08:01.488" level="INFO">0</msg>
<msg timestamp="20190402 07:08:01.488" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:01.488" starttime="20190402 07:08:01.488"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:08:01.489" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:08:01.489" starttime="20190402 07:08:01.488"></status>
</kw>
<msg timestamp="20190402 07:08:01.489" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:01.489" starttime="20190402 07:08:01.486"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:01.490" starttime="20190402 07:08:01.489"></status>
</kw>
<status status="PASS" endtime="20190402 07:08:01.490" starttime="20190402 07:08:01.489"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:01.490" starttime="20190402 07:08:01.490"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:08:01.490" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:08:01.490" starttime="20190402 07:08:01.490"></status>
</kw>
<msg timestamp="20190402 07:08:01.490" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:08:01.491" starttime="20190402 07:08:00.448"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:08:01.491" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:08:01.491" starttime="20190402 07:08:01.491"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:08:01.492" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:08:01.492" starttime="20190402 07:08:01.491"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:01.492" starttime="20190402 07:08:01.491"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:01.492" starttime="20190402 07:08:00.445"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:08:06.495" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:06.495" starttime="20190402 07:08:06.494"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:06.498" starttime="20190402 07:08:06.497"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:08:06.498" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:08:06.499" starttime="20190402 07:08:06.498"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:06.499" starttime="20190402 07:08:06.499"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:06.499" starttime="20190402 07:08:06.499"></status>
</kw>
<msg timestamp="20190402 07:08:06.499" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:08:06.500" starttime="20190402 07:08:06.498"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:08:06.500" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:06.500" starttime="20190402 07:08:06.500"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:08:06.502" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:06.502" starttime="20190402 07:08:06.500"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:08:08.072" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:08:08.072" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:08.072" starttime="20190402 07:08:06.502"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:08:08.073" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:08.073" starttime="20190402 07:08:08.072"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:08:08.073" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:08.073" starttime="20190402 07:08:08.073"></status>
</kw>
<msg timestamp="20190402 07:08:08.073" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:08.073" starttime="20190402 07:08:08.072"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:08:08.076" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:08:08.076" starttime="20190402 07:08:08.073"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:08:08.076" level="INFO">0</msg>
<msg timestamp="20190402 07:08:08.076" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:08.076" starttime="20190402 07:08:08.076"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:08:08.076" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:08:08.077" starttime="20190402 07:08:08.076"></status>
</kw>
<msg timestamp="20190402 07:08:08.077" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:08.077" starttime="20190402 07:08:08.073"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:08.077" starttime="20190402 07:08:08.077"></status>
</kw>
<status status="PASS" endtime="20190402 07:08:08.077" starttime="20190402 07:08:08.077"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:08.078" starttime="20190402 07:08:08.078"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:08:08.078" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:08:08.078" starttime="20190402 07:08:08.078"></status>
</kw>
<msg timestamp="20190402 07:08:08.078" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:08:08.078" starttime="20190402 07:08:06.496"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:08:08.079" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:08:08.079" starttime="20190402 07:08:08.078"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:08:08.079" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:08:08.079" starttime="20190402 07:08:08.079"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:08.080" starttime="20190402 07:08:08.079"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:08.080" starttime="20190402 07:08:06.493"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:08:13.083" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:13.083" starttime="20190402 07:08:13.082"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:13.086" starttime="20190402 07:08:13.085"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:08:13.087" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:08:13.087" starttime="20190402 07:08:13.086"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:13.087" starttime="20190402 07:08:13.087"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:13.087" starttime="20190402 07:08:13.087"></status>
</kw>
<msg timestamp="20190402 07:08:13.088" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:08:13.088" starttime="20190402 07:08:13.086"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:08:13.088" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:13.088" starttime="20190402 07:08:13.088"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:08:13.101" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:13.101" starttime="20190402 07:08:13.088"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:08:14.360" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:08:14.360" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:14.360" starttime="20190402 07:08:13.101"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:08:14.361" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:14.361" starttime="20190402 07:08:14.361"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:08:14.361" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:14.361" starttime="20190402 07:08:14.361"></status>
</kw>
<msg timestamp="20190402 07:08:14.362" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:14.362" starttime="20190402 07:08:14.360"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:08:14.364" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:08:14.364" starttime="20190402 07:08:14.362"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:08:14.370" level="INFO">0</msg>
<msg timestamp="20190402 07:08:14.370" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:14.370" starttime="20190402 07:08:14.364"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:08:14.370" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:08:14.370" starttime="20190402 07:08:14.370"></status>
</kw>
<msg timestamp="20190402 07:08:14.371" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:14.371" starttime="20190402 07:08:14.362"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:14.371" starttime="20190402 07:08:14.371"></status>
</kw>
<status status="PASS" endtime="20190402 07:08:14.371" starttime="20190402 07:08:14.371"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:14.372" starttime="20190402 07:08:14.371"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:08:14.372" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:08:14.372" starttime="20190402 07:08:14.372"></status>
</kw>
<msg timestamp="20190402 07:08:14.372" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:08:14.372" starttime="20190402 07:08:13.084"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:08:14.373" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:08:14.373" starttime="20190402 07:08:14.372"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:08:14.373" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:08:14.373" starttime="20190402 07:08:14.373"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:14.373" starttime="20190402 07:08:14.373"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:14.374" starttime="20190402 07:08:13.081"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:08:19.377" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:19.377" starttime="20190402 07:08:19.376"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:19.380" starttime="20190402 07:08:19.379"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:08:19.382" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:08:19.383" starttime="20190402 07:08:19.381"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:19.384" starttime="20190402 07:08:19.383"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:19.385" starttime="20190402 07:08:19.384"></status>
</kw>
<msg timestamp="20190402 07:08:19.386" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:08:19.386" starttime="20190402 07:08:19.380"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:08:19.387" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:19.387" starttime="20190402 07:08:19.386"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:08:19.413" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:19.413" starttime="20190402 07:08:19.387"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:08:20.442" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:08:20.442" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:20.442" starttime="20190402 07:08:19.413"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:08:20.443" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:20.443" starttime="20190402 07:08:20.443"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:08:20.444" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:20.444" starttime="20190402 07:08:20.443"></status>
</kw>
<msg timestamp="20190402 07:08:20.444" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:20.444" starttime="20190402 07:08:20.443"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:08:20.446" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:08:20.446" starttime="20190402 07:08:20.444"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:08:20.446" level="INFO">0</msg>
<msg timestamp="20190402 07:08:20.446" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:20.446" starttime="20190402 07:08:20.446"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:08:20.446" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:08:20.446" starttime="20190402 07:08:20.446"></status>
</kw>
<msg timestamp="20190402 07:08:20.447" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:20.447" starttime="20190402 07:08:20.444"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:20.447" starttime="20190402 07:08:20.447"></status>
</kw>
<status status="PASS" endtime="20190402 07:08:20.447" starttime="20190402 07:08:20.447"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:20.448" starttime="20190402 07:08:20.447"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:08:20.448" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:08:20.448" starttime="20190402 07:08:20.448"></status>
</kw>
<msg timestamp="20190402 07:08:20.448" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:08:20.448" starttime="20190402 07:08:19.378"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:08:20.449" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:08:20.449" starttime="20190402 07:08:20.448"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:08:20.449" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:08:20.449" starttime="20190402 07:08:20.449"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:20.449" starttime="20190402 07:08:20.449"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:20.450" starttime="20190402 07:08:19.374"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:08:25.453" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:25.453" starttime="20190402 07:08:25.452"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:25.455" starttime="20190402 07:08:25.454"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:08:25.456" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:08:25.456" starttime="20190402 07:08:25.455"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:25.456" starttime="20190402 07:08:25.456"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:25.457" starttime="20190402 07:08:25.456"></status>
</kw>
<msg timestamp="20190402 07:08:25.457" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:08:25.457" starttime="20190402 07:08:25.455"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:08:25.457" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:25.457" starttime="20190402 07:08:25.457"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:08:25.471" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:25.471" starttime="20190402 07:08:25.457"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:08:26.691" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:08:26.691" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:26.691" starttime="20190402 07:08:25.471"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:08:26.692" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:26.692" starttime="20190402 07:08:26.692"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:08:26.692" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:26.692" starttime="20190402 07:08:26.692"></status>
</kw>
<msg timestamp="20190402 07:08:26.692" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:26.692" starttime="20190402 07:08:26.691"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:08:26.694" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:08:26.694" starttime="20190402 07:08:26.693"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:08:26.695" level="INFO">0</msg>
<msg timestamp="20190402 07:08:26.695" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:26.695" starttime="20190402 07:08:26.694"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:08:26.695" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:08:26.695" starttime="20190402 07:08:26.695"></status>
</kw>
<msg timestamp="20190402 07:08:26.695" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:26.695" starttime="20190402 07:08:26.692"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:26.696" starttime="20190402 07:08:26.696"></status>
</kw>
<status status="PASS" endtime="20190402 07:08:26.696" starttime="20190402 07:08:26.695"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:26.696" starttime="20190402 07:08:26.696"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:08:26.696" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:08:26.696" starttime="20190402 07:08:26.696"></status>
</kw>
<msg timestamp="20190402 07:08:26.697" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:08:26.697" starttime="20190402 07:08:25.453"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:08:26.697" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:08:26.697" starttime="20190402 07:08:26.697"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:08:26.698" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:08:26.698" starttime="20190402 07:08:26.697"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:26.698" starttime="20190402 07:08:26.697"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:26.698" starttime="20190402 07:08:25.450"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:08:31.701" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:31.701" starttime="20190402 07:08:31.700"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:31.704" starttime="20190402 07:08:31.703"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:08:31.705" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:08:31.705" starttime="20190402 07:08:31.704"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:31.705" starttime="20190402 07:08:31.705"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:31.706" starttime="20190402 07:08:31.705"></status>
</kw>
<msg timestamp="20190402 07:08:31.706" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:08:31.706" starttime="20190402 07:08:31.704"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:08:31.706" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:31.706" starttime="20190402 07:08:31.706"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:08:31.715" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:31.715" starttime="20190402 07:08:31.706"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:08:32.890" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:08:32.891" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:32.891" starttime="20190402 07:08:31.716"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:08:32.891" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:32.891" starttime="20190402 07:08:32.891"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:08:32.892" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:32.892" starttime="20190402 07:08:32.892"></status>
</kw>
<msg timestamp="20190402 07:08:32.892" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:32.892" starttime="20190402 07:08:32.891"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:08:32.894" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:08:32.894" starttime="20190402 07:08:32.892"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:08:32.894" level="INFO">0</msg>
<msg timestamp="20190402 07:08:32.894" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:32.894" starttime="20190402 07:08:32.894"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:08:32.895" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:08:32.895" starttime="20190402 07:08:32.894"></status>
</kw>
<msg timestamp="20190402 07:08:32.895" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:32.895" starttime="20190402 07:08:32.892"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:32.896" starttime="20190402 07:08:32.895"></status>
</kw>
<status status="PASS" endtime="20190402 07:08:32.896" starttime="20190402 07:08:32.895"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:32.896" starttime="20190402 07:08:32.896"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:08:32.896" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:08:32.896" starttime="20190402 07:08:32.896"></status>
</kw>
<msg timestamp="20190402 07:08:32.897" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:08:32.897" starttime="20190402 07:08:31.702"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:08:32.897" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:08:32.897" starttime="20190402 07:08:32.897"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:08:32.898" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:08:32.898" starttime="20190402 07:08:32.897"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:32.898" starttime="20190402 07:08:32.897"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:32.898" starttime="20190402 07:08:31.699"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:08:37.900" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:37.901" starttime="20190402 07:08:37.900"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:37.903" starttime="20190402 07:08:37.902"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:08:37.904" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:08:37.904" starttime="20190402 07:08:37.904"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:37.905" starttime="20190402 07:08:37.904"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:37.905" starttime="20190402 07:08:37.905"></status>
</kw>
<msg timestamp="20190402 07:08:37.905" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:08:37.906" starttime="20190402 07:08:37.903"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:08:37.906" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:37.906" starttime="20190402 07:08:37.906"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:08:37.915" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:37.915" starttime="20190402 07:08:37.906"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:08:38.937" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:08:38.937" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:38.937" starttime="20190402 07:08:37.915"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:08:38.938" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:38.938" starttime="20190402 07:08:38.937"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:08:38.938" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:38.938" starttime="20190402 07:08:38.938"></status>
</kw>
<msg timestamp="20190402 07:08:38.938" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:38.938" starttime="20190402 07:08:38.937"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:08:38.940" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:08:38.940" starttime="20190402 07:08:38.938"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:08:38.940" level="INFO">0</msg>
<msg timestamp="20190402 07:08:38.940" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:38.940" starttime="20190402 07:08:38.940"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:08:38.941" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:08:38.941" starttime="20190402 07:08:38.940"></status>
</kw>
<msg timestamp="20190402 07:08:38.941" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:38.941" starttime="20190402 07:08:38.938"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:38.942" starttime="20190402 07:08:38.941"></status>
</kw>
<status status="PASS" endtime="20190402 07:08:38.942" starttime="20190402 07:08:38.941"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:38.942" starttime="20190402 07:08:38.942"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:08:38.942" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:08:38.942" starttime="20190402 07:08:38.942"></status>
</kw>
<msg timestamp="20190402 07:08:38.942" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:08:38.943" starttime="20190402 07:08:37.901"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:08:38.943" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:08:38.943" starttime="20190402 07:08:38.943"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:08:38.944" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:08:38.944" starttime="20190402 07:08:38.943"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:38.944" starttime="20190402 07:08:38.943"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:38.944" starttime="20190402 07:08:37.898"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:08:43.947" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:43.947" starttime="20190402 07:08:43.946"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:43.950" starttime="20190402 07:08:43.949"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:08:43.951" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:08:43.951" starttime="20190402 07:08:43.950"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:43.951" starttime="20190402 07:08:43.951"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:43.951" starttime="20190402 07:08:43.951"></status>
</kw>
<msg timestamp="20190402 07:08:43.952" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:08:43.952" starttime="20190402 07:08:43.950"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:08:43.952" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:43.952" starttime="20190402 07:08:43.952"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:08:43.961" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:43.961" starttime="20190402 07:08:43.952"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:08:45.057" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:08:45.057" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:45.057" starttime="20190402 07:08:43.961"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:08:45.058" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:45.058" starttime="20190402 07:08:45.058"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:08:45.058" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:45.058" starttime="20190402 07:08:45.058"></status>
</kw>
<msg timestamp="20190402 07:08:45.058" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:45.058" starttime="20190402 07:08:45.057"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:08:45.060" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:08:45.060" starttime="20190402 07:08:45.059"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:08:45.061" level="INFO">0</msg>
<msg timestamp="20190402 07:08:45.061" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:45.061" starttime="20190402 07:08:45.060"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:08:45.061" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:08:45.061" starttime="20190402 07:08:45.061"></status>
</kw>
<msg timestamp="20190402 07:08:45.061" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:45.061" starttime="20190402 07:08:45.058"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:45.062" starttime="20190402 07:08:45.062"></status>
</kw>
<status status="PASS" endtime="20190402 07:08:45.062" starttime="20190402 07:08:45.061"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:45.062" starttime="20190402 07:08:45.062"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:08:45.063" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:08:45.063" starttime="20190402 07:08:45.063"></status>
</kw>
<msg timestamp="20190402 07:08:45.063" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:08:45.063" starttime="20190402 07:08:43.948"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:08:45.063" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:08:45.063" starttime="20190402 07:08:45.063"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:08:45.064" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:08:45.064" starttime="20190402 07:08:45.064"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:45.064" starttime="20190402 07:08:45.063"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:45.064" starttime="20190402 07:08:43.944"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:08:50.067" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:50.067" starttime="20190402 07:08:50.066"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:50.070" starttime="20190402 07:08:50.069"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:08:50.071" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:08:50.071" starttime="20190402 07:08:50.070"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:50.071" starttime="20190402 07:08:50.071"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:50.071" starttime="20190402 07:08:50.071"></status>
</kw>
<msg timestamp="20190402 07:08:50.072" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:08:50.072" starttime="20190402 07:08:50.070"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:08:50.072" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:50.072" starttime="20190402 07:08:50.072"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:08:50.084" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:50.084" starttime="20190402 07:08:50.072"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:08:51.090" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:08:51.090" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:51.090" starttime="20190402 07:08:50.084"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:08:51.091" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:51.091" starttime="20190402 07:08:51.091"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:08:51.091" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:51.092" starttime="20190402 07:08:51.091"></status>
</kw>
<msg timestamp="20190402 07:08:51.092" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:51.092" starttime="20190402 07:08:51.090"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:08:51.094" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:08:51.094" starttime="20190402 07:08:51.092"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:08:51.095" level="INFO">0</msg>
<msg timestamp="20190402 07:08:51.095" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:51.095" starttime="20190402 07:08:51.095"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:08:51.095" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:08:51.095" starttime="20190402 07:08:51.095"></status>
</kw>
<msg timestamp="20190402 07:08:51.095" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:51.095" starttime="20190402 07:08:51.092"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:51.096" starttime="20190402 07:08:51.096"></status>
</kw>
<status status="PASS" endtime="20190402 07:08:51.096" starttime="20190402 07:08:51.096"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:51.097" starttime="20190402 07:08:51.096"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:08:51.097" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:08:51.097" starttime="20190402 07:08:51.097"></status>
</kw>
<msg timestamp="20190402 07:08:51.097" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:08:51.097" starttime="20190402 07:08:50.068"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:08:51.097" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:08:51.097" starttime="20190402 07:08:51.097"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:08:51.098" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:08:51.098" starttime="20190402 07:08:51.098"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:51.098" starttime="20190402 07:08:51.098"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:51.098" starttime="20190402 07:08:50.065"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:08:56.101" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:56.101" starttime="20190402 07:08:56.100"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:56.103" starttime="20190402 07:08:56.102"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:08:56.104" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:08:56.104" starttime="20190402 07:08:56.104"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:56.105" starttime="20190402 07:08:56.104"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:56.105" starttime="20190402 07:08:56.105"></status>
</kw>
<msg timestamp="20190402 07:08:56.105" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:08:56.105" starttime="20190402 07:08:56.103"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:08:56.105" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:56.105" starttime="20190402 07:08:56.105"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:08:56.115" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:08:56.115" starttime="20190402 07:08:56.106"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:08:57.154" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:08:57.154" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:57.154" starttime="20190402 07:08:56.115"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:08:57.155" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:08:57.155" starttime="20190402 07:08:57.155"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:08:57.155" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:57.155" starttime="20190402 07:08:57.155"></status>
</kw>
<msg timestamp="20190402 07:08:57.156" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:08:57.156" starttime="20190402 07:08:57.154"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:08:57.158" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:08:57.158" starttime="20190402 07:08:57.156"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:08:57.158" level="INFO">0</msg>
<msg timestamp="20190402 07:08:57.158" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:57.159" starttime="20190402 07:08:57.158"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:08:57.159" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:08:57.159" starttime="20190402 07:08:57.159"></status>
</kw>
<msg timestamp="20190402 07:08:57.159" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:08:57.159" starttime="20190402 07:08:57.156"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:57.160" starttime="20190402 07:08:57.159"></status>
</kw>
<status status="PASS" endtime="20190402 07:08:57.160" starttime="20190402 07:08:57.159"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:08:57.160" starttime="20190402 07:08:57.160"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:08:57.160" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:08:57.160" starttime="20190402 07:08:57.160"></status>
</kw>
<msg timestamp="20190402 07:08:57.161" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:08:57.161" starttime="20190402 07:08:56.101"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:08:57.161" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:08:57.161" starttime="20190402 07:08:57.161"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:08:57.162" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:08:57.162" starttime="20190402 07:08:57.161"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:57.162" starttime="20190402 07:08:57.161"></status>
</kw>
<status status="FAIL" endtime="20190402 07:08:57.162" starttime="20190402 07:08:56.099"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:09:02.164" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:02.164" starttime="20190402 07:09:02.163"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:02.166" starttime="20190402 07:09:02.165"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:09:02.168" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:09:02.168" starttime="20190402 07:09:02.167"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:02.168" starttime="20190402 07:09:02.168"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:02.169" starttime="20190402 07:09:02.168"></status>
</kw>
<msg timestamp="20190402 07:09:02.169" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:09:02.169" starttime="20190402 07:09:02.166"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:09:02.169" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:02.169" starttime="20190402 07:09:02.169"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:09:02.177" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:02.177" starttime="20190402 07:09:02.169"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:09:03.266" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:09:03.266" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:03.266" starttime="20190402 07:09:02.178"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:09:03.267" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:03.267" starttime="20190402 07:09:03.266"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:09:03.267" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:03.267" starttime="20190402 07:09:03.267"></status>
</kw>
<msg timestamp="20190402 07:09:03.267" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:03.267" starttime="20190402 07:09:03.266"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:09:03.269" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:09:03.269" starttime="20190402 07:09:03.267"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:09:03.269" level="INFO">0</msg>
<msg timestamp="20190402 07:09:03.269" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:03.269" starttime="20190402 07:09:03.269"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:09:03.269" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:09:03.270" starttime="20190402 07:09:03.269"></status>
</kw>
<msg timestamp="20190402 07:09:03.270" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:03.270" starttime="20190402 07:09:03.267"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:03.271" starttime="20190402 07:09:03.270"></status>
</kw>
<status status="PASS" endtime="20190402 07:09:03.271" starttime="20190402 07:09:03.270"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:03.271" starttime="20190402 07:09:03.271"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:09:03.271" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:09:03.271" starttime="20190402 07:09:03.271"></status>
</kw>
<msg timestamp="20190402 07:09:03.272" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:09:03.272" starttime="20190402 07:09:02.165"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:09:03.272" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:09:03.272" starttime="20190402 07:09:03.272"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:09:03.273" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:09:03.273" starttime="20190402 07:09:03.272"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:03.273" starttime="20190402 07:09:03.272"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:03.273" starttime="20190402 07:09:02.162"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:09:08.276" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:08.276" starttime="20190402 07:09:08.275"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:08.278" starttime="20190402 07:09:08.277"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:09:08.279" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:09:08.280" starttime="20190402 07:09:08.279"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:08.280" starttime="20190402 07:09:08.280"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:08.280" starttime="20190402 07:09:08.280"></status>
</kw>
<msg timestamp="20190402 07:09:08.280" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:09:08.280" starttime="20190402 07:09:08.279"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:09:08.281" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:08.281" starttime="20190402 07:09:08.281"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:09:08.290" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:08.290" starttime="20190402 07:09:08.281"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:09:09.420" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:09:09.420" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:09.420" starttime="20190402 07:09:08.291"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:09:09.421" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:09.421" starttime="20190402 07:09:09.420"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:09:09.421" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:09.421" starttime="20190402 07:09:09.421"></status>
</kw>
<msg timestamp="20190402 07:09:09.421" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:09.421" starttime="20190402 07:09:09.420"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:09:09.423" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:09:09.424" starttime="20190402 07:09:09.421"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:09:09.427" level="INFO">0</msg>
<msg timestamp="20190402 07:09:09.427" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:09.427" starttime="20190402 07:09:09.424"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:09:09.427" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:09:09.427" starttime="20190402 07:09:09.427"></status>
</kw>
<msg timestamp="20190402 07:09:09.428" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:09.428" starttime="20190402 07:09:09.421"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:09.428" starttime="20190402 07:09:09.428"></status>
</kw>
<status status="PASS" endtime="20190402 07:09:09.428" starttime="20190402 07:09:09.428"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:09.429" starttime="20190402 07:09:09.428"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:09:09.429" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:09:09.429" starttime="20190402 07:09:09.429"></status>
</kw>
<msg timestamp="20190402 07:09:09.429" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:09:09.429" starttime="20190402 07:09:08.276"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:09:09.430" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:09:09.430" starttime="20190402 07:09:09.429"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:09:09.431" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:09:09.431" starttime="20190402 07:09:09.430"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:09.431" starttime="20190402 07:09:09.430"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:09.431" starttime="20190402 07:09:08.274"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:09:14.434" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:14.434" starttime="20190402 07:09:14.433"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:14.436" starttime="20190402 07:09:14.436"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:09:14.437" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:09:14.437" starttime="20190402 07:09:14.436"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:14.437" starttime="20190402 07:09:14.437"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:14.438" starttime="20190402 07:09:14.437"></status>
</kw>
<msg timestamp="20190402 07:09:14.438" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:09:14.438" starttime="20190402 07:09:14.436"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:09:14.438" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:14.438" starttime="20190402 07:09:14.438"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:09:14.447" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:14.447" starttime="20190402 07:09:14.438"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:09:15.531" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:09:15.531" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:15.531" starttime="20190402 07:09:14.447"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:09:15.532" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:15.532" starttime="20190402 07:09:15.531"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:09:15.532" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:15.532" starttime="20190402 07:09:15.532"></status>
</kw>
<msg timestamp="20190402 07:09:15.532" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:15.532" starttime="20190402 07:09:15.531"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:09:15.534" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:09:15.534" starttime="20190402 07:09:15.533"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:09:15.534" level="INFO">0</msg>
<msg timestamp="20190402 07:09:15.534" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:15.534" starttime="20190402 07:09:15.534"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:09:15.535" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:09:15.535" starttime="20190402 07:09:15.535"></status>
</kw>
<msg timestamp="20190402 07:09:15.535" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:15.535" starttime="20190402 07:09:15.532"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:15.536" starttime="20190402 07:09:15.535"></status>
</kw>
<status status="PASS" endtime="20190402 07:09:15.536" starttime="20190402 07:09:15.535"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:15.536" starttime="20190402 07:09:15.536"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:09:15.536" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:09:15.536" starttime="20190402 07:09:15.536"></status>
</kw>
<msg timestamp="20190402 07:09:15.537" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:09:15.537" starttime="20190402 07:09:14.434"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:09:15.537" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:09:15.537" starttime="20190402 07:09:15.537"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:09:15.538" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:09:15.538" starttime="20190402 07:09:15.537"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:15.538" starttime="20190402 07:09:15.537"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:15.538" starttime="20190402 07:09:14.431"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:09:20.539" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:20.539" starttime="20190402 07:09:20.539"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:20.540" starttime="20190402 07:09:20.540"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:09:20.541" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:09:20.541" starttime="20190402 07:09:20.540"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:20.541" starttime="20190402 07:09:20.541"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:20.542" starttime="20190402 07:09:20.541"></status>
</kw>
<msg timestamp="20190402 07:09:20.542" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:09:20.542" starttime="20190402 07:09:20.540"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:09:20.542" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:20.542" starttime="20190402 07:09:20.542"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:09:20.551" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:20.551" starttime="20190402 07:09:20.542"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:09:21.665" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:09:21.665" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:21.665" starttime="20190402 07:09:20.551"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:09:21.666" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:21.666" starttime="20190402 07:09:21.666"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:09:21.667" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:21.667" starttime="20190402 07:09:21.666"></status>
</kw>
<msg timestamp="20190402 07:09:21.667" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:21.667" starttime="20190402 07:09:21.666"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:09:21.668" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:09:21.669" starttime="20190402 07:09:21.667"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:09:21.669" level="INFO">0</msg>
<msg timestamp="20190402 07:09:21.669" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:21.669" starttime="20190402 07:09:21.669"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:09:21.669" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:09:21.669" starttime="20190402 07:09:21.669"></status>
</kw>
<msg timestamp="20190402 07:09:21.670" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:21.670" starttime="20190402 07:09:21.667"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:21.670" starttime="20190402 07:09:21.670"></status>
</kw>
<status status="PASS" endtime="20190402 07:09:21.670" starttime="20190402 07:09:21.670"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:21.671" starttime="20190402 07:09:21.670"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:09:21.671" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:09:21.671" starttime="20190402 07:09:21.671"></status>
</kw>
<msg timestamp="20190402 07:09:21.671" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:09:21.671" starttime="20190402 07:09:20.540"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:09:21.672" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:09:21.672" starttime="20190402 07:09:21.671"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:09:21.672" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:09:21.672" starttime="20190402 07:09:21.672"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:21.672" starttime="20190402 07:09:21.672"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:21.673" starttime="20190402 07:09:20.539"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:09:26.676" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:26.676" starttime="20190402 07:09:26.675"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:26.679" starttime="20190402 07:09:26.678"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:09:26.680" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:09:26.680" starttime="20190402 07:09:26.679"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:26.680" starttime="20190402 07:09:26.680"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:26.680" starttime="20190402 07:09:26.680"></status>
</kw>
<msg timestamp="20190402 07:09:26.681" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:09:26.681" starttime="20190402 07:09:26.679"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:09:26.681" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:26.681" starttime="20190402 07:09:26.681"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:09:26.692" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:26.692" starttime="20190402 07:09:26.681"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:09:27.797" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:09:27.797" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:27.797" starttime="20190402 07:09:26.692"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:09:27.798" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:27.798" starttime="20190402 07:09:27.798"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:09:27.798" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:27.798" starttime="20190402 07:09:27.798"></status>
</kw>
<msg timestamp="20190402 07:09:27.798" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:27.798" starttime="20190402 07:09:27.797"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:09:27.801" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:09:27.801" starttime="20190402 07:09:27.799"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:09:27.801" level="INFO">0</msg>
<msg timestamp="20190402 07:09:27.801" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:27.801" starttime="20190402 07:09:27.801"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:09:27.802" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:09:27.802" starttime="20190402 07:09:27.802"></status>
</kw>
<msg timestamp="20190402 07:09:27.802" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:27.802" starttime="20190402 07:09:27.799"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:27.803" starttime="20190402 07:09:27.802"></status>
</kw>
<status status="PASS" endtime="20190402 07:09:27.803" starttime="20190402 07:09:27.802"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:27.803" starttime="20190402 07:09:27.803"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:09:27.803" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:09:27.803" starttime="20190402 07:09:27.803"></status>
</kw>
<msg timestamp="20190402 07:09:27.804" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:09:27.804" starttime="20190402 07:09:26.676"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:09:27.804" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:09:27.804" starttime="20190402 07:09:27.804"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:09:27.805" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:09:27.805" starttime="20190402 07:09:27.804"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:27.805" starttime="20190402 07:09:27.804"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:27.805" starttime="20190402 07:09:26.673"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:09:32.808" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:32.808" starttime="20190402 07:09:32.807"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:32.811" starttime="20190402 07:09:32.810"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:09:32.812" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:09:32.812" starttime="20190402 07:09:32.811"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:32.812" starttime="20190402 07:09:32.812"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:32.812" starttime="20190402 07:09:32.812"></status>
</kw>
<msg timestamp="20190402 07:09:32.813" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:09:32.813" starttime="20190402 07:09:32.811"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:09:32.813" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:32.813" starttime="20190402 07:09:32.813"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:09:32.826" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:32.826" starttime="20190402 07:09:32.813"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:09:34.117" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:09:34.117" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:34.117" starttime="20190402 07:09:32.826"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:09:34.118" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:34.118" starttime="20190402 07:09:34.117"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:09:34.118" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:34.118" starttime="20190402 07:09:34.118"></status>
</kw>
<msg timestamp="20190402 07:09:34.118" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:34.118" starttime="20190402 07:09:34.117"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:09:34.119" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:09:34.119" starttime="20190402 07:09:34.118"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:09:34.120" level="INFO">0</msg>
<msg timestamp="20190402 07:09:34.120" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:34.120" starttime="20190402 07:09:34.119"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:09:34.121" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:09:34.121" starttime="20190402 07:09:34.120"></status>
</kw>
<msg timestamp="20190402 07:09:34.121" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:34.121" starttime="20190402 07:09:34.118"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:34.121" starttime="20190402 07:09:34.121"></status>
</kw>
<status status="PASS" endtime="20190402 07:09:34.122" starttime="20190402 07:09:34.121"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:34.122" starttime="20190402 07:09:34.122"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:09:34.122" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:09:34.122" starttime="20190402 07:09:34.122"></status>
</kw>
<msg timestamp="20190402 07:09:34.122" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:09:34.122" starttime="20190402 07:09:32.809"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:09:34.123" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:09:34.123" starttime="20190402 07:09:34.123"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:09:34.124" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:09:34.124" starttime="20190402 07:09:34.123"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:34.124" starttime="20190402 07:09:34.123"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:34.124" starttime="20190402 07:09:32.806"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:09:39.140" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:39.140" starttime="20190402 07:09:39.126"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:39.141" starttime="20190402 07:09:39.141"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:09:39.142" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:09:39.142" starttime="20190402 07:09:39.142"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:39.142" starttime="20190402 07:09:39.142"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:39.143" starttime="20190402 07:09:39.142"></status>
</kw>
<msg timestamp="20190402 07:09:39.143" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:09:39.143" starttime="20190402 07:09:39.141"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:09:39.143" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:39.143" starttime="20190402 07:09:39.143"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:09:39.145" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:39.145" starttime="20190402 07:09:39.143"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:09:40.267" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:09:40.267" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:40.267" starttime="20190402 07:09:39.145"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:09:40.268" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:40.268" starttime="20190402 07:09:40.268"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:09:40.268" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:40.268" starttime="20190402 07:09:40.268"></status>
</kw>
<msg timestamp="20190402 07:09:40.269" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:40.269" starttime="20190402 07:09:40.268"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:09:40.270" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:09:40.270" starttime="20190402 07:09:40.269"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:09:40.271" level="INFO">0</msg>
<msg timestamp="20190402 07:09:40.271" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:40.271" starttime="20190402 07:09:40.270"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:09:40.271" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:09:40.271" starttime="20190402 07:09:40.271"></status>
</kw>
<msg timestamp="20190402 07:09:40.271" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:40.271" starttime="20190402 07:09:40.269"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:40.272" starttime="20190402 07:09:40.272"></status>
</kw>
<status status="PASS" endtime="20190402 07:09:40.272" starttime="20190402 07:09:40.271"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:40.272" starttime="20190402 07:09:40.272"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:09:40.273" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:09:40.273" starttime="20190402 07:09:40.272"></status>
</kw>
<msg timestamp="20190402 07:09:40.273" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:09:40.273" starttime="20190402 07:09:39.141"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:09:40.273" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:09:40.273" starttime="20190402 07:09:40.273"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:09:40.274" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:09:40.274" starttime="20190402 07:09:40.274"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:40.274" starttime="20190402 07:09:40.273"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:40.274" starttime="20190402 07:09:39.124"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:09:45.277" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:45.277" starttime="20190402 07:09:45.276"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:45.280" starttime="20190402 07:09:45.279"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:09:45.281" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:09:45.281" starttime="20190402 07:09:45.280"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:45.281" starttime="20190402 07:09:45.281"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:45.281" starttime="20190402 07:09:45.281"></status>
</kw>
<msg timestamp="20190402 07:09:45.282" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:09:45.282" starttime="20190402 07:09:45.280"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:09:45.282" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:45.282" starttime="20190402 07:09:45.282"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:09:45.293" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:45.293" starttime="20190402 07:09:45.282"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:09:46.396" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:09:46.397" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:46.397" starttime="20190402 07:09:45.293"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:09:46.398" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:46.398" starttime="20190402 07:09:46.397"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:09:46.398" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:46.398" starttime="20190402 07:09:46.398"></status>
</kw>
<msg timestamp="20190402 07:09:46.398" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:46.398" starttime="20190402 07:09:46.397"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:09:46.400" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:09:46.400" starttime="20190402 07:09:46.398"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:09:46.401" level="INFO">0</msg>
<msg timestamp="20190402 07:09:46.401" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:46.401" starttime="20190402 07:09:46.400"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:09:46.401" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:09:46.401" starttime="20190402 07:09:46.401"></status>
</kw>
<msg timestamp="20190402 07:09:46.401" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:46.401" starttime="20190402 07:09:46.398"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:46.402" starttime="20190402 07:09:46.402"></status>
</kw>
<status status="PASS" endtime="20190402 07:09:46.402" starttime="20190402 07:09:46.401"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:46.402" starttime="20190402 07:09:46.402"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:09:46.403" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:09:46.403" starttime="20190402 07:09:46.402"></status>
</kw>
<msg timestamp="20190402 07:09:46.403" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:09:46.403" starttime="20190402 07:09:45.278"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:09:46.403" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:09:46.403" starttime="20190402 07:09:46.403"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:09:46.404" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:09:46.404" starttime="20190402 07:09:46.404"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:46.404" starttime="20190402 07:09:46.403"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:46.404" starttime="20190402 07:09:45.275"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:09:51.407" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:51.408" starttime="20190402 07:09:51.407"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:51.410" starttime="20190402 07:09:51.409"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:09:51.411" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:09:51.411" starttime="20190402 07:09:51.410"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:51.411" starttime="20190402 07:09:51.411"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:51.411" starttime="20190402 07:09:51.411"></status>
</kw>
<msg timestamp="20190402 07:09:51.412" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:09:51.412" starttime="20190402 07:09:51.410"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:09:51.412" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:51.412" starttime="20190402 07:09:51.412"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:09:51.421" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:51.421" starttime="20190402 07:09:51.412"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:09:52.491" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:09:52.492" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:52.492" starttime="20190402 07:09:51.421"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:09:52.492" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:52.492" starttime="20190402 07:09:52.492"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:09:52.493" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:52.493" starttime="20190402 07:09:52.493"></status>
</kw>
<msg timestamp="20190402 07:09:52.493" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:52.493" starttime="20190402 07:09:52.492"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:09:52.495" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:09:52.495" starttime="20190402 07:09:52.493"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:09:52.495" level="INFO">0</msg>
<msg timestamp="20190402 07:09:52.495" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:52.496" starttime="20190402 07:09:52.495"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:09:52.496" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:09:52.496" starttime="20190402 07:09:52.496"></status>
</kw>
<msg timestamp="20190402 07:09:52.496" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:52.496" starttime="20190402 07:09:52.493"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:52.497" starttime="20190402 07:09:52.496"></status>
</kw>
<status status="PASS" endtime="20190402 07:09:52.497" starttime="20190402 07:09:52.496"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:52.497" starttime="20190402 07:09:52.497"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:09:52.497" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:09:52.497" starttime="20190402 07:09:52.497"></status>
</kw>
<msg timestamp="20190402 07:09:52.498" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:09:52.498" starttime="20190402 07:09:51.408"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:09:52.498" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:09:52.498" starttime="20190402 07:09:52.498"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:09:52.499" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:09:52.499" starttime="20190402 07:09:52.498"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:52.499" starttime="20190402 07:09:52.498"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:52.499" starttime="20190402 07:09:51.405"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:09:57.502" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:57.502" starttime="20190402 07:09:57.501"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:57.505" starttime="20190402 07:09:57.504"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:09:57.507" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:09:57.508" starttime="20190402 07:09:57.506"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:57.509" starttime="20190402 07:09:57.508"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:57.510" starttime="20190402 07:09:57.509"></status>
</kw>
<msg timestamp="20190402 07:09:57.511" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:09:57.511" starttime="20190402 07:09:57.505"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:09:57.512" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:57.512" starttime="20190402 07:09:57.512"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:09:57.538" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:09:57.538" starttime="20190402 07:09:57.513"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:09:58.589" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:09:58.589" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:58.589" starttime="20190402 07:09:57.538"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:09:58.590" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:09:58.590" starttime="20190402 07:09:58.590"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:09:58.591" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:58.591" starttime="20190402 07:09:58.590"></status>
</kw>
<msg timestamp="20190402 07:09:58.591" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:09:58.591" starttime="20190402 07:09:58.590"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:09:58.593" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:09:58.593" starttime="20190402 07:09:58.591"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:09:58.596" level="INFO">0</msg>
<msg timestamp="20190402 07:09:58.596" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:58.597" starttime="20190402 07:09:58.593"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:09:58.597" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:09:58.597" starttime="20190402 07:09:58.597"></status>
</kw>
<msg timestamp="20190402 07:09:58.597" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:09:58.597" starttime="20190402 07:09:58.591"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:58.598" starttime="20190402 07:09:58.598"></status>
</kw>
<status status="PASS" endtime="20190402 07:09:58.598" starttime="20190402 07:09:58.597"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:09:58.598" starttime="20190402 07:09:58.598"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:09:58.599" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:09:58.599" starttime="20190402 07:09:58.598"></status>
</kw>
<msg timestamp="20190402 07:09:58.599" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:09:58.599" starttime="20190402 07:09:57.503"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:09:58.599" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:09:58.599" starttime="20190402 07:09:58.599"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:09:58.600" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:09:58.600" starttime="20190402 07:09:58.600"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:58.600" starttime="20190402 07:09:58.599"></status>
</kw>
<status status="FAIL" endtime="20190402 07:09:58.600" starttime="20190402 07:09:57.500"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:10:03.603" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:03.604" starttime="20190402 07:10:03.602"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:03.606" starttime="20190402 07:10:03.605"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:10:03.609" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:10:03.609" starttime="20190402 07:10:03.607"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:03.610" starttime="20190402 07:10:03.610"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:03.612" starttime="20190402 07:10:03.611"></status>
</kw>
<msg timestamp="20190402 07:10:03.612" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:10:03.613" starttime="20190402 07:10:03.607"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:10:03.613" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:03.614" starttime="20190402 07:10:03.613"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:10:03.641" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:03.641" starttime="20190402 07:10:03.614"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:10:04.775" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:10:04.775" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:04.775" starttime="20190402 07:10:03.641"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:10:04.776" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:04.776" starttime="20190402 07:10:04.776"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:10:04.776" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:04.776" starttime="20190402 07:10:04.776"></status>
</kw>
<msg timestamp="20190402 07:10:04.776" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:04.776" starttime="20190402 07:10:04.775"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:10:04.778" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:10:04.778" starttime="20190402 07:10:04.777"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:10:04.779" level="INFO">0</msg>
<msg timestamp="20190402 07:10:04.779" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:04.779" starttime="20190402 07:10:04.778"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:10:04.779" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:10:04.779" starttime="20190402 07:10:04.779"></status>
</kw>
<msg timestamp="20190402 07:10:04.779" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:04.779" starttime="20190402 07:10:04.777"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:04.780" starttime="20190402 07:10:04.780"></status>
</kw>
<status status="PASS" endtime="20190402 07:10:04.780" starttime="20190402 07:10:04.779"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:04.780" starttime="20190402 07:10:04.780"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:10:04.781" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:10:04.781" starttime="20190402 07:10:04.781"></status>
</kw>
<msg timestamp="20190402 07:10:04.781" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:10:04.781" starttime="20190402 07:10:03.604"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:10:04.781" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:10:04.781" starttime="20190402 07:10:04.781"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:10:04.782" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:10:04.782" starttime="20190402 07:10:04.782"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:04.782" starttime="20190402 07:10:04.781"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:04.782" starttime="20190402 07:10:03.601"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:10:09.785" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:09.785" starttime="20190402 07:10:09.784"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:09.787" starttime="20190402 07:10:09.787"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:10:09.789" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:10:09.789" starttime="20190402 07:10:09.788"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:09.791" starttime="20190402 07:10:09.790"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:09.792" starttime="20190402 07:10:09.791"></status>
</kw>
<msg timestamp="20190402 07:10:09.792" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:10:09.792" starttime="20190402 07:10:09.788"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:10:09.793" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:09.793" starttime="20190402 07:10:09.793"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:10:09.815" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:09.815" starttime="20190402 07:10:09.794"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:10:11.161" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:10:11.161" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:11.161" starttime="20190402 07:10:09.815"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:10:11.162" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:11.162" starttime="20190402 07:10:11.162"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:10:11.163" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:11.163" starttime="20190402 07:10:11.162"></status>
</kw>
<msg timestamp="20190402 07:10:11.163" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:11.163" starttime="20190402 07:10:11.162"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:10:11.164" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:10:11.165" starttime="20190402 07:10:11.163"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:10:11.165" level="INFO">0</msg>
<msg timestamp="20190402 07:10:11.165" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:11.165" starttime="20190402 07:10:11.165"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:10:11.165" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:10:11.165" starttime="20190402 07:10:11.165"></status>
</kw>
<msg timestamp="20190402 07:10:11.165" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:11.166" starttime="20190402 07:10:11.163"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:11.166" starttime="20190402 07:10:11.166"></status>
</kw>
<status status="PASS" endtime="20190402 07:10:11.166" starttime="20190402 07:10:11.166"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:11.167" starttime="20190402 07:10:11.166"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:10:11.167" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:10:11.167" starttime="20190402 07:10:11.167"></status>
</kw>
<msg timestamp="20190402 07:10:11.167" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:10:11.167" starttime="20190402 07:10:09.785"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:10:11.168" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:10:11.168" starttime="20190402 07:10:11.167"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:10:11.168" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:10:11.168" starttime="20190402 07:10:11.168"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:11.168" starttime="20190402 07:10:11.168"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:11.169" starttime="20190402 07:10:09.783"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:10:16.172" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:16.172" starttime="20190402 07:10:16.171"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:16.174" starttime="20190402 07:10:16.174"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:10:16.175" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:10:16.175" starttime="20190402 07:10:16.174"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:16.175" starttime="20190402 07:10:16.175"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:16.175" starttime="20190402 07:10:16.175"></status>
</kw>
<msg timestamp="20190402 07:10:16.176" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:10:16.176" starttime="20190402 07:10:16.174"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:10:16.176" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:16.176" starttime="20190402 07:10:16.176"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:10:16.185" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:16.185" starttime="20190402 07:10:16.176"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:10:17.293" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:10:17.293" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:17.293" starttime="20190402 07:10:16.185"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:10:17.294" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:17.294" starttime="20190402 07:10:17.294"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:10:17.295" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:17.295" starttime="20190402 07:10:17.294"></status>
</kw>
<msg timestamp="20190402 07:10:17.295" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:17.295" starttime="20190402 07:10:17.294"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:10:17.296" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:10:17.296" starttime="20190402 07:10:17.295"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:10:17.297" level="INFO">0</msg>
<msg timestamp="20190402 07:10:17.297" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:17.297" starttime="20190402 07:10:17.297"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:10:17.297" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:10:17.297" starttime="20190402 07:10:17.297"></status>
</kw>
<msg timestamp="20190402 07:10:17.297" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:17.297" starttime="20190402 07:10:17.295"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:17.298" starttime="20190402 07:10:17.298"></status>
</kw>
<status status="PASS" endtime="20190402 07:10:17.298" starttime="20190402 07:10:17.298"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:17.298" starttime="20190402 07:10:17.298"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:10:17.299" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:10:17.299" starttime="20190402 07:10:17.299"></status>
</kw>
<msg timestamp="20190402 07:10:17.299" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:10:17.299" starttime="20190402 07:10:16.172"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:10:17.299" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:10:17.299" starttime="20190402 07:10:17.299"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:10:17.300" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:10:17.300" starttime="20190402 07:10:17.300"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:17.300" starttime="20190402 07:10:17.300"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:17.300" starttime="20190402 07:10:16.169"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:10:22.304" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:22.304" starttime="20190402 07:10:22.303"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:22.306" starttime="20190402 07:10:22.306"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:10:22.307" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:10:22.307" starttime="20190402 07:10:22.306"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:22.307" starttime="20190402 07:10:22.307"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:22.307" starttime="20190402 07:10:22.307"></status>
</kw>
<msg timestamp="20190402 07:10:22.308" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:10:22.308" starttime="20190402 07:10:22.306"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:10:22.308" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:22.308" starttime="20190402 07:10:22.308"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:10:22.317" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:22.317" starttime="20190402 07:10:22.308"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:10:23.447" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:10:23.447" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:23.447" starttime="20190402 07:10:22.317"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:10:23.447" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:23.448" starttime="20190402 07:10:23.447"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:10:23.448" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:23.448" starttime="20190402 07:10:23.448"></status>
</kw>
<msg timestamp="20190402 07:10:23.448" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:23.448" starttime="20190402 07:10:23.447"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:10:23.450" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:10:23.450" starttime="20190402 07:10:23.448"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:10:23.450" level="INFO">0</msg>
<msg timestamp="20190402 07:10:23.450" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:23.450" starttime="20190402 07:10:23.450"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:10:23.451" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:10:23.451" starttime="20190402 07:10:23.450"></status>
</kw>
<msg timestamp="20190402 07:10:23.451" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:23.451" starttime="20190402 07:10:23.448"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:23.452" starttime="20190402 07:10:23.451"></status>
</kw>
<status status="PASS" endtime="20190402 07:10:23.452" starttime="20190402 07:10:23.451"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:23.452" starttime="20190402 07:10:23.452"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:10:23.452" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:10:23.452" starttime="20190402 07:10:23.452"></status>
</kw>
<msg timestamp="20190402 07:10:23.452" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:10:23.453" starttime="20190402 07:10:22.304"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:10:23.453" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:10:23.453" starttime="20190402 07:10:23.453"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:10:23.454" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:10:23.454" starttime="20190402 07:10:23.453"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:23.454" starttime="20190402 07:10:23.453"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:23.454" starttime="20190402 07:10:22.301"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:10:28.457" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:28.457" starttime="20190402 07:10:28.456"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:28.459" starttime="20190402 07:10:28.458"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:10:28.460" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:10:28.460" starttime="20190402 07:10:28.460"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:28.461" starttime="20190402 07:10:28.461"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:28.461" starttime="20190402 07:10:28.461"></status>
</kw>
<msg timestamp="20190402 07:10:28.461" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:10:28.461" starttime="20190402 07:10:28.460"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:10:28.462" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:28.462" starttime="20190402 07:10:28.462"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:10:28.470" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:28.470" starttime="20190402 07:10:28.462"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:10:29.756" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:10:29.756" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:29.756" starttime="20190402 07:10:28.470"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:10:29.757" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:29.757" starttime="20190402 07:10:29.757"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:10:29.757" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:29.757" starttime="20190402 07:10:29.757"></status>
</kw>
<msg timestamp="20190402 07:10:29.757" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:29.757" starttime="20190402 07:10:29.756"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:10:29.759" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:10:29.759" starttime="20190402 07:10:29.758"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:10:29.760" level="INFO">0</msg>
<msg timestamp="20190402 07:10:29.760" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:29.760" starttime="20190402 07:10:29.759"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:10:29.760" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:10:29.760" starttime="20190402 07:10:29.760"></status>
</kw>
<msg timestamp="20190402 07:10:29.760" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:29.760" starttime="20190402 07:10:29.758"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:29.761" starttime="20190402 07:10:29.761"></status>
</kw>
<status status="PASS" endtime="20190402 07:10:29.761" starttime="20190402 07:10:29.761"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:29.762" starttime="20190402 07:10:29.761"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:10:29.762" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:10:29.762" starttime="20190402 07:10:29.762"></status>
</kw>
<msg timestamp="20190402 07:10:29.762" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:10:29.762" starttime="20190402 07:10:28.457"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:10:29.763" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:10:29.763" starttime="20190402 07:10:29.762"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:10:29.763" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:10:29.763" starttime="20190402 07:10:29.763"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:29.763" starttime="20190402 07:10:29.763"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:29.764" starttime="20190402 07:10:28.455"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:10:34.767" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:34.767" starttime="20190402 07:10:34.766"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:34.769" starttime="20190402 07:10:34.769"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:10:34.770" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:10:34.770" starttime="20190402 07:10:34.769"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:34.770" starttime="20190402 07:10:34.770"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:34.770" starttime="20190402 07:10:34.770"></status>
</kw>
<msg timestamp="20190402 07:10:34.771" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:10:34.771" starttime="20190402 07:10:34.769"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:10:34.771" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:34.771" starttime="20190402 07:10:34.771"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:10:34.785" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:34.785" starttime="20190402 07:10:34.771"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:10:35.869" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:10:35.869" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:35.869" starttime="20190402 07:10:34.785"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:10:35.870" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:35.870" starttime="20190402 07:10:35.870"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:10:35.870" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:35.870" starttime="20190402 07:10:35.870"></status>
</kw>
<msg timestamp="20190402 07:10:35.871" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:35.871" starttime="20190402 07:10:35.869"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:10:35.872" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:10:35.872" starttime="20190402 07:10:35.871"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:10:35.873" level="INFO">0</msg>
<msg timestamp="20190402 07:10:35.873" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:35.873" starttime="20190402 07:10:35.873"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:10:35.873" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:10:35.873" starttime="20190402 07:10:35.873"></status>
</kw>
<msg timestamp="20190402 07:10:35.873" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:35.873" starttime="20190402 07:10:35.871"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:35.874" starttime="20190402 07:10:35.874"></status>
</kw>
<status status="PASS" endtime="20190402 07:10:35.874" starttime="20190402 07:10:35.873"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:35.874" starttime="20190402 07:10:35.874"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:10:35.875" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:10:35.875" starttime="20190402 07:10:35.875"></status>
</kw>
<msg timestamp="20190402 07:10:35.875" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:10:35.875" starttime="20190402 07:10:34.767"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:10:35.875" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:10:35.875" starttime="20190402 07:10:35.875"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:10:35.876" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:10:35.876" starttime="20190402 07:10:35.876"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:35.876" starttime="20190402 07:10:35.876"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:35.876" starttime="20190402 07:10:34.764"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:10:40.880" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:40.880" starttime="20190402 07:10:40.879"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:40.882" starttime="20190402 07:10:40.882"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:10:40.883" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:10:40.883" starttime="20190402 07:10:40.882"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:40.883" starttime="20190402 07:10:40.883"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:40.884" starttime="20190402 07:10:40.883"></status>
</kw>
<msg timestamp="20190402 07:10:40.884" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:10:40.884" starttime="20190402 07:10:40.882"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:10:40.884" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:40.884" starttime="20190402 07:10:40.884"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:10:40.892" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:40.892" starttime="20190402 07:10:40.884"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:10:41.958" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:10:41.958" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:41.958" starttime="20190402 07:10:40.892"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:10:41.959" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:41.959" starttime="20190402 07:10:41.959"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:10:41.959" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:41.959" starttime="20190402 07:10:41.959"></status>
</kw>
<msg timestamp="20190402 07:10:41.959" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:41.959" starttime="20190402 07:10:41.958"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:10:41.962" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:10:41.962" starttime="20190402 07:10:41.960"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:10:41.963" level="INFO">0</msg>
<msg timestamp="20190402 07:10:41.964" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:41.964" starttime="20190402 07:10:41.962"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:10:41.964" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:10:41.964" starttime="20190402 07:10:41.964"></status>
</kw>
<msg timestamp="20190402 07:10:41.964" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:41.964" starttime="20190402 07:10:41.959"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:41.965" starttime="20190402 07:10:41.965"></status>
</kw>
<status status="PASS" endtime="20190402 07:10:41.965" starttime="20190402 07:10:41.964"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:41.965" starttime="20190402 07:10:41.965"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:10:41.966" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:10:41.966" starttime="20190402 07:10:41.965"></status>
</kw>
<msg timestamp="20190402 07:10:41.966" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:10:41.966" starttime="20190402 07:10:40.880"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:10:41.966" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:10:41.966" starttime="20190402 07:10:41.966"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:10:41.967" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:10:41.967" starttime="20190402 07:10:41.967"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:41.967" starttime="20190402 07:10:41.966"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:41.967" starttime="20190402 07:10:40.877"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:10:46.971" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:46.971" starttime="20190402 07:10:46.970"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:46.973" starttime="20190402 07:10:46.973"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:10:46.974" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:10:46.974" starttime="20190402 07:10:46.973"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:46.974" starttime="20190402 07:10:46.974"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:46.974" starttime="20190402 07:10:46.974"></status>
</kw>
<msg timestamp="20190402 07:10:46.975" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:10:46.975" starttime="20190402 07:10:46.973"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:10:46.975" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:46.975" starttime="20190402 07:10:46.975"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:10:46.984" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:46.984" starttime="20190402 07:10:46.975"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:10:48.035" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:10:48.035" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:48.035" starttime="20190402 07:10:46.984"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:10:48.036" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:48.036" starttime="20190402 07:10:48.035"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:10:48.036" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:48.036" starttime="20190402 07:10:48.036"></status>
</kw>
<msg timestamp="20190402 07:10:48.036" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:48.036" starttime="20190402 07:10:48.035"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:10:48.038" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:10:48.038" starttime="20190402 07:10:48.037"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:10:48.038" level="INFO">0</msg>
<msg timestamp="20190402 07:10:48.038" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:48.038" starttime="20190402 07:10:48.038"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:10:48.039" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:10:48.039" starttime="20190402 07:10:48.039"></status>
</kw>
<msg timestamp="20190402 07:10:48.039" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:48.039" starttime="20190402 07:10:48.036"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:48.040" starttime="20190402 07:10:48.039"></status>
</kw>
<status status="PASS" endtime="20190402 07:10:48.040" starttime="20190402 07:10:48.039"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:48.040" starttime="20190402 07:10:48.040"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:10:48.040" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:10:48.040" starttime="20190402 07:10:48.040"></status>
</kw>
<msg timestamp="20190402 07:10:48.041" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:10:48.041" starttime="20190402 07:10:46.971"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:10:48.041" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:10:48.041" starttime="20190402 07:10:48.041"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:10:48.042" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:10:48.042" starttime="20190402 07:10:48.041"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:48.042" starttime="20190402 07:10:48.041"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:48.042" starttime="20190402 07:10:46.968"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:10:53.045" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:53.045" starttime="20190402 07:10:53.044"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:53.048" starttime="20190402 07:10:53.047"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:10:53.049" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:10:53.049" starttime="20190402 07:10:53.048"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:53.049" starttime="20190402 07:10:53.049"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:53.049" starttime="20190402 07:10:53.049"></status>
</kw>
<msg timestamp="20190402 07:10:53.050" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:10:53.050" starttime="20190402 07:10:53.048"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:10:53.050" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:53.050" starttime="20190402 07:10:53.050"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:10:53.060" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:53.060" starttime="20190402 07:10:53.050"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:10:54.086" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:10:54.087" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:54.087" starttime="20190402 07:10:53.060"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:10:54.087" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:54.087" starttime="20190402 07:10:54.087"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:10:54.088" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:54.088" starttime="20190402 07:10:54.087"></status>
</kw>
<msg timestamp="20190402 07:10:54.088" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:10:54.088" starttime="20190402 07:10:54.087"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:10:54.089" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:10:54.090" starttime="20190402 07:10:54.088"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:10:54.090" level="INFO">0</msg>
<msg timestamp="20190402 07:10:54.090" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:54.090" starttime="20190402 07:10:54.090"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:10:54.090" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:10:54.090" starttime="20190402 07:10:54.090"></status>
</kw>
<msg timestamp="20190402 07:10:54.090" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:10:54.090" starttime="20190402 07:10:54.088"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:54.091" starttime="20190402 07:10:54.091"></status>
</kw>
<status status="PASS" endtime="20190402 07:10:54.091" starttime="20190402 07:10:54.091"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:54.092" starttime="20190402 07:10:54.091"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:10:54.092" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:10:54.092" starttime="20190402 07:10:54.092"></status>
</kw>
<msg timestamp="20190402 07:10:54.092" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:10:54.092" starttime="20190402 07:10:53.046"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:10:54.092" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:10:54.092" starttime="20190402 07:10:54.092"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:10:54.093" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:10:54.093" starttime="20190402 07:10:54.093"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:54.093" starttime="20190402 07:10:54.093"></status>
</kw>
<status status="FAIL" endtime="20190402 07:10:54.093" starttime="20190402 07:10:53.043"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:10:59.097" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:59.097" starttime="20190402 07:10:59.095"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:59.099" starttime="20190402 07:10:59.099"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:10:59.100" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:10:59.100" starttime="20190402 07:10:59.099"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:59.100" starttime="20190402 07:10:59.100"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:10:59.101" starttime="20190402 07:10:59.100"></status>
</kw>
<msg timestamp="20190402 07:10:59.101" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:10:59.101" starttime="20190402 07:10:59.099"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:10:59.101" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:10:59.101" starttime="20190402 07:10:59.101"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:10:59.104" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:10:59.104" starttime="20190402 07:10:59.101"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:11:00.170" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:11:00.170" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:00.170" starttime="20190402 07:10:59.104"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:11:00.171" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:00.171" starttime="20190402 07:11:00.170"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:11:00.171" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:00.171" starttime="20190402 07:11:00.171"></status>
</kw>
<msg timestamp="20190402 07:11:00.171" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:00.171" starttime="20190402 07:11:00.170"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:11:00.173" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:11:00.173" starttime="20190402 07:11:00.172"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:11:00.173" level="INFO">0</msg>
<msg timestamp="20190402 07:11:00.174" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:00.174" starttime="20190402 07:11:00.173"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:11:00.174" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:11:00.174" starttime="20190402 07:11:00.174"></status>
</kw>
<msg timestamp="20190402 07:11:00.174" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:00.174" starttime="20190402 07:11:00.171"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:00.175" starttime="20190402 07:11:00.175"></status>
</kw>
<status status="PASS" endtime="20190402 07:11:00.175" starttime="20190402 07:11:00.174"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:00.175" starttime="20190402 07:11:00.175"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:11:00.176" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:11:00.176" starttime="20190402 07:11:00.175"></status>
</kw>
<msg timestamp="20190402 07:11:00.176" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:11:00.176" starttime="20190402 07:10:59.098"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:11:00.176" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:11:00.176" starttime="20190402 07:11:00.176"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:11:00.177" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:11:00.177" starttime="20190402 07:11:00.177"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:00.177" starttime="20190402 07:11:00.176"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:00.177" starttime="20190402 07:10:59.094"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:11:05.180" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:05.181" starttime="20190402 07:11:05.179"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:05.183" starttime="20190402 07:11:05.182"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:11:05.184" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:11:05.184" starttime="20190402 07:11:05.184"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:05.184" starttime="20190402 07:11:05.184"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:05.185" starttime="20190402 07:11:05.184"></status>
</kw>
<msg timestamp="20190402 07:11:05.185" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:11:05.185" starttime="20190402 07:11:05.183"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:11:05.185" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:05.185" starttime="20190402 07:11:05.185"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:11:05.194" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:05.194" starttime="20190402 07:11:05.185"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:11:06.285" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:11:06.285" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:06.285" starttime="20190402 07:11:05.194"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:11:06.286" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:06.286" starttime="20190402 07:11:06.285"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:11:06.286" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:06.286" starttime="20190402 07:11:06.286"></status>
</kw>
<msg timestamp="20190402 07:11:06.286" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:06.286" starttime="20190402 07:11:06.285"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:11:06.288" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:11:06.288" starttime="20190402 07:11:06.286"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:11:06.290" level="INFO">0</msg>
<msg timestamp="20190402 07:11:06.290" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:06.290" starttime="20190402 07:11:06.288"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:11:06.290" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:11:06.290" starttime="20190402 07:11:06.290"></status>
</kw>
<msg timestamp="20190402 07:11:06.290" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:06.290" starttime="20190402 07:11:06.286"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:06.291" starttime="20190402 07:11:06.291"></status>
</kw>
<status status="PASS" endtime="20190402 07:11:06.291" starttime="20190402 07:11:06.290"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:06.291" starttime="20190402 07:11:06.291"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:11:06.291" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:11:06.292" starttime="20190402 07:11:06.291"></status>
</kw>
<msg timestamp="20190402 07:11:06.292" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:11:06.292" starttime="20190402 07:11:05.181"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:11:06.292" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:11:06.292" starttime="20190402 07:11:06.292"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:11:06.293" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:11:06.293" starttime="20190402 07:11:06.293"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:06.293" starttime="20190402 07:11:06.292"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:06.293" starttime="20190402 07:11:05.178"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:11:11.296" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:11.296" starttime="20190402 07:11:11.295"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:11.299" starttime="20190402 07:11:11.298"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:11:11.300" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:11:11.300" starttime="20190402 07:11:11.299"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:11.300" starttime="20190402 07:11:11.300"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:11.300" starttime="20190402 07:11:11.300"></status>
</kw>
<msg timestamp="20190402 07:11:11.301" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:11:11.301" starttime="20190402 07:11:11.299"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:11:11.301" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:11.301" starttime="20190402 07:11:11.301"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:11:11.314" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:11.314" starttime="20190402 07:11:11.301"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:11:12.335" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:11:12.335" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:12.335" starttime="20190402 07:11:11.315"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:11:12.336" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:12.336" starttime="20190402 07:11:12.335"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:11:12.336" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:12.336" starttime="20190402 07:11:12.336"></status>
</kw>
<msg timestamp="20190402 07:11:12.336" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:12.336" starttime="20190402 07:11:12.335"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:11:12.339" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:11:12.339" starttime="20190402 07:11:12.337"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:11:12.339" level="INFO">0</msg>
<msg timestamp="20190402 07:11:12.339" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:12.339" starttime="20190402 07:11:12.339"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:11:12.339" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:11:12.339" starttime="20190402 07:11:12.339"></status>
</kw>
<msg timestamp="20190402 07:11:12.340" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:12.340" starttime="20190402 07:11:12.336"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:12.340" starttime="20190402 07:11:12.340"></status>
</kw>
<status status="PASS" endtime="20190402 07:11:12.341" starttime="20190402 07:11:12.340"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:12.341" starttime="20190402 07:11:12.341"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:11:12.341" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:11:12.341" starttime="20190402 07:11:12.341"></status>
</kw>
<msg timestamp="20190402 07:11:12.341" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:11:12.341" starttime="20190402 07:11:11.297"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:11:12.342" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:11:12.342" starttime="20190402 07:11:12.342"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:11:12.342" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:11:12.342" starttime="20190402 07:11:12.342"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:12.343" starttime="20190402 07:11:12.342"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:12.343" starttime="20190402 07:11:11.294"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:11:17.346" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:17.346" starttime="20190402 07:11:17.345"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:17.348" starttime="20190402 07:11:17.348"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:11:17.349" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:11:17.349" starttime="20190402 07:11:17.348"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:17.349" starttime="20190402 07:11:17.349"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:17.350" starttime="20190402 07:11:17.349"></status>
</kw>
<msg timestamp="20190402 07:11:17.350" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:11:17.350" starttime="20190402 07:11:17.348"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:11:17.350" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:17.350" starttime="20190402 07:11:17.350"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:11:17.364" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:17.364" starttime="20190402 07:11:17.350"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:11:18.421" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:11:18.421" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:18.421" starttime="20190402 07:11:17.365"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:11:18.422" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:18.422" starttime="20190402 07:11:18.422"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:11:18.422" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:18.422" starttime="20190402 07:11:18.422"></status>
</kw>
<msg timestamp="20190402 07:11:18.422" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:18.422" starttime="20190402 07:11:18.421"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:11:18.424" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:11:18.425" starttime="20190402 07:11:18.423"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:11:18.425" level="INFO">0</msg>
<msg timestamp="20190402 07:11:18.425" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:18.425" starttime="20190402 07:11:18.425"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:11:18.425" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:11:18.425" starttime="20190402 07:11:18.425"></status>
</kw>
<msg timestamp="20190402 07:11:18.425" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:18.425" starttime="20190402 07:11:18.423"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:18.426" starttime="20190402 07:11:18.426"></status>
</kw>
<status status="PASS" endtime="20190402 07:11:18.426" starttime="20190402 07:11:18.426"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:18.427" starttime="20190402 07:11:18.426"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:11:18.427" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:11:18.427" starttime="20190402 07:11:18.427"></status>
</kw>
<msg timestamp="20190402 07:11:18.427" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:11:18.427" starttime="20190402 07:11:17.346"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:11:18.427" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:11:18.427" starttime="20190402 07:11:18.427"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:11:18.428" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:11:18.428" starttime="20190402 07:11:18.428"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:18.428" starttime="20190402 07:11:18.428"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:18.428" starttime="20190402 07:11:17.343"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:11:23.431" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:23.431" starttime="20190402 07:11:23.430"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:23.434" starttime="20190402 07:11:23.433"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:11:23.435" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:11:23.435" starttime="20190402 07:11:23.434"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:23.435" starttime="20190402 07:11:23.435"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:23.435" starttime="20190402 07:11:23.435"></status>
</kw>
<msg timestamp="20190402 07:11:23.436" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:11:23.436" starttime="20190402 07:11:23.434"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:11:23.436" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:23.436" starttime="20190402 07:11:23.436"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:11:23.445" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:23.445" starttime="20190402 07:11:23.436"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:11:24.487" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:11:24.487" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:24.487" starttime="20190402 07:11:23.446"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:11:24.488" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:24.488" starttime="20190402 07:11:24.487"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:11:24.488" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:24.488" starttime="20190402 07:11:24.488"></status>
</kw>
<msg timestamp="20190402 07:11:24.488" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:24.488" starttime="20190402 07:11:24.487"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:11:24.490" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:11:24.490" starttime="20190402 07:11:24.489"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:11:24.490" level="INFO">0</msg>
<msg timestamp="20190402 07:11:24.490" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:24.490" starttime="20190402 07:11:24.490"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:11:24.490" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:11:24.491" starttime="20190402 07:11:24.490"></status>
</kw>
<msg timestamp="20190402 07:11:24.491" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:24.491" starttime="20190402 07:11:24.488"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:24.491" starttime="20190402 07:11:24.491"></status>
</kw>
<status status="PASS" endtime="20190402 07:11:24.491" starttime="20190402 07:11:24.491"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:24.492" starttime="20190402 07:11:24.492"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:11:24.492" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:11:24.492" starttime="20190402 07:11:24.492"></status>
</kw>
<msg timestamp="20190402 07:11:24.492" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:11:24.492" starttime="20190402 07:11:23.432"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:11:24.493" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:11:24.493" starttime="20190402 07:11:24.492"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:11:24.493" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:11:24.493" starttime="20190402 07:11:24.493"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:24.493" starttime="20190402 07:11:24.493"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:24.494" starttime="20190402 07:11:23.429"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:11:29.497" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:29.497" starttime="20190402 07:11:29.496"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:29.499" starttime="20190402 07:11:29.499"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:11:29.500" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:11:29.500" starttime="20190402 07:11:29.499"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:29.500" starttime="20190402 07:11:29.500"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:29.500" starttime="20190402 07:11:29.500"></status>
</kw>
<msg timestamp="20190402 07:11:29.501" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:11:29.501" starttime="20190402 07:11:29.499"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:11:29.501" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:29.501" starttime="20190402 07:11:29.501"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:11:29.509" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:29.509" starttime="20190402 07:11:29.501"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:11:30.659" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:11:30.660" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:30.660" starttime="20190402 07:11:29.510"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:11:30.661" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:30.661" starttime="20190402 07:11:30.660"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:11:30.661" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:30.661" starttime="20190402 07:11:30.661"></status>
</kw>
<msg timestamp="20190402 07:11:30.661" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:30.661" starttime="20190402 07:11:30.660"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:11:30.663" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:11:30.663" starttime="20190402 07:11:30.662"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:11:30.664" level="INFO">0</msg>
<msg timestamp="20190402 07:11:30.664" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:30.664" starttime="20190402 07:11:30.664"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:11:30.664" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:11:30.664" starttime="20190402 07:11:30.664"></status>
</kw>
<msg timestamp="20190402 07:11:30.664" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:30.664" starttime="20190402 07:11:30.661"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:30.665" starttime="20190402 07:11:30.665"></status>
</kw>
<status status="PASS" endtime="20190402 07:11:30.665" starttime="20190402 07:11:30.665"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:30.666" starttime="20190402 07:11:30.665"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:11:30.666" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:11:30.666" starttime="20190402 07:11:30.666"></status>
</kw>
<msg timestamp="20190402 07:11:30.666" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:11:30.666" starttime="20190402 07:11:29.497"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:11:30.666" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:11:30.666" starttime="20190402 07:11:30.666"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:11:30.667" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:11:30.667" starttime="20190402 07:11:30.667"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:30.667" starttime="20190402 07:11:30.667"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:30.667" starttime="20190402 07:11:29.494"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:11:35.670" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:35.671" starttime="20190402 07:11:35.669"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:35.673" starttime="20190402 07:11:35.672"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:11:35.674" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:11:35.674" starttime="20190402 07:11:35.673"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:35.674" starttime="20190402 07:11:35.674"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:35.674" starttime="20190402 07:11:35.674"></status>
</kw>
<msg timestamp="20190402 07:11:35.674" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:11:35.675" starttime="20190402 07:11:35.673"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:11:35.675" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:35.675" starttime="20190402 07:11:35.675"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:11:35.688" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:35.688" starttime="20190402 07:11:35.675"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:11:36.694" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:11:36.694" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:36.694" starttime="20190402 07:11:35.688"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:11:36.695" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:36.695" starttime="20190402 07:11:36.695"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:11:36.695" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:36.695" starttime="20190402 07:11:36.695"></status>
</kw>
<msg timestamp="20190402 07:11:36.695" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:36.695" starttime="20190402 07:11:36.694"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:11:36.698" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:11:36.698" starttime="20190402 07:11:36.696"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:11:36.699" level="INFO">0</msg>
<msg timestamp="20190402 07:11:36.699" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:36.699" starttime="20190402 07:11:36.698"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:11:36.699" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:11:36.699" starttime="20190402 07:11:36.699"></status>
</kw>
<msg timestamp="20190402 07:11:36.699" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:36.699" starttime="20190402 07:11:36.695"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:36.700" starttime="20190402 07:11:36.700"></status>
</kw>
<status status="PASS" endtime="20190402 07:11:36.700" starttime="20190402 07:11:36.699"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:36.700" starttime="20190402 07:11:36.700"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:11:36.701" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:11:36.701" starttime="20190402 07:11:36.700"></status>
</kw>
<msg timestamp="20190402 07:11:36.701" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:11:36.701" starttime="20190402 07:11:35.671"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:11:36.701" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:11:36.701" starttime="20190402 07:11:36.701"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:11:36.702" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:11:36.702" starttime="20190402 07:11:36.702"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:36.702" starttime="20190402 07:11:36.701"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:36.702" starttime="20190402 07:11:35.668"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:11:41.705" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:41.705" starttime="20190402 07:11:41.704"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:41.708" starttime="20190402 07:11:41.707"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:11:41.709" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:11:41.709" starttime="20190402 07:11:41.708"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:41.709" starttime="20190402 07:11:41.709"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:41.709" starttime="20190402 07:11:41.709"></status>
</kw>
<msg timestamp="20190402 07:11:41.710" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:11:41.710" starttime="20190402 07:11:41.708"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:11:41.710" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:41.710" starttime="20190402 07:11:41.710"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:11:41.719" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:41.719" starttime="20190402 07:11:41.710"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:11:42.726" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:11:42.726" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:42.726" starttime="20190402 07:11:41.720"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:11:42.727" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:42.727" starttime="20190402 07:11:42.727"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:11:42.727" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:42.727" starttime="20190402 07:11:42.727"></status>
</kw>
<msg timestamp="20190402 07:11:42.728" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:42.728" starttime="20190402 07:11:42.727"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:11:42.729" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:11:42.729" starttime="20190402 07:11:42.728"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:11:42.730" level="INFO">0</msg>
<msg timestamp="20190402 07:11:42.730" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:42.730" starttime="20190402 07:11:42.729"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:11:42.730" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:11:42.730" starttime="20190402 07:11:42.730"></status>
</kw>
<msg timestamp="20190402 07:11:42.730" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:42.730" starttime="20190402 07:11:42.728"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:42.731" starttime="20190402 07:11:42.731"></status>
</kw>
<status status="PASS" endtime="20190402 07:11:42.731" starttime="20190402 07:11:42.731"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:42.732" starttime="20190402 07:11:42.731"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:11:42.732" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:11:42.732" starttime="20190402 07:11:42.732"></status>
</kw>
<msg timestamp="20190402 07:11:42.732" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:11:42.732" starttime="20190402 07:11:41.706"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:11:42.733" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:11:42.733" starttime="20190402 07:11:42.732"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:11:42.733" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:11:42.733" starttime="20190402 07:11:42.733"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:42.733" starttime="20190402 07:11:42.733"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:42.734" starttime="20190402 07:11:41.703"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:11:47.736" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:47.736" starttime="20190402 07:11:47.735"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:47.739" starttime="20190402 07:11:47.738"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:11:47.741" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:11:47.741" starttime="20190402 07:11:47.740"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:47.743" starttime="20190402 07:11:47.742"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:47.744" starttime="20190402 07:11:47.743"></status>
</kw>
<msg timestamp="20190402 07:11:47.744" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:11:47.745" starttime="20190402 07:11:47.739"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:11:47.745" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:47.745" starttime="20190402 07:11:47.745"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:11:47.770" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:47.770" starttime="20190402 07:11:47.746"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:11:48.792" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:11:48.792" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:48.792" starttime="20190402 07:11:47.771"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:11:48.793" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:48.793" starttime="20190402 07:11:48.793"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:11:48.794" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:48.794" starttime="20190402 07:11:48.793"></status>
</kw>
<msg timestamp="20190402 07:11:48.794" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:48.794" starttime="20190402 07:11:48.793"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:11:48.796" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:11:48.796" starttime="20190402 07:11:48.794"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:11:48.796" level="INFO">0</msg>
<msg timestamp="20190402 07:11:48.796" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:48.796" starttime="20190402 07:11:48.796"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:11:48.797" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:11:48.797" starttime="20190402 07:11:48.797"></status>
</kw>
<msg timestamp="20190402 07:11:48.797" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:48.797" starttime="20190402 07:11:48.794"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:48.798" starttime="20190402 07:11:48.797"></status>
</kw>
<status status="PASS" endtime="20190402 07:11:48.798" starttime="20190402 07:11:48.797"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:48.798" starttime="20190402 07:11:48.798"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:11:48.798" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:11:48.798" starttime="20190402 07:11:48.798"></status>
</kw>
<msg timestamp="20190402 07:11:48.799" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:11:48.799" starttime="20190402 07:11:47.737"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:11:48.799" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:11:48.799" starttime="20190402 07:11:48.799"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:11:48.800" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:11:48.800" starttime="20190402 07:11:48.799"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:48.800" starttime="20190402 07:11:48.799"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:48.800" starttime="20190402 07:11:47.734"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:11:53.803" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:53.803" starttime="20190402 07:11:53.802"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:53.806" starttime="20190402 07:11:53.805"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:11:53.807" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:11:53.807" starttime="20190402 07:11:53.806"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:53.807" starttime="20190402 07:11:53.807"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:53.807" starttime="20190402 07:11:53.807"></status>
</kw>
<msg timestamp="20190402 07:11:53.808" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:11:53.808" starttime="20190402 07:11:53.806"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:11:53.808" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:53.808" starttime="20190402 07:11:53.808"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:11:53.817" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:53.817" starttime="20190402 07:11:53.808"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:11:54.902" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:11:54.902" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:54.902" starttime="20190402 07:11:53.817"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:11:54.903" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:54.903" starttime="20190402 07:11:54.903"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:11:54.903" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:54.903" starttime="20190402 07:11:54.903"></status>
</kw>
<msg timestamp="20190402 07:11:54.903" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:11:54.903" starttime="20190402 07:11:54.902"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:11:54.905" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:11:54.905" starttime="20190402 07:11:54.904"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:11:54.907" level="INFO">0</msg>
<msg timestamp="20190402 07:11:54.907" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:54.907" starttime="20190402 07:11:54.906"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:11:54.908" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:11:54.908" starttime="20190402 07:11:54.907"></status>
</kw>
<msg timestamp="20190402 07:11:54.908" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:11:54.908" starttime="20190402 07:11:54.903"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:54.909" starttime="20190402 07:11:54.908"></status>
</kw>
<status status="PASS" endtime="20190402 07:11:54.909" starttime="20190402 07:11:54.908"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:54.909" starttime="20190402 07:11:54.909"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:11:54.909" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:11:54.909" starttime="20190402 07:11:54.909"></status>
</kw>
<msg timestamp="20190402 07:11:54.910" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:11:54.910" starttime="20190402 07:11:53.804"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:11:54.910" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:11:54.910" starttime="20190402 07:11:54.910"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:11:54.911" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:11:54.911" starttime="20190402 07:11:54.910"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:54.911" starttime="20190402 07:11:54.910"></status>
</kw>
<status status="FAIL" endtime="20190402 07:11:54.911" starttime="20190402 07:11:53.801"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:11:59.913" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:59.913" starttime="20190402 07:11:59.913"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:59.915" starttime="20190402 07:11:59.915"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:11:59.917" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:11:59.917" starttime="20190402 07:11:59.916"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:59.918" starttime="20190402 07:11:59.917"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:11:59.919" starttime="20190402 07:11:59.918"></status>
</kw>
<msg timestamp="20190402 07:11:59.920" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:11:59.920" starttime="20190402 07:11:59.916"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:11:59.920" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:11:59.921" starttime="20190402 07:11:59.920"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:11:59.947" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:11:59.947" starttime="20190402 07:11:59.921"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:12:01.011" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:12:01.011" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:01.011" starttime="20190402 07:11:59.947"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:12:01.011" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:01.012" starttime="20190402 07:12:01.011"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:12:01.012" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:01.012" starttime="20190402 07:12:01.012"></status>
</kw>
<msg timestamp="20190402 07:12:01.012" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:01.012" starttime="20190402 07:12:01.011"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:12:01.014" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:12:01.014" starttime="20190402 07:12:01.012"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:12:01.014" level="INFO">0</msg>
<msg timestamp="20190402 07:12:01.014" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:01.014" starttime="20190402 07:12:01.014"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:12:01.015" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:12:01.015" starttime="20190402 07:12:01.015"></status>
</kw>
<msg timestamp="20190402 07:12:01.015" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:01.015" starttime="20190402 07:12:01.012"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:01.016" starttime="20190402 07:12:01.015"></status>
</kw>
<status status="PASS" endtime="20190402 07:12:01.016" starttime="20190402 07:12:01.015"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:01.016" starttime="20190402 07:12:01.016"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:12:01.016" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:12:01.016" starttime="20190402 07:12:01.016"></status>
</kw>
<msg timestamp="20190402 07:12:01.017" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:12:01.017" starttime="20190402 07:11:59.914"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:12:01.017" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:12:01.017" starttime="20190402 07:12:01.017"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:12:01.018" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:12:01.018" starttime="20190402 07:12:01.017"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:01.018" starttime="20190402 07:12:01.017"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:01.018" starttime="20190402 07:11:59.912"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:12:06.020" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:06.020" starttime="20190402 07:12:06.020"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:06.022" starttime="20190402 07:12:06.022"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:12:06.024" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:12:06.024" starttime="20190402 07:12:06.023"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:06.024" starttime="20190402 07:12:06.024"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:06.025" starttime="20190402 07:12:06.024"></status>
</kw>
<msg timestamp="20190402 07:12:06.025" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:12:06.025" starttime="20190402 07:12:06.022"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:12:06.025" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:06.025" starttime="20190402 07:12:06.025"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:12:06.036" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:06.036" starttime="20190402 07:12:06.025"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:12:07.164" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:12:07.164" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:07.164" starttime="20190402 07:12:06.037"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:12:07.165" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:07.165" starttime="20190402 07:12:07.164"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:12:07.165" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:07.165" starttime="20190402 07:12:07.165"></status>
</kw>
<msg timestamp="20190402 07:12:07.165" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:07.165" starttime="20190402 07:12:07.164"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:12:07.167" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:12:07.167" starttime="20190402 07:12:07.166"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:12:07.168" level="INFO">0</msg>
<msg timestamp="20190402 07:12:07.168" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:07.168" starttime="20190402 07:12:07.167"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:12:07.168" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:12:07.168" starttime="20190402 07:12:07.168"></status>
</kw>
<msg timestamp="20190402 07:12:07.168" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:07.168" starttime="20190402 07:12:07.165"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:07.169" starttime="20190402 07:12:07.169"></status>
</kw>
<status status="PASS" endtime="20190402 07:12:07.169" starttime="20190402 07:12:07.168"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:07.169" starttime="20190402 07:12:07.169"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:12:07.170" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:12:07.170" starttime="20190402 07:12:07.169"></status>
</kw>
<msg timestamp="20190402 07:12:07.170" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:12:07.170" starttime="20190402 07:12:06.021"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:12:07.170" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:12:07.170" starttime="20190402 07:12:07.170"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:12:07.171" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:12:07.171" starttime="20190402 07:12:07.171"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:07.171" starttime="20190402 07:12:07.170"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:07.172" starttime="20190402 07:12:06.019"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:12:12.175" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:12.175" starttime="20190402 07:12:12.174"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:12.177" starttime="20190402 07:12:12.176"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:12:12.178" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:12:12.178" starttime="20190402 07:12:12.177"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:12.178" starttime="20190402 07:12:12.178"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:12.178" starttime="20190402 07:12:12.178"></status>
</kw>
<msg timestamp="20190402 07:12:12.179" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:12:12.179" starttime="20190402 07:12:12.177"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:12:12.179" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:12.179" starttime="20190402 07:12:12.179"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:12:12.188" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:12.188" starttime="20190402 07:12:12.179"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:12:13.202" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:12:13.202" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:13.202" starttime="20190402 07:12:12.188"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:12:13.203" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:13.203" starttime="20190402 07:12:13.202"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:12:13.203" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:13.203" starttime="20190402 07:12:13.203"></status>
</kw>
<msg timestamp="20190402 07:12:13.203" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:13.203" starttime="20190402 07:12:13.202"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:12:13.205" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:12:13.205" starttime="20190402 07:12:13.203"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:12:13.206" level="INFO">0</msg>
<msg timestamp="20190402 07:12:13.206" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:13.206" starttime="20190402 07:12:13.205"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:12:13.206" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:12:13.206" starttime="20190402 07:12:13.206"></status>
</kw>
<msg timestamp="20190402 07:12:13.206" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:13.206" starttime="20190402 07:12:13.203"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:13.207" starttime="20190402 07:12:13.207"></status>
</kw>
<status status="PASS" endtime="20190402 07:12:13.207" starttime="20190402 07:12:13.206"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:13.207" starttime="20190402 07:12:13.207"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:12:13.208" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:12:13.208" starttime="20190402 07:12:13.207"></status>
</kw>
<msg timestamp="20190402 07:12:13.208" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:12:13.208" starttime="20190402 07:12:12.175"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:12:13.208" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:12:13.208" starttime="20190402 07:12:13.208"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:12:13.209" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:12:13.209" starttime="20190402 07:12:13.209"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:13.209" starttime="20190402 07:12:13.208"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:13.209" starttime="20190402 07:12:12.172"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:12:18.212" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:18.213" starttime="20190402 07:12:18.211"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:18.215" starttime="20190402 07:12:18.214"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:12:18.216" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:12:18.216" starttime="20190402 07:12:18.215"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:18.216" starttime="20190402 07:12:18.216"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:18.216" starttime="20190402 07:12:18.216"></status>
</kw>
<msg timestamp="20190402 07:12:18.217" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:12:18.217" starttime="20190402 07:12:18.215"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:12:18.217" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:18.217" starttime="20190402 07:12:18.217"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:12:18.230" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:18.231" starttime="20190402 07:12:18.217"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:12:19.258" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:12:19.258" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:19.258" starttime="20190402 07:12:18.231"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:12:19.259" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:19.259" starttime="20190402 07:12:19.259"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:12:19.259" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:19.259" starttime="20190402 07:12:19.259"></status>
</kw>
<msg timestamp="20190402 07:12:19.260" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:19.260" starttime="20190402 07:12:19.258"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:12:19.261" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:12:19.262" starttime="20190402 07:12:19.260"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:12:19.262" level="INFO">0</msg>
<msg timestamp="20190402 07:12:19.262" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:19.262" starttime="20190402 07:12:19.262"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:12:19.262" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:12:19.262" starttime="20190402 07:12:19.262"></status>
</kw>
<msg timestamp="20190402 07:12:19.263" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:19.263" starttime="20190402 07:12:19.260"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:19.263" starttime="20190402 07:12:19.263"></status>
</kw>
<status status="PASS" endtime="20190402 07:12:19.263" starttime="20190402 07:12:19.263"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:19.264" starttime="20190402 07:12:19.263"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:12:19.264" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:12:19.264" starttime="20190402 07:12:19.264"></status>
</kw>
<msg timestamp="20190402 07:12:19.264" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:12:19.264" starttime="20190402 07:12:18.213"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:12:19.265" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:12:19.265" starttime="20190402 07:12:19.264"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:12:19.265" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:12:19.265" starttime="20190402 07:12:19.265"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:19.265" starttime="20190402 07:12:19.265"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:19.265" starttime="20190402 07:12:18.210"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:12:24.268" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:24.269" starttime="20190402 07:12:24.268"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:24.272" starttime="20190402 07:12:24.271"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:12:24.275" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:12:24.275" starttime="20190402 07:12:24.273"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:24.276" starttime="20190402 07:12:24.276"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:24.278" starttime="20190402 07:12:24.277"></status>
</kw>
<msg timestamp="20190402 07:12:24.278" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:12:24.279" starttime="20190402 07:12:24.273"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:12:24.279" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:24.280" starttime="20190402 07:12:24.279"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:12:24.305" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:24.306" starttime="20190402 07:12:24.280"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:12:25.361" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:12:25.362" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:25.362" starttime="20190402 07:12:24.306"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:12:25.362" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:25.362" starttime="20190402 07:12:25.362"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:12:25.363" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:25.363" starttime="20190402 07:12:25.362"></status>
</kw>
<msg timestamp="20190402 07:12:25.363" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:25.363" starttime="20190402 07:12:25.362"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:12:25.365" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:12:25.365" starttime="20190402 07:12:25.363"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:12:25.367" level="INFO">0</msg>
<msg timestamp="20190402 07:12:25.367" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:25.367" starttime="20190402 07:12:25.365"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:12:25.367" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:12:25.367" starttime="20190402 07:12:25.367"></status>
</kw>
<msg timestamp="20190402 07:12:25.368" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:25.368" starttime="20190402 07:12:25.363"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:25.368" starttime="20190402 07:12:25.368"></status>
</kw>
<status status="PASS" endtime="20190402 07:12:25.368" starttime="20190402 07:12:25.368"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:25.369" starttime="20190402 07:12:25.369"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:12:25.369" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:12:25.369" starttime="20190402 07:12:25.369"></status>
</kw>
<msg timestamp="20190402 07:12:25.369" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:12:25.369" starttime="20190402 07:12:24.269"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:12:25.370" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:12:25.370" starttime="20190402 07:12:25.369"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:12:25.370" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:12:25.370" starttime="20190402 07:12:25.370"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:25.371" starttime="20190402 07:12:25.370"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:25.371" starttime="20190402 07:12:24.266"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:12:30.374" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:30.374" starttime="20190402 07:12:30.373"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:30.377" starttime="20190402 07:12:30.376"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:12:30.380" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:12:30.380" starttime="20190402 07:12:30.378"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:30.381" starttime="20190402 07:12:30.381"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:30.382" starttime="20190402 07:12:30.382"></status>
</kw>
<msg timestamp="20190402 07:12:30.383" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:12:30.383" starttime="20190402 07:12:30.377"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:12:30.384" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:30.384" starttime="20190402 07:12:30.384"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:12:30.411" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:30.411" starttime="20190402 07:12:30.385"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:12:31.420" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:12:31.420" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:31.420" starttime="20190402 07:12:30.411"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:12:31.421" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:31.421" starttime="20190402 07:12:31.420"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:12:31.421" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:31.421" starttime="20190402 07:12:31.421"></status>
</kw>
<msg timestamp="20190402 07:12:31.421" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:31.421" starttime="20190402 07:12:31.420"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:12:31.423" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:12:31.423" starttime="20190402 07:12:31.422"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:12:31.423" level="INFO">0</msg>
<msg timestamp="20190402 07:12:31.423" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:31.423" starttime="20190402 07:12:31.423"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:12:31.424" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:12:31.424" starttime="20190402 07:12:31.423"></status>
</kw>
<msg timestamp="20190402 07:12:31.424" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:31.424" starttime="20190402 07:12:31.421"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:31.425" starttime="20190402 07:12:31.424"></status>
</kw>
<status status="PASS" endtime="20190402 07:12:31.425" starttime="20190402 07:12:31.424"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:31.425" starttime="20190402 07:12:31.425"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:12:31.425" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:12:31.425" starttime="20190402 07:12:31.425"></status>
</kw>
<msg timestamp="20190402 07:12:31.426" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:12:31.426" starttime="20190402 07:12:30.374"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:12:31.426" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:12:31.426" starttime="20190402 07:12:31.426"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:12:31.427" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:12:31.427" starttime="20190402 07:12:31.426"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:31.427" starttime="20190402 07:12:31.426"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:31.427" starttime="20190402 07:12:30.371"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:12:36.430" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:36.430" starttime="20190402 07:12:36.429"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:36.433" starttime="20190402 07:12:36.432"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:12:36.434" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:12:36.434" starttime="20190402 07:12:36.433"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:36.434" starttime="20190402 07:12:36.434"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:36.434" starttime="20190402 07:12:36.434"></status>
</kw>
<msg timestamp="20190402 07:12:36.435" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:12:36.435" starttime="20190402 07:12:36.433"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:12:36.435" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:36.435" starttime="20190402 07:12:36.435"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:12:36.443" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:36.443" starttime="20190402 07:12:36.435"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:12:37.503" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:12:37.504" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:37.504" starttime="20190402 07:12:36.443"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:12:37.504" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:37.504" starttime="20190402 07:12:37.504"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:12:37.505" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:37.505" starttime="20190402 07:12:37.505"></status>
</kw>
<msg timestamp="20190402 07:12:37.505" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:37.505" starttime="20190402 07:12:37.504"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:12:37.507" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:12:37.507" starttime="20190402 07:12:37.505"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:12:37.507" level="INFO">0</msg>
<msg timestamp="20190402 07:12:37.507" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:37.507" starttime="20190402 07:12:37.507"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:12:37.507" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:12:37.508" starttime="20190402 07:12:37.507"></status>
</kw>
<msg timestamp="20190402 07:12:37.508" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:37.508" starttime="20190402 07:12:37.505"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:37.508" starttime="20190402 07:12:37.508"></status>
</kw>
<status status="PASS" endtime="20190402 07:12:37.509" starttime="20190402 07:12:37.508"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:37.509" starttime="20190402 07:12:37.509"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:12:37.509" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:12:37.509" starttime="20190402 07:12:37.509"></status>
</kw>
<msg timestamp="20190402 07:12:37.509" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:12:37.509" starttime="20190402 07:12:36.431"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:12:37.510" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:12:37.510" starttime="20190402 07:12:37.510"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:12:37.510" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:12:37.511" starttime="20190402 07:12:37.510"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:37.511" starttime="20190402 07:12:37.510"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:37.511" starttime="20190402 07:12:36.428"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:12:42.514" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:42.514" starttime="20190402 07:12:42.513"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:42.516" starttime="20190402 07:12:42.516"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:12:42.517" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:12:42.517" starttime="20190402 07:12:42.516"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:42.517" starttime="20190402 07:12:42.517"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:42.517" starttime="20190402 07:12:42.517"></status>
</kw>
<msg timestamp="20190402 07:12:42.518" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:12:42.518" starttime="20190402 07:12:42.516"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:12:42.518" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:42.518" starttime="20190402 07:12:42.518"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:12:42.529" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:42.529" starttime="20190402 07:12:42.518"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:12:44.026" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:12:44.026" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:44.026" starttime="20190402 07:12:42.530"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:12:44.027" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:44.027" starttime="20190402 07:12:44.027"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:12:44.027" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:44.027" starttime="20190402 07:12:44.027"></status>
</kw>
<msg timestamp="20190402 07:12:44.027" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:44.027" starttime="20190402 07:12:44.026"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:12:44.030" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:12:44.030" starttime="20190402 07:12:44.028"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:12:44.030" level="INFO">0</msg>
<msg timestamp="20190402 07:12:44.030" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:44.030" starttime="20190402 07:12:44.030"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:12:44.030" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:12:44.030" starttime="20190402 07:12:44.030"></status>
</kw>
<msg timestamp="20190402 07:12:44.031" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:44.031" starttime="20190402 07:12:44.028"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:44.031" starttime="20190402 07:12:44.031"></status>
</kw>
<status status="PASS" endtime="20190402 07:12:44.031" starttime="20190402 07:12:44.031"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:44.032" starttime="20190402 07:12:44.032"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:12:44.032" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:12:44.032" starttime="20190402 07:12:44.032"></status>
</kw>
<msg timestamp="20190402 07:12:44.032" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:12:44.032" starttime="20190402 07:12:42.514"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:12:44.033" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:12:44.033" starttime="20190402 07:12:44.033"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:12:44.033" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:12:44.034" starttime="20190402 07:12:44.033"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:44.034" starttime="20190402 07:12:44.033"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:44.034" starttime="20190402 07:12:42.511"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:12:49.037" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:49.037" starttime="20190402 07:12:49.036"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:49.039" starttime="20190402 07:12:49.038"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:12:49.042" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:12:49.042" starttime="20190402 07:12:49.040"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:49.043" starttime="20190402 07:12:49.042"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:49.044" starttime="20190402 07:12:49.043"></status>
</kw>
<msg timestamp="20190402 07:12:49.045" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:12:49.045" starttime="20190402 07:12:49.040"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:12:49.046" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:49.046" starttime="20190402 07:12:49.045"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:12:49.068" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:49.069" starttime="20190402 07:12:49.046"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:12:51.295" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:12:51.295" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:51.295" starttime="20190402 07:12:49.069"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:12:51.296" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:51.296" starttime="20190402 07:12:51.295"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:12:51.296" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:51.296" starttime="20190402 07:12:51.296"></status>
</kw>
<msg timestamp="20190402 07:12:51.296" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:51.296" starttime="20190402 07:12:51.295"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:12:51.299" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:12:51.299" starttime="20190402 07:12:51.297"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:12:51.304" level="INFO">0</msg>
<msg timestamp="20190402 07:12:51.304" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:51.304" starttime="20190402 07:12:51.299"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:12:51.304" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:12:51.304" starttime="20190402 07:12:51.304"></status>
</kw>
<msg timestamp="20190402 07:12:51.305" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:51.305" starttime="20190402 07:12:51.297"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:51.305" starttime="20190402 07:12:51.305"></status>
</kw>
<status status="PASS" endtime="20190402 07:12:51.305" starttime="20190402 07:12:51.305"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:51.306" starttime="20190402 07:12:51.305"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:12:51.306" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:12:51.306" starttime="20190402 07:12:51.306"></status>
</kw>
<msg timestamp="20190402 07:12:51.306" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:12:51.306" starttime="20190402 07:12:49.037"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:12:51.307" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:12:51.307" starttime="20190402 07:12:51.306"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:12:51.307" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:12:51.307" starttime="20190402 07:12:51.307"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:51.307" starttime="20190402 07:12:51.307"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:51.308" starttime="20190402 07:12:49.034"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:12:56.311" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:56.311" starttime="20190402 07:12:56.310"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:56.313" starttime="20190402 07:12:56.313"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:12:56.316" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:12:56.316" starttime="20190402 07:12:56.315"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:56.318" starttime="20190402 07:12:56.316"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:56.319" starttime="20190402 07:12:56.318"></status>
</kw>
<msg timestamp="20190402 07:12:56.320" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:12:56.320" starttime="20190402 07:12:56.314"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:12:56.321" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:56.321" starttime="20190402 07:12:56.320"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:12:56.351" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:12:56.352" starttime="20190402 07:12:56.321"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:12:57.603" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:12:57.604" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:57.604" starttime="20190402 07:12:56.352"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:12:57.604" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:12:57.604" starttime="20190402 07:12:57.604"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:12:57.605" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:57.605" starttime="20190402 07:12:57.605"></status>
</kw>
<msg timestamp="20190402 07:12:57.605" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:12:57.605" starttime="20190402 07:12:57.604"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:12:57.607" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:12:57.607" starttime="20190402 07:12:57.605"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:12:57.608" level="INFO">0</msg>
<msg timestamp="20190402 07:12:57.608" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:57.608" starttime="20190402 07:12:57.607"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:12:57.608" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:12:57.608" starttime="20190402 07:12:57.608"></status>
</kw>
<msg timestamp="20190402 07:12:57.608" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:12:57.608" starttime="20190402 07:12:57.605"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:57.609" starttime="20190402 07:12:57.609"></status>
</kw>
<status status="PASS" endtime="20190402 07:12:57.609" starttime="20190402 07:12:57.608"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:12:57.609" starttime="20190402 07:12:57.609"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:12:57.610" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:12:57.610" starttime="20190402 07:12:57.609"></status>
</kw>
<msg timestamp="20190402 07:12:57.610" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:12:57.610" starttime="20190402 07:12:56.311"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:12:57.610" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:12:57.610" starttime="20190402 07:12:57.610"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:12:57.611" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:12:57.611" starttime="20190402 07:12:57.611"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:57.611" starttime="20190402 07:12:57.610"></status>
</kw>
<status status="FAIL" endtime="20190402 07:12:57.611" starttime="20190402 07:12:56.308"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:13:02.614" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:02.614" starttime="20190402 07:13:02.613"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:02.617" starttime="20190402 07:13:02.616"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:13:02.620" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:13:02.620" starttime="20190402 07:13:02.618"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:02.621" starttime="20190402 07:13:02.621"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:02.622" starttime="20190402 07:13:02.622"></status>
</kw>
<msg timestamp="20190402 07:13:02.624" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:13:02.624" starttime="20190402 07:13:02.617"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:13:02.625" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:02.625" starttime="20190402 07:13:02.624"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:13:02.651" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:02.651" starttime="20190402 07:13:02.625"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:13:03.805" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:13:03.805" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:03.805" starttime="20190402 07:13:02.651"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:13:03.806" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:03.806" starttime="20190402 07:13:03.805"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:13:03.806" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:03.806" starttime="20190402 07:13:03.806"></status>
</kw>
<msg timestamp="20190402 07:13:03.806" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:03.806" starttime="20190402 07:13:03.805"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:13:03.808" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:13:03.808" starttime="20190402 07:13:03.806"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:13:03.808" level="INFO">0</msg>
<msg timestamp="20190402 07:13:03.808" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:03.808" starttime="20190402 07:13:03.808"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:13:03.809" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:13:03.809" starttime="20190402 07:13:03.809"></status>
</kw>
<msg timestamp="20190402 07:13:03.809" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:03.809" starttime="20190402 07:13:03.806"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:03.810" starttime="20190402 07:13:03.809"></status>
</kw>
<status status="PASS" endtime="20190402 07:13:03.810" starttime="20190402 07:13:03.809"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:03.810" starttime="20190402 07:13:03.810"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:13:03.811" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:13:03.811" starttime="20190402 07:13:03.810"></status>
</kw>
<msg timestamp="20190402 07:13:03.811" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:13:03.811" starttime="20190402 07:13:02.615"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:13:03.811" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:13:03.811" starttime="20190402 07:13:03.811"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:13:03.812" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:13:03.812" starttime="20190402 07:13:03.812"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:03.812" starttime="20190402 07:13:03.811"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:03.812" starttime="20190402 07:13:02.612"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:13:08.815" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:08.815" starttime="20190402 07:13:08.814"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:08.818" starttime="20190402 07:13:08.817"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:13:08.819" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:13:08.819" starttime="20190402 07:13:08.818"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:08.819" starttime="20190402 07:13:08.819"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:08.819" starttime="20190402 07:13:08.819"></status>
</kw>
<msg timestamp="20190402 07:13:08.820" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:13:08.820" starttime="20190402 07:13:08.818"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:13:08.820" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:08.820" starttime="20190402 07:13:08.820"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:13:08.829" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:08.829" starttime="20190402 07:13:08.820"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:13:09.918" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:13:09.918" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:09.918" starttime="20190402 07:13:08.829"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:13:09.919" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:09.919" starttime="20190402 07:13:09.918"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:13:09.919" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:09.919" starttime="20190402 07:13:09.919"></status>
</kw>
<msg timestamp="20190402 07:13:09.919" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:09.919" starttime="20190402 07:13:09.918"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:13:09.921" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:13:09.921" starttime="20190402 07:13:09.919"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:13:09.921" level="INFO">0</msg>
<msg timestamp="20190402 07:13:09.921" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:09.921" starttime="20190402 07:13:09.921"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:13:09.922" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:13:09.922" starttime="20190402 07:13:09.922"></status>
</kw>
<msg timestamp="20190402 07:13:09.922" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:09.922" starttime="20190402 07:13:09.919"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:09.923" starttime="20190402 07:13:09.922"></status>
</kw>
<status status="PASS" endtime="20190402 07:13:09.923" starttime="20190402 07:13:09.922"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:09.923" starttime="20190402 07:13:09.923"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:13:09.923" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:13:09.923" starttime="20190402 07:13:09.923"></status>
</kw>
<msg timestamp="20190402 07:13:09.924" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:13:09.924" starttime="20190402 07:13:08.816"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:13:09.924" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:13:09.924" starttime="20190402 07:13:09.924"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:13:09.925" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:13:09.925" starttime="20190402 07:13:09.925"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:09.925" starttime="20190402 07:13:09.924"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:09.925" starttime="20190402 07:13:08.813"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:13:14.926" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:14.926" starttime="20190402 07:13:14.926"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:14.927" starttime="20190402 07:13:14.927"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:13:14.928" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:13:14.928" starttime="20190402 07:13:14.927"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:14.928" starttime="20190402 07:13:14.928"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:14.929" starttime="20190402 07:13:14.928"></status>
</kw>
<msg timestamp="20190402 07:13:14.929" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:13:14.929" starttime="20190402 07:13:14.927"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:13:14.929" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:14.929" starttime="20190402 07:13:14.929"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:13:14.940" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:14.940" starttime="20190402 07:13:14.929"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:13:16.138" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:13:16.138" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:16.138" starttime="20190402 07:13:14.940"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:13:16.139" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:16.139" starttime="20190402 07:13:16.139"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:13:16.139" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:16.139" starttime="20190402 07:13:16.139"></status>
</kw>
<msg timestamp="20190402 07:13:16.139" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:16.139" starttime="20190402 07:13:16.138"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:13:16.141" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:13:16.141" starttime="20190402 07:13:16.140"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:13:16.142" level="INFO">0</msg>
<msg timestamp="20190402 07:13:16.142" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:16.142" starttime="20190402 07:13:16.141"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:13:16.142" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:13:16.142" starttime="20190402 07:13:16.142"></status>
</kw>
<msg timestamp="20190402 07:13:16.142" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:16.142" starttime="20190402 07:13:16.140"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:16.143" starttime="20190402 07:13:16.143"></status>
</kw>
<status status="PASS" endtime="20190402 07:13:16.143" starttime="20190402 07:13:16.142"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:16.143" starttime="20190402 07:13:16.143"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:13:16.144" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:13:16.144" starttime="20190402 07:13:16.143"></status>
</kw>
<msg timestamp="20190402 07:13:16.144" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:13:16.144" starttime="20190402 07:13:14.926"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:13:16.144" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:13:16.144" starttime="20190402 07:13:16.144"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:13:16.145" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:13:16.145" starttime="20190402 07:13:16.145"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:16.145" starttime="20190402 07:13:16.144"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:16.145" starttime="20190402 07:13:14.925"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:13:21.148" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:21.148" starttime="20190402 07:13:21.147"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:21.150" starttime="20190402 07:13:21.150"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:13:21.153" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:13:21.153" starttime="20190402 07:13:21.151"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:21.154" starttime="20190402 07:13:21.153"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:21.155" starttime="20190402 07:13:21.154"></status>
</kw>
<msg timestamp="20190402 07:13:21.156" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:13:21.156" starttime="20190402 07:13:21.151"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:13:21.156" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:21.157" starttime="20190402 07:13:21.156"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:13:21.180" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:21.180" starttime="20190402 07:13:21.157"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:13:22.240" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:13:22.241" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:22.241" starttime="20190402 07:13:21.180"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:13:22.241" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:22.241" starttime="20190402 07:13:22.241"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:13:22.242" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:22.242" starttime="20190402 07:13:22.241"></status>
</kw>
<msg timestamp="20190402 07:13:22.242" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:22.242" starttime="20190402 07:13:22.241"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:13:22.244" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:13:22.244" starttime="20190402 07:13:22.242"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:13:22.244" level="INFO">0</msg>
<msg timestamp="20190402 07:13:22.244" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:22.244" starttime="20190402 07:13:22.244"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:13:22.244" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:13:22.245" starttime="20190402 07:13:22.244"></status>
</kw>
<msg timestamp="20190402 07:13:22.245" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:22.245" starttime="20190402 07:13:22.242"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:22.245" starttime="20190402 07:13:22.245"></status>
</kw>
<status status="PASS" endtime="20190402 07:13:22.245" starttime="20190402 07:13:22.245"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:22.246" starttime="20190402 07:13:22.246"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:13:22.246" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:13:22.246" starttime="20190402 07:13:22.246"></status>
</kw>
<msg timestamp="20190402 07:13:22.246" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:13:22.246" starttime="20190402 07:13:21.149"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:13:22.247" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:13:22.247" starttime="20190402 07:13:22.246"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:13:22.247" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:13:22.247" starttime="20190402 07:13:22.247"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:22.247" starttime="20190402 07:13:22.247"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:22.248" starttime="20190402 07:13:21.146"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:13:27.251" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:27.251" starttime="20190402 07:13:27.249"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:27.254" starttime="20190402 07:13:27.253"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:13:27.256" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:13:27.257" starttime="20190402 07:13:27.255"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:27.258" starttime="20190402 07:13:27.257"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:27.259" starttime="20190402 07:13:27.258"></status>
</kw>
<msg timestamp="20190402 07:13:27.259" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:13:27.259" starttime="20190402 07:13:27.254"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:13:27.260" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:27.260" starttime="20190402 07:13:27.260"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:13:27.282" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:27.282" starttime="20190402 07:13:27.260"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:13:28.467" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:13:28.467" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:28.467" starttime="20190402 07:13:27.283"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:13:28.468" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:28.468" starttime="20190402 07:13:28.468"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:13:28.468" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:28.468" starttime="20190402 07:13:28.468"></status>
</kw>
<msg timestamp="20190402 07:13:28.468" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:28.468" starttime="20190402 07:13:28.467"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:13:28.470" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:13:28.470" starttime="20190402 07:13:28.469"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:13:28.471" level="INFO">0</msg>
<msg timestamp="20190402 07:13:28.471" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:28.471" starttime="20190402 07:13:28.470"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:13:28.471" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:13:28.471" starttime="20190402 07:13:28.471"></status>
</kw>
<msg timestamp="20190402 07:13:28.471" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:28.471" starttime="20190402 07:13:28.468"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:28.472" starttime="20190402 07:13:28.472"></status>
</kw>
<status status="PASS" endtime="20190402 07:13:28.472" starttime="20190402 07:13:28.472"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:28.473" starttime="20190402 07:13:28.472"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:13:28.473" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:13:28.473" starttime="20190402 07:13:28.473"></status>
</kw>
<msg timestamp="20190402 07:13:28.473" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:13:28.473" starttime="20190402 07:13:27.252"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:13:28.473" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:13:28.474" starttime="20190402 07:13:28.473"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:13:28.474" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:13:28.474" starttime="20190402 07:13:28.474"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:28.474" starttime="20190402 07:13:28.474"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:28.474" starttime="20190402 07:13:27.248"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:13:33.477" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:33.477" starttime="20190402 07:13:33.476"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:33.480" starttime="20190402 07:13:33.479"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:13:33.481" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:13:33.481" starttime="20190402 07:13:33.481"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:33.481" starttime="20190402 07:13:33.481"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:33.482" starttime="20190402 07:13:33.481"></status>
</kw>
<msg timestamp="20190402 07:13:33.482" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:13:33.482" starttime="20190402 07:13:33.480"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:13:33.482" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:33.482" starttime="20190402 07:13:33.482"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:13:33.491" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:33.491" starttime="20190402 07:13:33.482"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:13:34.639" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:13:34.639" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:34.639" starttime="20190402 07:13:33.491"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:13:34.640" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:34.640" starttime="20190402 07:13:34.640"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:13:34.640" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:34.640" starttime="20190402 07:13:34.640"></status>
</kw>
<msg timestamp="20190402 07:13:34.640" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:34.640" starttime="20190402 07:13:34.639"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:13:34.642" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:13:34.642" starttime="20190402 07:13:34.641"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:13:34.643" level="INFO">0</msg>
<msg timestamp="20190402 07:13:34.643" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:34.643" starttime="20190402 07:13:34.642"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:13:34.643" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:13:34.643" starttime="20190402 07:13:34.643"></status>
</kw>
<msg timestamp="20190402 07:13:34.644" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:34.644" starttime="20190402 07:13:34.641"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:34.644" starttime="20190402 07:13:34.644"></status>
</kw>
<status status="PASS" endtime="20190402 07:13:34.644" starttime="20190402 07:13:34.644"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:34.645" starttime="20190402 07:13:34.645"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:13:34.645" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:13:34.645" starttime="20190402 07:13:34.645"></status>
</kw>
<msg timestamp="20190402 07:13:34.645" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:13:34.645" starttime="20190402 07:13:33.478"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:13:34.646" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:13:34.646" starttime="20190402 07:13:34.645"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:13:34.646" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:13:34.646" starttime="20190402 07:13:34.646"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:34.646" starttime="20190402 07:13:34.646"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:34.647" starttime="20190402 07:13:33.475"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:13:39.648" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:39.648" starttime="20190402 07:13:39.648"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:39.649" starttime="20190402 07:13:39.649"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:13:39.650" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:13:39.651" starttime="20190402 07:13:39.650"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:39.651" starttime="20190402 07:13:39.651"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:39.652" starttime="20190402 07:13:39.651"></status>
</kw>
<msg timestamp="20190402 07:13:39.652" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:13:39.652" starttime="20190402 07:13:39.649"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:13:39.653" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:39.653" starttime="20190402 07:13:39.652"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:13:39.666" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:39.666" starttime="20190402 07:13:39.653"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:13:41.235" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:13:41.235" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:41.235" starttime="20190402 07:13:39.666"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:13:41.236" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:41.236" starttime="20190402 07:13:41.235"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:13:41.236" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:41.236" starttime="20190402 07:13:41.236"></status>
</kw>
<msg timestamp="20190402 07:13:41.236" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:41.236" starttime="20190402 07:13:41.235"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:13:41.238" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:13:41.238" starttime="20190402 07:13:41.236"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:13:41.244" level="INFO">0</msg>
<msg timestamp="20190402 07:13:41.244" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:41.244" starttime="20190402 07:13:41.238"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:13:41.244" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:13:41.244" starttime="20190402 07:13:41.244"></status>
</kw>
<msg timestamp="20190402 07:13:41.245" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:41.245" starttime="20190402 07:13:41.236"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:41.246" starttime="20190402 07:13:41.245"></status>
</kw>
<status status="PASS" endtime="20190402 07:13:41.246" starttime="20190402 07:13:41.245"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:41.246" starttime="20190402 07:13:41.246"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:13:41.246" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:13:41.246" starttime="20190402 07:13:41.246"></status>
</kw>
<msg timestamp="20190402 07:13:41.246" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:13:41.247" starttime="20190402 07:13:39.648"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:13:41.247" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:13:41.247" starttime="20190402 07:13:41.247"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:13:41.248" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:13:41.248" starttime="20190402 07:13:41.247"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:41.248" starttime="20190402 07:13:41.247"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:41.248" starttime="20190402 07:13:39.647"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:13:46.251" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:46.251" starttime="20190402 07:13:46.250"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:46.253" starttime="20190402 07:13:46.253"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:13:46.254" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:13:46.254" starttime="20190402 07:13:46.253"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:46.254" starttime="20190402 07:13:46.254"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:46.254" starttime="20190402 07:13:46.254"></status>
</kw>
<msg timestamp="20190402 07:13:46.255" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:13:46.255" starttime="20190402 07:13:46.253"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:13:46.255" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:46.255" starttime="20190402 07:13:46.255"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:13:46.264" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:46.264" starttime="20190402 07:13:46.255"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:13:47.802" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:13:47.802" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:47.802" starttime="20190402 07:13:46.264"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:13:47.803" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:47.803" starttime="20190402 07:13:47.803"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:13:47.803" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:47.803" starttime="20190402 07:13:47.803"></status>
</kw>
<msg timestamp="20190402 07:13:47.803" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:47.803" starttime="20190402 07:13:47.802"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:13:47.806" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:13:47.806" starttime="20190402 07:13:47.804"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:13:47.806" level="INFO">0</msg>
<msg timestamp="20190402 07:13:47.806" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:47.806" starttime="20190402 07:13:47.806"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:13:47.807" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:13:47.807" starttime="20190402 07:13:47.807"></status>
</kw>
<msg timestamp="20190402 07:13:47.807" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:47.807" starttime="20190402 07:13:47.804"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:47.808" starttime="20190402 07:13:47.807"></status>
</kw>
<status status="PASS" endtime="20190402 07:13:47.808" starttime="20190402 07:13:47.807"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:47.808" starttime="20190402 07:13:47.808"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:13:47.808" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:13:47.808" starttime="20190402 07:13:47.808"></status>
</kw>
<msg timestamp="20190402 07:13:47.809" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:13:47.809" starttime="20190402 07:13:46.251"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:13:47.809" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:13:47.809" starttime="20190402 07:13:47.809"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:13:47.810" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:13:47.810" starttime="20190402 07:13:47.809"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:47.810" starttime="20190402 07:13:47.809"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:47.810" starttime="20190402 07:13:46.248"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:13:52.813" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:52.813" starttime="20190402 07:13:52.812"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:52.816" starttime="20190402 07:13:52.815"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:13:52.817" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:13:52.817" starttime="20190402 07:13:52.816"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:52.817" starttime="20190402 07:13:52.817"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:52.817" starttime="20190402 07:13:52.817"></status>
</kw>
<msg timestamp="20190402 07:13:52.818" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:13:52.818" starttime="20190402 07:13:52.816"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:13:52.818" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:52.818" starttime="20190402 07:13:52.818"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:13:52.826" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:52.826" starttime="20190402 07:13:52.818"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:13:54.260" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:13:54.260" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:54.260" starttime="20190402 07:13:52.827"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:13:54.261" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:54.261" starttime="20190402 07:13:54.261"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:13:54.261" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:54.261" starttime="20190402 07:13:54.261"></status>
</kw>
<msg timestamp="20190402 07:13:54.261" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:13:54.261" starttime="20190402 07:13:54.260"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:13:54.263" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:13:54.263" starttime="20190402 07:13:54.262"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:13:54.265" level="INFO">0</msg>
<msg timestamp="20190402 07:13:54.265" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:54.265" starttime="20190402 07:13:54.263"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:13:54.265" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:13:54.266" starttime="20190402 07:13:54.265"></status>
</kw>
<msg timestamp="20190402 07:13:54.266" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:13:54.266" starttime="20190402 07:13:54.261"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:54.267" starttime="20190402 07:13:54.266"></status>
</kw>
<status status="PASS" endtime="20190402 07:13:54.267" starttime="20190402 07:13:54.266"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:54.267" starttime="20190402 07:13:54.267"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:13:54.267" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:13:54.267" starttime="20190402 07:13:54.267"></status>
</kw>
<msg timestamp="20190402 07:13:54.268" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:13:54.268" starttime="20190402 07:13:52.813"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:13:54.268" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:13:54.268" starttime="20190402 07:13:54.268"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:13:54.269" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:13:54.269" starttime="20190402 07:13:54.268"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:54.269" starttime="20190402 07:13:54.268"></status>
</kw>
<status status="FAIL" endtime="20190402 07:13:54.269" starttime="20190402 07:13:52.811"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:13:59.272" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:59.272" starttime="20190402 07:13:59.271"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:59.274" starttime="20190402 07:13:59.273"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:13:59.275" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:13:59.275" starttime="20190402 07:13:59.275"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:59.276" starttime="20190402 07:13:59.276"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:13:59.276" starttime="20190402 07:13:59.276"></status>
</kw>
<msg timestamp="20190402 07:13:59.276" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:13:59.276" starttime="20190402 07:13:59.275"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:13:59.277" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:13:59.277" starttime="20190402 07:13:59.276"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:13:59.290" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:13:59.290" starttime="20190402 07:13:59.277"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:14:00.572" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:14:00.572" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:00.572" starttime="20190402 07:13:59.290"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:14:00.573" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:00.573" starttime="20190402 07:14:00.573"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:14:00.573" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:00.573" starttime="20190402 07:14:00.573"></status>
</kw>
<msg timestamp="20190402 07:14:00.574" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:00.574" starttime="20190402 07:14:00.572"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:14:00.576" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:14:00.576" starttime="20190402 07:14:00.574"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:14:00.577" level="INFO">0</msg>
<msg timestamp="20190402 07:14:00.577" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:00.577" starttime="20190402 07:14:00.577"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:14:00.577" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:14:00.577" starttime="20190402 07:14:00.577"></status>
</kw>
<msg timestamp="20190402 07:14:00.577" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:00.577" starttime="20190402 07:14:00.574"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:00.578" starttime="20190402 07:14:00.578"></status>
</kw>
<status status="PASS" endtime="20190402 07:14:00.578" starttime="20190402 07:14:00.577"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:00.578" starttime="20190402 07:14:00.578"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:14:00.579" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:14:00.579" starttime="20190402 07:14:00.579"></status>
</kw>
<msg timestamp="20190402 07:14:00.579" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:14:00.579" starttime="20190402 07:13:59.272"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:14:00.579" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:14:00.579" starttime="20190402 07:14:00.579"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:14:00.580" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:14:00.580" starttime="20190402 07:14:00.580"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:00.580" starttime="20190402 07:14:00.579"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:00.580" starttime="20190402 07:13:59.269"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:14:05.583" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:05.583" starttime="20190402 07:14:05.582"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:05.586" starttime="20190402 07:14:05.585"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:14:05.587" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:14:05.587" starttime="20190402 07:14:05.586"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:05.587" starttime="20190402 07:14:05.587"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:05.587" starttime="20190402 07:14:05.587"></status>
</kw>
<msg timestamp="20190402 07:14:05.588" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:14:05.588" starttime="20190402 07:14:05.586"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:14:05.588" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:05.588" starttime="20190402 07:14:05.588"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:14:05.597" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:05.597" starttime="20190402 07:14:05.588"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:14:07.181" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:14:07.182" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:07.182" starttime="20190402 07:14:05.597"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:14:07.182" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:07.182" starttime="20190402 07:14:07.182"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:14:07.183" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:07.183" starttime="20190402 07:14:07.183"></status>
</kw>
<msg timestamp="20190402 07:14:07.183" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:07.183" starttime="20190402 07:14:07.182"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:14:07.185" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:14:07.185" starttime="20190402 07:14:07.183"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:14:07.186" level="INFO">0</msg>
<msg timestamp="20190402 07:14:07.186" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:07.186" starttime="20190402 07:14:07.185"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:14:07.186" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:14:07.186" starttime="20190402 07:14:07.186"></status>
</kw>
<msg timestamp="20190402 07:14:07.186" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:07.186" starttime="20190402 07:14:07.183"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:07.187" starttime="20190402 07:14:07.187"></status>
</kw>
<status status="PASS" endtime="20190402 07:14:07.187" starttime="20190402 07:14:07.186"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:07.187" starttime="20190402 07:14:07.187"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:14:07.188" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:14:07.188" starttime="20190402 07:14:07.188"></status>
</kw>
<msg timestamp="20190402 07:14:07.188" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:14:07.188" starttime="20190402 07:14:05.584"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:14:07.188" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:14:07.188" starttime="20190402 07:14:07.188"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:14:07.189" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:14:07.189" starttime="20190402 07:14:07.189"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:07.189" starttime="20190402 07:14:07.188"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:07.189" starttime="20190402 07:14:05.581"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:14:12.192" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:12.192" starttime="20190402 07:14:12.191"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:12.195" starttime="20190402 07:14:12.194"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:14:12.196" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:14:12.196" starttime="20190402 07:14:12.195"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:12.196" starttime="20190402 07:14:12.196"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:12.196" starttime="20190402 07:14:12.196"></status>
</kw>
<msg timestamp="20190402 07:14:12.197" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:14:12.197" starttime="20190402 07:14:12.195"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:14:12.197" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:12.197" starttime="20190402 07:14:12.197"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:14:12.206" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:12.207" starttime="20190402 07:14:12.197"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:14:13.355" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:14:13.356" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:13.356" starttime="20190402 07:14:12.207"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:14:13.356" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:13.356" starttime="20190402 07:14:13.356"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:14:13.357" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:13.357" starttime="20190402 07:14:13.356"></status>
</kw>
<msg timestamp="20190402 07:14:13.357" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:13.357" starttime="20190402 07:14:13.356"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:14:13.359" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:14:13.359" starttime="20190402 07:14:13.357"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:14:13.359" level="INFO">0</msg>
<msg timestamp="20190402 07:14:13.359" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:13.359" starttime="20190402 07:14:13.359"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:14:13.359" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:14:13.360" starttime="20190402 07:14:13.359"></status>
</kw>
<msg timestamp="20190402 07:14:13.360" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:13.360" starttime="20190402 07:14:13.357"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:13.361" starttime="20190402 07:14:13.360"></status>
</kw>
<status status="PASS" endtime="20190402 07:14:13.361" starttime="20190402 07:14:13.360"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:13.361" starttime="20190402 07:14:13.361"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:14:13.361" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:14:13.361" starttime="20190402 07:14:13.361"></status>
</kw>
<msg timestamp="20190402 07:14:13.362" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:14:13.362" starttime="20190402 07:14:12.193"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:14:13.362" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:14:13.362" starttime="20190402 07:14:13.362"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:14:13.363" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:14:13.363" starttime="20190402 07:14:13.362"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:13.363" starttime="20190402 07:14:13.362"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:13.363" starttime="20190402 07:14:12.190"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:14:18.366" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:18.366" starttime="20190402 07:14:18.365"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:18.369" starttime="20190402 07:14:18.368"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:14:18.370" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:14:18.370" starttime="20190402 07:14:18.369"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:18.370" starttime="20190402 07:14:18.370"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:18.371" starttime="20190402 07:14:18.370"></status>
</kw>
<msg timestamp="20190402 07:14:18.371" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:14:18.371" starttime="20190402 07:14:18.369"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:14:18.371" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:18.371" starttime="20190402 07:14:18.371"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:14:18.373" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:18.373" starttime="20190402 07:14:18.371"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:14:19.732" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:14:19.732" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:19.732" starttime="20190402 07:14:18.373"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:14:19.733" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:19.733" starttime="20190402 07:14:19.733"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:14:19.733" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:19.733" starttime="20190402 07:14:19.733"></status>
</kw>
<msg timestamp="20190402 07:14:19.734" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:19.734" starttime="20190402 07:14:19.733"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:14:19.735" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:14:19.735" starttime="20190402 07:14:19.734"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:14:19.735" level="INFO">0</msg>
<msg timestamp="20190402 07:14:19.735" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:19.735" starttime="20190402 07:14:19.735"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:14:19.736" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:14:19.736" starttime="20190402 07:14:19.736"></status>
</kw>
<msg timestamp="20190402 07:14:19.736" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:19.736" starttime="20190402 07:14:19.734"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:19.737" starttime="20190402 07:14:19.736"></status>
</kw>
<status status="PASS" endtime="20190402 07:14:19.737" starttime="20190402 07:14:19.736"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:19.737" starttime="20190402 07:14:19.737"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:14:19.737" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:14:19.737" starttime="20190402 07:14:19.737"></status>
</kw>
<msg timestamp="20190402 07:14:19.738" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:14:19.738" starttime="20190402 07:14:18.366"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:14:19.738" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:14:19.738" starttime="20190402 07:14:19.738"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:14:19.739" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:14:19.739" starttime="20190402 07:14:19.739"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:19.739" starttime="20190402 07:14:19.738"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:19.739" starttime="20190402 07:14:18.364"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:14:24.742" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:24.742" starttime="20190402 07:14:24.741"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:24.745" starttime="20190402 07:14:24.744"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:14:24.746" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:14:24.746" starttime="20190402 07:14:24.745"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:24.746" starttime="20190402 07:14:24.746"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:24.746" starttime="20190402 07:14:24.746"></status>
</kw>
<msg timestamp="20190402 07:14:24.747" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:14:24.747" starttime="20190402 07:14:24.745"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:14:24.747" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:24.747" starttime="20190402 07:14:24.747"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:14:24.757" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:24.757" starttime="20190402 07:14:24.747"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:14:26.015" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:14:26.015" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:26.015" starttime="20190402 07:14:24.758"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:14:26.016" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:26.016" starttime="20190402 07:14:26.015"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:14:26.016" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:26.016" starttime="20190402 07:14:26.016"></status>
</kw>
<msg timestamp="20190402 07:14:26.016" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:26.016" starttime="20190402 07:14:26.015"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:14:26.018" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:14:26.018" starttime="20190402 07:14:26.017"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:14:26.023" level="INFO">0</msg>
<msg timestamp="20190402 07:14:26.023" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:26.023" starttime="20190402 07:14:26.018"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:14:26.024" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:14:26.024" starttime="20190402 07:14:26.023"></status>
</kw>
<msg timestamp="20190402 07:14:26.024" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:26.024" starttime="20190402 07:14:26.016"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:26.025" starttime="20190402 07:14:26.024"></status>
</kw>
<status status="PASS" endtime="20190402 07:14:26.025" starttime="20190402 07:14:26.024"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:26.025" starttime="20190402 07:14:26.025"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:14:26.025" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:14:26.025" starttime="20190402 07:14:26.025"></status>
</kw>
<msg timestamp="20190402 07:14:26.025" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:14:26.025" starttime="20190402 07:14:24.742"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:14:26.026" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:14:26.026" starttime="20190402 07:14:26.026"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:14:26.027" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:14:26.027" starttime="20190402 07:14:26.026"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:26.027" starttime="20190402 07:14:26.026"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:26.027" starttime="20190402 07:14:24.740"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:14:31.030" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:31.030" starttime="20190402 07:14:31.029"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:31.033" starttime="20190402 07:14:31.032"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:14:31.034" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:14:31.034" starttime="20190402 07:14:31.033"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:31.034" starttime="20190402 07:14:31.034"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:31.034" starttime="20190402 07:14:31.034"></status>
</kw>
<msg timestamp="20190402 07:14:31.035" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:14:31.035" starttime="20190402 07:14:31.033"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:14:31.035" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:31.035" starttime="20190402 07:14:31.035"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:14:31.043" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:31.043" starttime="20190402 07:14:31.035"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:14:32.150" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:14:32.150" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:32.150" starttime="20190402 07:14:31.043"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:14:32.151" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:32.151" starttime="20190402 07:14:32.151"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:14:32.151" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:32.151" starttime="20190402 07:14:32.151"></status>
</kw>
<msg timestamp="20190402 07:14:32.151" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:32.151" starttime="20190402 07:14:32.150"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:14:32.153" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:14:32.153" starttime="20190402 07:14:32.152"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:14:32.153" level="INFO">0</msg>
<msg timestamp="20190402 07:14:32.153" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:32.153" starttime="20190402 07:14:32.153"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:14:32.154" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:14:32.154" starttime="20190402 07:14:32.154"></status>
</kw>
<msg timestamp="20190402 07:14:32.154" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:32.154" starttime="20190402 07:14:32.152"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:32.155" starttime="20190402 07:14:32.154"></status>
</kw>
<status status="PASS" endtime="20190402 07:14:32.155" starttime="20190402 07:14:32.154"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:32.155" starttime="20190402 07:14:32.155"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:14:32.155" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:14:32.155" starttime="20190402 07:14:32.155"></status>
</kw>
<msg timestamp="20190402 07:14:32.156" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:14:32.156" starttime="20190402 07:14:31.030"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:14:32.156" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:14:32.156" starttime="20190402 07:14:32.156"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:14:32.157" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:14:32.157" starttime="20190402 07:14:32.156"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:32.157" starttime="20190402 07:14:32.156"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:32.157" starttime="20190402 07:14:31.028"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:14:37.161" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:37.161" starttime="20190402 07:14:37.159"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:37.163" starttime="20190402 07:14:37.163"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:14:37.164" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:14:37.164" starttime="20190402 07:14:37.163"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:37.164" starttime="20190402 07:14:37.164"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:37.165" starttime="20190402 07:14:37.164"></status>
</kw>
<msg timestamp="20190402 07:14:37.165" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:14:37.165" starttime="20190402 07:14:37.163"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:14:37.165" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:37.165" starttime="20190402 07:14:37.165"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:14:37.174" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:37.174" starttime="20190402 07:14:37.165"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:14:38.211" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:14:38.211" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:38.211" starttime="20190402 07:14:37.175"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:14:38.212" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:38.212" starttime="20190402 07:14:38.212"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:14:38.213" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:38.213" starttime="20190402 07:14:38.212"></status>
</kw>
<msg timestamp="20190402 07:14:38.213" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:38.213" starttime="20190402 07:14:38.212"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:14:38.215" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:14:38.215" starttime="20190402 07:14:38.213"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:14:38.216" level="INFO">0</msg>
<msg timestamp="20190402 07:14:38.216" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:38.216" starttime="20190402 07:14:38.215"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:14:38.216" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:14:38.216" starttime="20190402 07:14:38.216"></status>
</kw>
<msg timestamp="20190402 07:14:38.217" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:38.217" starttime="20190402 07:14:38.213"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:38.217" starttime="20190402 07:14:38.217"></status>
</kw>
<status status="PASS" endtime="20190402 07:14:38.218" starttime="20190402 07:14:38.217"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:38.218" starttime="20190402 07:14:38.218"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:14:38.218" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:14:38.218" starttime="20190402 07:14:38.218"></status>
</kw>
<msg timestamp="20190402 07:14:38.218" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:14:38.218" starttime="20190402 07:14:37.161"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:14:38.219" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:14:38.219" starttime="20190402 07:14:38.219"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:14:38.219" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:14:38.220" starttime="20190402 07:14:38.219"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:38.220" starttime="20190402 07:14:38.219"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:38.220" starttime="20190402 07:14:37.158"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:14:43.222" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:43.222" starttime="20190402 07:14:43.221"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:43.224" starttime="20190402 07:14:43.223"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:14:43.225" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:14:43.225" starttime="20190402 07:14:43.225"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:43.226" starttime="20190402 07:14:43.226"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:43.226" starttime="20190402 07:14:43.226"></status>
</kw>
<msg timestamp="20190402 07:14:43.226" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:14:43.226" starttime="20190402 07:14:43.225"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:14:43.227" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:43.227" starttime="20190402 07:14:43.226"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:14:43.235" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:43.235" starttime="20190402 07:14:43.227"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:14:44.494" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:14:44.494" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:44.494" starttime="20190402 07:14:43.235"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:14:44.495" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:44.495" starttime="20190402 07:14:44.495"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:14:44.495" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:44.495" starttime="20190402 07:14:44.495"></status>
</kw>
<msg timestamp="20190402 07:14:44.495" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:44.495" starttime="20190402 07:14:44.494"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:14:44.497" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:14:44.497" starttime="20190402 07:14:44.496"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:14:44.497" level="INFO">0</msg>
<msg timestamp="20190402 07:14:44.498" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:44.498" starttime="20190402 07:14:44.497"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:14:44.498" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:14:44.498" starttime="20190402 07:14:44.498"></status>
</kw>
<msg timestamp="20190402 07:14:44.498" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:44.498" starttime="20190402 07:14:44.495"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:44.499" starttime="20190402 07:14:44.499"></status>
</kw>
<status status="PASS" endtime="20190402 07:14:44.499" starttime="20190402 07:14:44.498"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:44.499" starttime="20190402 07:14:44.499"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:14:44.499" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:14:44.500" starttime="20190402 07:14:44.499"></status>
</kw>
<msg timestamp="20190402 07:14:44.500" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:14:44.500" starttime="20190402 07:14:43.222"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:14:44.500" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:14:44.500" starttime="20190402 07:14:44.500"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:14:44.501" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:14:44.501" starttime="20190402 07:14:44.501"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:44.501" starttime="20190402 07:14:44.500"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:44.501" starttime="20190402 07:14:43.220"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:14:49.504" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:49.504" starttime="20190402 07:14:49.503"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:49.507" starttime="20190402 07:14:49.506"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:14:49.508" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:14:49.508" starttime="20190402 07:14:49.507"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:49.509" starttime="20190402 07:14:49.508"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:49.509" starttime="20190402 07:14:49.509"></status>
</kw>
<msg timestamp="20190402 07:14:49.509" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:14:49.509" starttime="20190402 07:14:49.507"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:14:49.510" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:49.510" starttime="20190402 07:14:49.509"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:14:49.519" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:49.519" starttime="20190402 07:14:49.510"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:14:50.788" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:14:50.789" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:50.789" starttime="20190402 07:14:49.519"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:14:50.789" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:50.789" starttime="20190402 07:14:50.789"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:14:50.790" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:50.790" starttime="20190402 07:14:50.789"></status>
</kw>
<msg timestamp="20190402 07:14:50.790" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:50.790" starttime="20190402 07:14:50.789"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:14:50.792" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:14:50.792" starttime="20190402 07:14:50.790"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:14:50.792" level="INFO">0</msg>
<msg timestamp="20190402 07:14:50.792" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:50.792" starttime="20190402 07:14:50.792"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:14:50.793" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:14:50.793" starttime="20190402 07:14:50.793"></status>
</kw>
<msg timestamp="20190402 07:14:50.793" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:50.793" starttime="20190402 07:14:50.790"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:50.794" starttime="20190402 07:14:50.793"></status>
</kw>
<status status="PASS" endtime="20190402 07:14:50.794" starttime="20190402 07:14:50.793"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:50.794" starttime="20190402 07:14:50.794"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:14:50.794" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:14:50.794" starttime="20190402 07:14:50.794"></status>
</kw>
<msg timestamp="20190402 07:14:50.795" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:14:50.795" starttime="20190402 07:14:49.505"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:14:50.795" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:14:50.795" starttime="20190402 07:14:50.795"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:14:50.796" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:14:50.796" starttime="20190402 07:14:50.795"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:50.796" starttime="20190402 07:14:50.795"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:50.796" starttime="20190402 07:14:49.502"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:14:55.799" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:55.799" starttime="20190402 07:14:55.798"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:55.802" starttime="20190402 07:14:55.801"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:14:55.803" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:14:55.803" starttime="20190402 07:14:55.802"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:55.803" starttime="20190402 07:14:55.803"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:55.804" starttime="20190402 07:14:55.803"></status>
</kw>
<msg timestamp="20190402 07:14:55.804" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:14:55.804" starttime="20190402 07:14:55.802"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:14:55.804" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:55.805" starttime="20190402 07:14:55.804"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:14:55.813" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:14:55.813" starttime="20190402 07:14:55.805"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:14:56.899" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:14:56.900" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:56.900" starttime="20190402 07:14:55.813"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:14:56.900" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:14:56.900" starttime="20190402 07:14:56.900"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:14:56.901" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:56.901" starttime="20190402 07:14:56.900"></status>
</kw>
<msg timestamp="20190402 07:14:56.901" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:14:56.901" starttime="20190402 07:14:56.900"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:14:56.903" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:14:56.903" starttime="20190402 07:14:56.901"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:14:56.903" level="INFO">0</msg>
<msg timestamp="20190402 07:14:56.903" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:56.903" starttime="20190402 07:14:56.903"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:14:56.904" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:14:56.904" starttime="20190402 07:14:56.904"></status>
</kw>
<msg timestamp="20190402 07:14:56.904" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:14:56.904" starttime="20190402 07:14:56.901"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:56.905" starttime="20190402 07:14:56.904"></status>
</kw>
<status status="PASS" endtime="20190402 07:14:56.905" starttime="20190402 07:14:56.904"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:14:56.905" starttime="20190402 07:14:56.905"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:14:56.905" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:14:56.905" starttime="20190402 07:14:56.905"></status>
</kw>
<msg timestamp="20190402 07:14:56.906" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:14:56.906" starttime="20190402 07:14:55.800"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:14:56.906" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:14:56.906" starttime="20190402 07:14:56.906"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:14:56.907" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:14:56.907" starttime="20190402 07:14:56.906"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:56.907" starttime="20190402 07:14:56.906"></status>
</kw>
<status status="FAIL" endtime="20190402 07:14:56.907" starttime="20190402 07:14:55.797"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:15:01.909" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:01.909" starttime="20190402 07:15:01.908"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:01.910" starttime="20190402 07:15:01.909"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:15:01.911" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:15:01.911" starttime="20190402 07:15:01.910"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:01.911" starttime="20190402 07:15:01.911"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:01.911" starttime="20190402 07:15:01.911"></status>
</kw>
<msg timestamp="20190402 07:15:01.912" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:15:01.912" starttime="20190402 07:15:01.910"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:15:01.912" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:01.912" starttime="20190402 07:15:01.912"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:15:01.917" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:01.917" starttime="20190402 07:15:01.912"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:15:03.114" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:15:03.114" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:03.114" starttime="20190402 07:15:01.917"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:15:03.115" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:03.115" starttime="20190402 07:15:03.115"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:15:03.115" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:03.115" starttime="20190402 07:15:03.115"></status>
</kw>
<msg timestamp="20190402 07:15:03.115" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:03.115" starttime="20190402 07:15:03.114"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:15:03.117" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:15:03.117" starttime="20190402 07:15:03.116"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:15:03.117" level="INFO">0</msg>
<msg timestamp="20190402 07:15:03.117" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:03.118" starttime="20190402 07:15:03.117"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:15:03.118" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:15:03.118" starttime="20190402 07:15:03.118"></status>
</kw>
<msg timestamp="20190402 07:15:03.118" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:03.118" starttime="20190402 07:15:03.115"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:03.119" starttime="20190402 07:15:03.118"></status>
</kw>
<status status="PASS" endtime="20190402 07:15:03.119" starttime="20190402 07:15:03.118"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:03.119" starttime="20190402 07:15:03.119"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:15:03.119" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:15:03.119" starttime="20190402 07:15:03.119"></status>
</kw>
<msg timestamp="20190402 07:15:03.120" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:15:03.120" starttime="20190402 07:15:01.909"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:15:03.120" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:15:03.120" starttime="20190402 07:15:03.120"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:15:03.121" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:15:03.121" starttime="20190402 07:15:03.120"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:03.121" starttime="20190402 07:15:03.120"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:03.121" starttime="20190402 07:15:01.907"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:15:08.124" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:08.124" starttime="20190402 07:15:08.123"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:08.127" starttime="20190402 07:15:08.126"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:15:08.128" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:15:08.128" starttime="20190402 07:15:08.127"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:08.128" starttime="20190402 07:15:08.128"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:08.128" starttime="20190402 07:15:08.128"></status>
</kw>
<msg timestamp="20190402 07:15:08.129" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:15:08.129" starttime="20190402 07:15:08.127"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:15:08.129" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:08.129" starttime="20190402 07:15:08.129"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:15:08.138" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:08.138" starttime="20190402 07:15:08.129"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:15:09.346" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:15:09.346" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:09.346" starttime="20190402 07:15:08.138"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:15:09.347" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:09.347" starttime="20190402 07:15:09.347"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:15:09.348" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:09.348" starttime="20190402 07:15:09.347"></status>
</kw>
<msg timestamp="20190402 07:15:09.348" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:09.348" starttime="20190402 07:15:09.346"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:15:09.350" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:15:09.350" starttime="20190402 07:15:09.348"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:15:09.350" level="INFO">0</msg>
<msg timestamp="20190402 07:15:09.351" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:09.351" starttime="20190402 07:15:09.350"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:15:09.351" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:15:09.351" starttime="20190402 07:15:09.351"></status>
</kw>
<msg timestamp="20190402 07:15:09.351" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:09.351" starttime="20190402 07:15:09.348"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:09.352" starttime="20190402 07:15:09.352"></status>
</kw>
<status status="PASS" endtime="20190402 07:15:09.352" starttime="20190402 07:15:09.351"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:09.352" starttime="20190402 07:15:09.352"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:15:09.353" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:15:09.353" starttime="20190402 07:15:09.352"></status>
</kw>
<msg timestamp="20190402 07:15:09.353" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:15:09.353" starttime="20190402 07:15:08.125"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:15:09.353" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:15:09.353" starttime="20190402 07:15:09.353"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:15:09.354" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:15:09.354" starttime="20190402 07:15:09.354"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:09.354" starttime="20190402 07:15:09.353"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:09.354" starttime="20190402 07:15:08.122"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:15:14.357" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:14.357" starttime="20190402 07:15:14.356"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:14.359" starttime="20190402 07:15:14.358"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:15:14.360" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:15:14.361" starttime="20190402 07:15:14.360"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:14.361" starttime="20190402 07:15:14.361"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:14.361" starttime="20190402 07:15:14.361"></status>
</kw>
<msg timestamp="20190402 07:15:14.361" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:15:14.361" starttime="20190402 07:15:14.360"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:15:14.362" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:14.362" starttime="20190402 07:15:14.362"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:15:14.371" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:14.371" starttime="20190402 07:15:14.362"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:15:15.483" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:15:15.484" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:15.484" starttime="20190402 07:15:14.371"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:15:15.484" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:15.484" starttime="20190402 07:15:15.484"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:15:15.485" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:15.485" starttime="20190402 07:15:15.484"></status>
</kw>
<msg timestamp="20190402 07:15:15.485" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:15.485" starttime="20190402 07:15:15.484"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:15:15.487" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:15:15.487" starttime="20190402 07:15:15.485"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:15:15.487" level="INFO">0</msg>
<msg timestamp="20190402 07:15:15.487" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:15.487" starttime="20190402 07:15:15.487"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:15:15.487" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:15:15.487" starttime="20190402 07:15:15.487"></status>
</kw>
<msg timestamp="20190402 07:15:15.488" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:15.488" starttime="20190402 07:15:15.485"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:15.488" starttime="20190402 07:15:15.488"></status>
</kw>
<status status="PASS" endtime="20190402 07:15:15.488" starttime="20190402 07:15:15.488"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:15.489" starttime="20190402 07:15:15.489"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:15:15.489" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:15:15.489" starttime="20190402 07:15:15.489"></status>
</kw>
<msg timestamp="20190402 07:15:15.489" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:15:15.489" starttime="20190402 07:15:14.357"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:15:15.490" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:15:15.490" starttime="20190402 07:15:15.489"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:15:15.490" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:15:15.490" starttime="20190402 07:15:15.490"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:15.490" starttime="20190402 07:15:15.490"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:15.491" starttime="20190402 07:15:14.355"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:15:20.494" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:20.494" starttime="20190402 07:15:20.493"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:20.496" starttime="20190402 07:15:20.496"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:15:20.499" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:15:20.499" starttime="20190402 07:15:20.498"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:20.501" starttime="20190402 07:15:20.500"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:20.502" starttime="20190402 07:15:20.501"></status>
</kw>
<msg timestamp="20190402 07:15:20.503" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:15:20.503" starttime="20190402 07:15:20.497"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:15:20.504" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:20.504" starttime="20190402 07:15:20.503"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:15:20.529" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:20.529" starttime="20190402 07:15:20.504"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:15:22.370" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:15:22.371" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:22.371" starttime="20190402 07:15:20.530"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:15:22.371" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:22.371" starttime="20190402 07:15:22.371"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:15:22.372" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:22.372" starttime="20190402 07:15:22.372"></status>
</kw>
<msg timestamp="20190402 07:15:22.372" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:22.372" starttime="20190402 07:15:22.371"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:15:22.374" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:15:22.374" starttime="20190402 07:15:22.372"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:15:22.375" level="INFO">0</msg>
<msg timestamp="20190402 07:15:22.375" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:22.375" starttime="20190402 07:15:22.374"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:15:22.376" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:15:22.376" starttime="20190402 07:15:22.375"></status>
</kw>
<msg timestamp="20190402 07:15:22.376" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:22.376" starttime="20190402 07:15:22.372"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:22.377" starttime="20190402 07:15:22.376"></status>
</kw>
<status status="PASS" endtime="20190402 07:15:22.377" starttime="20190402 07:15:22.376"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:22.377" starttime="20190402 07:15:22.377"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:15:22.378" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:15:22.378" starttime="20190402 07:15:22.377"></status>
</kw>
<msg timestamp="20190402 07:15:22.378" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:15:22.378" starttime="20190402 07:15:20.494"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:15:22.378" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:15:22.378" starttime="20190402 07:15:22.378"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:15:22.379" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:15:22.379" starttime="20190402 07:15:22.379"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:22.379" starttime="20190402 07:15:22.378"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:22.379" starttime="20190402 07:15:20.491"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:15:27.382" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:27.382" starttime="20190402 07:15:27.381"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:27.385" starttime="20190402 07:15:27.384"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:15:27.386" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:15:27.386" starttime="20190402 07:15:27.385"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:27.386" starttime="20190402 07:15:27.386"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:27.386" starttime="20190402 07:15:27.386"></status>
</kw>
<msg timestamp="20190402 07:15:27.387" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:15:27.387" starttime="20190402 07:15:27.385"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:15:27.387" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:27.387" starttime="20190402 07:15:27.387"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:15:27.397" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:27.397" starttime="20190402 07:15:27.387"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:15:28.968" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:15:28.968" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:28.968" starttime="20190402 07:15:27.397"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:15:28.969" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:28.969" starttime="20190402 07:15:28.969"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:15:28.969" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:28.969" starttime="20190402 07:15:28.969"></status>
</kw>
<msg timestamp="20190402 07:15:28.970" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:28.970" starttime="20190402 07:15:28.969"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:15:28.971" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:15:28.971" starttime="20190402 07:15:28.970"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:15:28.972" level="INFO">0</msg>
<msg timestamp="20190402 07:15:28.972" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:28.972" starttime="20190402 07:15:28.971"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:15:28.972" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:15:28.972" starttime="20190402 07:15:28.972"></status>
</kw>
<msg timestamp="20190402 07:15:28.973" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:28.973" starttime="20190402 07:15:28.970"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:28.973" starttime="20190402 07:15:28.973"></status>
</kw>
<status status="PASS" endtime="20190402 07:15:28.973" starttime="20190402 07:15:28.973"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:28.974" starttime="20190402 07:15:28.973"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:15:28.974" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:15:28.974" starttime="20190402 07:15:28.974"></status>
</kw>
<msg timestamp="20190402 07:15:28.974" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:15:28.974" starttime="20190402 07:15:27.383"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:15:28.975" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:15:28.975" starttime="20190402 07:15:28.974"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:15:28.976" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:15:28.976" starttime="20190402 07:15:28.975"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:28.976" starttime="20190402 07:15:28.975"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:28.976" starttime="20190402 07:15:27.380"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:15:33.977" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:33.977" starttime="20190402 07:15:33.976"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:33.978" starttime="20190402 07:15:33.977"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:15:33.978" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:15:33.978" starttime="20190402 07:15:33.978"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:33.979" starttime="20190402 07:15:33.978"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:33.979" starttime="20190402 07:15:33.979"></status>
</kw>
<msg timestamp="20190402 07:15:33.979" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:15:33.979" starttime="20190402 07:15:33.978"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:15:33.979" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:33.979" starttime="20190402 07:15:33.979"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:15:33.981" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:33.981" starttime="20190402 07:15:33.980"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:15:35.119" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:15:35.119" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:35.119" starttime="20190402 07:15:33.981"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:15:35.120" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:35.120" starttime="20190402 07:15:35.120"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:15:35.120" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:35.120" starttime="20190402 07:15:35.120"></status>
</kw>
<msg timestamp="20190402 07:15:35.120" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:35.121" starttime="20190402 07:15:35.119"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:15:35.122" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:15:35.123" starttime="20190402 07:15:35.121"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:15:35.123" level="INFO">0</msg>
<msg timestamp="20190402 07:15:35.123" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:35.123" starttime="20190402 07:15:35.123"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:15:35.123" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:15:35.123" starttime="20190402 07:15:35.123"></status>
</kw>
<msg timestamp="20190402 07:15:35.124" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:35.124" starttime="20190402 07:15:35.121"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:35.124" starttime="20190402 07:15:35.124"></status>
</kw>
<status status="PASS" endtime="20190402 07:15:35.124" starttime="20190402 07:15:35.124"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:35.125" starttime="20190402 07:15:35.124"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:15:35.125" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:15:35.125" starttime="20190402 07:15:35.125"></status>
</kw>
<msg timestamp="20190402 07:15:35.125" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:15:35.125" starttime="20190402 07:15:33.977"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:15:35.126" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:15:35.126" starttime="20190402 07:15:35.125"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:15:35.126" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:15:35.127" starttime="20190402 07:15:35.126"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:35.127" starttime="20190402 07:15:35.126"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:35.127" starttime="20190402 07:15:33.976"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:15:40.128" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:40.128" starttime="20190402 07:15:40.127"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:40.129" starttime="20190402 07:15:40.128"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:15:40.129" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:15:40.129" starttime="20190402 07:15:40.129"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:40.130" starttime="20190402 07:15:40.129"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:40.130" starttime="20190402 07:15:40.130"></status>
</kw>
<msg timestamp="20190402 07:15:40.130" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:15:40.130" starttime="20190402 07:15:40.129"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:15:40.130" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:40.131" starttime="20190402 07:15:40.130"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:15:40.139" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:40.139" starttime="20190402 07:15:40.131"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:15:41.458" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:15:41.458" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:41.458" starttime="20190402 07:15:40.139"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:15:41.459" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:41.459" starttime="20190402 07:15:41.459"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:15:41.459" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:41.459" starttime="20190402 07:15:41.459"></status>
</kw>
<msg timestamp="20190402 07:15:41.460" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:41.460" starttime="20190402 07:15:41.458"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:15:41.462" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:15:41.462" starttime="20190402 07:15:41.460"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:15:41.462" level="INFO">0</msg>
<msg timestamp="20190402 07:15:41.462" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:41.462" starttime="20190402 07:15:41.462"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:15:41.462" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:15:41.463" starttime="20190402 07:15:41.462"></status>
</kw>
<msg timestamp="20190402 07:15:41.463" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:41.463" starttime="20190402 07:15:41.460"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:41.463" starttime="20190402 07:15:41.463"></status>
</kw>
<status status="PASS" endtime="20190402 07:15:41.463" starttime="20190402 07:15:41.463"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:41.464" starttime="20190402 07:15:41.464"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:15:41.464" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:15:41.464" starttime="20190402 07:15:41.464"></status>
</kw>
<msg timestamp="20190402 07:15:41.464" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:15:41.464" starttime="20190402 07:15:40.128"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:15:41.465" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:15:41.465" starttime="20190402 07:15:41.464"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:15:41.465" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:15:41.465" starttime="20190402 07:15:41.465"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:41.465" starttime="20190402 07:15:41.465"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:41.466" starttime="20190402 07:15:40.127"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:15:46.467" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:46.467" starttime="20190402 07:15:46.466"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:46.468" starttime="20190402 07:15:46.467"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:15:46.468" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:15:46.468" starttime="20190402 07:15:46.468"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:46.469" starttime="20190402 07:15:46.469"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:46.469" starttime="20190402 07:15:46.469"></status>
</kw>
<msg timestamp="20190402 07:15:46.469" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:15:46.469" starttime="20190402 07:15:46.468"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:15:46.470" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:46.470" starttime="20190402 07:15:46.469"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:15:46.478" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:46.478" starttime="20190402 07:15:46.470"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:15:47.657" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:15:47.657" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:47.657" starttime="20190402 07:15:46.478"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:15:47.658" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:47.658" starttime="20190402 07:15:47.658"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:15:47.658" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:47.658" starttime="20190402 07:15:47.658"></status>
</kw>
<msg timestamp="20190402 07:15:47.658" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:47.658" starttime="20190402 07:15:47.657"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:15:47.660" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:15:47.660" starttime="20190402 07:15:47.659"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:15:47.661" level="INFO">0</msg>
<msg timestamp="20190402 07:15:47.661" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:47.661" starttime="20190402 07:15:47.660"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:15:47.661" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:15:47.661" starttime="20190402 07:15:47.661"></status>
</kw>
<msg timestamp="20190402 07:15:47.661" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:47.661" starttime="20190402 07:15:47.658"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:47.662" starttime="20190402 07:15:47.662"></status>
</kw>
<status status="PASS" endtime="20190402 07:15:47.662" starttime="20190402 07:15:47.661"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:47.662" starttime="20190402 07:15:47.662"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:15:47.662" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:15:47.663" starttime="20190402 07:15:47.662"></status>
</kw>
<msg timestamp="20190402 07:15:47.663" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:15:47.663" starttime="20190402 07:15:46.467"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:15:47.663" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:15:47.663" starttime="20190402 07:15:47.663"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:15:47.664" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:15:47.664" starttime="20190402 07:15:47.664"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:47.664" starttime="20190402 07:15:47.663"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:47.664" starttime="20190402 07:15:46.466"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:15:52.665" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:52.665" starttime="20190402 07:15:52.665"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:52.666" starttime="20190402 07:15:52.666"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:15:52.667" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:15:52.667" starttime="20190402 07:15:52.666"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:52.667" starttime="20190402 07:15:52.667"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:52.667" starttime="20190402 07:15:52.667"></status>
</kw>
<msg timestamp="20190402 07:15:52.668" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:15:52.668" starttime="20190402 07:15:52.666"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:15:52.668" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:52.668" starttime="20190402 07:15:52.668"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:15:52.676" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:52.676" starttime="20190402 07:15:52.668"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:15:54.010" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:15:54.010" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:54.010" starttime="20190402 07:15:52.677"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:15:54.011" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:54.011" starttime="20190402 07:15:54.011"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:15:54.011" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:54.011" starttime="20190402 07:15:54.011"></status>
</kw>
<msg timestamp="20190402 07:15:54.011" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:15:54.011" starttime="20190402 07:15:54.010"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:15:54.019" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:15:54.019" starttime="20190402 07:15:54.012"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:15:54.026" level="INFO">0</msg>
<msg timestamp="20190402 07:15:54.026" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:54.026" starttime="20190402 07:15:54.019"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:15:54.027" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:15:54.027" starttime="20190402 07:15:54.027"></status>
</kw>
<msg timestamp="20190402 07:15:54.027" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:15:54.027" starttime="20190402 07:15:54.011"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:54.028" starttime="20190402 07:15:54.028"></status>
</kw>
<status status="PASS" endtime="20190402 07:15:54.028" starttime="20190402 07:15:54.027"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:54.028" starttime="20190402 07:15:54.028"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:15:54.029" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:15:54.029" starttime="20190402 07:15:54.028"></status>
</kw>
<msg timestamp="20190402 07:15:54.029" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:15:54.029" starttime="20190402 07:15:52.665"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:15:54.029" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:15:54.029" starttime="20190402 07:15:54.029"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:15:54.030" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:15:54.030" starttime="20190402 07:15:54.030"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:54.030" starttime="20190402 07:15:54.029"></status>
</kw>
<status status="FAIL" endtime="20190402 07:15:54.030" starttime="20190402 07:15:52.664"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:15:59.032" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:59.032" starttime="20190402 07:15:59.032"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:59.034" starttime="20190402 07:15:59.034"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:15:59.036" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:15:59.036" starttime="20190402 07:15:59.035"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:59.037" starttime="20190402 07:15:59.036"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:15:59.037" starttime="20190402 07:15:59.037"></status>
</kw>
<msg timestamp="20190402 07:15:59.037" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:15:59.037" starttime="20190402 07:15:59.035"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:15:59.037" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:15:59.038" starttime="20190402 07:15:59.037"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:15:59.047" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:15:59.047" starttime="20190402 07:15:59.038"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:16:00.257" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:16:00.257" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:00.257" starttime="20190402 07:15:59.047"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:16:00.258" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:00.258" starttime="20190402 07:16:00.258"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:16:00.258" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:00.258" starttime="20190402 07:16:00.258"></status>
</kw>
<msg timestamp="20190402 07:16:00.258" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:00.258" starttime="20190402 07:16:00.257"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:16:00.260" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:16:00.260" starttime="20190402 07:16:00.259"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:16:00.260" level="INFO">0</msg>
<msg timestamp="20190402 07:16:00.260" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:00.260" starttime="20190402 07:16:00.260"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:16:00.261" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:16:00.261" starttime="20190402 07:16:00.260"></status>
</kw>
<msg timestamp="20190402 07:16:00.261" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:00.261" starttime="20190402 07:16:00.259"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:00.262" starttime="20190402 07:16:00.261"></status>
</kw>
<status status="PASS" endtime="20190402 07:16:00.262" starttime="20190402 07:16:00.261"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:00.262" starttime="20190402 07:16:00.262"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:16:00.262" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:16:00.262" starttime="20190402 07:16:00.262"></status>
</kw>
<msg timestamp="20190402 07:16:00.263" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:16:00.263" starttime="20190402 07:15:59.033"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:16:00.263" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:16:00.263" starttime="20190402 07:16:00.263"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:16:00.264" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:16:00.264" starttime="20190402 07:16:00.263"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:00.264" starttime="20190402 07:16:00.263"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:00.264" starttime="20190402 07:15:59.031"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:16:05.267" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:05.267" starttime="20190402 07:16:05.266"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:05.269" starttime="20190402 07:16:05.269"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:16:05.270" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:16:05.270" starttime="20190402 07:16:05.269"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:05.270" starttime="20190402 07:16:05.270"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:05.270" starttime="20190402 07:16:05.270"></status>
</kw>
<msg timestamp="20190402 07:16:05.271" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:16:05.271" starttime="20190402 07:16:05.269"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:16:05.271" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:05.271" starttime="20190402 07:16:05.271"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:16:05.282" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:05.282" starttime="20190402 07:16:05.271"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:16:06.503" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:16:06.503" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:06.503" starttime="20190402 07:16:05.282"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:16:06.504" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:06.504" starttime="20190402 07:16:06.504"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:16:06.504" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:06.504" starttime="20190402 07:16:06.504"></status>
</kw>
<msg timestamp="20190402 07:16:06.504" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:06.504" starttime="20190402 07:16:06.503"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:16:06.506" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:16:06.506" starttime="20190402 07:16:06.505"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:16:06.507" level="INFO">0</msg>
<msg timestamp="20190402 07:16:06.507" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:06.507" starttime="20190402 07:16:06.506"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:16:06.507" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:16:06.507" starttime="20190402 07:16:06.507"></status>
</kw>
<msg timestamp="20190402 07:16:06.507" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:06.507" starttime="20190402 07:16:06.505"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:06.508" starttime="20190402 07:16:06.508"></status>
</kw>
<status status="PASS" endtime="20190402 07:16:06.508" starttime="20190402 07:16:06.507"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:06.508" starttime="20190402 07:16:06.508"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:16:06.509" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:16:06.509" starttime="20190402 07:16:06.508"></status>
</kw>
<msg timestamp="20190402 07:16:06.509" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:16:06.509" starttime="20190402 07:16:05.267"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:16:06.509" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:16:06.509" starttime="20190402 07:16:06.509"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:16:06.510" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:16:06.510" starttime="20190402 07:16:06.510"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:06.510" starttime="20190402 07:16:06.509"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:06.510" starttime="20190402 07:16:05.264"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:16:11.514" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:11.514" starttime="20190402 07:16:11.513"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:11.516" starttime="20190402 07:16:11.515"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:16:11.519" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:16:11.519" starttime="20190402 07:16:11.517"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:11.520" starttime="20190402 07:16:11.519"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:11.521" starttime="20190402 07:16:11.521"></status>
</kw>
<msg timestamp="20190402 07:16:11.522" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:16:11.522" starttime="20190402 07:16:11.517"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:16:11.523" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:11.523" starttime="20190402 07:16:11.522"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:16:11.549" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:11.549" starttime="20190402 07:16:11.523"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:16:12.763" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:16:12.763" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:12.763" starttime="20190402 07:16:11.549"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:16:12.764" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:12.764" starttime="20190402 07:16:12.764"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:16:12.765" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:12.765" starttime="20190402 07:16:12.765"></status>
</kw>
<msg timestamp="20190402 07:16:12.765" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:12.765" starttime="20190402 07:16:12.764"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:16:12.767" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:16:12.767" starttime="20190402 07:16:12.765"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:16:12.767" level="INFO">0</msg>
<msg timestamp="20190402 07:16:12.767" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:12.767" starttime="20190402 07:16:12.767"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:16:12.767" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:16:12.768" starttime="20190402 07:16:12.767"></status>
</kw>
<msg timestamp="20190402 07:16:12.768" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:12.768" starttime="20190402 07:16:12.765"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:12.768" starttime="20190402 07:16:12.768"></status>
</kw>
<status status="PASS" endtime="20190402 07:16:12.768" starttime="20190402 07:16:12.768"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:12.769" starttime="20190402 07:16:12.769"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:16:12.769" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:16:12.769" starttime="20190402 07:16:12.769"></status>
</kw>
<msg timestamp="20190402 07:16:12.769" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:16:12.769" starttime="20190402 07:16:11.514"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:16:12.770" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:16:12.770" starttime="20190402 07:16:12.770"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:16:12.770" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:16:12.770" starttime="20190402 07:16:12.770"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:12.770" starttime="20190402 07:16:12.770"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:12.771" starttime="20190402 07:16:11.511"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:16:17.773" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:17.773" starttime="20190402 07:16:17.772"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:17.776" starttime="20190402 07:16:17.775"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:16:17.777" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:16:17.777" starttime="20190402 07:16:17.776"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:17.777" starttime="20190402 07:16:17.777"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:17.777" starttime="20190402 07:16:17.777"></status>
</kw>
<msg timestamp="20190402 07:16:17.778" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:16:17.778" starttime="20190402 07:16:17.776"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:16:17.778" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:17.778" starttime="20190402 07:16:17.778"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:16:17.784" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:17.785" starttime="20190402 07:16:17.778"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:16:19.040" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:16:19.040" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:19.040" starttime="20190402 07:16:17.785"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:16:19.041" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:19.041" starttime="20190402 07:16:19.041"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:16:19.042" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:19.042" starttime="20190402 07:16:19.041"></status>
</kw>
<msg timestamp="20190402 07:16:19.042" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:19.042" starttime="20190402 07:16:19.041"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:16:19.044" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:16:19.044" starttime="20190402 07:16:19.043"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:16:19.045" level="INFO">0</msg>
<msg timestamp="20190402 07:16:19.045" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:19.045" starttime="20190402 07:16:19.044"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:16:19.045" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:16:19.045" starttime="20190402 07:16:19.045"></status>
</kw>
<msg timestamp="20190402 07:16:19.045" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:19.045" starttime="20190402 07:16:19.042"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:19.046" starttime="20190402 07:16:19.046"></status>
</kw>
<status status="PASS" endtime="20190402 07:16:19.046" starttime="20190402 07:16:19.045"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:19.046" starttime="20190402 07:16:19.046"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:16:19.047" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:16:19.047" starttime="20190402 07:16:19.047"></status>
</kw>
<msg timestamp="20190402 07:16:19.047" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:16:19.047" starttime="20190402 07:16:17.774"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:16:19.047" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:16:19.047" starttime="20190402 07:16:19.047"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:16:19.048" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:16:19.048" starttime="20190402 07:16:19.048"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:19.048" starttime="20190402 07:16:19.047"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:19.048" starttime="20190402 07:16:17.771"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:16:24.051" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:24.051" starttime="20190402 07:16:24.050"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:24.054" starttime="20190402 07:16:24.053"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:16:24.055" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:16:24.055" starttime="20190402 07:16:24.054"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:24.055" starttime="20190402 07:16:24.055"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:24.055" starttime="20190402 07:16:24.055"></status>
</kw>
<msg timestamp="20190402 07:16:24.055" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:16:24.055" starttime="20190402 07:16:24.054"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:16:24.056" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:24.056" starttime="20190402 07:16:24.056"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:16:24.065" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:24.065" starttime="20190402 07:16:24.056"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:16:25.296" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:16:25.296" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:25.296" starttime="20190402 07:16:24.065"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:16:25.297" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:25.297" starttime="20190402 07:16:25.297"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:16:25.297" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:25.297" starttime="20190402 07:16:25.297"></status>
</kw>
<msg timestamp="20190402 07:16:25.297" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:25.297" starttime="20190402 07:16:25.296"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:16:25.299" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:16:25.299" starttime="20190402 07:16:25.298"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:16:25.300" level="INFO">0</msg>
<msg timestamp="20190402 07:16:25.300" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:25.300" starttime="20190402 07:16:25.300"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:16:25.300" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:16:25.300" starttime="20190402 07:16:25.300"></status>
</kw>
<msg timestamp="20190402 07:16:25.300" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:25.300" starttime="20190402 07:16:25.297"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:25.301" starttime="20190402 07:16:25.301"></status>
</kw>
<status status="PASS" endtime="20190402 07:16:25.301" starttime="20190402 07:16:25.301"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:25.301" starttime="20190402 07:16:25.301"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:16:25.302" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:16:25.302" starttime="20190402 07:16:25.302"></status>
</kw>
<msg timestamp="20190402 07:16:25.302" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:16:25.302" starttime="20190402 07:16:24.052"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:16:25.302" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:16:25.302" starttime="20190402 07:16:25.302"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:16:25.303" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:16:25.303" starttime="20190402 07:16:25.303"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:25.303" starttime="20190402 07:16:25.303"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:25.303" starttime="20190402 07:16:24.049"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:16:30.306" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:30.306" starttime="20190402 07:16:30.305"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:30.309" starttime="20190402 07:16:30.308"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:16:30.310" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:16:30.310" starttime="20190402 07:16:30.309"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:30.310" starttime="20190402 07:16:30.310"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:30.310" starttime="20190402 07:16:30.310"></status>
</kw>
<msg timestamp="20190402 07:16:30.311" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:16:30.311" starttime="20190402 07:16:30.309"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:16:30.311" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:30.311" starttime="20190402 07:16:30.311"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:16:30.314" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:30.314" starttime="20190402 07:16:30.311"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:16:31.735" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:16:31.735" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:31.735" starttime="20190402 07:16:30.314"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:16:31.736" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:31.736" starttime="20190402 07:16:31.735"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:16:31.736" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:31.736" starttime="20190402 07:16:31.736"></status>
</kw>
<msg timestamp="20190402 07:16:31.736" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:31.736" starttime="20190402 07:16:31.735"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:16:31.738" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:16:31.738" starttime="20190402 07:16:31.736"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:16:31.738" level="INFO">0</msg>
<msg timestamp="20190402 07:16:31.738" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:31.738" starttime="20190402 07:16:31.738"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:16:31.739" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:16:31.739" starttime="20190402 07:16:31.739"></status>
</kw>
<msg timestamp="20190402 07:16:31.739" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:31.739" starttime="20190402 07:16:31.736"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:31.740" starttime="20190402 07:16:31.740"></status>
</kw>
<status status="PASS" endtime="20190402 07:16:31.740" starttime="20190402 07:16:31.739"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:31.740" starttime="20190402 07:16:31.740"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:16:31.741" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:16:31.741" starttime="20190402 07:16:31.740"></status>
</kw>
<msg timestamp="20190402 07:16:31.741" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:16:31.741" starttime="20190402 07:16:30.307"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:16:31.741" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:16:31.741" starttime="20190402 07:16:31.741"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:16:31.742" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:16:31.742" starttime="20190402 07:16:31.742"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:31.742" starttime="20190402 07:16:31.741"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:31.742" starttime="20190402 07:16:30.304"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:16:36.745" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:36.745" starttime="20190402 07:16:36.744"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:36.748" starttime="20190402 07:16:36.747"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:16:36.749" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:16:36.749" starttime="20190402 07:16:36.748"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:36.749" starttime="20190402 07:16:36.749"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:36.749" starttime="20190402 07:16:36.749"></status>
</kw>
<msg timestamp="20190402 07:16:36.750" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:16:36.750" starttime="20190402 07:16:36.748"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:16:36.750" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:36.750" starttime="20190402 07:16:36.750"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:16:36.758" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:36.758" starttime="20190402 07:16:36.750"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:16:37.863" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:16:37.864" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:37.864" starttime="20190402 07:16:36.759"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:16:37.864" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:37.864" starttime="20190402 07:16:37.864"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:16:37.865" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:37.865" starttime="20190402 07:16:37.865"></status>
</kw>
<msg timestamp="20190402 07:16:37.865" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:37.865" starttime="20190402 07:16:37.864"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:16:37.867" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:16:37.867" starttime="20190402 07:16:37.865"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:16:37.867" level="INFO">0</msg>
<msg timestamp="20190402 07:16:37.867" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:37.867" starttime="20190402 07:16:37.867"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:16:37.868" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:16:37.868" starttime="20190402 07:16:37.867"></status>
</kw>
<msg timestamp="20190402 07:16:37.868" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:37.868" starttime="20190402 07:16:37.865"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:37.869" starttime="20190402 07:16:37.868"></status>
</kw>
<status status="PASS" endtime="20190402 07:16:37.869" starttime="20190402 07:16:37.868"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:37.869" starttime="20190402 07:16:37.869"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:16:37.869" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:16:37.869" starttime="20190402 07:16:37.869"></status>
</kw>
<msg timestamp="20190402 07:16:37.870" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:16:37.870" starttime="20190402 07:16:36.746"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:16:37.870" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:16:37.870" starttime="20190402 07:16:37.870"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:16:37.871" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:16:37.871" starttime="20190402 07:16:37.870"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:37.871" starttime="20190402 07:16:37.870"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:37.871" starttime="20190402 07:16:36.743"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:16:42.873" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:42.873" starttime="20190402 07:16:42.873"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:42.875" starttime="20190402 07:16:42.875"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:16:42.877" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:16:42.877" starttime="20190402 07:16:42.876"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:42.878" starttime="20190402 07:16:42.877"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:42.879" starttime="20190402 07:16:42.878"></status>
</kw>
<msg timestamp="20190402 07:16:42.879" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:16:42.880" starttime="20190402 07:16:42.875"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:16:42.880" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:42.880" starttime="20190402 07:16:42.880"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:16:42.903" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:42.903" starttime="20190402 07:16:42.881"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:16:43.941" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:16:43.941" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:43.941" starttime="20190402 07:16:42.903"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:16:43.942" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:43.942" starttime="20190402 07:16:43.941"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:16:43.942" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:43.942" starttime="20190402 07:16:43.942"></status>
</kw>
<msg timestamp="20190402 07:16:43.942" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:43.942" starttime="20190402 07:16:43.941"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:16:43.944" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:16:43.944" starttime="20190402 07:16:43.943"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:16:43.944" level="INFO">0</msg>
<msg timestamp="20190402 07:16:43.945" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:43.945" starttime="20190402 07:16:43.944"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:16:43.945" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:16:43.945" starttime="20190402 07:16:43.945"></status>
</kw>
<msg timestamp="20190402 07:16:43.945" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:43.945" starttime="20190402 07:16:43.942"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:43.946" starttime="20190402 07:16:43.946"></status>
</kw>
<status status="PASS" endtime="20190402 07:16:43.946" starttime="20190402 07:16:43.945"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:43.946" starttime="20190402 07:16:43.946"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:16:43.947" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:16:43.947" starttime="20190402 07:16:43.946"></status>
</kw>
<msg timestamp="20190402 07:16:43.947" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:16:43.947" starttime="20190402 07:16:42.874"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:16:43.947" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:16:43.947" starttime="20190402 07:16:43.947"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:16:43.948" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:16:43.948" starttime="20190402 07:16:43.948"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:43.948" starttime="20190402 07:16:43.947"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:43.948" starttime="20190402 07:16:42.872"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:16:48.951" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:48.951" starttime="20190402 07:16:48.950"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:48.954" starttime="20190402 07:16:48.953"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:16:48.955" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:16:48.955" starttime="20190402 07:16:48.954"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:48.955" starttime="20190402 07:16:48.955"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:48.955" starttime="20190402 07:16:48.955"></status>
</kw>
<msg timestamp="20190402 07:16:48.956" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:16:48.956" starttime="20190402 07:16:48.954"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:16:48.956" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:48.956" starttime="20190402 07:16:48.956"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:16:48.966" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:48.966" starttime="20190402 07:16:48.956"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:16:50.038" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:16:50.038" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:50.039" starttime="20190402 07:16:48.966"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:16:50.039" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:50.039" starttime="20190402 07:16:50.039"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:16:50.040" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:50.040" starttime="20190402 07:16:50.039"></status>
</kw>
<msg timestamp="20190402 07:16:50.040" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:50.040" starttime="20190402 07:16:50.039"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:16:50.042" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:16:50.042" starttime="20190402 07:16:50.040"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:16:50.042" level="INFO">0</msg>
<msg timestamp="20190402 07:16:50.042" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:50.043" starttime="20190402 07:16:50.042"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:16:50.043" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:16:50.043" starttime="20190402 07:16:50.043"></status>
</kw>
<msg timestamp="20190402 07:16:50.043" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:50.043" starttime="20190402 07:16:50.040"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:50.044" starttime="20190402 07:16:50.043"></status>
</kw>
<status status="PASS" endtime="20190402 07:16:50.044" starttime="20190402 07:16:50.043"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:50.044" starttime="20190402 07:16:50.044"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:16:50.044" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:16:50.044" starttime="20190402 07:16:50.044"></status>
</kw>
<msg timestamp="20190402 07:16:50.045" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:16:50.045" starttime="20190402 07:16:48.952"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:16:50.045" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:16:50.045" starttime="20190402 07:16:50.045"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:16:50.046" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:16:50.046" starttime="20190402 07:16:50.045"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:50.046" starttime="20190402 07:16:50.045"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:50.046" starttime="20190402 07:16:48.949"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:16:55.050" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:55.050" starttime="20190402 07:16:55.048"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:55.052" starttime="20190402 07:16:55.052"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:16:55.053" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:16:55.053" starttime="20190402 07:16:55.052"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:55.053" starttime="20190402 07:16:55.053"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:55.054" starttime="20190402 07:16:55.053"></status>
</kw>
<msg timestamp="20190402 07:16:55.054" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:16:55.054" starttime="20190402 07:16:55.052"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:16:55.054" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:55.054" starttime="20190402 07:16:55.054"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:16:55.063" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:16:55.063" starttime="20190402 07:16:55.054"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:16:56.132" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:16:56.132" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:56.132" starttime="20190402 07:16:55.063"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:16:56.133" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:16:56.133" starttime="20190402 07:16:56.132"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:16:56.133" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:56.133" starttime="20190402 07:16:56.133"></status>
</kw>
<msg timestamp="20190402 07:16:56.133" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:16:56.133" starttime="20190402 07:16:56.132"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:16:56.135" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:16:56.135" starttime="20190402 07:16:56.134"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:16:56.135" level="INFO">0</msg>
<msg timestamp="20190402 07:16:56.135" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:56.135" starttime="20190402 07:16:56.135"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:16:56.136" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:16:56.136" starttime="20190402 07:16:56.136"></status>
</kw>
<msg timestamp="20190402 07:16:56.136" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:16:56.136" starttime="20190402 07:16:56.133"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:56.137" starttime="20190402 07:16:56.136"></status>
</kw>
<status status="PASS" endtime="20190402 07:16:56.137" starttime="20190402 07:16:56.136"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:16:56.137" starttime="20190402 07:16:56.137"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:16:56.137" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:16:56.137" starttime="20190402 07:16:56.137"></status>
</kw>
<msg timestamp="20190402 07:16:56.138" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:16:56.138" starttime="20190402 07:16:55.050"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:16:56.138" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:16:56.138" starttime="20190402 07:16:56.138"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:16:56.139" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:16:56.139" starttime="20190402 07:16:56.139"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:56.139" starttime="20190402 07:16:56.138"></status>
</kw>
<status status="FAIL" endtime="20190402 07:16:56.139" starttime="20190402 07:16:55.047"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:17:01.142" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:01.142" starttime="20190402 07:17:01.141"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:01.145" starttime="20190402 07:17:01.144"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:17:01.146" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:17:01.146" starttime="20190402 07:17:01.145"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:01.146" starttime="20190402 07:17:01.146"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:01.146" starttime="20190402 07:17:01.146"></status>
</kw>
<msg timestamp="20190402 07:17:01.147" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:17:01.147" starttime="20190402 07:17:01.145"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:17:01.147" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:01.147" starttime="20190402 07:17:01.147"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:17:01.156" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:01.156" starttime="20190402 07:17:01.147"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:17:02.230" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:17:02.231" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:02.231" starttime="20190402 07:17:01.156"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:17:02.231" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:02.232" starttime="20190402 07:17:02.231"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:17:02.232" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:02.232" starttime="20190402 07:17:02.232"></status>
</kw>
<msg timestamp="20190402 07:17:02.232" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:02.232" starttime="20190402 07:17:02.231"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:17:02.234" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:17:02.234" starttime="20190402 07:17:02.232"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:17:02.235" level="INFO">0</msg>
<msg timestamp="20190402 07:17:02.235" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:02.235" starttime="20190402 07:17:02.234"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:17:02.235" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:17:02.235" starttime="20190402 07:17:02.235"></status>
</kw>
<msg timestamp="20190402 07:17:02.235" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:02.235" starttime="20190402 07:17:02.232"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:02.236" starttime="20190402 07:17:02.236"></status>
</kw>
<status status="PASS" endtime="20190402 07:17:02.236" starttime="20190402 07:17:02.236"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:02.236" starttime="20190402 07:17:02.236"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:17:02.237" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:17:02.237" starttime="20190402 07:17:02.237"></status>
</kw>
<msg timestamp="20190402 07:17:02.237" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:17:02.237" starttime="20190402 07:17:01.142"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:17:02.237" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:17:02.237" starttime="20190402 07:17:02.237"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:17:02.238" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:17:02.238" starttime="20190402 07:17:02.238"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:02.238" starttime="20190402 07:17:02.238"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:02.238" starttime="20190402 07:17:01.140"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:17:07.241" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:07.241" starttime="20190402 07:17:07.240"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:07.244" starttime="20190402 07:17:07.243"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:17:07.245" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:17:07.245" starttime="20190402 07:17:07.244"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:07.245" starttime="20190402 07:17:07.245"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:07.245" starttime="20190402 07:17:07.245"></status>
</kw>
<msg timestamp="20190402 07:17:07.246" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:17:07.246" starttime="20190402 07:17:07.244"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:17:07.246" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:07.246" starttime="20190402 07:17:07.246"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:17:07.255" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:07.255" starttime="20190402 07:17:07.246"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:17:08.322" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:17:08.322" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:08.322" starttime="20190402 07:17:07.255"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:17:08.323" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:08.323" starttime="20190402 07:17:08.322"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:17:08.323" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:08.323" starttime="20190402 07:17:08.323"></status>
</kw>
<msg timestamp="20190402 07:17:08.323" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:08.323" starttime="20190402 07:17:08.322"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:17:08.325" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:17:08.325" starttime="20190402 07:17:08.323"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:17:08.325" level="INFO">0</msg>
<msg timestamp="20190402 07:17:08.325" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:08.325" starttime="20190402 07:17:08.325"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:17:08.326" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:17:08.326" starttime="20190402 07:17:08.325"></status>
</kw>
<msg timestamp="20190402 07:17:08.326" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:08.326" starttime="20190402 07:17:08.323"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:08.327" starttime="20190402 07:17:08.326"></status>
</kw>
<status status="PASS" endtime="20190402 07:17:08.327" starttime="20190402 07:17:08.326"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:08.327" starttime="20190402 07:17:08.327"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:17:08.327" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:17:08.327" starttime="20190402 07:17:08.327"></status>
</kw>
<msg timestamp="20190402 07:17:08.327" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:17:08.327" starttime="20190402 07:17:07.242"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:17:08.328" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:17:08.328" starttime="20190402 07:17:08.328"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:17:08.328" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:17:08.329" starttime="20190402 07:17:08.328"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:08.329" starttime="20190402 07:17:08.328"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:08.329" starttime="20190402 07:17:07.239"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:17:13.332" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:13.332" starttime="20190402 07:17:13.331"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:13.334" starttime="20190402 07:17:13.334"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:17:13.335" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:17:13.335" starttime="20190402 07:17:13.334"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:13.335" starttime="20190402 07:17:13.335"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:13.336" starttime="20190402 07:17:13.335"></status>
</kw>
<msg timestamp="20190402 07:17:13.336" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:17:13.336" starttime="20190402 07:17:13.334"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:17:13.336" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:13.336" starttime="20190402 07:17:13.336"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:17:13.346" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:13.346" starttime="20190402 07:17:13.337"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:17:14.474" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:17:14.474" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:14.474" starttime="20190402 07:17:13.346"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:17:14.475" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:14.475" starttime="20190402 07:17:14.475"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:17:14.476" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:14.476" starttime="20190402 07:17:14.475"></status>
</kw>
<msg timestamp="20190402 07:17:14.476" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:14.476" starttime="20190402 07:17:14.475"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:17:14.478" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:17:14.478" starttime="20190402 07:17:14.476"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:17:14.478" level="INFO">0</msg>
<msg timestamp="20190402 07:17:14.478" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:14.478" starttime="20190402 07:17:14.478"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:17:14.479" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:17:14.479" starttime="20190402 07:17:14.478"></status>
</kw>
<msg timestamp="20190402 07:17:14.479" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:14.479" starttime="20190402 07:17:14.476"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:14.480" starttime="20190402 07:17:14.479"></status>
</kw>
<status status="PASS" endtime="20190402 07:17:14.480" starttime="20190402 07:17:14.479"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:14.480" starttime="20190402 07:17:14.480"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:17:14.480" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:17:14.480" starttime="20190402 07:17:14.480"></status>
</kw>
<msg timestamp="20190402 07:17:14.480" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:17:14.480" starttime="20190402 07:17:13.333"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:17:14.481" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:17:14.481" starttime="20190402 07:17:14.481"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:17:14.481" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:17:14.482" starttime="20190402 07:17:14.481"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:14.482" starttime="20190402 07:17:14.481"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:14.482" starttime="20190402 07:17:13.329"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:17:19.485" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:19.485" starttime="20190402 07:17:19.484"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:19.487" starttime="20190402 07:17:19.487"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:17:19.488" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:17:19.488" starttime="20190402 07:17:19.487"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:19.488" starttime="20190402 07:17:19.488"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:19.488" starttime="20190402 07:17:19.488"></status>
</kw>
<msg timestamp="20190402 07:17:19.489" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:17:19.489" starttime="20190402 07:17:19.487"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:17:19.489" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:19.489" starttime="20190402 07:17:19.489"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:17:19.498" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:19.498" starttime="20190402 07:17:19.489"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:17:20.616" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:17:20.616" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:20.616" starttime="20190402 07:17:19.499"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:17:20.617" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:20.617" starttime="20190402 07:17:20.617"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:17:20.618" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:20.618" starttime="20190402 07:17:20.618"></status>
</kw>
<msg timestamp="20190402 07:17:20.618" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:20.618" starttime="20190402 07:17:20.617"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:17:20.620" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:17:20.620" starttime="20190402 07:17:20.618"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:17:20.621" level="INFO">0</msg>
<msg timestamp="20190402 07:17:20.621" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:20.621" starttime="20190402 07:17:20.620"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:17:20.621" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:17:20.621" starttime="20190402 07:17:20.621"></status>
</kw>
<msg timestamp="20190402 07:17:20.621" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:20.621" starttime="20190402 07:17:20.618"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:20.622" starttime="20190402 07:17:20.622"></status>
</kw>
<status status="PASS" endtime="20190402 07:17:20.622" starttime="20190402 07:17:20.621"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:20.622" starttime="20190402 07:17:20.622"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:17:20.623" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:17:20.623" starttime="20190402 07:17:20.623"></status>
</kw>
<msg timestamp="20190402 07:17:20.623" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:17:20.623" starttime="20190402 07:17:19.485"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:17:20.623" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:17:20.623" starttime="20190402 07:17:20.623"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:17:20.624" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:17:20.624" starttime="20190402 07:17:20.624"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:20.624" starttime="20190402 07:17:20.624"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:20.624" starttime="20190402 07:17:19.482"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:17:25.628" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:25.628" starttime="20190402 07:17:25.626"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:25.630" starttime="20190402 07:17:25.630"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:17:25.631" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:17:25.631" starttime="20190402 07:17:25.630"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:25.631" starttime="20190402 07:17:25.631"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:25.631" starttime="20190402 07:17:25.631"></status>
</kw>
<msg timestamp="20190402 07:17:25.632" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:17:25.632" starttime="20190402 07:17:25.630"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:17:25.632" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:25.632" starttime="20190402 07:17:25.632"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:17:25.641" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:25.641" starttime="20190402 07:17:25.632"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:17:26.757" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:17:26.757" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:26.757" starttime="20190402 07:17:25.641"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:17:26.758" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:26.758" starttime="20190402 07:17:26.757"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:17:26.758" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:26.758" starttime="20190402 07:17:26.758"></status>
</kw>
<msg timestamp="20190402 07:17:26.758" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:26.758" starttime="20190402 07:17:26.757"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:17:26.760" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:17:26.760" starttime="20190402 07:17:26.759"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:17:26.761" level="INFO">0</msg>
<msg timestamp="20190402 07:17:26.761" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:26.761" starttime="20190402 07:17:26.760"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:17:26.761" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:17:26.761" starttime="20190402 07:17:26.761"></status>
</kw>
<msg timestamp="20190402 07:17:26.761" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:26.761" starttime="20190402 07:17:26.758"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:26.762" starttime="20190402 07:17:26.762"></status>
</kw>
<status status="PASS" endtime="20190402 07:17:26.762" starttime="20190402 07:17:26.761"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:26.762" starttime="20190402 07:17:26.762"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:17:26.763" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:17:26.763" starttime="20190402 07:17:26.762"></status>
</kw>
<msg timestamp="20190402 07:17:26.763" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:17:26.763" starttime="20190402 07:17:25.628"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:17:26.763" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:17:26.763" starttime="20190402 07:17:26.763"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:17:26.764" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:17:26.764" starttime="20190402 07:17:26.764"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:26.764" starttime="20190402 07:17:26.763"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:26.764" starttime="20190402 07:17:25.625"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:17:31.767" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:31.767" starttime="20190402 07:17:31.766"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:31.770" starttime="20190402 07:17:31.769"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:17:31.771" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:17:31.771" starttime="20190402 07:17:31.770"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:31.771" starttime="20190402 07:17:31.771"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:31.771" starttime="20190402 07:17:31.771"></status>
</kw>
<msg timestamp="20190402 07:17:31.772" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:17:31.772" starttime="20190402 07:17:31.770"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:17:31.772" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:31.772" starttime="20190402 07:17:31.772"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:17:31.781" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:31.781" starttime="20190402 07:17:31.772"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:17:32.855" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:17:32.855" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:32.855" starttime="20190402 07:17:31.781"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:17:32.856" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:32.856" starttime="20190402 07:17:32.856"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:17:32.856" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:32.856" starttime="20190402 07:17:32.856"></status>
</kw>
<msg timestamp="20190402 07:17:32.857" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:32.857" starttime="20190402 07:17:32.855"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:17:32.859" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:17:32.859" starttime="20190402 07:17:32.857"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:17:32.859" level="INFO">0</msg>
<msg timestamp="20190402 07:17:32.859" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:32.859" starttime="20190402 07:17:32.859"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:17:32.860" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:17:32.860" starttime="20190402 07:17:32.859"></status>
</kw>
<msg timestamp="20190402 07:17:32.860" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:32.860" starttime="20190402 07:17:32.857"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:32.861" starttime="20190402 07:17:32.860"></status>
</kw>
<status status="PASS" endtime="20190402 07:17:32.861" starttime="20190402 07:17:32.860"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:32.861" starttime="20190402 07:17:32.861"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:17:32.861" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:17:32.861" starttime="20190402 07:17:32.861"></status>
</kw>
<msg timestamp="20190402 07:17:32.862" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:17:32.862" starttime="20190402 07:17:31.768"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:17:32.862" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:17:32.862" starttime="20190402 07:17:32.862"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:17:32.863" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:17:32.863" starttime="20190402 07:17:32.863"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:32.863" starttime="20190402 07:17:32.862"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:32.863" starttime="20190402 07:17:31.765"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:17:37.866" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:37.866" starttime="20190402 07:17:37.865"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:37.869" starttime="20190402 07:17:37.868"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:17:37.870" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:17:37.870" starttime="20190402 07:17:37.869"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:37.870" starttime="20190402 07:17:37.870"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:37.871" starttime="20190402 07:17:37.870"></status>
</kw>
<msg timestamp="20190402 07:17:37.871" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:17:37.871" starttime="20190402 07:17:37.869"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:17:37.871" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:37.871" starttime="20190402 07:17:37.871"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:17:37.879" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:37.879" starttime="20190402 07:17:37.871"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:17:38.937" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:17:38.938" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:38.938" starttime="20190402 07:17:37.879"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:17:38.938" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:38.938" starttime="20190402 07:17:38.938"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:17:38.939" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:38.939" starttime="20190402 07:17:38.938"></status>
</kw>
<msg timestamp="20190402 07:17:38.939" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:38.939" starttime="20190402 07:17:38.938"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:17:38.941" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:17:38.941" starttime="20190402 07:17:38.939"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:17:38.941" level="INFO">0</msg>
<msg timestamp="20190402 07:17:38.941" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:38.941" starttime="20190402 07:17:38.941"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:17:38.941" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:17:38.942" starttime="20190402 07:17:38.941"></status>
</kw>
<msg timestamp="20190402 07:17:38.942" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:38.942" starttime="20190402 07:17:38.939"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:38.943" starttime="20190402 07:17:38.943"></status>
</kw>
<status status="PASS" endtime="20190402 07:17:38.943" starttime="20190402 07:17:38.942"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:38.943" starttime="20190402 07:17:38.943"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:17:38.944" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:17:38.944" starttime="20190402 07:17:38.943"></status>
</kw>
<msg timestamp="20190402 07:17:38.944" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:17:38.944" starttime="20190402 07:17:37.867"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:17:38.944" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:17:38.944" starttime="20190402 07:17:38.944"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:17:38.945" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:17:38.945" starttime="20190402 07:17:38.945"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:38.945" starttime="20190402 07:17:38.944"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:38.945" starttime="20190402 07:17:37.864"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:17:43.948" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:43.948" starttime="20190402 07:17:43.947"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:43.951" starttime="20190402 07:17:43.951"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:17:43.953" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:17:43.953" starttime="20190402 07:17:43.952"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:43.953" starttime="20190402 07:17:43.953"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:43.953" starttime="20190402 07:17:43.953"></status>
</kw>
<msg timestamp="20190402 07:17:43.953" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:17:43.954" starttime="20190402 07:17:43.951"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:17:43.954" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:43.954" starttime="20190402 07:17:43.954"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:17:43.962" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:43.962" starttime="20190402 07:17:43.954"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:17:45.116" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:17:45.116" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:45.116" starttime="20190402 07:17:43.962"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:17:45.117" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:45.117" starttime="20190402 07:17:45.117"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:17:45.117" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:45.117" starttime="20190402 07:17:45.117"></status>
</kw>
<msg timestamp="20190402 07:17:45.117" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:45.118" starttime="20190402 07:17:45.116"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:17:45.119" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:17:45.119" starttime="20190402 07:17:45.118"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:17:45.120" level="INFO">0</msg>
<msg timestamp="20190402 07:17:45.120" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:45.120" starttime="20190402 07:17:45.119"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:17:45.120" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:17:45.120" starttime="20190402 07:17:45.120"></status>
</kw>
<msg timestamp="20190402 07:17:45.120" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:45.120" starttime="20190402 07:17:45.118"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:45.121" starttime="20190402 07:17:45.121"></status>
</kw>
<status status="PASS" endtime="20190402 07:17:45.121" starttime="20190402 07:17:45.120"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:45.121" starttime="20190402 07:17:45.121"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:17:45.122" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:17:45.122" starttime="20190402 07:17:45.121"></status>
</kw>
<msg timestamp="20190402 07:17:45.122" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:17:45.122" starttime="20190402 07:17:43.949"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:17:45.122" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:17:45.122" starttime="20190402 07:17:45.122"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:17:45.123" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:17:45.123" starttime="20190402 07:17:45.123"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:45.123" starttime="20190402 07:17:45.123"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:45.123" starttime="20190402 07:17:43.946"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:17:50.127" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:50.127" starttime="20190402 07:17:50.126"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:50.129" starttime="20190402 07:17:50.129"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:17:50.130" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:17:50.130" starttime="20190402 07:17:50.129"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:50.130" starttime="20190402 07:17:50.130"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:50.131" starttime="20190402 07:17:50.130"></status>
</kw>
<msg timestamp="20190402 07:17:50.131" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:17:50.131" starttime="20190402 07:17:50.129"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:17:50.131" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:50.131" starttime="20190402 07:17:50.131"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:17:50.140" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:50.140" starttime="20190402 07:17:50.131"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:17:51.212" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:17:51.212" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:51.212" starttime="20190402 07:17:50.140"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:17:51.213" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:51.213" starttime="20190402 07:17:51.213"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:17:51.213" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:51.213" starttime="20190402 07:17:51.213"></status>
</kw>
<msg timestamp="20190402 07:17:51.213" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:51.214" starttime="20190402 07:17:51.212"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:17:51.215" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:17:51.215" starttime="20190402 07:17:51.214"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:17:51.216" level="INFO">0</msg>
<msg timestamp="20190402 07:17:51.216" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:51.216" starttime="20190402 07:17:51.215"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:17:51.216" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:17:51.216" starttime="20190402 07:17:51.216"></status>
</kw>
<msg timestamp="20190402 07:17:51.216" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:51.216" starttime="20190402 07:17:51.214"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:51.217" starttime="20190402 07:17:51.217"></status>
</kw>
<status status="PASS" endtime="20190402 07:17:51.217" starttime="20190402 07:17:51.216"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:51.217" starttime="20190402 07:17:51.217"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:17:51.217" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:17:51.218" starttime="20190402 07:17:51.217"></status>
</kw>
<msg timestamp="20190402 07:17:51.218" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:17:51.218" starttime="20190402 07:17:50.127"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:17:51.218" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:17:51.218" starttime="20190402 07:17:51.218"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:17:51.219" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:17:51.219" starttime="20190402 07:17:51.219"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:51.219" starttime="20190402 07:17:51.218"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:51.219" starttime="20190402 07:17:50.124"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:17:56.222" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:56.222" starttime="20190402 07:17:56.221"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:56.225" starttime="20190402 07:17:56.224"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:17:56.226" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:17:56.226" starttime="20190402 07:17:56.225"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:56.226" starttime="20190402 07:17:56.226"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:56.226" starttime="20190402 07:17:56.226"></status>
</kw>
<msg timestamp="20190402 07:17:56.227" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:17:56.227" starttime="20190402 07:17:56.225"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:17:56.227" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:56.227" starttime="20190402 07:17:56.227"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:17:56.236" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:17:56.236" starttime="20190402 07:17:56.227"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:17:57.324" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:17:57.324" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:57.324" starttime="20190402 07:17:56.236"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:17:57.325" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:17:57.325" starttime="20190402 07:17:57.325"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:17:57.325" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:57.325" starttime="20190402 07:17:57.325"></status>
</kw>
<msg timestamp="20190402 07:17:57.326" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:17:57.326" starttime="20190402 07:17:57.324"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:17:57.327" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:17:57.327" starttime="20190402 07:17:57.326"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:17:57.328" level="INFO">0</msg>
<msg timestamp="20190402 07:17:57.328" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:57.328" starttime="20190402 07:17:57.328"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:17:57.328" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:17:57.328" starttime="20190402 07:17:57.328"></status>
</kw>
<msg timestamp="20190402 07:17:57.329" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:17:57.329" starttime="20190402 07:17:57.326"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:57.329" starttime="20190402 07:17:57.329"></status>
</kw>
<status status="PASS" endtime="20190402 07:17:57.329" starttime="20190402 07:17:57.329"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:17:57.330" starttime="20190402 07:17:57.329"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:17:57.330" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:17:57.330" starttime="20190402 07:17:57.330"></status>
</kw>
<msg timestamp="20190402 07:17:57.330" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:17:57.330" starttime="20190402 07:17:56.223"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:17:57.331" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:17:57.331" starttime="20190402 07:17:57.330"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:17:57.331" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:17:57.331" starttime="20190402 07:17:57.331"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:57.331" starttime="20190402 07:17:57.331"></status>
</kw>
<status status="FAIL" endtime="20190402 07:17:57.331" starttime="20190402 07:17:56.220"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:18:02.335" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:02.335" starttime="20190402 07:18:02.333"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:02.337" starttime="20190402 07:18:02.337"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:18:02.338" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:18:02.338" starttime="20190402 07:18:02.338"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:02.338" starttime="20190402 07:18:02.338"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:02.339" starttime="20190402 07:18:02.338"></status>
</kw>
<msg timestamp="20190402 07:18:02.339" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:18:02.339" starttime="20190402 07:18:02.337"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:18:02.339" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:02.339" starttime="20190402 07:18:02.339"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:18:02.349" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:02.349" starttime="20190402 07:18:02.339"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:18:03.432" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:18:03.432" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:03.432" starttime="20190402 07:18:02.349"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:18:03.433" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:03.433" starttime="20190402 07:18:03.433"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:18:03.433" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:03.434" starttime="20190402 07:18:03.433"></status>
</kw>
<msg timestamp="20190402 07:18:03.434" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:03.434" starttime="20190402 07:18:03.433"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:18:03.436" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:18:03.436" starttime="20190402 07:18:03.434"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:18:03.436" level="INFO">0</msg>
<msg timestamp="20190402 07:18:03.436" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:03.436" starttime="20190402 07:18:03.436"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:18:03.436" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:18:03.437" starttime="20190402 07:18:03.436"></status>
</kw>
<msg timestamp="20190402 07:18:03.437" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:03.437" starttime="20190402 07:18:03.434"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:03.437" starttime="20190402 07:18:03.437"></status>
</kw>
<status status="PASS" endtime="20190402 07:18:03.437" starttime="20190402 07:18:03.437"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:03.438" starttime="20190402 07:18:03.438"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:18:03.438" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:18:03.438" starttime="20190402 07:18:03.438"></status>
</kw>
<msg timestamp="20190402 07:18:03.438" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:18:03.438" starttime="20190402 07:18:02.336"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:18:03.439" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:18:03.439" starttime="20190402 07:18:03.438"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:18:03.439" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:18:03.440" starttime="20190402 07:18:03.439"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:03.440" starttime="20190402 07:18:03.439"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:03.440" starttime="20190402 07:18:02.332"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:18:08.442" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:08.443" starttime="20190402 07:18:08.442"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:08.446" starttime="20190402 07:18:08.444"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:18:08.448" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:18:08.448" starttime="20190402 07:18:08.447"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:08.450" starttime="20190402 07:18:08.449"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:08.451" starttime="20190402 07:18:08.450"></status>
</kw>
<msg timestamp="20190402 07:18:08.452" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:18:08.452" starttime="20190402 07:18:08.446"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:18:08.453" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:08.453" starttime="20190402 07:18:08.452"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:18:08.478" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:08.478" starttime="20190402 07:18:08.453"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:18:09.587" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:18:09.587" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:09.587" starttime="20190402 07:18:08.478"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:18:09.588" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:09.588" starttime="20190402 07:18:09.587"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:18:09.588" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:09.588" starttime="20190402 07:18:09.588"></status>
</kw>
<msg timestamp="20190402 07:18:09.588" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:09.588" starttime="20190402 07:18:09.587"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:18:09.590" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:18:09.590" starttime="20190402 07:18:09.588"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:18:09.590" level="INFO">0</msg>
<msg timestamp="20190402 07:18:09.590" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:09.590" starttime="20190402 07:18:09.590"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:18:09.591" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:18:09.591" starttime="20190402 07:18:09.590"></status>
</kw>
<msg timestamp="20190402 07:18:09.591" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:09.591" starttime="20190402 07:18:09.588"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:09.592" starttime="20190402 07:18:09.591"></status>
</kw>
<status status="PASS" endtime="20190402 07:18:09.592" starttime="20190402 07:18:09.591"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:09.592" starttime="20190402 07:18:09.592"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:18:09.592" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:18:09.592" starttime="20190402 07:18:09.592"></status>
</kw>
<msg timestamp="20190402 07:18:09.592" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:18:09.592" starttime="20190402 07:18:08.443"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:18:09.593" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:18:09.593" starttime="20190402 07:18:09.593"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:18:09.594" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:18:09.594" starttime="20190402 07:18:09.593"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:09.594" starttime="20190402 07:18:09.593"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:09.594" starttime="20190402 07:18:08.440"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:18:14.597" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:14.597" starttime="20190402 07:18:14.596"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:14.599" starttime="20190402 07:18:14.599"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:18:14.600" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:18:14.600" starttime="20190402 07:18:14.599"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:14.600" starttime="20190402 07:18:14.600"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:14.601" starttime="20190402 07:18:14.600"></status>
</kw>
<msg timestamp="20190402 07:18:14.601" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:18:14.601" starttime="20190402 07:18:14.599"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:18:14.601" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:14.601" starttime="20190402 07:18:14.601"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:18:14.610" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:14.610" starttime="20190402 07:18:14.601"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:18:15.673" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:18:15.673" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:15.673" starttime="20190402 07:18:14.610"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:18:15.674" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:15.674" starttime="20190402 07:18:15.674"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:18:15.674" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:15.674" starttime="20190402 07:18:15.674"></status>
</kw>
<msg timestamp="20190402 07:18:15.674" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:15.674" starttime="20190402 07:18:15.673"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:18:15.676" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:18:15.676" starttime="20190402 07:18:15.675"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:18:15.677" level="INFO">0</msg>
<msg timestamp="20190402 07:18:15.677" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:15.677" starttime="20190402 07:18:15.676"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:18:15.677" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:18:15.677" starttime="20190402 07:18:15.677"></status>
</kw>
<msg timestamp="20190402 07:18:15.677" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:15.677" starttime="20190402 07:18:15.675"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:15.678" starttime="20190402 07:18:15.678"></status>
</kw>
<status status="PASS" endtime="20190402 07:18:15.678" starttime="20190402 07:18:15.677"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:15.678" starttime="20190402 07:18:15.678"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:18:15.679" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:18:15.679" starttime="20190402 07:18:15.678"></status>
</kw>
<msg timestamp="20190402 07:18:15.679" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:18:15.679" starttime="20190402 07:18:14.597"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:18:15.679" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:18:15.679" starttime="20190402 07:18:15.679"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:18:15.680" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:18:15.680" starttime="20190402 07:18:15.680"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:15.680" starttime="20190402 07:18:15.679"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:15.680" starttime="20190402 07:18:14.594"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:18:20.682" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:20.683" starttime="20190402 07:18:20.682"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:20.685" starttime="20190402 07:18:20.684"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:18:20.686" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:18:20.686" starttime="20190402 07:18:20.685"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:20.687" starttime="20190402 07:18:20.686"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:20.687" starttime="20190402 07:18:20.687"></status>
</kw>
<msg timestamp="20190402 07:18:20.687" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:18:20.687" starttime="20190402 07:18:20.685"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:18:20.688" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:20.688" starttime="20190402 07:18:20.688"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:18:20.698" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:20.698" starttime="20190402 07:18:20.688"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:18:21.752" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:18:21.752" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:21.752" starttime="20190402 07:18:20.698"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:18:21.753" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:21.753" starttime="20190402 07:18:21.753"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:18:21.753" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:21.753" starttime="20190402 07:18:21.753"></status>
</kw>
<msg timestamp="20190402 07:18:21.753" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:21.753" starttime="20190402 07:18:21.752"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:18:21.755" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:18:21.755" starttime="20190402 07:18:21.754"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:18:21.755" level="INFO">0</msg>
<msg timestamp="20190402 07:18:21.755" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:21.756" starttime="20190402 07:18:21.755"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:18:21.756" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:18:21.756" starttime="20190402 07:18:21.756"></status>
</kw>
<msg timestamp="20190402 07:18:21.756" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:21.756" starttime="20190402 07:18:21.753"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:21.757" starttime="20190402 07:18:21.756"></status>
</kw>
<status status="PASS" endtime="20190402 07:18:21.757" starttime="20190402 07:18:21.756"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:21.757" starttime="20190402 07:18:21.757"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:18:21.757" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:18:21.757" starttime="20190402 07:18:21.757"></status>
</kw>
<msg timestamp="20190402 07:18:21.758" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:18:21.758" starttime="20190402 07:18:20.683"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:18:21.758" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:18:21.758" starttime="20190402 07:18:21.758"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:18:21.759" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:18:21.759" starttime="20190402 07:18:21.758"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:21.759" starttime="20190402 07:18:21.758"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:21.759" starttime="20190402 07:18:20.681"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:18:26.760" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:26.760" starttime="20190402 07:18:26.760"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:26.761" starttime="20190402 07:18:26.761"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:18:26.762" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:18:26.762" starttime="20190402 07:18:26.761"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:26.762" starttime="20190402 07:18:26.762"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:26.763" starttime="20190402 07:18:26.762"></status>
</kw>
<msg timestamp="20190402 07:18:26.763" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:18:26.763" starttime="20190402 07:18:26.761"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:18:26.763" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:26.763" starttime="20190402 07:18:26.763"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:18:26.772" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:26.773" starttime="20190402 07:18:26.763"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:18:28.680" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:18:28.680" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:28.680" starttime="20190402 07:18:26.773"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:18:28.681" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:28.681" starttime="20190402 07:18:28.680"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:18:28.681" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:28.681" starttime="20190402 07:18:28.681"></status>
</kw>
<msg timestamp="20190402 07:18:28.681" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:28.681" starttime="20190402 07:18:28.680"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:18:28.685" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:18:28.685" starttime="20190402 07:18:28.682"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:18:28.688" level="INFO">0</msg>
<msg timestamp="20190402 07:18:28.688" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:28.688" starttime="20190402 07:18:28.685"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:18:28.688" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:18:28.689" starttime="20190402 07:18:28.688"></status>
</kw>
<msg timestamp="20190402 07:18:28.689" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:28.689" starttime="20190402 07:18:28.681"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:28.689" starttime="20190402 07:18:28.689"></status>
</kw>
<status status="PASS" endtime="20190402 07:18:28.690" starttime="20190402 07:18:28.689"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:28.690" starttime="20190402 07:18:28.690"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:18:28.690" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:18:28.690" starttime="20190402 07:18:28.690"></status>
</kw>
<msg timestamp="20190402 07:18:28.690" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:18:28.690" starttime="20190402 07:18:26.760"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:18:28.691" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:18:28.691" starttime="20190402 07:18:28.691"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:18:28.691" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:18:28.692" starttime="20190402 07:18:28.691"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:28.692" starttime="20190402 07:18:28.691"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:28.692" starttime="20190402 07:18:26.759"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:18:33.695" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:33.695" starttime="20190402 07:18:33.694"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:33.698" starttime="20190402 07:18:33.697"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:18:33.700" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:18:33.700" starttime="20190402 07:18:33.699"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:33.702" starttime="20190402 07:18:33.701"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:33.703" starttime="20190402 07:18:33.702"></status>
</kw>
<msg timestamp="20190402 07:18:33.704" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:18:33.704" starttime="20190402 07:18:33.698"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:18:33.705" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:33.705" starttime="20190402 07:18:33.704"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:18:33.731" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:33.731" starttime="20190402 07:18:33.706"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:18:34.881" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:18:34.881" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:34.881" starttime="20190402 07:18:33.731"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:18:34.882" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:34.882" starttime="20190402 07:18:34.882"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:18:34.883" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:34.883" starttime="20190402 07:18:34.882"></status>
</kw>
<msg timestamp="20190402 07:18:34.883" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:34.883" starttime="20190402 07:18:34.882"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:18:34.885" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:18:34.885" starttime="20190402 07:18:34.883"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:18:34.885" level="INFO">0</msg>
<msg timestamp="20190402 07:18:34.885" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:34.885" starttime="20190402 07:18:34.885"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:18:34.886" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:18:34.886" starttime="20190402 07:18:34.885"></status>
</kw>
<msg timestamp="20190402 07:18:34.886" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:34.886" starttime="20190402 07:18:34.883"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:34.887" starttime="20190402 07:18:34.886"></status>
</kw>
<status status="PASS" endtime="20190402 07:18:34.887" starttime="20190402 07:18:34.886"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:34.887" starttime="20190402 07:18:34.887"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:18:34.887" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:18:34.887" starttime="20190402 07:18:34.887"></status>
</kw>
<msg timestamp="20190402 07:18:34.888" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:18:34.888" starttime="20190402 07:18:33.695"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:18:34.888" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:18:34.888" starttime="20190402 07:18:34.888"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:18:34.889" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:18:34.889" starttime="20190402 07:18:34.888"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:34.889" starttime="20190402 07:18:34.888"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:34.889" starttime="20190402 07:18:33.692"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:18:39.892" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:39.892" starttime="20190402 07:18:39.891"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:39.894" starttime="20190402 07:18:39.894"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:18:39.895" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:18:39.896" starttime="20190402 07:18:39.895"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:39.896" starttime="20190402 07:18:39.896"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:39.896" starttime="20190402 07:18:39.896"></status>
</kw>
<msg timestamp="20190402 07:18:39.896" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:18:39.896" starttime="20190402 07:18:39.895"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:18:39.897" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:39.897" starttime="20190402 07:18:39.897"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:18:39.905" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:39.905" starttime="20190402 07:18:39.897"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:18:41.003" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:18:41.003" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:41.003" starttime="20190402 07:18:39.905"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:18:41.004" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:41.004" starttime="20190402 07:18:41.004"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:18:41.004" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:41.005" starttime="20190402 07:18:41.004"></status>
</kw>
<msg timestamp="20190402 07:18:41.005" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:41.005" starttime="20190402 07:18:41.004"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:18:41.007" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:18:41.008" starttime="20190402 07:18:41.005"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:18:41.008" level="INFO">0</msg>
<msg timestamp="20190402 07:18:41.008" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:41.008" starttime="20190402 07:18:41.008"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:18:41.008" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:18:41.008" starttime="20190402 07:18:41.008"></status>
</kw>
<msg timestamp="20190402 07:18:41.009" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:41.009" starttime="20190402 07:18:41.005"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:41.009" starttime="20190402 07:18:41.009"></status>
</kw>
<status status="PASS" endtime="20190402 07:18:41.009" starttime="20190402 07:18:41.009"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:41.010" starttime="20190402 07:18:41.009"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:18:41.010" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:18:41.010" starttime="20190402 07:18:41.010"></status>
</kw>
<msg timestamp="20190402 07:18:41.010" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:18:41.010" starttime="20190402 07:18:39.892"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:18:41.011" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:18:41.011" starttime="20190402 07:18:41.010"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:18:41.011" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:18:41.011" starttime="20190402 07:18:41.011"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:41.011" starttime="20190402 07:18:41.011"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:41.011" starttime="20190402 07:18:39.890"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:18:46.014" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:46.015" starttime="20190402 07:18:46.013"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:46.017" starttime="20190402 07:18:46.016"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:18:46.018" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:18:46.018" starttime="20190402 07:18:46.017"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:46.018" starttime="20190402 07:18:46.018"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:46.018" starttime="20190402 07:18:46.018"></status>
</kw>
<msg timestamp="20190402 07:18:46.019" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:18:46.019" starttime="20190402 07:18:46.017"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:18:46.019" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:46.019" starttime="20190402 07:18:46.019"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:18:46.021" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:46.021" starttime="20190402 07:18:46.019"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:18:47.276" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:18:47.276" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:47.276" starttime="20190402 07:18:46.021"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:18:47.277" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:47.277" starttime="20190402 07:18:47.277"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:18:47.277" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:47.277" starttime="20190402 07:18:47.277"></status>
</kw>
<msg timestamp="20190402 07:18:47.277" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:47.277" starttime="20190402 07:18:47.276"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:18:47.280" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:18:47.280" starttime="20190402 07:18:47.278"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:18:47.285" level="INFO">0</msg>
<msg timestamp="20190402 07:18:47.285" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:47.285" starttime="20190402 07:18:47.281"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:18:47.285" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:18:47.285" starttime="20190402 07:18:47.285"></status>
</kw>
<msg timestamp="20190402 07:18:47.285" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:47.286" starttime="20190402 07:18:47.278"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:47.286" starttime="20190402 07:18:47.286"></status>
</kw>
<status status="PASS" endtime="20190402 07:18:47.287" starttime="20190402 07:18:47.286"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:47.287" starttime="20190402 07:18:47.287"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:18:47.287" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:18:47.287" starttime="20190402 07:18:47.287"></status>
</kw>
<msg timestamp="20190402 07:18:47.287" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:18:47.287" starttime="20190402 07:18:46.015"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:18:47.288" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:18:47.288" starttime="20190402 07:18:47.288"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:18:47.288" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:18:47.289" starttime="20190402 07:18:47.288"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:47.289" starttime="20190402 07:18:47.288"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:47.289" starttime="20190402 07:18:46.012"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:18:52.292" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:52.292" starttime="20190402 07:18:52.291"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:52.295" starttime="20190402 07:18:52.294"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:18:52.297" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:18:52.298" starttime="20190402 07:18:52.296"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:52.299" starttime="20190402 07:18:52.298"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:52.300" starttime="20190402 07:18:52.299"></status>
</kw>
<msg timestamp="20190402 07:18:52.301" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:18:52.301" starttime="20190402 07:18:52.295"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:18:52.302" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:52.302" starttime="20190402 07:18:52.302"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:18:52.327" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:52.327" starttime="20190402 07:18:52.303"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:18:53.438" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:18:53.438" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:53.438" starttime="20190402 07:18:52.328"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:18:53.439" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:53.439" starttime="20190402 07:18:53.439"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:18:53.439" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:53.439" starttime="20190402 07:18:53.439"></status>
</kw>
<msg timestamp="20190402 07:18:53.439" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:53.439" starttime="20190402 07:18:53.438"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:18:53.441" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:18:53.441" starttime="20190402 07:18:53.440"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:18:53.442" level="INFO">0</msg>
<msg timestamp="20190402 07:18:53.442" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:53.442" starttime="20190402 07:18:53.442"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:18:53.442" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:18:53.442" starttime="20190402 07:18:53.442"></status>
</kw>
<msg timestamp="20190402 07:18:53.442" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:53.442" starttime="20190402 07:18:53.439"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:53.443" starttime="20190402 07:18:53.443"></status>
</kw>
<status status="PASS" endtime="20190402 07:18:53.443" starttime="20190402 07:18:53.442"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:53.443" starttime="20190402 07:18:53.443"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:18:53.444" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:18:53.444" starttime="20190402 07:18:53.443"></status>
</kw>
<msg timestamp="20190402 07:18:53.444" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:18:53.444" starttime="20190402 07:18:52.292"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:18:53.444" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:18:53.445" starttime="20190402 07:18:53.444"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:18:53.445" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:18:53.445" starttime="20190402 07:18:53.445"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:53.445" starttime="20190402 07:18:53.445"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:53.445" starttime="20190402 07:18:52.289"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:18:58.449" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:58.449" starttime="20190402 07:18:58.448"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:58.451" starttime="20190402 07:18:58.451"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:18:58.452" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:18:58.452" starttime="20190402 07:18:58.451"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:58.452" starttime="20190402 07:18:58.452"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:58.453" starttime="20190402 07:18:58.452"></status>
</kw>
<msg timestamp="20190402 07:18:58.453" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:18:58.453" starttime="20190402 07:18:58.451"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:18:58.453" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:58.453" starttime="20190402 07:18:58.453"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:18:58.461" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:18:58.461" starttime="20190402 07:18:58.453"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:18:59.699" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:18:59.699" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:59.699" starttime="20190402 07:18:58.461"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:18:59.700" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:18:59.700" starttime="20190402 07:18:59.700"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:18:59.700" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:59.701" starttime="20190402 07:18:59.700"></status>
</kw>
<msg timestamp="20190402 07:18:59.701" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:18:59.701" starttime="20190402 07:18:59.700"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:18:59.703" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:18:59.703" starttime="20190402 07:18:59.701"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:18:59.706" level="INFO">0</msg>
<msg timestamp="20190402 07:18:59.706" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:59.706" starttime="20190402 07:18:59.703"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:18:59.706" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:18:59.706" starttime="20190402 07:18:59.706"></status>
</kw>
<msg timestamp="20190402 07:18:59.706" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:18:59.706" starttime="20190402 07:18:59.701"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:59.707" starttime="20190402 07:18:59.707"></status>
</kw>
<status status="PASS" endtime="20190402 07:18:59.707" starttime="20190402 07:18:59.707"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:18:59.708" starttime="20190402 07:18:59.707"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:18:59.708" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:18:59.708" starttime="20190402 07:18:59.708"></status>
</kw>
<msg timestamp="20190402 07:18:59.708" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:18:59.708" starttime="20190402 07:18:58.449"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:18:59.708" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:18:59.709" starttime="20190402 07:18:59.708"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:18:59.710" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:18:59.710" starttime="20190402 07:18:59.709"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:59.710" starttime="20190402 07:18:59.709"></status>
</kw>
<status status="FAIL" endtime="20190402 07:18:59.710" starttime="20190402 07:18:58.446"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:19:04.713" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:04.713" starttime="20190402 07:19:04.712"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:04.716" starttime="20190402 07:19:04.715"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:19:04.718" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:19:04.719" starttime="20190402 07:19:04.717"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:04.720" starttime="20190402 07:19:04.719"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:04.721" starttime="20190402 07:19:04.721"></status>
</kw>
<msg timestamp="20190402 07:19:04.722" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:19:04.722" starttime="20190402 07:19:04.716"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:19:04.723" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:04.723" starttime="20190402 07:19:04.723"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:19:04.749" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:04.749" starttime="20190402 07:19:04.724"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:19:05.828" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:19:05.829" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:05.829" starttime="20190402 07:19:04.749"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:19:05.829" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:05.829" starttime="20190402 07:19:05.829"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:19:05.830" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:05.830" starttime="20190402 07:19:05.830"></status>
</kw>
<msg timestamp="20190402 07:19:05.830" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:05.830" starttime="20190402 07:19:05.829"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:19:05.832" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:19:05.832" starttime="20190402 07:19:05.830"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:19:05.832" level="INFO">0</msg>
<msg timestamp="20190402 07:19:05.832" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:05.833" starttime="20190402 07:19:05.832"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:19:05.833" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:19:05.833" starttime="20190402 07:19:05.833"></status>
</kw>
<msg timestamp="20190402 07:19:05.833" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:05.833" starttime="20190402 07:19:05.830"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:05.834" starttime="20190402 07:19:05.833"></status>
</kw>
<status status="PASS" endtime="20190402 07:19:05.834" starttime="20190402 07:19:05.833"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:05.834" starttime="20190402 07:19:05.834"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:19:05.834" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:19:05.834" starttime="20190402 07:19:05.834"></status>
</kw>
<msg timestamp="20190402 07:19:05.835" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:19:05.835" starttime="20190402 07:19:04.714"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:19:05.835" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:19:05.835" starttime="20190402 07:19:05.835"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:19:05.836" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:19:05.836" starttime="20190402 07:19:05.835"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:05.836" starttime="20190402 07:19:05.835"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:05.836" starttime="20190402 07:19:04.711"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:19:10.840" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:10.840" starttime="20190402 07:19:10.838"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:10.843" starttime="20190402 07:19:10.842"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:19:10.846" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:19:10.846" starttime="20190402 07:19:10.844"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:10.847" starttime="20190402 07:19:10.846"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:10.848" starttime="20190402 07:19:10.848"></status>
</kw>
<msg timestamp="20190402 07:19:10.849" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:19:10.849" starttime="20190402 07:19:10.843"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:19:10.850" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:10.850" starttime="20190402 07:19:10.850"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:19:10.868" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:10.868" starttime="20190402 07:19:10.851"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:19:11.961" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:19:11.961" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:11.961" starttime="20190402 07:19:10.868"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:19:11.962" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:11.962" starttime="20190402 07:19:11.962"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:19:11.963" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:11.963" starttime="20190402 07:19:11.962"></status>
</kw>
<msg timestamp="20190402 07:19:11.963" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:11.963" starttime="20190402 07:19:11.962"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:19:11.965" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:19:11.965" starttime="20190402 07:19:11.963"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:19:11.966" level="INFO">0</msg>
<msg timestamp="20190402 07:19:11.966" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:11.966" starttime="20190402 07:19:11.966"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:19:11.966" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:19:11.966" starttime="20190402 07:19:11.966"></status>
</kw>
<msg timestamp="20190402 07:19:11.966" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:11.966" starttime="20190402 07:19:11.963"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:11.967" starttime="20190402 07:19:11.967"></status>
</kw>
<status status="PASS" endtime="20190402 07:19:11.967" starttime="20190402 07:19:11.966"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:11.967" starttime="20190402 07:19:11.967"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:19:11.968" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:19:11.968" starttime="20190402 07:19:11.967"></status>
</kw>
<msg timestamp="20190402 07:19:11.968" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:19:11.968" starttime="20190402 07:19:10.840"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:19:11.968" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:19:11.968" starttime="20190402 07:19:11.968"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:19:11.969" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:19:11.969" starttime="20190402 07:19:11.969"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:11.969" starttime="20190402 07:19:11.968"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:11.969" starttime="20190402 07:19:10.837"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:19:16.972" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:16.972" starttime="20190402 07:19:16.971"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:16.976" starttime="20190402 07:19:16.974"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:19:16.979" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:19:16.979" starttime="20190402 07:19:16.977"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:16.980" starttime="20190402 07:19:16.979"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:16.981" starttime="20190402 07:19:16.980"></status>
</kw>
<msg timestamp="20190402 07:19:16.982" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:19:16.982" starttime="20190402 07:19:16.976"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:19:16.983" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:16.983" starttime="20190402 07:19:16.983"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:19:17.009" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:17.010" starttime="20190402 07:19:16.984"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:19:18.121" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:19:18.121" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:18.121" starttime="20190402 07:19:17.010"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:19:18.122" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:18.122" starttime="20190402 07:19:18.122"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:19:18.122" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:18.122" starttime="20190402 07:19:18.122"></status>
</kw>
<msg timestamp="20190402 07:19:18.122" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:18.122" starttime="20190402 07:19:18.121"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:19:18.124" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:19:18.124" starttime="20190402 07:19:18.123"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:19:18.125" level="INFO">0</msg>
<msg timestamp="20190402 07:19:18.125" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:18.125" starttime="20190402 07:19:18.124"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:19:18.125" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:19:18.125" starttime="20190402 07:19:18.125"></status>
</kw>
<msg timestamp="20190402 07:19:18.125" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:18.125" starttime="20190402 07:19:18.122"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:18.126" starttime="20190402 07:19:18.126"></status>
</kw>
<status status="PASS" endtime="20190402 07:19:18.126" starttime="20190402 07:19:18.126"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:18.126" starttime="20190402 07:19:18.126"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:19:18.127" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:19:18.127" starttime="20190402 07:19:18.127"></status>
</kw>
<msg timestamp="20190402 07:19:18.127" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:19:18.127" starttime="20190402 07:19:16.973"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:19:18.127" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:19:18.127" starttime="20190402 07:19:18.127"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:19:18.128" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:19:18.128" starttime="20190402 07:19:18.128"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:18.128" starttime="20190402 07:19:18.128"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:18.128" starttime="20190402 07:19:16.970"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:19:23.131" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:23.132" starttime="20190402 07:19:23.131"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:23.134" starttime="20190402 07:19:23.133"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:19:23.135" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:19:23.135" starttime="20190402 07:19:23.134"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:23.135" starttime="20190402 07:19:23.135"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:23.136" starttime="20190402 07:19:23.135"></status>
</kw>
<msg timestamp="20190402 07:19:23.136" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:19:23.136" starttime="20190402 07:19:23.134"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:19:23.136" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:23.136" starttime="20190402 07:19:23.136"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:19:23.145" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:23.146" starttime="20190402 07:19:23.136"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:19:24.294" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:19:24.294" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:24.294" starttime="20190402 07:19:23.146"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:19:24.295" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:24.295" starttime="20190402 07:19:24.294"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:19:24.295" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:24.295" starttime="20190402 07:19:24.295"></status>
</kw>
<msg timestamp="20190402 07:19:24.295" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:24.295" starttime="20190402 07:19:24.294"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:19:24.297" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:19:24.297" starttime="20190402 07:19:24.296"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:19:24.298" level="INFO">0</msg>
<msg timestamp="20190402 07:19:24.298" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:24.298" starttime="20190402 07:19:24.297"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:19:24.298" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:19:24.298" starttime="20190402 07:19:24.298"></status>
</kw>
<msg timestamp="20190402 07:19:24.298" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:24.298" starttime="20190402 07:19:24.295"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:24.299" starttime="20190402 07:19:24.299"></status>
</kw>
<status status="PASS" endtime="20190402 07:19:24.299" starttime="20190402 07:19:24.299"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:24.300" starttime="20190402 07:19:24.299"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:19:24.300" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:19:24.300" starttime="20190402 07:19:24.300"></status>
</kw>
<msg timestamp="20190402 07:19:24.300" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:19:24.300" starttime="20190402 07:19:23.132"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:19:24.300" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:19:24.301" starttime="20190402 07:19:24.300"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:19:24.301" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:19:24.301" starttime="20190402 07:19:24.301"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:24.301" starttime="20190402 07:19:24.301"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:24.301" starttime="20190402 07:19:23.129"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:19:29.304" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:29.304" starttime="20190402 07:19:29.303"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:29.307" starttime="20190402 07:19:29.306"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:19:29.308" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:19:29.308" starttime="20190402 07:19:29.307"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:29.308" starttime="20190402 07:19:29.308"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:29.308" starttime="20190402 07:19:29.308"></status>
</kw>
<msg timestamp="20190402 07:19:29.309" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:19:29.309" starttime="20190402 07:19:29.307"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:19:29.309" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:29.309" starttime="20190402 07:19:29.309"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:19:29.319" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:29.319" starttime="20190402 07:19:29.309"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:19:30.895" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:19:30.896" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:30.896" starttime="20190402 07:19:29.319"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:19:30.896" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:30.896" starttime="20190402 07:19:30.896"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:19:30.897" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:30.897" starttime="20190402 07:19:30.897"></status>
</kw>
<msg timestamp="20190402 07:19:30.897" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:30.897" starttime="20190402 07:19:30.896"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:19:30.899" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:19:30.899" starttime="20190402 07:19:30.897"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:19:30.904" level="INFO">0</msg>
<msg timestamp="20190402 07:19:30.904" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:30.904" starttime="20190402 07:19:30.899"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:19:30.904" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:19:30.904" starttime="20190402 07:19:30.904"></status>
</kw>
<msg timestamp="20190402 07:19:30.905" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:30.905" starttime="20190402 07:19:30.897"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:30.905" starttime="20190402 07:19:30.905"></status>
</kw>
<status status="PASS" endtime="20190402 07:19:30.905" starttime="20190402 07:19:30.905"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:30.906" starttime="20190402 07:19:30.906"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:19:30.906" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:19:30.906" starttime="20190402 07:19:30.906"></status>
</kw>
<msg timestamp="20190402 07:19:30.906" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:19:30.906" starttime="20190402 07:19:29.305"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:19:30.907" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:19:30.907" starttime="20190402 07:19:30.906"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:19:30.907" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:19:30.907" starttime="20190402 07:19:30.907"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:30.907" starttime="20190402 07:19:30.907"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:30.908" starttime="20190402 07:19:29.302"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:19:35.910" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:35.910" starttime="20190402 07:19:35.909"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:35.912" starttime="20190402 07:19:35.911"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:19:35.913" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:19:35.913" starttime="20190402 07:19:35.913"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:35.914" starttime="20190402 07:19:35.913"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:35.914" starttime="20190402 07:19:35.914"></status>
</kw>
<msg timestamp="20190402 07:19:35.914" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:19:35.914" starttime="20190402 07:19:35.912"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:19:35.915" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:35.915" starttime="20190402 07:19:35.914"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:19:35.923" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:35.923" starttime="20190402 07:19:35.915"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:19:37.141" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:19:37.141" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:37.142" starttime="20190402 07:19:35.923"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:19:37.142" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:37.143" starttime="20190402 07:19:37.142"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:19:37.143" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:37.143" starttime="20190402 07:19:37.143"></status>
</kw>
<msg timestamp="20190402 07:19:37.143" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:37.143" starttime="20190402 07:19:37.142"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:19:37.146" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:19:37.147" starttime="20190402 07:19:37.143"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:19:37.153" level="INFO">0</msg>
<msg timestamp="20190402 07:19:37.153" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:37.153" starttime="20190402 07:19:37.147"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:19:37.154" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:19:37.154" starttime="20190402 07:19:37.154"></status>
</kw>
<msg timestamp="20190402 07:19:37.154" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:37.154" starttime="20190402 07:19:37.143"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:37.155" starttime="20190402 07:19:37.155"></status>
</kw>
<status status="PASS" endtime="20190402 07:19:37.155" starttime="20190402 07:19:37.154"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:37.155" starttime="20190402 07:19:37.155"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:19:37.156" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:19:37.156" starttime="20190402 07:19:37.155"></status>
</kw>
<msg timestamp="20190402 07:19:37.156" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:19:37.156" starttime="20190402 07:19:35.910"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:19:37.156" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:19:37.156" starttime="20190402 07:19:37.156"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:19:37.157" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:19:37.157" starttime="20190402 07:19:37.157"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:37.157" starttime="20190402 07:19:37.156"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:37.157" starttime="20190402 07:19:35.908"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:19:42.160" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:42.161" starttime="20190402 07:19:42.159"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:42.163" starttime="20190402 07:19:42.163"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:19:42.164" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:19:42.164" starttime="20190402 07:19:42.163"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:42.164" starttime="20190402 07:19:42.164"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:42.164" starttime="20190402 07:19:42.164"></status>
</kw>
<msg timestamp="20190402 07:19:42.165" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:19:42.165" starttime="20190402 07:19:42.163"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:19:42.165" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:42.165" starttime="20190402 07:19:42.165"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:19:42.175" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:42.175" starttime="20190402 07:19:42.165"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:19:43.341" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:19:43.341" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:43.341" starttime="20190402 07:19:42.175"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:19:43.342" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:43.342" starttime="20190402 07:19:43.341"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:19:43.342" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:43.342" starttime="20190402 07:19:43.342"></status>
</kw>
<msg timestamp="20190402 07:19:43.342" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:43.342" starttime="20190402 07:19:43.341"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:19:43.344" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:19:43.344" starttime="20190402 07:19:43.343"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:19:43.345" level="INFO">0</msg>
<msg timestamp="20190402 07:19:43.345" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:43.345" starttime="20190402 07:19:43.344"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:19:43.345" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:19:43.345" starttime="20190402 07:19:43.345"></status>
</kw>
<msg timestamp="20190402 07:19:43.345" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:43.345" starttime="20190402 07:19:43.343"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:43.346" starttime="20190402 07:19:43.346"></status>
</kw>
<status status="PASS" endtime="20190402 07:19:43.346" starttime="20190402 07:19:43.345"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:43.346" starttime="20190402 07:19:43.346"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:19:43.346" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:19:43.346" starttime="20190402 07:19:43.346"></status>
</kw>
<msg timestamp="20190402 07:19:43.347" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:19:43.347" starttime="20190402 07:19:42.161"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:19:43.347" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:19:43.347" starttime="20190402 07:19:43.347"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:19:43.348" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:19:43.348" starttime="20190402 07:19:43.348"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:43.348" starttime="20190402 07:19:43.347"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:43.348" starttime="20190402 07:19:42.158"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:19:48.351" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:48.351" starttime="20190402 07:19:48.350"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:48.354" starttime="20190402 07:19:48.353"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:19:48.355" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:19:48.355" starttime="20190402 07:19:48.354"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:48.355" starttime="20190402 07:19:48.355"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:48.355" starttime="20190402 07:19:48.355"></status>
</kw>
<msg timestamp="20190402 07:19:48.356" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:19:48.356" starttime="20190402 07:19:48.354"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:19:48.356" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:48.356" starttime="20190402 07:19:48.356"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:19:48.366" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:48.366" starttime="20190402 07:19:48.356"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:19:49.762" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:19:49.763" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:49.763" starttime="20190402 07:19:48.366"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:19:49.763" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:49.764" starttime="20190402 07:19:49.763"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:19:49.764" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:49.764" starttime="20190402 07:19:49.764"></status>
</kw>
<msg timestamp="20190402 07:19:49.764" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:49.764" starttime="20190402 07:19:49.763"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:19:49.766" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:19:49.766" starttime="20190402 07:19:49.764"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:19:49.767" level="INFO">0</msg>
<msg timestamp="20190402 07:19:49.767" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:49.767" starttime="20190402 07:19:49.766"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:19:49.767" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:19:49.767" starttime="20190402 07:19:49.767"></status>
</kw>
<msg timestamp="20190402 07:19:49.767" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:49.767" starttime="20190402 07:19:49.764"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:49.768" starttime="20190402 07:19:49.768"></status>
</kw>
<status status="PASS" endtime="20190402 07:19:49.768" starttime="20190402 07:19:49.767"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:49.768" starttime="20190402 07:19:49.768"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:19:49.769" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:19:49.769" starttime="20190402 07:19:49.769"></status>
</kw>
<msg timestamp="20190402 07:19:49.769" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:19:49.769" starttime="20190402 07:19:48.352"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:19:49.769" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:19:49.769" starttime="20190402 07:19:49.769"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:19:49.770" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:19:49.770" starttime="20190402 07:19:49.770"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:49.770" starttime="20190402 07:19:49.770"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:49.770" starttime="20190402 07:19:48.349"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:19:54.774" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:54.774" starttime="20190402 07:19:54.773"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:54.776" starttime="20190402 07:19:54.776"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:19:54.777" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:19:54.777" starttime="20190402 07:19:54.777"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:54.777" starttime="20190402 07:19:54.777"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:54.778" starttime="20190402 07:19:54.777"></status>
</kw>
<msg timestamp="20190402 07:19:54.778" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:19:54.778" starttime="20190402 07:19:54.776"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:19:54.778" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:54.778" starttime="20190402 07:19:54.778"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:19:54.786" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:19:54.786" starttime="20190402 07:19:54.778"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:19:55.966" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:19:55.966" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:55.967" starttime="20190402 07:19:54.786"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:19:55.967" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:19:55.967" starttime="20190402 07:19:55.967"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:19:55.968" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:55.968" starttime="20190402 07:19:55.968"></status>
</kw>
<msg timestamp="20190402 07:19:55.968" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:19:55.968" starttime="20190402 07:19:55.967"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:19:55.970" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:19:55.970" starttime="20190402 07:19:55.968"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:19:55.971" level="INFO">0</msg>
<msg timestamp="20190402 07:19:55.971" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:55.971" starttime="20190402 07:19:55.971"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:19:55.971" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:19:55.971" starttime="20190402 07:19:55.971"></status>
</kw>
<msg timestamp="20190402 07:19:55.971" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:19:55.971" starttime="20190402 07:19:55.968"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:55.972" starttime="20190402 07:19:55.972"></status>
</kw>
<status status="PASS" endtime="20190402 07:19:55.972" starttime="20190402 07:19:55.972"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:19:55.973" starttime="20190402 07:19:55.973"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:19:55.973" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:19:55.973" starttime="20190402 07:19:55.973"></status>
</kw>
<msg timestamp="20190402 07:19:55.973" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:19:55.973" starttime="20190402 07:19:54.774"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:19:55.974" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:19:55.974" starttime="20190402 07:19:55.974"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:19:55.974" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:19:55.974" starttime="20190402 07:19:55.974"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:55.975" starttime="20190402 07:19:55.974"></status>
</kw>
<status status="FAIL" endtime="20190402 07:19:55.975" starttime="20190402 07:19:54.771"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:20:00.978" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:00.978" starttime="20190402 07:20:00.977"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:00.980" starttime="20190402 07:20:00.980"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:20:00.981" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:20:00.981" starttime="20190402 07:20:00.981"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:00.981" starttime="20190402 07:20:00.981"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:00.982" starttime="20190402 07:20:00.981"></status>
</kw>
<msg timestamp="20190402 07:20:00.982" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:20:00.982" starttime="20190402 07:20:00.980"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:20:00.982" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:00.982" starttime="20190402 07:20:00.982"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:20:00.991" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:00.992" starttime="20190402 07:20:00.982"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:20:02.207" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:20:02.208" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:02.208" starttime="20190402 07:20:00.992"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:20:02.208" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:02.208" starttime="20190402 07:20:02.208"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:20:02.209" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:02.209" starttime="20190402 07:20:02.209"></status>
</kw>
<msg timestamp="20190402 07:20:02.209" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:02.209" starttime="20190402 07:20:02.208"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:20:02.211" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:20:02.211" starttime="20190402 07:20:02.209"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:20:02.211" level="INFO">0</msg>
<msg timestamp="20190402 07:20:02.211" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:02.211" starttime="20190402 07:20:02.211"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:20:02.212" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:20:02.212" starttime="20190402 07:20:02.211"></status>
</kw>
<msg timestamp="20190402 07:20:02.212" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:02.212" starttime="20190402 07:20:02.209"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:02.213" starttime="20190402 07:20:02.212"></status>
</kw>
<status status="PASS" endtime="20190402 07:20:02.213" starttime="20190402 07:20:02.212"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:02.213" starttime="20190402 07:20:02.213"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:20:02.213" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:20:02.213" starttime="20190402 07:20:02.213"></status>
</kw>
<msg timestamp="20190402 07:20:02.213" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:20:02.213" starttime="20190402 07:20:00.978"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:20:02.214" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:20:02.214" starttime="20190402 07:20:02.214"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:20:02.215" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:20:02.215" starttime="20190402 07:20:02.214"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:02.215" starttime="20190402 07:20:02.214"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:02.215" starttime="20190402 07:20:00.975"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:20:07.218" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:07.218" starttime="20190402 07:20:07.217"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:07.221" starttime="20190402 07:20:07.220"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:20:07.222" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:20:07.222" starttime="20190402 07:20:07.221"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:07.222" starttime="20190402 07:20:07.222"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:07.222" starttime="20190402 07:20:07.222"></status>
</kw>
<msg timestamp="20190402 07:20:07.223" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:20:07.223" starttime="20190402 07:20:07.221"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:20:07.223" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:07.223" starttime="20190402 07:20:07.223"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:20:07.232" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:07.232" starttime="20190402 07:20:07.223"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:20:08.398" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:20:08.398" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:08.398" starttime="20190402 07:20:07.232"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:20:08.399" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:08.399" starttime="20190402 07:20:08.398"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:20:08.399" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:08.399" starttime="20190402 07:20:08.399"></status>
</kw>
<msg timestamp="20190402 07:20:08.399" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:08.399" starttime="20190402 07:20:08.398"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:20:08.401" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:20:08.401" starttime="20190402 07:20:08.400"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:20:08.401" level="INFO">0</msg>
<msg timestamp="20190402 07:20:08.401" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:08.401" starttime="20190402 07:20:08.401"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:20:08.402" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:20:08.402" starttime="20190402 07:20:08.402"></status>
</kw>
<msg timestamp="20190402 07:20:08.402" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:08.402" starttime="20190402 07:20:08.399"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:08.403" starttime="20190402 07:20:08.402"></status>
</kw>
<status status="PASS" endtime="20190402 07:20:08.403" starttime="20190402 07:20:08.402"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:08.403" starttime="20190402 07:20:08.403"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:20:08.403" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:20:08.403" starttime="20190402 07:20:08.403"></status>
</kw>
<msg timestamp="20190402 07:20:08.404" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:20:08.404" starttime="20190402 07:20:07.218"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:20:08.404" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:20:08.404" starttime="20190402 07:20:08.404"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:20:08.405" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:20:08.405" starttime="20190402 07:20:08.404"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:08.405" starttime="20190402 07:20:08.404"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:08.405" starttime="20190402 07:20:07.216"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:20:13.408" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:13.408" starttime="20190402 07:20:13.407"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:13.411" starttime="20190402 07:20:13.410"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:20:13.414" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:20:13.414" starttime="20190402 07:20:13.412"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:13.416" starttime="20190402 07:20:13.415"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:13.417" starttime="20190402 07:20:13.416"></status>
</kw>
<msg timestamp="20190402 07:20:13.418" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:20:13.418" starttime="20190402 07:20:13.412"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:20:13.419" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:13.419" starttime="20190402 07:20:13.418"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:20:13.448" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:13.448" starttime="20190402 07:20:13.419"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:20:14.528" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:20:14.528" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:14.528" starttime="20190402 07:20:13.448"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:20:14.529" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:14.529" starttime="20190402 07:20:14.528"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:20:14.529" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:14.529" starttime="20190402 07:20:14.529"></status>
</kw>
<msg timestamp="20190402 07:20:14.529" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:14.529" starttime="20190402 07:20:14.528"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:20:14.531" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:20:14.531" starttime="20190402 07:20:14.530"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:20:14.531" level="INFO">0</msg>
<msg timestamp="20190402 07:20:14.532" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:14.532" starttime="20190402 07:20:14.531"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:20:14.532" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:20:14.532" starttime="20190402 07:20:14.532"></status>
</kw>
<msg timestamp="20190402 07:20:14.532" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:14.532" starttime="20190402 07:20:14.529"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:14.533" starttime="20190402 07:20:14.533"></status>
</kw>
<status status="PASS" endtime="20190402 07:20:14.533" starttime="20190402 07:20:14.532"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:14.533" starttime="20190402 07:20:14.533"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:20:14.534" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:20:14.534" starttime="20190402 07:20:14.533"></status>
</kw>
<msg timestamp="20190402 07:20:14.534" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:20:14.534" starttime="20190402 07:20:13.409"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:20:14.534" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:20:14.534" starttime="20190402 07:20:14.534"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:20:14.535" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:20:14.535" starttime="20190402 07:20:14.535"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:14.535" starttime="20190402 07:20:14.534"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:14.535" starttime="20190402 07:20:13.406"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:20:19.538" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:19.539" starttime="20190402 07:20:19.538"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:19.541" starttime="20190402 07:20:19.540"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:20:19.542" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:20:19.542" starttime="20190402 07:20:19.541"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:19.542" starttime="20190402 07:20:19.542"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:19.543" starttime="20190402 07:20:19.542"></status>
</kw>
<msg timestamp="20190402 07:20:19.543" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:20:19.543" starttime="20190402 07:20:19.541"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:20:19.543" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:19.543" starttime="20190402 07:20:19.543"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:20:19.552" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:19.552" starttime="20190402 07:20:19.543"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:20:20.673" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:20:20.673" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:20.673" starttime="20190402 07:20:19.553"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:20:20.674" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:20.674" starttime="20190402 07:20:20.673"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:20:20.674" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:20.674" starttime="20190402 07:20:20.674"></status>
</kw>
<msg timestamp="20190402 07:20:20.674" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:20.674" starttime="20190402 07:20:20.673"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:20:20.676" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:20:20.676" starttime="20190402 07:20:20.674"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:20:20.676" level="INFO">0</msg>
<msg timestamp="20190402 07:20:20.676" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:20.676" starttime="20190402 07:20:20.676"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:20:20.677" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:20:20.677" starttime="20190402 07:20:20.676"></status>
</kw>
<msg timestamp="20190402 07:20:20.677" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:20.677" starttime="20190402 07:20:20.674"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:20.678" starttime="20190402 07:20:20.677"></status>
</kw>
<status status="PASS" endtime="20190402 07:20:20.678" starttime="20190402 07:20:20.677"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:20.678" starttime="20190402 07:20:20.678"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:20:20.678" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:20:20.678" starttime="20190402 07:20:20.678"></status>
</kw>
<msg timestamp="20190402 07:20:20.678" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:20:20.678" starttime="20190402 07:20:19.539"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:20:20.679" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:20:20.679" starttime="20190402 07:20:20.679"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:20:20.680" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:20:20.680" starttime="20190402 07:20:20.679"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:20.680" starttime="20190402 07:20:20.679"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:20.680" starttime="20190402 07:20:19.536"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:20:25.683" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:25.683" starttime="20190402 07:20:25.682"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:25.686" starttime="20190402 07:20:25.685"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:20:25.688" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:20:25.688" starttime="20190402 07:20:25.687"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:25.689" starttime="20190402 07:20:25.689"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:25.691" starttime="20190402 07:20:25.690"></status>
</kw>
<msg timestamp="20190402 07:20:25.692" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:20:25.693" starttime="20190402 07:20:25.686"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:20:25.694" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:25.694" starttime="20190402 07:20:25.693"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:20:25.720" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:25.720" starttime="20190402 07:20:25.695"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:20:27.262" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:20:27.262" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:27.262" starttime="20190402 07:20:25.720"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:20:27.263" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:27.263" starttime="20190402 07:20:27.262"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:20:27.263" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:27.263" starttime="20190402 07:20:27.263"></status>
</kw>
<msg timestamp="20190402 07:20:27.263" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:27.263" starttime="20190402 07:20:27.262"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:20:27.265" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:20:27.265" starttime="20190402 07:20:27.264"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:20:27.266" level="INFO">0</msg>
<msg timestamp="20190402 07:20:27.266" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:27.266" starttime="20190402 07:20:27.265"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:20:27.266" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:20:27.266" starttime="20190402 07:20:27.266"></status>
</kw>
<msg timestamp="20190402 07:20:27.266" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:27.266" starttime="20190402 07:20:27.263"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:27.267" starttime="20190402 07:20:27.267"></status>
</kw>
<status status="PASS" endtime="20190402 07:20:27.267" starttime="20190402 07:20:27.267"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:27.268" starttime="20190402 07:20:27.267"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:20:27.268" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:20:27.268" starttime="20190402 07:20:27.268"></status>
</kw>
<msg timestamp="20190402 07:20:27.268" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:20:27.268" starttime="20190402 07:20:25.684"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:20:27.268" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:20:27.268" starttime="20190402 07:20:27.268"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:20:27.269" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:20:27.269" starttime="20190402 07:20:27.269"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:27.269" starttime="20190402 07:20:27.269"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:27.269" starttime="20190402 07:20:25.681"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:20:32.273" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:32.273" starttime="20190402 07:20:32.271"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:32.275" starttime="20190402 07:20:32.275"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:20:32.276" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:20:32.276" starttime="20190402 07:20:32.276"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:32.276" starttime="20190402 07:20:32.276"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:32.277" starttime="20190402 07:20:32.276"></status>
</kw>
<msg timestamp="20190402 07:20:32.277" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:20:32.277" starttime="20190402 07:20:32.275"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:20:32.277" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:32.277" starttime="20190402 07:20:32.277"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:20:32.287" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:32.287" starttime="20190402 07:20:32.277"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:20:33.392" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:20:33.393" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:33.393" starttime="20190402 07:20:32.287"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:20:33.393" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:33.394" starttime="20190402 07:20:33.393"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:20:33.394" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:33.394" starttime="20190402 07:20:33.394"></status>
</kw>
<msg timestamp="20190402 07:20:33.394" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:33.394" starttime="20190402 07:20:33.393"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:20:33.397" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:20:33.397" starttime="20190402 07:20:33.394"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:20:33.398" level="INFO">0</msg>
<msg timestamp="20190402 07:20:33.398" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:33.398" starttime="20190402 07:20:33.397"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:20:33.398" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:20:33.398" starttime="20190402 07:20:33.398"></status>
</kw>
<msg timestamp="20190402 07:20:33.399" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:33.399" starttime="20190402 07:20:33.394"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:33.399" starttime="20190402 07:20:33.399"></status>
</kw>
<status status="PASS" endtime="20190402 07:20:33.399" starttime="20190402 07:20:33.399"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:33.400" starttime="20190402 07:20:33.400"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:20:33.400" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:20:33.400" starttime="20190402 07:20:33.400"></status>
</kw>
<msg timestamp="20190402 07:20:33.400" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:20:33.400" starttime="20190402 07:20:32.274"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:20:33.401" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:20:33.401" starttime="20190402 07:20:33.401"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:20:33.402" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:20:33.402" starttime="20190402 07:20:33.401"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:33.402" starttime="20190402 07:20:33.401"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:33.402" starttime="20190402 07:20:32.270"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:20:38.405" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:38.405" starttime="20190402 07:20:38.404"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:38.408" starttime="20190402 07:20:38.407"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:20:38.408" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:20:38.408" starttime="20190402 07:20:38.408"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:38.409" starttime="20190402 07:20:38.408"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:38.409" starttime="20190402 07:20:38.409"></status>
</kw>
<msg timestamp="20190402 07:20:38.409" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:20:38.409" starttime="20190402 07:20:38.408"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:20:38.409" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:38.410" starttime="20190402 07:20:38.409"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:20:38.413" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:38.413" starttime="20190402 07:20:38.410"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:20:39.736" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:20:39.736" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:39.737" starttime="20190402 07:20:38.413"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:20:39.737" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:39.737" starttime="20190402 07:20:39.737"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:20:39.738" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:39.738" starttime="20190402 07:20:39.737"></status>
</kw>
<msg timestamp="20190402 07:20:39.738" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:39.738" starttime="20190402 07:20:39.737"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:20:39.741" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:20:39.741" starttime="20190402 07:20:39.738"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:20:39.754" level="INFO">0</msg>
<msg timestamp="20190402 07:20:39.754" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:39.754" starttime="20190402 07:20:39.741"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:20:39.754" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:20:39.754" starttime="20190402 07:20:39.754"></status>
</kw>
<msg timestamp="20190402 07:20:39.755" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:39.755" starttime="20190402 07:20:39.738"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:39.755" starttime="20190402 07:20:39.755"></status>
</kw>
<status status="PASS" endtime="20190402 07:20:39.756" starttime="20190402 07:20:39.755"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:39.756" starttime="20190402 07:20:39.756"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:20:39.756" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:20:39.756" starttime="20190402 07:20:39.756"></status>
</kw>
<msg timestamp="20190402 07:20:39.756" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:20:39.756" starttime="20190402 07:20:38.406"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:20:39.757" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:20:39.757" starttime="20190402 07:20:39.757"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:20:39.757" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:20:39.758" starttime="20190402 07:20:39.757"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:39.758" starttime="20190402 07:20:39.757"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:39.758" starttime="20190402 07:20:38.402"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:20:44.761" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:44.761" starttime="20190402 07:20:44.760"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:44.764" starttime="20190402 07:20:44.763"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:20:44.767" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:20:44.767" starttime="20190402 07:20:44.765"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:44.768" starttime="20190402 07:20:44.767"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:44.769" starttime="20190402 07:20:44.769"></status>
</kw>
<msg timestamp="20190402 07:20:44.770" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:20:44.770" starttime="20190402 07:20:44.764"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:20:44.771" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:44.772" starttime="20190402 07:20:44.771"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:20:44.796" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:44.797" starttime="20190402 07:20:44.772"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:20:45.929" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:20:45.929" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:45.929" starttime="20190402 07:20:44.797"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:20:45.930" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:45.930" starttime="20190402 07:20:45.930"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:20:45.930" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:45.930" starttime="20190402 07:20:45.930"></status>
</kw>
<msg timestamp="20190402 07:20:45.930" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:45.930" starttime="20190402 07:20:45.929"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:20:45.932" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:20:45.932" starttime="20190402 07:20:45.931"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:20:45.932" level="INFO">0</msg>
<msg timestamp="20190402 07:20:45.933" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:45.933" starttime="20190402 07:20:45.932"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:20:45.933" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:20:45.933" starttime="20190402 07:20:45.933"></status>
</kw>
<msg timestamp="20190402 07:20:45.933" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:45.933" starttime="20190402 07:20:45.930"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:45.934" starttime="20190402 07:20:45.934"></status>
</kw>
<status status="PASS" endtime="20190402 07:20:45.934" starttime="20190402 07:20:45.933"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:45.934" starttime="20190402 07:20:45.934"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:20:45.934" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:20:45.935" starttime="20190402 07:20:45.934"></status>
</kw>
<msg timestamp="20190402 07:20:45.935" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:20:45.935" starttime="20190402 07:20:44.761"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:20:45.935" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:20:45.935" starttime="20190402 07:20:45.935"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:20:45.936" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:20:45.936" starttime="20190402 07:20:45.936"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:45.936" starttime="20190402 07:20:45.935"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:45.936" starttime="20190402 07:20:44.758"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:20:50.938" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:50.938" starttime="20190402 07:20:50.937"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:50.940" starttime="20190402 07:20:50.939"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:20:50.941" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:20:50.941" starttime="20190402 07:20:50.940"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:50.942" starttime="20190402 07:20:50.942"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:50.942" starttime="20190402 07:20:50.942"></status>
</kw>
<msg timestamp="20190402 07:20:50.943" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:20:50.943" starttime="20190402 07:20:50.940"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:20:50.943" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:50.943" starttime="20190402 07:20:50.943"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:20:50.952" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:50.952" starttime="20190402 07:20:50.943"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:20:52.094" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:20:52.094" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:52.094" starttime="20190402 07:20:50.952"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:20:52.095" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:52.095" starttime="20190402 07:20:52.095"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:20:52.095" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:52.095" starttime="20190402 07:20:52.095"></status>
</kw>
<msg timestamp="20190402 07:20:52.095" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:52.095" starttime="20190402 07:20:52.094"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:20:52.097" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:20:52.097" starttime="20190402 07:20:52.096"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:20:52.098" level="INFO">0</msg>
<msg timestamp="20190402 07:20:52.098" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:52.098" starttime="20190402 07:20:52.097"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:20:52.098" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:20:52.098" starttime="20190402 07:20:52.098"></status>
</kw>
<msg timestamp="20190402 07:20:52.098" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:52.098" starttime="20190402 07:20:52.096"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:52.099" starttime="20190402 07:20:52.099"></status>
</kw>
<status status="PASS" endtime="20190402 07:20:52.099" starttime="20190402 07:20:52.098"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:52.099" starttime="20190402 07:20:52.099"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:20:52.100" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:20:52.100" starttime="20190402 07:20:52.099"></status>
</kw>
<msg timestamp="20190402 07:20:52.100" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:20:52.100" starttime="20190402 07:20:50.938"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:20:52.100" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:20:52.100" starttime="20190402 07:20:52.100"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:20:52.101" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:20:52.101" starttime="20190402 07:20:52.101"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:52.101" starttime="20190402 07:20:52.100"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:52.101" starttime="20190402 07:20:50.937"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:20:57.104" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:57.104" starttime="20190402 07:20:57.103"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:57.107" starttime="20190402 07:20:57.106"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:20:57.110" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:20:57.110" starttime="20190402 07:20:57.108"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:57.112" starttime="20190402 07:20:57.111"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:57.113" starttime="20190402 07:20:57.112"></status>
</kw>
<msg timestamp="20190402 07:20:57.114" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:20:57.114" starttime="20190402 07:20:57.108"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:20:57.114" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:57.115" starttime="20190402 07:20:57.114"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:20:57.144" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:20:57.145" starttime="20190402 07:20:57.115"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:20:58.272" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:20:58.273" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:58.273" starttime="20190402 07:20:57.145"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:20:58.274" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:20:58.274" starttime="20190402 07:20:58.273"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:20:58.274" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:58.274" starttime="20190402 07:20:58.274"></status>
</kw>
<msg timestamp="20190402 07:20:58.274" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:20:58.274" starttime="20190402 07:20:58.273"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:20:58.276" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:20:58.276" starttime="20190402 07:20:58.274"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:20:58.276" level="INFO">0</msg>
<msg timestamp="20190402 07:20:58.276" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:58.276" starttime="20190402 07:20:58.276"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:20:58.277" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:20:58.277" starttime="20190402 07:20:58.277"></status>
</kw>
<msg timestamp="20190402 07:20:58.277" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:20:58.277" starttime="20190402 07:20:58.274"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:58.278" starttime="20190402 07:20:58.277"></status>
</kw>
<status status="PASS" endtime="20190402 07:20:58.278" starttime="20190402 07:20:58.277"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:20:58.278" starttime="20190402 07:20:58.278"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:20:58.278" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:20:58.278" starttime="20190402 07:20:58.278"></status>
</kw>
<msg timestamp="20190402 07:20:58.279" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:20:58.279" starttime="20190402 07:20:57.105"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:20:58.279" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:20:58.279" starttime="20190402 07:20:58.279"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:20:58.280" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:20:58.280" starttime="20190402 07:20:58.279"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:58.280" starttime="20190402 07:20:58.279"></status>
</kw>
<status status="FAIL" endtime="20190402 07:20:58.280" starttime="20190402 07:20:57.102"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:21:03.283" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:03.283" starttime="20190402 07:21:03.282"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:03.286" starttime="20190402 07:21:03.285"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:21:03.287" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:21:03.287" starttime="20190402 07:21:03.286"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:03.287" starttime="20190402 07:21:03.287"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:03.287" starttime="20190402 07:21:03.287"></status>
</kw>
<msg timestamp="20190402 07:21:03.288" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:21:03.288" starttime="20190402 07:21:03.286"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:21:03.288" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:03.288" starttime="20190402 07:21:03.288"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:21:03.297" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:03.297" starttime="20190402 07:21:03.288"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:21:04.360" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:21:04.360" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:04.360" starttime="20190402 07:21:03.297"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:21:04.361" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:04.361" starttime="20190402 07:21:04.360"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:21:04.361" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:04.361" starttime="20190402 07:21:04.361"></status>
</kw>
<msg timestamp="20190402 07:21:04.361" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:04.361" starttime="20190402 07:21:04.360"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:21:04.363" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:21:04.363" starttime="20190402 07:21:04.362"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:21:04.367" level="INFO">0</msg>
<msg timestamp="20190402 07:21:04.367" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:04.367" starttime="20190402 07:21:04.363"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:21:04.367" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:21:04.367" starttime="20190402 07:21:04.367"></status>
</kw>
<msg timestamp="20190402 07:21:04.368" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:04.368" starttime="20190402 07:21:04.362"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:04.368" starttime="20190402 07:21:04.368"></status>
</kw>
<status status="PASS" endtime="20190402 07:21:04.368" starttime="20190402 07:21:04.368"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:04.369" starttime="20190402 07:21:04.369"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:21:04.369" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:21:04.369" starttime="20190402 07:21:04.369"></status>
</kw>
<msg timestamp="20190402 07:21:04.369" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:21:04.369" starttime="20190402 07:21:03.284"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:21:04.370" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:21:04.370" starttime="20190402 07:21:04.369"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:21:04.370" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:21:04.370" starttime="20190402 07:21:04.370"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:04.370" starttime="20190402 07:21:04.370"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:04.371" starttime="20190402 07:21:03.281"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:21:09.374" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:09.374" starttime="20190402 07:21:09.373"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:09.376" starttime="20190402 07:21:09.376"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:21:09.377" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:21:09.377" starttime="20190402 07:21:09.377"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:09.377" starttime="20190402 07:21:09.377"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:09.378" starttime="20190402 07:21:09.377"></status>
</kw>
<msg timestamp="20190402 07:21:09.378" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:21:09.378" starttime="20190402 07:21:09.376"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:21:09.378" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:09.378" starttime="20190402 07:21:09.378"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:21:09.386" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:09.386" starttime="20190402 07:21:09.378"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:21:10.493" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:21:10.493" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:10.493" starttime="20190402 07:21:09.386"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:21:10.494" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:10.494" starttime="20190402 07:21:10.493"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:21:10.494" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:10.494" starttime="20190402 07:21:10.494"></status>
</kw>
<msg timestamp="20190402 07:21:10.494" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:10.494" starttime="20190402 07:21:10.493"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:21:10.496" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:21:10.496" starttime="20190402 07:21:10.494"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:21:10.496" level="INFO">0</msg>
<msg timestamp="20190402 07:21:10.497" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:10.497" starttime="20190402 07:21:10.496"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:21:10.497" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:21:10.497" starttime="20190402 07:21:10.497"></status>
</kw>
<msg timestamp="20190402 07:21:10.497" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:10.497" starttime="20190402 07:21:10.494"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:10.498" starttime="20190402 07:21:10.498"></status>
</kw>
<status status="PASS" endtime="20190402 07:21:10.498" starttime="20190402 07:21:10.497"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:10.498" starttime="20190402 07:21:10.498"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:21:10.498" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:21:10.498" starttime="20190402 07:21:10.498"></status>
</kw>
<msg timestamp="20190402 07:21:10.499" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:21:10.499" starttime="20190402 07:21:09.374"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:21:10.499" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:21:10.499" starttime="20190402 07:21:10.499"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:21:10.500" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:21:10.500" starttime="20190402 07:21:10.500"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:10.500" starttime="20190402 07:21:10.499"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:10.500" starttime="20190402 07:21:09.371"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:21:15.503" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:15.503" starttime="20190402 07:21:15.502"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:15.506" starttime="20190402 07:21:15.505"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:21:15.507" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:21:15.507" starttime="20190402 07:21:15.506"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:15.507" starttime="20190402 07:21:15.507"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:15.507" starttime="20190402 07:21:15.507"></status>
</kw>
<msg timestamp="20190402 07:21:15.508" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:21:15.508" starttime="20190402 07:21:15.506"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:21:15.508" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:15.508" starttime="20190402 07:21:15.508"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:21:15.515" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:15.515" starttime="20190402 07:21:15.508"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:21:16.598" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:21:16.599" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:16.599" starttime="20190402 07:21:15.515"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:21:16.599" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:16.599" starttime="20190402 07:21:16.599"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:21:16.600" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:16.600" starttime="20190402 07:21:16.600"></status>
</kw>
<msg timestamp="20190402 07:21:16.600" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:16.600" starttime="20190402 07:21:16.599"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:21:16.602" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:21:16.602" starttime="20190402 07:21:16.600"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:21:16.602" level="INFO">0</msg>
<msg timestamp="20190402 07:21:16.602" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:16.602" starttime="20190402 07:21:16.602"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:21:16.603" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:21:16.603" starttime="20190402 07:21:16.602"></status>
</kw>
<msg timestamp="20190402 07:21:16.603" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:16.603" starttime="20190402 07:21:16.600"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:16.604" starttime="20190402 07:21:16.603"></status>
</kw>
<status status="PASS" endtime="20190402 07:21:16.604" starttime="20190402 07:21:16.603"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:16.604" starttime="20190402 07:21:16.604"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:21:16.604" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:21:16.604" starttime="20190402 07:21:16.604"></status>
</kw>
<msg timestamp="20190402 07:21:16.605" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:21:16.605" starttime="20190402 07:21:15.504"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:21:16.605" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:21:16.605" starttime="20190402 07:21:16.605"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:21:16.606" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:21:16.606" starttime="20190402 07:21:16.606"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:16.606" starttime="20190402 07:21:16.605"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:16.606" starttime="20190402 07:21:15.501"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:21:21.609" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:21.609" starttime="20190402 07:21:21.608"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:21.612" starttime="20190402 07:21:21.611"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:21:21.615" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:21:21.615" starttime="20190402 07:21:21.614"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:21.617" starttime="20190402 07:21:21.616"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:21.618" starttime="20190402 07:21:21.617"></status>
</kw>
<msg timestamp="20190402 07:21:21.619" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:21:21.619" starttime="20190402 07:21:21.613"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:21:21.620" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:21.620" starttime="20190402 07:21:21.619"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:21:21.638" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:21.638" starttime="20190402 07:21:21.620"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:21:22.745" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:21:22.745" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:22.745" starttime="20190402 07:21:21.639"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:21:22.746" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:22.746" starttime="20190402 07:21:22.746"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:21:22.746" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:22.746" starttime="20190402 07:21:22.746"></status>
</kw>
<msg timestamp="20190402 07:21:22.746" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:22.746" starttime="20190402 07:21:22.745"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:21:22.748" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:21:22.748" starttime="20190402 07:21:22.747"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:21:22.749" level="INFO">0</msg>
<msg timestamp="20190402 07:21:22.749" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:22.749" starttime="20190402 07:21:22.748"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:21:22.749" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:21:22.749" starttime="20190402 07:21:22.749"></status>
</kw>
<msg timestamp="20190402 07:21:22.749" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:22.749" starttime="20190402 07:21:22.747"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:22.750" starttime="20190402 07:21:22.750"></status>
</kw>
<status status="PASS" endtime="20190402 07:21:22.750" starttime="20190402 07:21:22.749"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:22.750" starttime="20190402 07:21:22.750"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:21:22.751" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:21:22.751" starttime="20190402 07:21:22.751"></status>
</kw>
<msg timestamp="20190402 07:21:22.751" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:21:22.751" starttime="20190402 07:21:21.610"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:21:22.752" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:21:22.752" starttime="20190402 07:21:22.751"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:21:22.752" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:21:22.752" starttime="20190402 07:21:22.752"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:22.752" starttime="20190402 07:21:22.752"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:22.752" starttime="20190402 07:21:21.607"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:21:27.755" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:27.756" starttime="20190402 07:21:27.755"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:27.758" starttime="20190402 07:21:27.758"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:21:27.759" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:21:27.759" starttime="20190402 07:21:27.758"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:27.759" starttime="20190402 07:21:27.759"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:27.760" starttime="20190402 07:21:27.759"></status>
</kw>
<msg timestamp="20190402 07:21:27.760" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:21:27.760" starttime="20190402 07:21:27.758"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:21:27.760" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:27.760" starttime="20190402 07:21:27.760"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:21:27.770" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:27.770" starttime="20190402 07:21:27.760"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:21:28.872" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:21:28.872" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:28.872" starttime="20190402 07:21:27.770"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:21:28.873" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:28.873" starttime="20190402 07:21:28.873"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:21:28.873" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:28.873" starttime="20190402 07:21:28.873"></status>
</kw>
<msg timestamp="20190402 07:21:28.873" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:28.873" starttime="20190402 07:21:28.872"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:21:28.875" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:21:28.875" starttime="20190402 07:21:28.874"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:21:28.876" level="INFO">0</msg>
<msg timestamp="20190402 07:21:28.876" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:28.876" starttime="20190402 07:21:28.876"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:21:28.876" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:21:28.876" starttime="20190402 07:21:28.876"></status>
</kw>
<msg timestamp="20190402 07:21:28.876" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:28.876" starttime="20190402 07:21:28.874"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:28.877" starttime="20190402 07:21:28.877"></status>
</kw>
<status status="PASS" endtime="20190402 07:21:28.877" starttime="20190402 07:21:28.876"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:28.877" starttime="20190402 07:21:28.877"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:21:28.878" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:21:28.878" starttime="20190402 07:21:28.878"></status>
</kw>
<msg timestamp="20190402 07:21:28.878" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:21:28.878" starttime="20190402 07:21:27.756"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:21:28.878" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:21:28.878" starttime="20190402 07:21:28.878"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:21:28.879" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:21:28.879" starttime="20190402 07:21:28.879"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:28.879" starttime="20190402 07:21:28.879"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:28.879" starttime="20190402 07:21:27.753"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:21:33.883" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:33.883" starttime="20190402 07:21:33.882"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:33.885" starttime="20190402 07:21:33.885"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:21:33.886" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:21:33.886" starttime="20190402 07:21:33.885"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:33.886" starttime="20190402 07:21:33.886"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:33.887" starttime="20190402 07:21:33.886"></status>
</kw>
<msg timestamp="20190402 07:21:33.887" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:21:33.887" starttime="20190402 07:21:33.885"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:21:33.887" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:33.887" starttime="20190402 07:21:33.887"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:21:33.896" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:33.896" starttime="20190402 07:21:33.887"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:21:35.021" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:21:35.021" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:35.021" starttime="20190402 07:21:33.896"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:21:35.022" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:35.022" starttime="20190402 07:21:35.022"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:21:35.022" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:35.022" starttime="20190402 07:21:35.022"></status>
</kw>
<msg timestamp="20190402 07:21:35.022" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:35.022" starttime="20190402 07:21:35.021"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:21:35.024" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:21:35.024" starttime="20190402 07:21:35.023"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:21:35.024" level="INFO">0</msg>
<msg timestamp="20190402 07:21:35.025" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:35.025" starttime="20190402 07:21:35.024"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:21:35.025" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:21:35.025" starttime="20190402 07:21:35.025"></status>
</kw>
<msg timestamp="20190402 07:21:35.025" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:35.025" starttime="20190402 07:21:35.022"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:35.026" starttime="20190402 07:21:35.026"></status>
</kw>
<status status="PASS" endtime="20190402 07:21:35.026" starttime="20190402 07:21:35.025"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:35.026" starttime="20190402 07:21:35.026"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:21:35.026" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:21:35.027" starttime="20190402 07:21:35.026"></status>
</kw>
<msg timestamp="20190402 07:21:35.027" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:21:35.027" starttime="20190402 07:21:33.883"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:21:35.027" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:21:35.027" starttime="20190402 07:21:35.027"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:21:35.028" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:21:35.028" starttime="20190402 07:21:35.028"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:35.028" starttime="20190402 07:21:35.027"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:35.028" starttime="20190402 07:21:33.880"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:21:40.031" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:40.032" starttime="20190402 07:21:40.030"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:40.034" starttime="20190402 07:21:40.033"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:21:40.037" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:21:40.037" starttime="20190402 07:21:40.036"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:40.039" starttime="20190402 07:21:40.038"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:40.040" starttime="20190402 07:21:40.039"></status>
</kw>
<msg timestamp="20190402 07:21:40.041" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:21:40.041" starttime="20190402 07:21:40.035"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:21:40.042" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:40.042" starttime="20190402 07:21:40.041"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:21:40.069" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:40.069" starttime="20190402 07:21:40.042"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:21:41.662" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:21:41.663" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:41.663" starttime="20190402 07:21:40.069"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:21:41.663" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:41.663" starttime="20190402 07:21:41.663"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:21:41.664" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:41.664" starttime="20190402 07:21:41.664"></status>
</kw>
<msg timestamp="20190402 07:21:41.664" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:41.664" starttime="20190402 07:21:41.663"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:21:41.666" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:21:41.666" starttime="20190402 07:21:41.664"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:21:41.670" level="INFO">0</msg>
<msg timestamp="20190402 07:21:41.670" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:41.670" starttime="20190402 07:21:41.666"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:21:41.671" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:21:41.671" starttime="20190402 07:21:41.671"></status>
</kw>
<msg timestamp="20190402 07:21:41.671" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:41.671" starttime="20190402 07:21:41.664"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:41.672" starttime="20190402 07:21:41.672"></status>
</kw>
<status status="PASS" endtime="20190402 07:21:41.672" starttime="20190402 07:21:41.671"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:41.672" starttime="20190402 07:21:41.672"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:21:41.672" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:21:41.673" starttime="20190402 07:21:41.672"></status>
</kw>
<msg timestamp="20190402 07:21:41.673" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:21:41.673" starttime="20190402 07:21:40.032"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:21:41.673" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:21:41.673" starttime="20190402 07:21:41.673"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:21:41.674" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:21:41.674" starttime="20190402 07:21:41.674"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:41.674" starttime="20190402 07:21:41.673"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:41.675" starttime="20190402 07:21:40.029"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:21:46.677" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:46.678" starttime="20190402 07:21:46.677"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:46.680" starttime="20190402 07:21:46.679"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:21:46.681" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:21:46.681" starttime="20190402 07:21:46.680"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:46.681" starttime="20190402 07:21:46.681"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:46.681" starttime="20190402 07:21:46.681"></status>
</kw>
<msg timestamp="20190402 07:21:46.682" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:21:46.682" starttime="20190402 07:21:46.680"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:21:46.682" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:46.682" starttime="20190402 07:21:46.682"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:21:46.690" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:46.691" starttime="20190402 07:21:46.682"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:21:47.954" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:21:47.955" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:47.955" starttime="20190402 07:21:46.691"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:21:47.956" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:47.956" starttime="20190402 07:21:47.955"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:21:47.956" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:47.956" starttime="20190402 07:21:47.956"></status>
</kw>
<msg timestamp="20190402 07:21:47.956" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:47.956" starttime="20190402 07:21:47.955"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:21:47.958" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:21:47.958" starttime="20190402 07:21:47.956"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:21:47.959" level="INFO">0</msg>
<msg timestamp="20190402 07:21:47.959" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:47.959" starttime="20190402 07:21:47.958"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:21:47.959" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:21:47.959" starttime="20190402 07:21:47.959"></status>
</kw>
<msg timestamp="20190402 07:21:47.959" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:47.959" starttime="20190402 07:21:47.956"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:47.960" starttime="20190402 07:21:47.960"></status>
</kw>
<status status="PASS" endtime="20190402 07:21:47.960" starttime="20190402 07:21:47.959"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:47.960" starttime="20190402 07:21:47.960"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:21:47.960" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:21:47.961" starttime="20190402 07:21:47.960"></status>
</kw>
<msg timestamp="20190402 07:21:47.961" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:21:47.961" starttime="20190402 07:21:46.678"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:21:47.961" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:21:47.961" starttime="20190402 07:21:47.961"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:21:47.962" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:21:47.962" starttime="20190402 07:21:47.962"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:47.962" starttime="20190402 07:21:47.961"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:47.962" starttime="20190402 07:21:46.675"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:21:52.966" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:52.966" starttime="20190402 07:21:52.964"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:52.968" starttime="20190402 07:21:52.968"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:21:52.969" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:21:52.969" starttime="20190402 07:21:52.969"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:52.969" starttime="20190402 07:21:52.969"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:52.970" starttime="20190402 07:21:52.969"></status>
</kw>
<msg timestamp="20190402 07:21:52.970" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:21:52.970" starttime="20190402 07:21:52.968"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:21:52.970" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:52.970" starttime="20190402 07:21:52.970"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:21:52.978" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:52.978" starttime="20190402 07:21:52.970"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:21:54.305" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:21:54.305" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:54.305" starttime="20190402 07:21:52.978"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:21:54.306" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:54.306" starttime="20190402 07:21:54.305"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:21:54.306" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:54.306" starttime="20190402 07:21:54.306"></status>
</kw>
<msg timestamp="20190402 07:21:54.306" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:21:54.306" starttime="20190402 07:21:54.305"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:21:54.308" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:21:54.308" starttime="20190402 07:21:54.307"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:21:54.308" level="INFO">0</msg>
<msg timestamp="20190402 07:21:54.308" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:54.308" starttime="20190402 07:21:54.308"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:21:54.309" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:21:54.309" starttime="20190402 07:21:54.308"></status>
</kw>
<msg timestamp="20190402 07:21:54.309" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:21:54.309" starttime="20190402 07:21:54.306"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:54.309" starttime="20190402 07:21:54.309"></status>
</kw>
<status status="PASS" endtime="20190402 07:21:54.310" starttime="20190402 07:21:54.309"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:54.310" starttime="20190402 07:21:54.310"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:21:54.310" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:21:54.310" starttime="20190402 07:21:54.310"></status>
</kw>
<msg timestamp="20190402 07:21:54.310" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:21:54.310" starttime="20190402 07:21:52.967"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:21:54.311" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:21:54.311" starttime="20190402 07:21:54.311"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:21:54.311" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:21:54.312" starttime="20190402 07:21:54.311"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:54.312" starttime="20190402 07:21:54.311"></status>
</kw>
<status status="FAIL" endtime="20190402 07:21:54.312" starttime="20190402 07:21:52.963"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:21:59.314" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:59.315" starttime="20190402 07:21:59.314"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:59.317" starttime="20190402 07:21:59.316"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:21:59.318" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:21:59.318" starttime="20190402 07:21:59.318"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:59.318" starttime="20190402 07:21:59.318"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:21:59.319" starttime="20190402 07:21:59.318"></status>
</kw>
<msg timestamp="20190402 07:21:59.319" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:21:59.319" starttime="20190402 07:21:59.317"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:21:59.319" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:21:59.319" starttime="20190402 07:21:59.319"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:21:59.327" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:21:59.327" starttime="20190402 07:21:59.319"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:22:00.491" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:22:00.491" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:00.491" starttime="20190402 07:21:59.327"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:22:00.492" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:00.492" starttime="20190402 07:22:00.492"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:22:00.492" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:00.492" starttime="20190402 07:22:00.492"></status>
</kw>
<msg timestamp="20190402 07:22:00.492" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:00.492" starttime="20190402 07:22:00.491"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:22:00.494" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:22:00.494" starttime="20190402 07:22:00.493"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:22:00.495" level="INFO">0</msg>
<msg timestamp="20190402 07:22:00.495" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:00.495" starttime="20190402 07:22:00.495"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:22:00.495" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:22:00.495" starttime="20190402 07:22:00.495"></status>
</kw>
<msg timestamp="20190402 07:22:00.495" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:00.496" starttime="20190402 07:22:00.492"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:00.496" starttime="20190402 07:22:00.496"></status>
</kw>
<status status="PASS" endtime="20190402 07:22:00.496" starttime="20190402 07:22:00.496"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:00.497" starttime="20190402 07:22:00.497"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:22:00.497" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:22:00.497" starttime="20190402 07:22:00.497"></status>
</kw>
<msg timestamp="20190402 07:22:00.497" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:22:00.497" starttime="20190402 07:21:59.315"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:22:00.498" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:22:00.498" starttime="20190402 07:22:00.497"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:22:00.498" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:22:00.498" starttime="20190402 07:22:00.498"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:00.498" starttime="20190402 07:22:00.498"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:00.499" starttime="20190402 07:21:59.312"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:22:05.502" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:05.502" starttime="20190402 07:22:05.501"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:05.505" starttime="20190402 07:22:05.504"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:22:05.508" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:22:05.509" starttime="20190402 07:22:05.506"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:05.510" starttime="20190402 07:22:05.509"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:05.511" starttime="20190402 07:22:05.511"></status>
</kw>
<msg timestamp="20190402 07:22:05.513" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:22:05.513" starttime="20190402 07:22:05.505"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:22:05.515" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:05.515" starttime="20190402 07:22:05.514"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:22:05.540" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:05.540" starttime="20190402 07:22:05.516"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:22:06.869" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:22:06.869" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:06.869" starttime="20190402 07:22:05.541"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:22:06.870" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:06.870" starttime="20190402 07:22:06.870"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:22:06.870" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:06.870" starttime="20190402 07:22:06.870"></status>
</kw>
<msg timestamp="20190402 07:22:06.870" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:06.870" starttime="20190402 07:22:06.869"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:22:06.872" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:22:06.872" starttime="20190402 07:22:06.871"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:22:06.873" level="INFO">0</msg>
<msg timestamp="20190402 07:22:06.873" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:06.873" starttime="20190402 07:22:06.873"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:22:06.873" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:22:06.873" starttime="20190402 07:22:06.873"></status>
</kw>
<msg timestamp="20190402 07:22:06.873" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:06.873" starttime="20190402 07:22:06.870"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:06.874" starttime="20190402 07:22:06.874"></status>
</kw>
<status status="PASS" endtime="20190402 07:22:06.874" starttime="20190402 07:22:06.873"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:06.875" starttime="20190402 07:22:06.874"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:22:06.875" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:22:06.875" starttime="20190402 07:22:06.875"></status>
</kw>
<msg timestamp="20190402 07:22:06.875" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:22:06.875" starttime="20190402 07:22:05.502"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:22:06.876" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:22:06.876" starttime="20190402 07:22:06.875"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:22:06.876" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:22:06.876" starttime="20190402 07:22:06.876"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:06.876" starttime="20190402 07:22:06.876"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:06.876" starttime="20190402 07:22:05.499"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:22:11.879" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:11.879" starttime="20190402 07:22:11.878"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:11.882" starttime="20190402 07:22:11.881"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:22:11.883" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:22:11.883" starttime="20190402 07:22:11.882"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:11.883" starttime="20190402 07:22:11.883"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:11.883" starttime="20190402 07:22:11.883"></status>
</kw>
<msg timestamp="20190402 07:22:11.884" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:22:11.884" starttime="20190402 07:22:11.882"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:22:11.884" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:11.884" starttime="20190402 07:22:11.884"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:22:11.894" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:11.894" starttime="20190402 07:22:11.884"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:22:12.941" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:22:12.942" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:12.942" starttime="20190402 07:22:11.894"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:22:12.942" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:12.942" starttime="20190402 07:22:12.942"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:22:12.943" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:12.943" starttime="20190402 07:22:12.943"></status>
</kw>
<msg timestamp="20190402 07:22:12.943" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:12.943" starttime="20190402 07:22:12.942"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:22:12.945" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:22:12.945" starttime="20190402 07:22:12.943"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:22:12.945" level="INFO">0</msg>
<msg timestamp="20190402 07:22:12.945" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:12.945" starttime="20190402 07:22:12.945"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:22:12.946" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:22:12.946" starttime="20190402 07:22:12.946"></status>
</kw>
<msg timestamp="20190402 07:22:12.946" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:12.946" starttime="20190402 07:22:12.943"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:12.947" starttime="20190402 07:22:12.946"></status>
</kw>
<status status="PASS" endtime="20190402 07:22:12.947" starttime="20190402 07:22:12.946"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:12.947" starttime="20190402 07:22:12.947"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:22:12.947" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:22:12.947" starttime="20190402 07:22:12.947"></status>
</kw>
<msg timestamp="20190402 07:22:12.948" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:22:12.948" starttime="20190402 07:22:11.880"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:22:12.948" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:22:12.948" starttime="20190402 07:22:12.948"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:22:12.949" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:22:12.949" starttime="20190402 07:22:12.948"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:12.949" starttime="20190402 07:22:12.948"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:12.949" starttime="20190402 07:22:11.877"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:22:17.951" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:17.951" starttime="20190402 07:22:17.950"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:17.952" starttime="20190402 07:22:17.952"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:22:17.954" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:22:17.954" starttime="20190402 07:22:17.953"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:17.954" starttime="20190402 07:22:17.954"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:17.955" starttime="20190402 07:22:17.955"></status>
</kw>
<msg timestamp="20190402 07:22:17.955" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:22:17.955" starttime="20190402 07:22:17.952"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:22:17.956" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:17.956" starttime="20190402 07:22:17.955"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:22:17.964" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:17.964" starttime="20190402 07:22:17.956"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:22:19.088" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:22:19.089" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:19.089" starttime="20190402 07:22:17.964"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:22:19.090" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:19.090" starttime="20190402 07:22:19.089"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:22:19.090" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:19.090" starttime="20190402 07:22:19.090"></status>
</kw>
<msg timestamp="20190402 07:22:19.090" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:19.090" starttime="20190402 07:22:19.089"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:22:19.092" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:22:19.092" starttime="20190402 07:22:19.091"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:22:19.092" level="INFO">0</msg>
<msg timestamp="20190402 07:22:19.092" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:19.092" starttime="20190402 07:22:19.092"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:22:19.093" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:22:19.093" starttime="20190402 07:22:19.093"></status>
</kw>
<msg timestamp="20190402 07:22:19.093" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:19.093" starttime="20190402 07:22:19.090"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:19.094" starttime="20190402 07:22:19.093"></status>
</kw>
<status status="PASS" endtime="20190402 07:22:19.094" starttime="20190402 07:22:19.093"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:19.094" starttime="20190402 07:22:19.094"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:22:19.094" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:22:19.094" starttime="20190402 07:22:19.094"></status>
</kw>
<msg timestamp="20190402 07:22:19.095" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:22:19.095" starttime="20190402 07:22:17.951"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:22:19.095" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:22:19.095" starttime="20190402 07:22:19.095"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:22:19.096" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:22:19.096" starttime="20190402 07:22:19.095"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:19.096" starttime="20190402 07:22:19.095"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:19.096" starttime="20190402 07:22:17.949"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:22:24.099" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:24.099" starttime="20190402 07:22:24.098"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:24.101" starttime="20190402 07:22:24.101"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:22:24.102" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:22:24.102" starttime="20190402 07:22:24.101"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:24.102" starttime="20190402 07:22:24.102"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:24.103" starttime="20190402 07:22:24.102"></status>
</kw>
<msg timestamp="20190402 07:22:24.103" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:22:24.103" starttime="20190402 07:22:24.101"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:22:24.103" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:24.103" starttime="20190402 07:22:24.103"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:22:24.113" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:24.113" starttime="20190402 07:22:24.103"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:22:25.472" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:22:25.472" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:25.472" starttime="20190402 07:22:24.113"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:22:25.473" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:25.473" starttime="20190402 07:22:25.473"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:22:25.473" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:25.473" starttime="20190402 07:22:25.473"></status>
</kw>
<msg timestamp="20190402 07:22:25.474" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:25.474" starttime="20190402 07:22:25.472"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:22:25.475" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:22:25.475" starttime="20190402 07:22:25.474"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:22:25.476" level="INFO">0</msg>
<msg timestamp="20190402 07:22:25.476" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:25.476" starttime="20190402 07:22:25.475"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:22:25.476" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:22:25.476" starttime="20190402 07:22:25.476"></status>
</kw>
<msg timestamp="20190402 07:22:25.476" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:25.476" starttime="20190402 07:22:25.474"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:25.477" starttime="20190402 07:22:25.477"></status>
</kw>
<status status="PASS" endtime="20190402 07:22:25.477" starttime="20190402 07:22:25.476"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:25.477" starttime="20190402 07:22:25.477"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:22:25.478" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:22:25.478" starttime="20190402 07:22:25.477"></status>
</kw>
<msg timestamp="20190402 07:22:25.478" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:22:25.478" starttime="20190402 07:22:24.099"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:22:25.478" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:22:25.478" starttime="20190402 07:22:25.478"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:22:25.479" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:22:25.479" starttime="20190402 07:22:25.479"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:25.479" starttime="20190402 07:22:25.478"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:25.479" starttime="20190402 07:22:24.096"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:22:30.482" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:30.483" starttime="20190402 07:22:30.481"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:30.485" starttime="20190402 07:22:30.484"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:22:30.486" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:22:30.486" starttime="20190402 07:22:30.485"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:30.486" starttime="20190402 07:22:30.486"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:30.486" starttime="20190402 07:22:30.486"></status>
</kw>
<msg timestamp="20190402 07:22:30.487" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:22:30.487" starttime="20190402 07:22:30.485"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:22:30.487" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:30.487" starttime="20190402 07:22:30.487"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:22:30.500" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:30.500" starttime="20190402 07:22:30.487"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:22:31.651" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:22:31.651" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:31.651" starttime="20190402 07:22:30.500"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:22:31.652" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:31.652" starttime="20190402 07:22:31.652"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:22:31.652" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:31.652" starttime="20190402 07:22:31.652"></status>
</kw>
<msg timestamp="20190402 07:22:31.652" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:31.652" starttime="20190402 07:22:31.651"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:22:31.655" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:22:31.655" starttime="20190402 07:22:31.653"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:22:31.655" level="INFO">0</msg>
<msg timestamp="20190402 07:22:31.655" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:31.655" starttime="20190402 07:22:31.655"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:22:31.656" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:22:31.656" starttime="20190402 07:22:31.655"></status>
</kw>
<msg timestamp="20190402 07:22:31.656" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:31.656" starttime="20190402 07:22:31.653"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:31.657" starttime="20190402 07:22:31.656"></status>
</kw>
<status status="PASS" endtime="20190402 07:22:31.657" starttime="20190402 07:22:31.656"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:31.657" starttime="20190402 07:22:31.657"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:22:31.657" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:22:31.657" starttime="20190402 07:22:31.657"></status>
</kw>
<msg timestamp="20190402 07:22:31.657" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:22:31.658" starttime="20190402 07:22:30.483"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:22:31.658" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:22:31.658" starttime="20190402 07:22:31.658"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:22:31.659" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:22:31.659" starttime="20190402 07:22:31.658"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:31.659" starttime="20190402 07:22:31.658"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:31.659" starttime="20190402 07:22:30.480"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:22:36.662" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:36.662" starttime="20190402 07:22:36.661"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:36.664" starttime="20190402 07:22:36.664"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:22:36.665" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:22:36.665" starttime="20190402 07:22:36.665"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:36.665" starttime="20190402 07:22:36.665"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:36.666" starttime="20190402 07:22:36.665"></status>
</kw>
<msg timestamp="20190402 07:22:36.666" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:22:36.666" starttime="20190402 07:22:36.664"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:22:36.666" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:36.666" starttime="20190402 07:22:36.666"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:22:36.676" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:36.676" starttime="20190402 07:22:36.666"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:22:37.824" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:22:37.824" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:37.824" starttime="20190402 07:22:36.676"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:22:37.825" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:37.825" starttime="20190402 07:22:37.825"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:22:37.825" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:37.825" starttime="20190402 07:22:37.825"></status>
</kw>
<msg timestamp="20190402 07:22:37.826" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:37.826" starttime="20190402 07:22:37.825"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:22:37.827" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:22:37.827" starttime="20190402 07:22:37.826"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:22:37.828" level="INFO">0</msg>
<msg timestamp="20190402 07:22:37.828" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:37.828" starttime="20190402 07:22:37.828"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:22:37.828" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:22:37.828" starttime="20190402 07:22:37.828"></status>
</kw>
<msg timestamp="20190402 07:22:37.828" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:37.828" starttime="20190402 07:22:37.826"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:37.829" starttime="20190402 07:22:37.829"></status>
</kw>
<status status="PASS" endtime="20190402 07:22:37.829" starttime="20190402 07:22:37.829"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:37.830" starttime="20190402 07:22:37.830"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:22:37.830" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:22:37.830" starttime="20190402 07:22:37.830"></status>
</kw>
<msg timestamp="20190402 07:22:37.830" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:22:37.830" starttime="20190402 07:22:36.662"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:22:37.831" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:22:37.831" starttime="20190402 07:22:37.830"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:22:37.831" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:22:37.831" starttime="20190402 07:22:37.831"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:37.832" starttime="20190402 07:22:37.831"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:37.832" starttime="20190402 07:22:36.659"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:22:42.835" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:42.835" starttime="20190402 07:22:42.834"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:42.837" starttime="20190402 07:22:42.837"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:22:42.838" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:22:42.838" starttime="20190402 07:22:42.838"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:42.838" starttime="20190402 07:22:42.838"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:42.839" starttime="20190402 07:22:42.838"></status>
</kw>
<msg timestamp="20190402 07:22:42.839" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:22:42.839" starttime="20190402 07:22:42.837"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:22:42.839" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:42.839" starttime="20190402 07:22:42.839"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:22:42.849" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:42.849" starttime="20190402 07:22:42.839"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:22:43.927" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:22:43.927" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:43.927" starttime="20190402 07:22:42.849"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:22:43.928" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:43.928" starttime="20190402 07:22:43.928"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:22:43.928" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:43.928" starttime="20190402 07:22:43.928"></status>
</kw>
<msg timestamp="20190402 07:22:43.929" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:43.929" starttime="20190402 07:22:43.928"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:22:43.930" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:22:43.930" starttime="20190402 07:22:43.929"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:22:43.931" level="INFO">0</msg>
<msg timestamp="20190402 07:22:43.931" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:43.931" starttime="20190402 07:22:43.931"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:22:43.931" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:22:43.931" starttime="20190402 07:22:43.931"></status>
</kw>
<msg timestamp="20190402 07:22:43.931" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:43.932" starttime="20190402 07:22:43.929"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:43.932" starttime="20190402 07:22:43.932"></status>
</kw>
<status status="PASS" endtime="20190402 07:22:43.932" starttime="20190402 07:22:43.932"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:43.933" starttime="20190402 07:22:43.932"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:22:43.933" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:22:43.933" starttime="20190402 07:22:43.933"></status>
</kw>
<msg timestamp="20190402 07:22:43.933" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:22:43.933" starttime="20190402 07:22:42.836"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:22:43.934" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:22:43.934" starttime="20190402 07:22:43.933"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:22:43.934" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:22:43.935" starttime="20190402 07:22:43.934"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:43.935" starttime="20190402 07:22:43.934"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:43.935" starttime="20190402 07:22:42.832"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:22:48.938" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:48.938" starttime="20190402 07:22:48.937"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:48.940" starttime="20190402 07:22:48.940"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:22:48.941" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:22:48.941" starttime="20190402 07:22:48.940"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:48.941" starttime="20190402 07:22:48.941"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:48.941" starttime="20190402 07:22:48.941"></status>
</kw>
<msg timestamp="20190402 07:22:48.942" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:22:48.942" starttime="20190402 07:22:48.940"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:22:48.942" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:48.942" starttime="20190402 07:22:48.942"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:22:48.952" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:48.952" starttime="20190402 07:22:48.942"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:22:50.112" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:22:50.113" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:50.113" starttime="20190402 07:22:48.952"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:22:50.113" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:50.113" starttime="20190402 07:22:50.113"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:22:50.114" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:50.114" starttime="20190402 07:22:50.114"></status>
</kw>
<msg timestamp="20190402 07:22:50.114" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:50.114" starttime="20190402 07:22:50.113"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:22:50.116" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:22:50.116" starttime="20190402 07:22:50.114"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:22:50.116" level="INFO">0</msg>
<msg timestamp="20190402 07:22:50.116" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:50.116" starttime="20190402 07:22:50.116"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:22:50.117" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:22:50.117" starttime="20190402 07:22:50.117"></status>
</kw>
<msg timestamp="20190402 07:22:50.117" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:50.117" starttime="20190402 07:22:50.114"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:50.118" starttime="20190402 07:22:50.117"></status>
</kw>
<status status="PASS" endtime="20190402 07:22:50.118" starttime="20190402 07:22:50.117"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:50.118" starttime="20190402 07:22:50.118"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:22:50.118" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:22:50.118" starttime="20190402 07:22:50.118"></status>
</kw>
<msg timestamp="20190402 07:22:50.119" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:22:50.119" starttime="20190402 07:22:48.938"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:22:50.119" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:22:50.119" starttime="20190402 07:22:50.119"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:22:50.120" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:22:50.120" starttime="20190402 07:22:50.119"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:50.120" starttime="20190402 07:22:50.119"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:50.120" starttime="20190402 07:22:48.935"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:22:55.123" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:55.123" starttime="20190402 07:22:55.122"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:55.125" starttime="20190402 07:22:55.124"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:22:55.127" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:22:55.127" starttime="20190402 07:22:55.126"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:55.128" starttime="20190402 07:22:55.128"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:55.130" starttime="20190402 07:22:55.129"></status>
</kw>
<msg timestamp="20190402 07:22:55.131" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:22:55.131" starttime="20190402 07:22:55.125"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:22:55.131" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:55.132" starttime="20190402 07:22:55.131"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:22:55.154" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:22:55.154" starttime="20190402 07:22:55.132"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:22:56.236" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:22:56.237" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:56.237" starttime="20190402 07:22:55.154"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:22:56.237" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:22:56.237" starttime="20190402 07:22:56.237"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:22:56.238" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:56.238" starttime="20190402 07:22:56.237"></status>
</kw>
<msg timestamp="20190402 07:22:56.238" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:22:56.238" starttime="20190402 07:22:56.237"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:22:56.240" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:22:56.240" starttime="20190402 07:22:56.238"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:22:56.240" level="INFO">0</msg>
<msg timestamp="20190402 07:22:56.240" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:56.240" starttime="20190402 07:22:56.240"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:22:56.241" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:22:56.241" starttime="20190402 07:22:56.240"></status>
</kw>
<msg timestamp="20190402 07:22:56.241" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:22:56.241" starttime="20190402 07:22:56.238"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:56.241" starttime="20190402 07:22:56.241"></status>
</kw>
<status status="PASS" endtime="20190402 07:22:56.242" starttime="20190402 07:22:56.241"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:22:56.242" starttime="20190402 07:22:56.242"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:22:56.242" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:22:56.242" starttime="20190402 07:22:56.242"></status>
</kw>
<msg timestamp="20190402 07:22:56.242" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:22:56.242" starttime="20190402 07:22:55.123"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:22:56.243" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:22:56.243" starttime="20190402 07:22:56.243"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:22:56.243" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:22:56.244" starttime="20190402 07:22:56.243"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:56.244" starttime="20190402 07:22:56.243"></status>
</kw>
<status status="FAIL" endtime="20190402 07:22:56.244" starttime="20190402 07:22:55.121"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:23:01.247" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:01.247" starttime="20190402 07:23:01.246"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:01.249" starttime="20190402 07:23:01.248"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:23:01.251" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:23:01.251" starttime="20190402 07:23:01.250"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:01.251" starttime="20190402 07:23:01.251"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:01.251" starttime="20190402 07:23:01.251"></status>
</kw>
<msg timestamp="20190402 07:23:01.251" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:23:01.251" starttime="20190402 07:23:01.250"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:23:01.252" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:01.252" starttime="20190402 07:23:01.252"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:23:01.259" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:01.259" starttime="20190402 07:23:01.252"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:23:02.779" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:23:02.779" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:02.779" starttime="20190402 07:23:01.259"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:23:02.780" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:02.780" starttime="20190402 07:23:02.779"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:23:02.780" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:02.780" starttime="20190402 07:23:02.780"></status>
</kw>
<msg timestamp="20190402 07:23:02.780" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:02.780" starttime="20190402 07:23:02.779"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:23:02.782" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:23:02.782" starttime="20190402 07:23:02.780"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:23:02.785" level="INFO">0</msg>
<msg timestamp="20190402 07:23:02.785" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:02.785" starttime="20190402 07:23:02.782"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:23:02.786" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:23:02.786" starttime="20190402 07:23:02.786"></status>
</kw>
<msg timestamp="20190402 07:23:02.786" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:02.786" starttime="20190402 07:23:02.780"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:02.787" starttime="20190402 07:23:02.786"></status>
</kw>
<status status="PASS" endtime="20190402 07:23:02.787" starttime="20190402 07:23:02.786"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:02.787" starttime="20190402 07:23:02.787"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:23:02.787" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:23:02.787" starttime="20190402 07:23:02.787"></status>
</kw>
<msg timestamp="20190402 07:23:02.788" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:23:02.788" starttime="20190402 07:23:01.247"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:23:02.788" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:23:02.788" starttime="20190402 07:23:02.788"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:23:02.789" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:23:02.789" starttime="20190402 07:23:02.788"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:02.789" starttime="20190402 07:23:02.788"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:02.789" starttime="20190402 07:23:01.245"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:23:07.793" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:07.793" starttime="20190402 07:23:07.792"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:07.795" starttime="20190402 07:23:07.795"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:23:07.796" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:23:07.796" starttime="20190402 07:23:07.795"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:07.796" starttime="20190402 07:23:07.796"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:07.797" starttime="20190402 07:23:07.796"></status>
</kw>
<msg timestamp="20190402 07:23:07.797" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:23:07.797" starttime="20190402 07:23:07.795"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:23:07.797" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:07.797" starttime="20190402 07:23:07.797"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:23:07.805" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:07.806" starttime="20190402 07:23:07.797"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:23:08.934" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:23:08.934" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:08.934" starttime="20190402 07:23:07.806"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:23:08.935" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:08.935" starttime="20190402 07:23:08.935"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:23:08.935" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:08.935" starttime="20190402 07:23:08.935"></status>
</kw>
<msg timestamp="20190402 07:23:08.935" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:08.935" starttime="20190402 07:23:08.934"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:23:08.937" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:23:08.937" starttime="20190402 07:23:08.936"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:23:08.937" level="INFO">0</msg>
<msg timestamp="20190402 07:23:08.938" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:08.938" starttime="20190402 07:23:08.937"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:23:08.938" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:23:08.938" starttime="20190402 07:23:08.938"></status>
</kw>
<msg timestamp="20190402 07:23:08.938" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:08.938" starttime="20190402 07:23:08.935"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:08.939" starttime="20190402 07:23:08.939"></status>
</kw>
<status status="PASS" endtime="20190402 07:23:08.939" starttime="20190402 07:23:08.938"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:08.939" starttime="20190402 07:23:08.939"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:23:08.940" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:23:08.940" starttime="20190402 07:23:08.939"></status>
</kw>
<msg timestamp="20190402 07:23:08.940" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:23:08.940" starttime="20190402 07:23:07.793"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:23:08.940" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:23:08.940" starttime="20190402 07:23:08.940"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:23:08.941" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:23:08.941" starttime="20190402 07:23:08.941"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:08.941" starttime="20190402 07:23:08.940"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:08.941" starttime="20190402 07:23:07.790"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:23:13.945" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:13.945" starttime="20190402 07:23:13.943"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:13.947" starttime="20190402 07:23:13.947"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:23:13.948" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:23:13.948" starttime="20190402 07:23:13.948"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:13.948" starttime="20190402 07:23:13.948"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:13.949" starttime="20190402 07:23:13.948"></status>
</kw>
<msg timestamp="20190402 07:23:13.949" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:23:13.949" starttime="20190402 07:23:13.947"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:23:13.949" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:13.949" starttime="20190402 07:23:13.949"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:23:13.958" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:13.959" starttime="20190402 07:23:13.949"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:23:15.076" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:23:15.076" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:15.076" starttime="20190402 07:23:13.959"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:23:15.077" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:15.077" starttime="20190402 07:23:15.076"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:23:15.077" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:15.077" starttime="20190402 07:23:15.077"></status>
</kw>
<msg timestamp="20190402 07:23:15.077" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:15.077" starttime="20190402 07:23:15.076"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:23:15.079" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:23:15.079" starttime="20190402 07:23:15.077"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:23:15.079" level="INFO">0</msg>
<msg timestamp="20190402 07:23:15.079" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:15.079" starttime="20190402 07:23:15.079"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:23:15.080" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:23:15.080" starttime="20190402 07:23:15.079"></status>
</kw>
<msg timestamp="20190402 07:23:15.080" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:15.080" starttime="20190402 07:23:15.077"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:15.081" starttime="20190402 07:23:15.080"></status>
</kw>
<status status="PASS" endtime="20190402 07:23:15.081" starttime="20190402 07:23:15.080"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:15.081" starttime="20190402 07:23:15.081"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:23:15.081" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:23:15.081" starttime="20190402 07:23:15.081"></status>
</kw>
<msg timestamp="20190402 07:23:15.081" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:23:15.082" starttime="20190402 07:23:13.946"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:23:15.082" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:23:15.082" starttime="20190402 07:23:15.082"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:23:15.083" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:23:15.083" starttime="20190402 07:23:15.082"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:15.083" starttime="20190402 07:23:15.082"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:15.083" starttime="20190402 07:23:13.942"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:23:20.086" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:20.086" starttime="20190402 07:23:20.085"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:20.088" starttime="20190402 07:23:20.088"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:23:20.089" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:23:20.089" starttime="20190402 07:23:20.089"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:20.089" starttime="20190402 07:23:20.089"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:20.090" starttime="20190402 07:23:20.090"></status>
</kw>
<msg timestamp="20190402 07:23:20.090" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:23:20.090" starttime="20190402 07:23:20.089"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:23:20.090" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:20.090" starttime="20190402 07:23:20.090"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:23:20.092" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:20.092" starttime="20190402 07:23:20.090"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:23:21.254" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:23:21.254" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:21.254" starttime="20190402 07:23:20.092"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:23:21.255" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:21.255" starttime="20190402 07:23:21.255"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:23:21.255" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:21.255" starttime="20190402 07:23:21.255"></status>
</kw>
<msg timestamp="20190402 07:23:21.255" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:21.255" starttime="20190402 07:23:21.254"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:23:21.257" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:23:21.257" starttime="20190402 07:23:21.256"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:23:21.258" level="INFO">0</msg>
<msg timestamp="20190402 07:23:21.258" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:21.258" starttime="20190402 07:23:21.257"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:23:21.258" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:23:21.258" starttime="20190402 07:23:21.258"></status>
</kw>
<msg timestamp="20190402 07:23:21.258" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:21.258" starttime="20190402 07:23:21.256"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:21.259" starttime="20190402 07:23:21.259"></status>
</kw>
<status status="PASS" endtime="20190402 07:23:21.259" starttime="20190402 07:23:21.259"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:21.259" starttime="20190402 07:23:21.259"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:23:21.260" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:23:21.260" starttime="20190402 07:23:21.260"></status>
</kw>
<msg timestamp="20190402 07:23:21.260" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:23:21.260" starttime="20190402 07:23:20.086"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:23:21.260" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:23:21.260" starttime="20190402 07:23:21.260"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:23:21.261" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:23:21.261" starttime="20190402 07:23:21.261"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:21.261" starttime="20190402 07:23:21.261"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:21.261" starttime="20190402 07:23:20.083"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:23:26.262" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:26.263" starttime="20190402 07:23:26.262"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:26.263" starttime="20190402 07:23:26.263"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:23:26.264" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:23:26.264" starttime="20190402 07:23:26.264"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:26.265" starttime="20190402 07:23:26.264"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:26.265" starttime="20190402 07:23:26.265"></status>
</kw>
<msg timestamp="20190402 07:23:26.265" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:23:26.265" starttime="20190402 07:23:26.263"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:23:26.266" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:26.266" starttime="20190402 07:23:26.265"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:23:26.274" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:26.274" starttime="20190402 07:23:26.266"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:23:27.465" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:23:27.465" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:27.465" starttime="20190402 07:23:26.274"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:23:27.466" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:27.466" starttime="20190402 07:23:27.465"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:23:27.466" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:27.466" starttime="20190402 07:23:27.466"></status>
</kw>
<msg timestamp="20190402 07:23:27.466" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:27.466" starttime="20190402 07:23:27.465"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:23:27.467" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:23:27.467" starttime="20190402 07:23:27.466"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:23:27.468" level="INFO">0</msg>
<msg timestamp="20190402 07:23:27.468" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:27.468" starttime="20190402 07:23:27.467"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:23:27.468" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:23:27.469" starttime="20190402 07:23:27.468"></status>
</kw>
<msg timestamp="20190402 07:23:27.469" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:27.469" starttime="20190402 07:23:27.466"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:27.469" starttime="20190402 07:23:27.469"></status>
</kw>
<status status="PASS" endtime="20190402 07:23:27.469" starttime="20190402 07:23:27.469"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:27.470" starttime="20190402 07:23:27.470"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:23:27.470" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:23:27.470" starttime="20190402 07:23:27.470"></status>
</kw>
<msg timestamp="20190402 07:23:27.470" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:23:27.470" starttime="20190402 07:23:26.263"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:23:27.471" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:23:27.471" starttime="20190402 07:23:27.471"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:23:27.471" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:23:27.471" starttime="20190402 07:23:27.471"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:27.471" starttime="20190402 07:23:27.471"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:27.472" starttime="20190402 07:23:26.262"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:23:32.475" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:32.475" starttime="20190402 07:23:32.474"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:32.477" starttime="20190402 07:23:32.477"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:23:32.478" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:23:32.478" starttime="20190402 07:23:32.478"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:32.478" starttime="20190402 07:23:32.478"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:32.479" starttime="20190402 07:23:32.478"></status>
</kw>
<msg timestamp="20190402 07:23:32.479" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:23:32.479" starttime="20190402 07:23:32.477"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:23:32.479" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:32.479" starttime="20190402 07:23:32.479"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:23:32.481" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:32.481" starttime="20190402 07:23:32.479"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:23:33.652" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:23:33.652" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:33.652" starttime="20190402 07:23:32.482"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:23:33.653" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:33.653" starttime="20190402 07:23:33.653"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:23:33.654" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:33.654" starttime="20190402 07:23:33.653"></status>
</kw>
<msg timestamp="20190402 07:23:33.654" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:33.654" starttime="20190402 07:23:33.653"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:23:33.656" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:23:33.656" starttime="20190402 07:23:33.654"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:23:33.656" level="INFO">0</msg>
<msg timestamp="20190402 07:23:33.656" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:33.656" starttime="20190402 07:23:33.656"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:23:33.656" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:23:33.656" starttime="20190402 07:23:33.656"></status>
</kw>
<msg timestamp="20190402 07:23:33.657" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:33.657" starttime="20190402 07:23:33.654"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:33.657" starttime="20190402 07:23:33.657"></status>
</kw>
<status status="PASS" endtime="20190402 07:23:33.657" starttime="20190402 07:23:33.657"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:33.658" starttime="20190402 07:23:33.657"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:23:33.658" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:23:33.658" starttime="20190402 07:23:33.658"></status>
</kw>
<msg timestamp="20190402 07:23:33.658" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:23:33.658" starttime="20190402 07:23:32.475"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:23:33.659" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:23:33.659" starttime="20190402 07:23:33.658"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:23:33.659" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:23:33.659" starttime="20190402 07:23:33.659"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:33.659" starttime="20190402 07:23:33.659"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:33.660" starttime="20190402 07:23:32.472"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:23:38.662" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:38.662" starttime="20190402 07:23:38.661"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:38.664" starttime="20190402 07:23:38.664"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:23:38.666" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:23:38.666" starttime="20190402 07:23:38.665"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:38.666" starttime="20190402 07:23:38.666"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:38.666" starttime="20190402 07:23:38.666"></status>
</kw>
<msg timestamp="20190402 07:23:38.667" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:23:38.667" starttime="20190402 07:23:38.665"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:23:38.667" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:38.667" starttime="20190402 07:23:38.667"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:23:38.668" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:38.668" starttime="20190402 07:23:38.667"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:23:39.898" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:23:39.898" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:39.898" starttime="20190402 07:23:38.669"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:23:39.899" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:39.899" starttime="20190402 07:23:39.899"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:23:39.899" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:39.899" starttime="20190402 07:23:39.899"></status>
</kw>
<msg timestamp="20190402 07:23:39.899" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:39.900" starttime="20190402 07:23:39.898"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:23:39.901" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:23:39.901" starttime="20190402 07:23:39.900"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:23:39.902" level="INFO">0</msg>
<msg timestamp="20190402 07:23:39.902" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:39.902" starttime="20190402 07:23:39.902"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:23:39.902" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:23:39.902" starttime="20190402 07:23:39.902"></status>
</kw>
<msg timestamp="20190402 07:23:39.902" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:39.902" starttime="20190402 07:23:39.900"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:39.903" starttime="20190402 07:23:39.903"></status>
</kw>
<status status="PASS" endtime="20190402 07:23:39.903" starttime="20190402 07:23:39.902"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:39.903" starttime="20190402 07:23:39.903"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:23:39.904" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:23:39.904" starttime="20190402 07:23:39.903"></status>
</kw>
<msg timestamp="20190402 07:23:39.904" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:23:39.904" starttime="20190402 07:23:38.663"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:23:39.904" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:23:39.904" starttime="20190402 07:23:39.904"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:23:39.905" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:23:39.905" starttime="20190402 07:23:39.905"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:39.905" starttime="20190402 07:23:39.904"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:39.905" starttime="20190402 07:23:38.660"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:23:44.907" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:44.908" starttime="20190402 07:23:44.907"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:44.910" starttime="20190402 07:23:44.909"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:23:44.911" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:23:44.911" starttime="20190402 07:23:44.910"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:44.912" starttime="20190402 07:23:44.911"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:44.912" starttime="20190402 07:23:44.912"></status>
</kw>
<msg timestamp="20190402 07:23:44.912" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:23:44.912" starttime="20190402 07:23:44.910"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:23:44.912" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:44.913" starttime="20190402 07:23:44.912"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:23:44.920" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:44.920" starttime="20190402 07:23:44.913"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:23:46.079" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:23:46.079" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:46.079" starttime="20190402 07:23:44.920"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:23:46.080" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:46.080" starttime="20190402 07:23:46.079"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:23:46.080" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:46.080" starttime="20190402 07:23:46.080"></status>
</kw>
<msg timestamp="20190402 07:23:46.080" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:46.080" starttime="20190402 07:23:46.079"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:23:46.082" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:23:46.082" starttime="20190402 07:23:46.081"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:23:46.083" level="INFO">0</msg>
<msg timestamp="20190402 07:23:46.083" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:46.083" starttime="20190402 07:23:46.082"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:23:46.083" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:23:46.083" starttime="20190402 07:23:46.083"></status>
</kw>
<msg timestamp="20190402 07:23:46.083" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:46.083" starttime="20190402 07:23:46.081"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:46.084" starttime="20190402 07:23:46.084"></status>
</kw>
<status status="PASS" endtime="20190402 07:23:46.084" starttime="20190402 07:23:46.083"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:46.084" starttime="20190402 07:23:46.084"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:23:46.085" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:23:46.085" starttime="20190402 07:23:46.084"></status>
</kw>
<msg timestamp="20190402 07:23:46.085" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:23:46.085" starttime="20190402 07:23:44.908"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:23:46.085" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:23:46.085" starttime="20190402 07:23:46.085"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:23:46.086" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:23:46.086" starttime="20190402 07:23:46.086"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:46.086" starttime="20190402 07:23:46.085"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:46.086" starttime="20190402 07:23:44.906"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:23:51.089" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:51.090" starttime="20190402 07:23:51.088"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:51.092" starttime="20190402 07:23:51.092"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:23:51.095" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:23:51.095" starttime="20190402 07:23:51.094"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:51.097" starttime="20190402 07:23:51.096"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:51.098" starttime="20190402 07:23:51.097"></status>
</kw>
<msg timestamp="20190402 07:23:51.099" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:23:51.099" starttime="20190402 07:23:51.093"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:23:51.100" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:51.100" starttime="20190402 07:23:51.100"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:23:51.126" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:51.126" starttime="20190402 07:23:51.101"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:23:52.261" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:23:52.261" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:52.261" starttime="20190402 07:23:51.126"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:23:52.262" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:52.262" starttime="20190402 07:23:52.261"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:23:52.262" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:52.262" starttime="20190402 07:23:52.262"></status>
</kw>
<msg timestamp="20190402 07:23:52.262" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:52.262" starttime="20190402 07:23:52.261"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:23:52.264" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:23:52.264" starttime="20190402 07:23:52.263"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:23:52.264" level="INFO">0</msg>
<msg timestamp="20190402 07:23:52.264" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:52.264" starttime="20190402 07:23:52.264"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:23:52.265" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:23:52.265" starttime="20190402 07:23:52.265"></status>
</kw>
<msg timestamp="20190402 07:23:52.265" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:52.265" starttime="20190402 07:23:52.262"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:52.266" starttime="20190402 07:23:52.265"></status>
</kw>
<status status="PASS" endtime="20190402 07:23:52.266" starttime="20190402 07:23:52.265"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:52.266" starttime="20190402 07:23:52.266"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:23:52.266" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:23:52.266" starttime="20190402 07:23:52.266"></status>
</kw>
<msg timestamp="20190402 07:23:52.267" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:23:52.267" starttime="20190402 07:23:51.090"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:23:52.267" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:23:52.267" starttime="20190402 07:23:52.267"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:23:52.268" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:23:52.268" starttime="20190402 07:23:52.267"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:52.268" starttime="20190402 07:23:52.267"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:52.268" starttime="20190402 07:23:51.087"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:23:57.271" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:57.271" starttime="20190402 07:23:57.270"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:57.273" starttime="20190402 07:23:57.273"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:23:57.274" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:23:57.274" starttime="20190402 07:23:57.274"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:57.274" starttime="20190402 07:23:57.274"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:57.275" starttime="20190402 07:23:57.274"></status>
</kw>
<msg timestamp="20190402 07:23:57.275" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:23:57.275" starttime="20190402 07:23:57.273"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:23:57.275" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:57.275" starttime="20190402 07:23:57.275"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:23:57.277" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:23:57.277" starttime="20190402 07:23:57.275"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:23:58.397" level="INFO">applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:23:58.398" level="INFO">${output} = applying
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:58.398" starttime="20190402 07:23:57.277"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:23:58.398" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:23:58.398" starttime="20190402 07:23:58.398"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:23:58.399" level="INFO">${clean_out} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:58.399" starttime="20190402 07:23:58.398"></status>
</kw>
<msg timestamp="20190402 07:23:58.399" level="INFO">${output} = applying
</msg>
<status status="PASS" endtime="20190402 07:23:58.399" starttime="20190402 07:23:58.398"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:23:58.401" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:23:58.401" starttime="20190402 07:23:58.399"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:23:58.401" level="INFO">0</msg>
<msg timestamp="20190402 07:23:58.401" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:58.401" starttime="20190402 07:23:58.401"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:23:58.401" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:23:58.402" starttime="20190402 07:23:58.401"></status>
</kw>
<msg timestamp="20190402 07:23:58.402" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:23:58.402" starttime="20190402 07:23:58.399"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:58.403" starttime="20190402 07:23:58.402"></status>
</kw>
<status status="PASS" endtime="20190402 07:23:58.403" starttime="20190402 07:23:58.402"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:23:58.403" starttime="20190402 07:23:58.403"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:23:58.403" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applying</msg>
<status status="PASS" endtime="20190402 07:23:58.403" starttime="20190402 07:23:58.403"></status>
</kw>
<msg timestamp="20190402 07:23:58.404" level="INFO">&amp;{result} = { stdout=applying | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:23:58.404" starttime="20190402 07:23:57.272"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:23:58.404" level="INFO">${value} = applying</msg>
<status status="PASS" endtime="20190402 07:23:58.404" starttime="20190402 07:23:58.404"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190402 07:23:58.405" level="FAIL">applying != applied</msg>
<status status="FAIL" endtime="20190402 07:23:58.405" starttime="20190402 07:23:58.404"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:58.405" starttime="20190402 07:23:58.404"></status>
</kw>
<status status="FAIL" endtime="20190402 07:23:58.405" starttime="20190402 07:23:57.269"></status>
</kw>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:03.408" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:24:03.408" starttime="20190402 07:24:03.407"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:03.410" starttime="20190402 07:24:03.410"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:24:03.411" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:24:03.411" starttime="20190402 07:24:03.411"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:03.411" starttime="20190402 07:24:03.411"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:03.412" starttime="20190402 07:24:03.411"></status>
</kw>
<msg timestamp="20190402 07:24:03.412" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:24:03.412" starttime="20190402 07:24:03.410"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:24:03.412" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:03.412" starttime="20190402 07:24:03.412"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:24:03.422" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:24:03.422" starttime="20190402 07:24:03.412"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:24:04.646" level="INFO">applied
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:24:04.647" level="INFO">${output} = applied
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:04.647" starttime="20190402 07:24:03.422"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:24:04.647" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:04.647" starttime="20190402 07:24:04.647"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:24:04.648" level="INFO">${clean_out} = applied
</msg>
<status status="PASS" endtime="20190402 07:24:04.648" starttime="20190402 07:24:04.647"></status>
</kw>
<msg timestamp="20190402 07:24:04.648" level="INFO">${output} = applied
</msg>
<status status="PASS" endtime="20190402 07:24:04.648" starttime="20190402 07:24:04.647"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:24:04.650" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:24:04.650" starttime="20190402 07:24:04.648"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:04.650" level="INFO">0</msg>
<msg timestamp="20190402 07:24:04.650" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:04.650" starttime="20190402 07:24:04.650"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:24:04.651" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:24:04.651" starttime="20190402 07:24:04.650"></status>
</kw>
<msg timestamp="20190402 07:24:04.651" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:04.651" starttime="20190402 07:24:04.648"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:04.652" starttime="20190402 07:24:04.651"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:04.652" starttime="20190402 07:24:04.651"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:04.652" starttime="20190402 07:24:04.652"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:24:04.652" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applied</msg>
<status status="PASS" endtime="20190402 07:24:04.652" starttime="20190402 07:24:04.652"></status>
</kw>
<msg timestamp="20190402 07:24:04.652" level="INFO">&amp;{result} = { stdout=applied | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:24:04.653" starttime="20190402 07:24:03.409"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:24:04.653" level="INFO">${value} = applied</msg>
<status status="PASS" endtime="20190402 07:24:04.653" starttime="20190402 07:24:04.653"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:04.654" starttime="20190402 07:24:04.653"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:04.654" starttime="20190402 07:24:04.653"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:04.654" starttime="20190402 07:24:03.405"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:04.654" starttime="20190402 06:58:36.842"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:04.654" starttime="20190402 06:58:35.828"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>60 min</arg>
<arg>5 sec</arg>
<arg>Check System Application Status</arg>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>${application}</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:04.655" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:24:04.655" starttime="20190402 07:24:04.655"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:04.656" starttime="20190402 07:24:04.655"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:24:04.656" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:24:04.656" starttime="20190402 07:24:04.656"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:04.657" starttime="20190402 07:24:04.656"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:04.657" starttime="20190402 07:24:04.657"></status>
</kw>
<msg timestamp="20190402 07:24:04.657" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:24:04.657" starttime="20190402 07:24:04.656"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:24:04.657" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:04.658" starttime="20190402 07:24:04.657"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:24:04.666" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190402 07:24:04.666" starttime="20190402 07:24:04.658"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:24:05.893" level="INFO">applied
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:24:05.893" level="INFO">${output} = applied
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:05.893" starttime="20190402 07:24:04.666"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:24:05.894" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:05.894" starttime="20190402 07:24:05.894"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:24:05.894" level="INFO">${clean_out} = applied
</msg>
<status status="PASS" endtime="20190402 07:24:05.894" starttime="20190402 07:24:05.894"></status>
</kw>
<msg timestamp="20190402 07:24:05.895" level="INFO">${output} = applied
</msg>
<status status="PASS" endtime="20190402 07:24:05.895" starttime="20190402 07:24:05.894"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:24:05.897" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:24:05.897" starttime="20190402 07:24:05.895"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:05.897" level="INFO">0</msg>
<msg timestamp="20190402 07:24:05.897" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:05.897" starttime="20190402 07:24:05.897"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:24:05.897" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:24:05.897" starttime="20190402 07:24:05.897"></status>
</kw>
<msg timestamp="20190402 07:24:05.898" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:05.898" starttime="20190402 07:24:05.895"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:05.898" starttime="20190402 07:24:05.898"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:05.898" starttime="20190402 07:24:05.898"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:05.899" starttime="20190402 07:24:05.898"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:24:05.899" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: applied</msg>
<status status="PASS" endtime="20190402 07:24:05.899" starttime="20190402 07:24:05.899"></status>
</kw>
<msg timestamp="20190402 07:24:05.899" level="INFO">&amp;{result} = { stdout=applied | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:24:05.899" starttime="20190402 07:24:04.655"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190402 07:24:05.900" level="INFO">${value} = applied</msg>
<status status="PASS" endtime="20190402 07:24:05.900" starttime="20190402 07:24:05.899"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:05.900" starttime="20190402 07:24:05.900"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:05.900" starttime="20190402 07:24:05.900"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:05.900" starttime="20190402 07:24:04.654"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:05.900" starttime="20190402 07:24:04.654"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:05.901" starttime="20190402 06:58:35.828"></status>
</kw>
<kw name="Set Ceph Pool Replication" library="Utils">
<doc>Set Ceph pool replication to get HEALTH_OK</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd pool ls | xargs -i ceph osd pool set {} size 1</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:05.902" starttime="20190402 07:24:05.901"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:24:05.902" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:24:05.902" starttime="20190402 07:24:05.902"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:05.903" starttime="20190402 07:24:05.902"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:05.903" starttime="20190402 07:24:05.903"></status>
</kw>
<msg timestamp="20190402 07:24:05.903" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:24:05.903" starttime="20190402 07:24:05.902"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:24:05.904" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:05.904" starttime="20190402 07:24:05.903"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:24:05.905" level="INFO">ceph osd pool ls | xargs -i ceph osd p ool set {} size 1</msg>
<status status="PASS" endtime="20190402 07:24:05.905" starttime="20190402 07:24:05.904"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:24:17.022" level="INFO">set pool 0 size to 1
set pool 1 size to 1
set pool 2 size to 1
set pool 3 size to 1
set pool 4 size to 1
set pool 5 size to 1
set pool 6 size to 1
set pool 7 size to 1
set pool 8 size to 1
set pool 9 size to 1
set pool 10 size to 1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:24:17.022" level="INFO">${output} = set pool 0 size to 1
set pool 1 size to 1
set pool 2 size to 1
set pool 3 size to 1
set pool 4 size to 1
set pool 5 size to 1
set pool 6 size to 1
set pool 7 size to 1
set pool 8 size to 1
se...</msg>
<status status="PASS" endtime="20190402 07:24:17.022" starttime="20190402 07:24:05.905"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:24:17.023" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:17.023" starttime="20190402 07:24:17.022"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:24:17.023" level="INFO">${clean_out} = set pool 0 size to 1
set pool 1 size to 1
set pool 2 size to 1
set pool 3 size to 1
set pool 4 size to 1
set pool 5 size to 1
set pool 6 size to 1
set pool 7 size to 1
set pool 8 size to 1
se...</msg>
<status status="PASS" endtime="20190402 07:24:17.023" starttime="20190402 07:24:17.023"></status>
</kw>
<msg timestamp="20190402 07:24:17.023" level="INFO">${output} = set pool 0 size to 1
set pool 1 size to 1
set pool 2 size to 1
set pool 3 size to 1
set pool 4 size to 1
set pool 5 size to 1
set pool 6 size to 1
set pool 7 size to 1
set pool 8 size to 1
se...</msg>
<status status="PASS" endtime="20190402 07:24:17.023" starttime="20190402 07:24:17.022"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:24:17.025" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:24:17.025" starttime="20190402 07:24:17.024"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:17.025" level="INFO">0</msg>
<msg timestamp="20190402 07:24:17.026" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:17.026" starttime="20190402 07:24:17.025"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:24:17.026" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:24:17.026" starttime="20190402 07:24:17.026"></status>
</kw>
<msg timestamp="20190402 07:24:17.026" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:17.026" starttime="20190402 07:24:17.023"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.027" starttime="20190402 07:24:17.027"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:17.027" starttime="20190402 07:24:17.026"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.027" starttime="20190402 07:24:17.027"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:24:17.028" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: set pool 0 size to 1
set pool 1 size to 1
set pool 2 size to 1
set pool 3 size to 1
set pool 4 size to 1
set pool 5 size to 1
set pool 6 size to 1
set pool 7 size to 1
set pool 8 size to 1
set pool 9 size to 1
set pool 10 size to 1</msg>
<status status="PASS" endtime="20190402 07:24:17.028" starttime="20190402 07:24:17.027"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:17.028" starttime="20190402 07:24:05.901"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:17.028" starttime="20190402 07:24:05.901"></status>
</kw>
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/Utils/${clouds_yml}</arg>
<arg>${host_image_path}/${clouds_yml}</arg>
</arguments>
<msg timestamp="20190402 07:24:17.032" level="INFO">'/home/mgperezi/duplex/stx-test-suite/Utils/clouds.yml' -&gt; '/home/wrsroot//clouds.yml'</msg>
<status status="PASS" endtime="20190402 07:24:17.032" starttime="20190402 07:24:17.028"></status>
</kw>
<kw name="Set Cluster Endpoints" library="Utils">
<doc>Set and verify the cluster endpoints.</doc>
<arguments>
<arg>${clouds_yml}</arg>
</arguments>
<kw name="Execute Sudo Command" library="Utils">
<doc>Execute a sudo on controller over ssh connection keeping
environment visible to the subsequent keywords that will ask for
password everytime it is run. It is recommended to run sudo commands
manually using -k option (sudo -k) to find if password is required.
If password is not required after verify the command manually,
please use Run Command.</doc>
<arguments>
<arg>mkdir -p /etc/openstack</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=:</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.033" starttime="20190402 07:24:17.033"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:24:17.034" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:17.034" starttime="20190402 07:24:17.033"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>sudo -k ${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:24:17.035" level="INFO">sudo -k mkdir -p /etc/openstack</msg>
<status status="PASS" endtime="20190402 07:24:17.035" starttime="20190402 07:24:17.034"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:24:17.055" level="INFO">Password:</msg>
<msg timestamp="20190402 07:24:17.055" level="INFO">${output} = Password:</msg>
<status status="PASS" endtime="20190402 07:24:17.055" starttime="20190402 07:24:17.035"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${CLI_USER_PASS}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.056" starttime="20190402 07:24:17.055"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:24:17.056" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:24:17.057" starttime="20190402 07:24:17.056"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.057" starttime="20190402 07:24:17.057"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.057" starttime="20190402 07:24:17.057"></status>
</kw>
<msg timestamp="20190402 07:24:17.057" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:24:17.057" starttime="20190402 07:24:17.056"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190402 07:24:17.058" starttime="20190402 07:24:17.058"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.058" starttime="20190402 07:24:17.058"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:24:17.105" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:24:17.105" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:17.105" starttime="20190402 07:24:17.059"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:24:17.106" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:17.106" starttime="20190402 07:24:17.105"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:24:17.106" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190402 07:24:17.106" starttime="20190402 07:24:17.106"></status>
</kw>
<msg timestamp="20190402 07:24:17.106" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190402 07:24:17.106" starttime="20190402 07:24:17.105"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:24:17.107" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:24:17.107" starttime="20190402 07:24:17.107"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:17.108" level="INFO">0</msg>
<msg timestamp="20190402 07:24:17.108" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:17.108" starttime="20190402 07:24:17.107"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:24:17.108" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:24:17.108" starttime="20190402 07:24:17.108"></status>
</kw>
<msg timestamp="20190402 07:24:17.109" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:17.109" starttime="20190402 07:24:17.106"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.109" starttime="20190402 07:24:17.109"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:17.109" starttime="20190402 07:24:17.109"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.110" starttime="20190402 07:24:17.109"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:24:17.110" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190402 07:24:17.110" starttime="20190402 07:24:17.110"></status>
</kw>
<msg timestamp="20190402 07:24:17.110" level="INFO">${output} = {u'stdout': u'', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 07:24:17.110" starttime="20190402 07:24:17.055"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:17.110" starttime="20190402 07:24:17.033"></status>
</kw>
<kw name="Execute Sudo Command" library="Utils">
<doc>Execute a sudo on controller over ssh connection keeping
environment visible to the subsequent keywords that will ask for
password everytime it is run. It is recommended to run sudo commands
manually using -k option (sudo -k) to find if password is required.
If password is not required after verify the command manually,
please use Run Command.</doc>
<arguments>
<arg>mv ${clouds_yml} /etc/openstack/.</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=:</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.111" starttime="20190402 07:24:17.111"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190402 07:24:17.111" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:17.111" starttime="20190402 07:24:17.111"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>sudo -k ${cmd}</arg>
</arguments>
<msg timestamp="20190402 07:24:17.114" level="INFO">sudo -k mv clouds.yml /etc/openstack/. [A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K.</msg>
<status status="PASS" endtime="20190402 07:24:17.114" starttime="20190402 07:24:17.111"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:24:17.125" level="INFO">Password:</msg>
<msg timestamp="20190402 07:24:17.125" level="INFO">${output} = Password:</msg>
<status status="PASS" endtime="20190402 07:24:17.125" starttime="20190402 07:24:17.114"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${CLI_USER_PASS}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.126" starttime="20190402 07:24:17.126"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190402 07:24:17.127" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190402 07:24:17.127" starttime="20190402 07:24:17.126"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.127" starttime="20190402 07:24:17.127"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.128" starttime="20190402 07:24:17.127"></status>
</kw>
<msg timestamp="20190402 07:24:17.128" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190402 07:24:17.128" starttime="20190402 07:24:17.126"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190402 07:24:17.128" starttime="20190402 07:24:17.128"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.129" starttime="20190402 07:24:17.128"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190402 07:24:17.174" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190402 07:24:17.174" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:17.174" starttime="20190402 07:24:17.129"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190402 07:24:17.175" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190402 07:24:17.175" starttime="20190402 07:24:17.174"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190402 07:24:17.175" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190402 07:24:17.175" starttime="20190402 07:24:17.175"></status>
</kw>
<msg timestamp="20190402 07:24:17.175" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190402 07:24:17.175" starttime="20190402 07:24:17.174"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190402 07:24:17.176" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190402 07:24:17.176" starttime="20190402 07:24:17.176"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:17.177" level="INFO">0</msg>
<msg timestamp="20190402 07:24:17.177" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:17.177" starttime="20190402 07:24:17.176"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190402 07:24:17.177" level="INFO">0</msg>
<status status="PASS" endtime="20190402 07:24:17.177" starttime="20190402 07:24:17.177"></status>
</kw>
<msg timestamp="20190402 07:24:17.178" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:17.178" starttime="20190402 07:24:17.175"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.178" starttime="20190402 07:24:17.178"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:17.178" starttime="20190402 07:24:17.178"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:17.179" starttime="20190402 07:24:17.178"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190402 07:24:17.179" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190402 07:24:17.179" starttime="20190402 07:24:17.179"></status>
</kw>
<msg timestamp="20190402 07:24:17.179" level="INFO">${output} = {u'stdout': u'', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190402 07:24:17.179" starttime="20190402 07:24:17.125"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:17.179" starttime="20190402 07:24:17.110"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:17.179" starttime="20190402 07:24:17.032"></status>
</kw>
<kw name="Provider Network Setup" library="OpenStack">
<doc>Create the network segment ranges.</doc>
<arguments>
<arg>${physnet0}</arg>
<arg>${physnet1}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack project list | grep admin | awk '{print $2}'</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{output}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:17.180" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:17.180" starttime="20190402 07:24:17.180"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:17.181" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack project list | grep admin | awk '{print $2}''.</msg>
<msg timestamp="20190402 07:24:18.663" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:18.664" level="INFO">${stdout} = 0f11d1f07cb3473ea654e73eea746848</msg>
<msg timestamp="20190402 07:24:18.664" level="INFO">${stderr} = </msg>
<msg timestamp="20190402 07:24:18.664" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:18.664" starttime="20190402 07:24:17.181"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:18.666" level="INFO">${res} = {u'stdout': u'0f11d1f07cb3473ea654e73eea746848', u'stderr': u'', u'rc': 0}</msg>
<status status="PASS" endtime="20190402 07:24:18.666" starttime="20190402 07:24:18.665"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:18.667" starttime="20190402 07:24:18.667"></status>
</kw>
<msg timestamp="20190402 07:24:18.668" level="INFO">&amp;{output} = { stdout=0f11d1f07cb3473ea654e73eea746848 | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:24:18.668" starttime="20190402 07:24:17.180"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${adminid}</var>
</assign>
<msg timestamp="20190402 07:24:18.669" level="INFO">${adminid} = 0f11d1f07cb3473ea654e73eea746848</msg>
<status status="PASS" endtime="20190402 07:24:18.669" starttime="20190402 07:24:18.669"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network segment range create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190402 07:24:18.669" level="INFO">${openstack_cmd} = openstack network segment range create</msg>
<status status="PASS" endtime="20190402 07:24:18.669" starttime="20190402 07:24:18.669"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>${physnet0}-a</arg>
<arg>--network-type vlan</arg>
<arg>--physical-network ${physnet0}</arg>
<arg>--minimum 400</arg>
<arg>--maximum 499</arg>
<arg>--private</arg>
<arg>--project ${adminid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:18.670" level="INFO">${cmd} = openstack network segment range create physnet0-a --network-type vlan --physical-network physnet0 --minimum 400 --maximum 499 --private --project 0f11d1f07cb3473ea654e73eea746848</msg>
<status status="PASS" endtime="20190402 07:24:18.670" starttime="20190402 07:24:18.669"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:18.671" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:18.671" starttime="20190402 07:24:18.670"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:18.671" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network segment range create physnet0-a --network-type vlan --physical-network physnet0 --minimum 400 --maximum 499 --private --project 0f11d1f07cb3473ea654e73eea746848'.</msg>
<msg timestamp="20190402 07:24:21.810" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:21.810" level="INFO">${stdout} = +------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------...</msg>
<msg timestamp="20190402 07:24:21.811" level="INFO">${stderr} = </msg>
<msg timestamp="20190402 07:24:21.811" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:21.811" starttime="20190402 07:24:18.671"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:21.813" level="INFO">${res} = {u'stdout': u"+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 07:24:21.813" starttime="20190402 07:24:21.812"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:21.815" starttime="20190402 07:24:21.814"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:21.815" starttime="20190402 07:24:18.670"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>${physnet0}-b</arg>
<arg>--network-type vlan</arg>
<arg>--physical-network ${physnet0}</arg>
<arg>--minimum 10</arg>
<arg>--maximum 10</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:21.816" level="INFO">${cmd} = openstack network segment range create physnet0-b --network-type vlan --physical-network physnet0 --minimum 10 --maximum 10</msg>
<status status="PASS" endtime="20190402 07:24:21.816" starttime="20190402 07:24:21.815"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:21.816" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:21.816" starttime="20190402 07:24:21.816"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:21.817" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network segment range create physnet0-b --network-type vlan --physical-network physnet0 --minimum 10 --maximum 10'.</msg>
<msg timestamp="20190402 07:24:23.099" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:23.100" level="INFO">${stdout} = +------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------...</msg>
<msg timestamp="20190402 07:24:23.100" level="INFO">${stderr} = </msg>
<msg timestamp="20190402 07:24:23.100" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:23.100" starttime="20190402 07:24:21.816"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:23.103" level="INFO">${res} = {u'stdout': u"+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 07:24:23.103" starttime="20190402 07:24:23.101"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:23.104" starttime="20190402 07:24:23.103"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:23.104" starttime="20190402 07:24:21.816"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>${physnet1}-a</arg>
<arg>--network-type vlan</arg>
<arg>--physical-network ${physnet1}</arg>
<arg>--minimum 500</arg>
<arg>--maximum 599</arg>
<arg>--private</arg>
<arg>--project ${adminid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:23.105" level="INFO">${cmd} = openstack network segment range create physnet1-a --network-type vlan --physical-network physnet1 --minimum 500 --maximum 599 --private --project 0f11d1f07cb3473ea654e73eea746848</msg>
<status status="PASS" endtime="20190402 07:24:23.105" starttime="20190402 07:24:23.105"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:23.106" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:23.106" starttime="20190402 07:24:23.106"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:23.106" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network segment range create physnet1-a --network-type vlan --physical-network physnet1 --minimum 500 --maximum 599 --private --project 0f11d1f07cb3473ea654e73eea746848'.</msg>
<msg timestamp="20190402 07:24:24.489" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:24.490" level="INFO">${stdout} = +------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------...</msg>
<msg timestamp="20190402 07:24:24.490" level="INFO">${stderr} = </msg>
<msg timestamp="20190402 07:24:24.490" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:24.490" starttime="20190402 07:24:23.106"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:24.492" level="INFO">${res} = {u'stdout': u"+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------...</msg>
<status status="PASS" endtime="20190402 07:24:24.492" starttime="20190402 07:24:24.491"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:24.494" starttime="20190402 07:24:24.493"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:24.494" starttime="20190402 07:24:23.105"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:24.494" starttime="20190402 07:24:17.180"></status>
</kw>
<kw name="Tenant Networking Setup" library="OpenStack">
<doc>Setup tenant networking</doc>
<arguments>
<arg>${physnet0}</arg>
<arg>${physnet1}</arg>
<arg>${externalnet}</arg>
<arg>${publicnet}</arg>
<arg>${privatenet}</arg>
<arg>${internalnet}</arg>
<arg>${publicsubnet}</arg>
<arg>${privatesubnet}</arg>
<arg>${internalsubnet}</arg>
<arg>${externalsubnet}</arg>
<arg>${publicrouter}</arg>
<arg>${privaterouter}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack project list | grep admin | awk '{print $2}'</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{output}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:24.499" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:24.499" starttime="20190402 07:24:24.498"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:24.501" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack project list | grep admin | awk '{print $2}''.</msg>
<msg timestamp="20190402 07:24:25.734" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:25.734" level="INFO">${stdout} = 0f11d1f07cb3473ea654e73eea746848</msg>
<msg timestamp="20190402 07:24:25.735" level="INFO">${stderr} = </msg>
<msg timestamp="20190402 07:24:25.735" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:25.735" starttime="20190402 07:24:24.500"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:25.737" level="INFO">${res} = {u'stdout': u'0f11d1f07cb3473ea654e73eea746848', u'stderr': u'', u'rc': 0}</msg>
<status status="PASS" endtime="20190402 07:24:25.737" starttime="20190402 07:24:25.735"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:25.738" starttime="20190402 07:24:25.737"></status>
</kw>
<msg timestamp="20190402 07:24:25.739" level="INFO">&amp;{output} = { stdout=0f11d1f07cb3473ea654e73eea746848 | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:24:25.739" starttime="20190402 07:24:24.497"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${adminid}</var>
</assign>
<msg timestamp="20190402 07:24:25.741" level="INFO">${adminid} = 0f11d1f07cb3473ea654e73eea746848</msg>
<status status="PASS" endtime="20190402 07:24:25.741" starttime="20190402 07:24:25.740"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>neutron net-create --tenant-id ${adminid}</arg>
</arguments>
<assign>
<var>${neutron_cmd}</var>
</assign>
<msg timestamp="20190402 07:24:25.742" level="INFO">${neutron_cmd} = neutron net-create --tenant-id 0f11d1f07cb3473ea654e73eea746848</msg>
<status status="PASS" endtime="20190402 07:24:25.742" starttime="20190402 07:24:25.741"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${neutron_cmd}</arg>
<arg>--provider:network_type=vlan</arg>
<arg>--provider:physical_network=${physnet0}</arg>
<arg>--provider:segmentation_id=10</arg>
<arg>--router:external ${externalnet}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:25.743" level="INFO">${cmd} = neutron net-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --provider:network_type=vlan --provider:physical_network=physnet0 --provider:segmentation_id=10 --router:external external-net0</msg>
<status status="PASS" endtime="20190402 07:24:25.744" starttime="20190402 07:24:25.742"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:25.746" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:25.746" starttime="20190402 07:24:25.745"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:25.747" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron net-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --provider:network_type=vlan --provider:physical_network=physnet0 --provider:segmentation_id=10 --router:external external-net0'.</msg>
<msg timestamp="20190402 07:24:27.031" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:27.032" level="INFO">${stdout} = Created a new network:
+---------------------------+--------------------------------------+
| Field                     | Value                                |
+---------------------------+----------...</msg>
<msg timestamp="20190402 07:24:27.032" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:27.032" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:27.032" starttime="20190402 07:24:25.746"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:27.035" level="INFO">${res} = {u'stdout': u'Created a new network:\n+---------------------------+--------------------------------------+\n| Field                     | Value                                |\n+---------------------...</msg>
<status status="PASS" endtime="20190402 07:24:27.035" starttime="20190402 07:24:27.033"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:27.038" starttime="20190402 07:24:27.036"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:27.038" starttime="20190402 07:24:25.744"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${neutron_cmd}</arg>
<arg>--provider:network_type=vlan</arg>
<arg>--provider:physical_network=${physnet0}</arg>
<arg>--provider:segmentation_id=400 ${publicnet}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:27.040" level="INFO">${cmd} = neutron net-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --provider:network_type=vlan --provider:physical_network=physnet0 --provider:segmentation_id=400 public-net0</msg>
<status status="PASS" endtime="20190402 07:24:27.040" starttime="20190402 07:24:27.039"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:27.043" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:27.043" starttime="20190402 07:24:27.042"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:27.044" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron net-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --provider:network_type=vlan --provider:physical_network=physnet0 --provider:segmentation_id=400 public-net0'.</msg>
<msg timestamp="20190402 07:24:28.077" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:28.077" level="INFO">${stdout} = Created a new network:
+---------------------------+--------------------------------------+
| Field                     | Value                                |
+---------------------------+----------...</msg>
<msg timestamp="20190402 07:24:28.078" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:28.078" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:28.078" starttime="20190402 07:24:27.043"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:28.080" level="INFO">${res} = {u'stdout': u'Created a new network:\n+---------------------------+--------------------------------------+\n| Field                     | Value                                |\n+---------------------...</msg>
<status status="PASS" endtime="20190402 07:24:28.080" starttime="20190402 07:24:28.079"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:28.082" starttime="20190402 07:24:28.081"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:28.082" starttime="20190402 07:24:27.041"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${neutron_cmd}</arg>
<arg>--provider:network_type=vlan</arg>
<arg>--provider:physical_network=${physnet1}</arg>
<arg>--provider:segmentation_id=500 ${privatenet}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:28.083" level="INFO">${cmd} = neutron net-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --provider:network_type=vlan --provider:physical_network=physnet1 --provider:segmentation_id=500 private-net0</msg>
<status status="PASS" endtime="20190402 07:24:28.084" starttime="20190402 07:24:28.083"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:28.086" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:28.086" starttime="20190402 07:24:28.085"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:28.088" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron net-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --provider:network_type=vlan --provider:physical_network=physnet1 --provider:segmentation_id=500 private-net0'.</msg>
<msg timestamp="20190402 07:24:29.070" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:29.070" level="INFO">${stdout} = Created a new network:
+---------------------------+--------------------------------------+
| Field                     | Value                                |
+---------------------------+----------...</msg>
<msg timestamp="20190402 07:24:29.071" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:29.071" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:29.071" starttime="20190402 07:24:28.086"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:29.073" level="INFO">${res} = {u'stdout': u'Created a new network:\n+---------------------------+--------------------------------------+\n| Field                     | Value                                |\n+---------------------...</msg>
<status status="PASS" endtime="20190402 07:24:29.073" starttime="20190402 07:24:29.072"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:29.075" starttime="20190402 07:24:29.074"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:29.075" starttime="20190402 07:24:28.084"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${neutron_cmd}</arg>
<arg>${internalnet}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:29.075" level="INFO">${cmd} = neutron net-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 internal-net0</msg>
<status status="PASS" endtime="20190402 07:24:29.076" starttime="20190402 07:24:29.075"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:29.076" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:29.076" starttime="20190402 07:24:29.076"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:29.077" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron net-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 internal-net0'.</msg>
<msg timestamp="20190402 07:24:30.259" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:30.259" level="INFO">${stdout} = Created a new network:
+---------------------------+--------------------------------------+
| Field                     | Value                                |
+---------------------------+----------...</msg>
<msg timestamp="20190402 07:24:30.259" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:30.260" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:30.260" starttime="20190402 07:24:29.076"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:30.263" level="INFO">${res} = {u'stdout': u'Created a new network:\n+---------------------------+--------------------------------------+\n| Field                     | Value                                |\n+---------------------...</msg>
<status status="PASS" endtime="20190402 07:24:30.263" starttime="20190402 07:24:30.260"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:30.264" starttime="20190402 07:24:30.263"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:30.264" starttime="20190402 07:24:29.076"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>neutron net-list | grep ${publicnet} | awk '{print $2}'</arg>
</arguments>
<assign>
<var>&amp;{output}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:30.265" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:30.265" starttime="20190402 07:24:30.265"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:30.265" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron net-list | grep public-net0 | awk '{print $2}''.</msg>
<msg timestamp="20190402 07:24:31.655" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:31.655" level="INFO">${stdout} = 901f0b8c-7e41-4828-af92-df1813184c45</msg>
<msg timestamp="20190402 07:24:31.655" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:31.656" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:31.656" starttime="20190402 07:24:30.265"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:31.658" level="INFO">${res} = {u'stdout': u'901f0b8c-7e41-4828-af92-df1813184c45', u'stderr': u'neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.', u'rc': 0}</msg>
<status status="PASS" endtime="20190402 07:24:31.658" starttime="20190402 07:24:31.656"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:31.659" starttime="20190402 07:24:31.658"></status>
</kw>
<msg timestamp="20190402 07:24:31.660" level="INFO">&amp;{output} = { stdout=901f0b8c-7e41-4828-af92-df1813184c45 | stderr=neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead. | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:24:31.660" starttime="20190402 07:24:30.264"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${publicnetid}</var>
</assign>
<msg timestamp="20190402 07:24:31.662" level="INFO">${publicnetid} = 901f0b8c-7e41-4828-af92-df1813184c45</msg>
<status status="PASS" endtime="20190402 07:24:31.662" starttime="20190402 07:24:31.661"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>neutron net-list | grep ${privatenet} | awk '{print $2}'</arg>
</arguments>
<assign>
<var>&amp;{output}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:31.665" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:31.666" starttime="20190402 07:24:31.665"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:31.667" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron net-list | grep private-net0 | awk '{print $2}''.</msg>
<msg timestamp="20190402 07:24:32.856" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:32.856" level="INFO">${stdout} = f332d9b7-15fc-4a0f-8870-502d3f86b38e</msg>
<msg timestamp="20190402 07:24:32.857" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:32.857" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:32.857" starttime="20190402 07:24:31.666"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:32.859" level="INFO">${res} = {u'stdout': u'f332d9b7-15fc-4a0f-8870-502d3f86b38e', u'stderr': u'neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.', u'rc': 0}</msg>
<status status="PASS" endtime="20190402 07:24:32.859" starttime="20190402 07:24:32.858"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:32.861" starttime="20190402 07:24:32.860"></status>
</kw>
<msg timestamp="20190402 07:24:32.861" level="INFO">&amp;{output} = { stdout=f332d9b7-15fc-4a0f-8870-502d3f86b38e | stderr=neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead. | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:24:32.861" starttime="20190402 07:24:31.663"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${privatenetid}</var>
</assign>
<msg timestamp="20190402 07:24:32.862" level="INFO">${privatenetid} = f332d9b7-15fc-4a0f-8870-502d3f86b38e</msg>
<status status="PASS" endtime="20190402 07:24:32.862" starttime="20190402 07:24:32.861"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>neutron net-list | grep ${internalnet} | awk '{print $2}'</arg>
</arguments>
<assign>
<var>&amp;{output}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:32.862" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:32.862" starttime="20190402 07:24:32.862"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:32.863" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron net-list | grep internal-net0 | awk '{print $2}''.</msg>
<msg timestamp="20190402 07:24:34.051" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:34.052" level="INFO">${stdout} = 773fde25-ab9d-49b0-b055-033eea408f15</msg>
<msg timestamp="20190402 07:24:34.052" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:34.052" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:34.052" starttime="20190402 07:24:32.862"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:34.054" level="INFO">${res} = {u'stdout': u'773fde25-ab9d-49b0-b055-033eea408f15', u'stderr': u'neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.', u'rc': 0}</msg>
<status status="PASS" endtime="20190402 07:24:34.054" starttime="20190402 07:24:34.053"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:34.056" starttime="20190402 07:24:34.055"></status>
</kw>
<msg timestamp="20190402 07:24:34.056" level="INFO">&amp;{output} = { stdout=773fde25-ab9d-49b0-b055-033eea408f15 | stderr=neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead. | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:24:34.056" starttime="20190402 07:24:32.862"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${internalnetid}</var>
</assign>
<msg timestamp="20190402 07:24:34.056" level="INFO">${internalnetid} = 773fde25-ab9d-49b0-b055-033eea408f15</msg>
<status status="PASS" endtime="20190402 07:24:34.057" starttime="20190402 07:24:34.056"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>neutron net-list | grep ${externalnet} | awk '{print $2}'</arg>
</arguments>
<assign>
<var>&amp;{output}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:34.057" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:34.057" starttime="20190402 07:24:34.057"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:34.058" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron net-list | grep external-net0 | awk '{print $2}''.</msg>
<msg timestamp="20190402 07:24:35.271" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:35.271" level="INFO">${stdout} = 867d67fc-10e7-464e-8fdd-8c30f102826e</msg>
<msg timestamp="20190402 07:24:35.271" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:35.272" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:35.272" starttime="20190402 07:24:34.057"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:35.275" level="INFO">${res} = {u'stdout': u'867d67fc-10e7-464e-8fdd-8c30f102826e', u'stderr': u'neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.', u'rc': 0}</msg>
<status status="PASS" endtime="20190402 07:24:35.275" starttime="20190402 07:24:35.272"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:35.276" starttime="20190402 07:24:35.275"></status>
</kw>
<msg timestamp="20190402 07:24:35.277" level="INFO">&amp;{output} = { stdout=867d67fc-10e7-464e-8fdd-8c30f102826e | stderr=neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead. | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:24:35.277" starttime="20190402 07:24:34.057"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${externalnetid}</var>
</assign>
<msg timestamp="20190402 07:24:35.278" level="INFO">${externalnetid} = 867d67fc-10e7-464e-8fdd-8c30f102826e</msg>
<status status="PASS" endtime="20190402 07:24:35.278" starttime="20190402 07:24:35.277"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>neutron subnet-create --tenant-id ${adminid}</arg>
</arguments>
<assign>
<var>${neutron_cmd}</var>
</assign>
<msg timestamp="20190402 07:24:35.279" level="INFO">${neutron_cmd} = neutron subnet-create --tenant-id 0f11d1f07cb3473ea654e73eea746848</msg>
<status status="PASS" endtime="20190402 07:24:35.279" starttime="20190402 07:24:35.279"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${neutron_cmd}</arg>
<arg>--name ${publicsubnet}</arg>
<arg>${publicnet} 192.168.101.0/24</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:35.281" level="INFO">${cmd} = neutron subnet-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --name public-subnet0 public-net0 192.168.101.0/24</msg>
<status status="PASS" endtime="20190402 07:24:35.281" starttime="20190402 07:24:35.280"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:35.283" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:35.283" starttime="20190402 07:24:35.282"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:35.285" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron subnet-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --name public-subnet0 public-net0 192.168.101.0/24'.</msg>
<msg timestamp="20190402 07:24:36.482" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:36.483" level="INFO">${stdout} = Created a new subnet:
+-------------------+------------------------------------------------------+
| Field             | Value                                                |
+-------------------+---...</msg>
<msg timestamp="20190402 07:24:36.483" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:36.483" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:36.483" starttime="20190402 07:24:35.284"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:36.486" level="INFO">${res} = {u'stdout': u'Created a new subnet:\n+-------------------+------------------------------------------------------+\n| Field             | Value                                                |\n+------...</msg>
<status status="PASS" endtime="20190402 07:24:36.486" starttime="20190402 07:24:36.484"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:36.487" starttime="20190402 07:24:36.486"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:36.487" starttime="20190402 07:24:35.281"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${neutron_cmd}</arg>
<arg>--name ${privatesubnet}</arg>
<arg>${privatenet} 192.168.201.0/24</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:36.488" level="INFO">${cmd} = neutron subnet-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --name private-subnet0 private-net0 192.168.201.0/24</msg>
<status status="PASS" endtime="20190402 07:24:36.488" starttime="20190402 07:24:36.487"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:36.488" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:36.488" starttime="20190402 07:24:36.488"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:36.489" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron subnet-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --name private-subnet0 private-net0 192.168.201.0/24'.</msg>
<msg timestamp="20190402 07:24:37.853" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:37.853" level="INFO">${stdout} = Created a new subnet:
+-------------------+------------------------------------------------------+
| Field             | Value                                                |
+-------------------+---...</msg>
<msg timestamp="20190402 07:24:37.853" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:37.854" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:37.854" starttime="20190402 07:24:36.488"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:37.856" level="INFO">${res} = {u'stdout': u'Created a new subnet:\n+-------------------+------------------------------------------------------+\n| Field             | Value                                                |\n+------...</msg>
<status status="PASS" endtime="20190402 07:24:37.856" starttime="20190402 07:24:37.854"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:37.857" starttime="20190402 07:24:37.857"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:37.858" starttime="20190402 07:24:36.488"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${neutron_cmd}</arg>
<arg>--name ${internalsubnet}</arg>
<arg>--no-gateway</arg>
<arg>${internalnet} 10.10.0.0/24</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:37.859" level="INFO">${cmd} = neutron subnet-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --name internal-subnet0 --no-gateway internal-net0 10.10.0.0/24</msg>
<status status="PASS" endtime="20190402 07:24:37.860" starttime="20190402 07:24:37.858"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:37.862" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:37.862" starttime="20190402 07:24:37.861"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:37.864" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron subnet-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --name internal-subnet0 --no-gateway internal-net0 10.10.0.0/24'.</msg>
<msg timestamp="20190402 07:24:39.298" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:39.299" level="INFO">${stdout} = Created a new subnet:
+-------------------+----------------------------------------------+
| Field             | Value                                        |
+-------------------+-------------------...</msg>
<msg timestamp="20190402 07:24:39.299" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:39.299" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:39.300" starttime="20190402 07:24:37.863"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:39.302" level="INFO">${res} = {u'stdout': u'Created a new subnet:\n+-------------------+----------------------------------------------+\n| Field             | Value                                        |\n+-------------------+--...</msg>
<status status="PASS" endtime="20190402 07:24:39.302" starttime="20190402 07:24:39.300"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:39.303" starttime="20190402 07:24:39.302"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:39.303" starttime="20190402 07:24:37.860"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${neutron_cmd}</arg>
<arg>--name ${externalsubnet}</arg>
<arg>--gateway 192.168.1.1</arg>
<arg>--disable-dhcp ${externalnet} 192.168.1.0/24</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:39.304" level="INFO">${cmd} = neutron subnet-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --name external-subnet0 --gateway 192.168.1.1 --disable-dhcp external-net0 192.168.1.0/24</msg>
<status status="PASS" endtime="20190402 07:24:39.304" starttime="20190402 07:24:39.303"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:39.304" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:39.304" starttime="20190402 07:24:39.304"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:39.305" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron subnet-create --tenant-id 0f11d1f07cb3473ea654e73eea746848 --name external-subnet0 --gateway 192.168.1.1 --disable-dhcp external-net0 192.168.1.0/24'.</msg>
<msg timestamp="20190402 07:24:40.537" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:40.538" level="INFO">${stdout} = Created a new subnet:
+-------------------+--------------------------------------------------+
| Field             | Value                                            |
+-------------------+-----------...</msg>
<msg timestamp="20190402 07:24:40.538" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:40.538" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:40.538" starttime="20190402 07:24:39.304"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:40.540" level="INFO">${res} = {u'stdout': u'Created a new subnet:\n+-------------------+--------------------------------------------------+\n| Field             | Value                                            |\n+--------------...</msg>
<status status="PASS" endtime="20190402 07:24:40.541" starttime="20190402 07:24:40.539"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:40.542" starttime="20190402 07:24:40.541"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:40.542" starttime="20190402 07:24:39.304"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>neutron router-create ${publicrouter}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:40.545" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:40.545" starttime="20190402 07:24:40.544"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:40.547" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron router-create public-router0'.</msg>
<msg timestamp="20190402 07:24:41.479" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:41.480" level="INFO">${stdout} = Created a new router:
+-------------------------+--------------------------------------+
| Field                   | Value                                |
+-------------------------+-----------------...</msg>
<msg timestamp="20190402 07:24:41.480" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:41.480" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:41.480" starttime="20190402 07:24:40.545"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:41.482" level="INFO">${res} = {u'stdout': u'Created a new router:\n+-------------------------+--------------------------------------+\n| Field                   | Value                                |\n+-------------------------+...</msg>
<status status="PASS" endtime="20190402 07:24:41.483" starttime="20190402 07:24:41.481"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:41.484" starttime="20190402 07:24:41.483"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:41.484" starttime="20190402 07:24:40.543"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>neutron router-create ${privaterouter}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:41.485" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:41.485" starttime="20190402 07:24:41.485"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:41.485" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron router-create private-router0'.</msg>
<msg timestamp="20190402 07:24:42.373" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:42.373" level="INFO">${stdout} = Created a new router:
+-------------------------+--------------------------------------+
| Field                   | Value                                |
+-------------------------+-----------------...</msg>
<msg timestamp="20190402 07:24:42.373" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:42.373" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:42.374" starttime="20190402 07:24:41.485"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:42.376" level="INFO">${res} = {u'stdout': u'Created a new router:\n+-------------------------+--------------------------------------+\n| Field                   | Value                                |\n+-------------------------+...</msg>
<status status="PASS" endtime="20190402 07:24:42.376" starttime="20190402 07:24:42.374"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:42.377" starttime="20190402 07:24:42.376"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:42.377" starttime="20190402 07:24:41.484"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>neutron router-list | grep ${privaterouter} | awk '{print $2}'</arg>
</arguments>
<assign>
<var>&amp;{output}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:42.378" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:42.379" starttime="20190402 07:24:42.378"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:42.379" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron router-list | grep private-router0 | awk '{print $2}''.</msg>
<msg timestamp="20190402 07:24:43.561" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:43.561" level="INFO">${stdout} = 437b919f-bcd8-4fce-9f63-edc1dfd80c0a</msg>
<msg timestamp="20190402 07:24:43.562" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:43.562" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:43.562" starttime="20190402 07:24:42.379"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:43.564" level="INFO">${res} = {u'stdout': u'437b919f-bcd8-4fce-9f63-edc1dfd80c0a', u'stderr': u'neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.', u'rc': 0}</msg>
<status status="PASS" endtime="20190402 07:24:43.564" starttime="20190402 07:24:43.562"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:43.565" starttime="20190402 07:24:43.565"></status>
</kw>
<msg timestamp="20190402 07:24:43.566" level="INFO">&amp;{output} = { stdout=437b919f-bcd8-4fce-9f63-edc1dfd80c0a | stderr=neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead. | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:24:43.566" starttime="20190402 07:24:42.378"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${privaterouterid}</var>
</assign>
<msg timestamp="20190402 07:24:43.566" level="INFO">${privaterouterid} = 437b919f-bcd8-4fce-9f63-edc1dfd80c0a</msg>
<status status="PASS" endtime="20190402 07:24:43.567" starttime="20190402 07:24:43.566"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>neutron router-list | grep ${publicrouter} | awk '{print $2}'</arg>
</arguments>
<assign>
<var>&amp;{output}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:43.567" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:43.567" starttime="20190402 07:24:43.567"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:43.568" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron router-list | grep public-router0 | awk '{print $2}''.</msg>
<msg timestamp="20190402 07:24:44.900" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:44.901" level="INFO">${stdout} = cb12ca1f-d89d-408f-8cd6-6d0d59a9946b</msg>
<msg timestamp="20190402 07:24:44.901" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:44.901" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:44.901" starttime="20190402 07:24:43.567"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:44.904" level="INFO">${res} = {u'stdout': u'cb12ca1f-d89d-408f-8cd6-6d0d59a9946b', u'stderr': u'neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.', u'rc': 0}</msg>
<status status="PASS" endtime="20190402 07:24:44.904" starttime="20190402 07:24:44.902"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:44.905" starttime="20190402 07:24:44.904"></status>
</kw>
<msg timestamp="20190402 07:24:44.905" level="INFO">&amp;{output} = { stdout=cb12ca1f-d89d-408f-8cd6-6d0d59a9946b | stderr=neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead. | rc=0 }</msg>
<status status="PASS" endtime="20190402 07:24:44.905" starttime="20190402 07:24:43.567"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${publicrouterid}</var>
</assign>
<msg timestamp="20190402 07:24:44.906" level="INFO">${publicrouterid} = cb12ca1f-d89d-408f-8cd6-6d0d59a9946b</msg>
<status status="PASS" endtime="20190402 07:24:44.906" starttime="20190402 07:24:44.905"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>neutron router-gateway-set --disable-snat</arg>
<arg>${publicrouterid}</arg>
<arg>${externalnetid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:44.906" level="INFO">${cmd} = neutron router-gateway-set --disable-snat cb12ca1f-d89d-408f-8cd6-6d0d59a9946b 867d67fc-10e7-464e-8fdd-8c30f102826e</msg>
<status status="PASS" endtime="20190402 07:24:44.906" starttime="20190402 07:24:44.906"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:44.907" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:44.907" starttime="20190402 07:24:44.907"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:44.908" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron router-gateway-set --disable-snat cb12ca1f-d89d-408f-8cd6-6d0d59a9946b 867d67fc-10e7-464e-8fdd-8c30f102826e'.</msg>
<msg timestamp="20190402 07:24:47.676" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:47.677" level="INFO">${stdout} = Set gateway for router cb12ca1f-d89d-408f-8cd6-6d0d59a9946b</msg>
<msg timestamp="20190402 07:24:47.677" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:47.677" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:47.677" starttime="20190402 07:24:44.907"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:47.680" level="INFO">${res} = {u'stdout': u'Set gateway for router cb12ca1f-d89d-408f-8cd6-6d0d59a9946b', u'stderr': u'neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.', u'rc': 0}</msg>
<status status="PASS" endtime="20190402 07:24:47.680" starttime="20190402 07:24:47.678"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:47.681" starttime="20190402 07:24:47.681"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:47.681" starttime="20190402 07:24:44.906"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>neutron router-gateway-set --disable-snat</arg>
<arg>${privaterouterid}</arg>
<arg>${externalnetid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190402 07:24:47.682" level="INFO">${cmd} = neutron router-gateway-set --disable-snat 437b919f-bcd8-4fce-9f63-edc1dfd80c0a 867d67fc-10e7-464e-8fdd-8c30f102826e</msg>
<status status="PASS" endtime="20190402 07:24:47.682" starttime="20190402 07:24:47.681"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:47.682" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:47.682" starttime="20190402 07:24:47.682"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:47.683" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron router-gateway-set --disable-snat 437b919f-bcd8-4fce-9f63-edc1dfd80c0a 867d67fc-10e7-464e-8fdd-8c30f102826e'.</msg>
<msg timestamp="20190402 07:24:50.176" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:50.177" level="INFO">${stdout} = Set gateway for router 437b919f-bcd8-4fce-9f63-edc1dfd80c0a</msg>
<msg timestamp="20190402 07:24:50.177" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:50.177" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:50.177" starttime="20190402 07:24:47.683"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:50.179" level="INFO">${res} = {u'stdout': u'Set gateway for router 437b919f-bcd8-4fce-9f63-edc1dfd80c0a', u'stderr': u'neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.', u'rc': 0}</msg>
<status status="PASS" endtime="20190402 07:24:50.180" starttime="20190402 07:24:50.178"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:50.181" starttime="20190402 07:24:50.180"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:50.181" starttime="20190402 07:24:47.682"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>neutron router-interface-add ${publicrouter} ${publicsubnet}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:50.182" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:50.182" starttime="20190402 07:24:50.182"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:50.182" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron router-interface-add public-router0 public-subnet0'.</msg>
<msg timestamp="20190402 07:24:52.633" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:52.634" level="INFO">${stdout} = Added interface 00b23a3e-77eb-42fd-afb5-556855d46685 to router public-router0.</msg>
<msg timestamp="20190402 07:24:52.634" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:52.634" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:52.634" starttime="20190402 07:24:50.182"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:52.636" level="INFO">${res} = {u'stdout': u'Added interface 00b23a3e-77eb-42fd-afb5-556855d46685 to router public-router0.', u'stderr': u'neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.', u'...</msg>
<status status="PASS" endtime="20190402 07:24:52.637" starttime="20190402 07:24:52.635"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:52.638" starttime="20190402 07:24:52.637"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:52.638" starttime="20190402 07:24:50.181"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>neutron router-interface-add ${privaterouter} ${privatesubnet}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190402 07:24:52.639" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190402 07:24:52.639" starttime="20190402 07:24:52.639"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190402 07:24:52.639" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; neutron router-interface-add private-router0 private-subnet0'.</msg>
<msg timestamp="20190402 07:24:55.427" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190402 07:24:55.428" level="INFO">${stdout} = Added interface 85f69b05-5e1f-45da-9e0c-1d7eb5fc6c37 to router private-router0.</msg>
<msg timestamp="20190402 07:24:55.428" level="INFO">${stderr} = neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.</msg>
<msg timestamp="20190402 07:24:55.428" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190402 07:24:55.428" starttime="20190402 07:24:52.639"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190402 07:24:55.430" level="INFO">${res} = {u'stdout': u'Added interface 85f69b05-5e1f-45da-9e0c-1d7eb5fc6c37 to router private-router0.', u'stderr': u'neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead.', u...</msg>
<status status="PASS" endtime="20190402 07:24:55.430" starttime="20190402 07:24:55.429"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190402 07:24:55.432" starttime="20190402 07:24:55.431"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:55.432" starttime="20190402 07:24:52.638"></status>
</kw>
<status status="PASS" endtime="20190402 07:24:55.432" starttime="20190402 07:24:24.495"></status>
</kw>
<doc>Validates provisioning of a duplex configuration
according to steps defined at
"https://wiki.openstack.org/wiki/StarlingX/Containers/
InstallationOnAIODX"</doc>
<tags>
<tag>Duplex</tag>
</tags>
<status status="PASS" endtime="20190402 07:24:55.432" critical="yes" starttime="20190402 06:58:14.677"></status>
</test>
<doc>Tests for provisioning and unlocking controllers, computes and
storage hosts.
Author(s):
- Jose Perez Carranza &lt;jose.perez.carranza@intel.com&gt;
- Juan Carlos Alonso &lt;juan.carlos.alonso@intel.com&gt;</doc>
<metadata>
<item name="ISO">bootimage.iso</item>
<item name="System">duplex</item>
</metadata>
<status status="PASS" endtime="20190402 07:24:55.433" starttime="20190402 06:58:13.040"></status>
</suite>
<statistics>
<total>
<stat fail="0" pass="1">Critical Tests</stat>
<stat fail="0" pass="1">All Tests</stat>
</total>
<tag>
<stat fail="0" pass="1">Duplex</stat>
</tag>
<suite>
<stat fail="0" id="s1" name="Provision-Containers" pass="1">Provision-Containers</stat>
</suite>
</statistics>
<errors>
</errors>
</robot>
