<?xml version="1.0" encoding="UTF-8"?>
<robot rpa="false" generated="20190401 12:29:08.394" generator="Robot 3.1.1 (Python 2.7.15 on linux2)">
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Provision-Containers.robot" id="s1" name="Provision-Containers">
<kw type="setup" name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Utils.Stx Suite Setup</arg>
<arg>provisioning.Assign Data Interfaces</arg>
</arguments>
<kw name="Stx Suite Setup" library="Utils">
<doc>Wrapper to setup the environment needed for exercise
StarlingX features</doc>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190401 12:29:08.566" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 12:29:08.566" starttime="20190401 12:29:08.566"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190401 12:29:08.567" level="INFO">Length is 10</msg>
<msg timestamp="20190401 12:29:08.567" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190401 12:29:08.567" starttime="20190401 12:29:08.567"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190401 12:29:08.567" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190401 12:29:09.735" level="INFO">Read output: Last login: Mon Apr  1 17:30:56 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<msg timestamp="20190401 12:29:09.736" level="INFO">/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:39: CryptographyDeprecationWarning: encode_point has been deprecated on EllipticCurvePublicNumbers and will be removed in a future version. Please use EllipticCurvePublicKey.public_bytes to obtain both compressed and uncompressed point encoding.
  m.add_string(self.Q_C.public_numbers().encode_point())
/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:96: CryptographyDeprecationWarning: Support for unsafe construction of public numbers from encoded data will be removed in a future version. Please use EllipticCurvePublicKey.from_encoded_point
  self.curve, Q_S_bytes
/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:111: CryptographyDeprecationWarning: encode_point has been deprecated on EllipticCurvePublicNumbers and will be removed in a future version. Please use EllipticCurvePublicKey.public_bytes to obtain both compressed and uncompressed point encoding.
  hm.add_string(self.Q_C.public_numbers().encode_point())</msg>
<status status="PASS" endtime="20190401 12:29:09.736" starttime="20190401 12:29:08.567"></status>
</kw>
<msg timestamp="20190401 12:29:09.736" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 12:29:09.736" starttime="20190401 12:29:08.567"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:09.736" starttime="20190401 12:29:08.566"></status>
</kw>
<msg timestamp="20190401 12:29:09.736" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 12:29:09.736" starttime="20190401 12:29:08.565"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 12:29:09.737" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 12:29:09.737" starttime="20190401 12:29:09.737"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 12:29:09.737" level="INFO">1</msg>
<status status="PASS" endtime="20190401 12:29:09.737" starttime="20190401 12:29:09.737"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:09.737" starttime="20190401 12:29:08.565"></status>
</kw>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:09.739" starttime="20190401 12:29:09.738"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:09.739" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:09.739" starttime="20190401 12:29:09.739"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:09.740" starttime="20190401 12:29:09.740"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:09.740" starttime="20190401 12:29:09.740"></status>
</kw>
<msg timestamp="20190401 12:29:09.740" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:09.740" starttime="20190401 12:29:09.739"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190401 12:29:09.741" starttime="20190401 12:29:09.741"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:09.744" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:29:09.745" starttime="20190401 12:29:09.741"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:10.142" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:10.142" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:10.142" starttime="20190401 12:29:09.745"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:10.143" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:10.143" starttime="20190401 12:29:10.143"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:10.144" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 12:29:10.144" starttime="20190401 12:29:10.143"></status>
</kw>
<msg timestamp="20190401 12:29:10.144" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 12:29:10.144" starttime="20190401 12:29:10.143"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:10.146" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:10.146" starttime="20190401 12:29:10.144"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:10.147" level="INFO">0</msg>
<msg timestamp="20190401 12:29:10.147" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:10.147" starttime="20190401 12:29:10.146"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:10.147" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:10.147" starttime="20190401 12:29:10.147"></status>
</kw>
<msg timestamp="20190401 12:29:10.147" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:10.147" starttime="20190401 12:29:10.144"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:10.148" starttime="20190401 12:29:10.148"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:10.148" starttime="20190401 12:29:10.147"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:10.148" starttime="20190401 12:29:10.148"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:10.149" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 12:29:10.149" starttime="20190401 12:29:10.148"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:10.149" starttime="20190401 12:29:09.738"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:10.149" starttime="20190401 12:29:09.738"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:10.149" starttime="20190401 12:29:08.565"></status>
</kw>
<kw name="Assign Data Interfaces" library="provisioning">
<doc>Set variables for Data interfaces according to the
configuration selected</doc>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${ENVIRONMENT}'=='virtual'</arg>
<arg>Create List</arg>
<arg>eth1000</arg>
<arg>eth1001</arg>
<arg>ELSE</arg>
<arg>Create List</arg>
<arg>enp24s0f0</arg>
<arg>enp24s0f1</arg>
</arguments>
<assign>
<var>@{data_interfaces}</var>
</assign>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<arguments>
<arg>enp24s0f0</arg>
<arg>enp24s0f1</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:10.150" starttime="20190401 12:29:10.150"></status>
</kw>
<msg timestamp="20190401 12:29:10.150" level="INFO">@{data_interfaces} = [ enp24s0f0 | enp24s0f1 ]</msg>
<status status="PASS" endtime="20190401 12:29:10.150" starttime="20190401 12:29:10.149"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${data_interfaces}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data0if}</var>
</assign>
<msg timestamp="20190401 12:29:10.150" level="INFO">${data0if} = enp24s0f0</msg>
<status status="PASS" endtime="20190401 12:29:10.150" starttime="20190401 12:29:10.150"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${data_interfaces}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data1if}</var>
</assign>
<msg timestamp="20190401 12:29:10.151" level="INFO">${data1if} = enp24s0f1</msg>
<status status="PASS" endtime="20190401 12:29:10.151" starttime="20190401 12:29:10.150"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${data0if}</arg>
</arguments>
<msg timestamp="20190401 12:29:10.151" level="INFO">${data0if} = enp24s0f0</msg>
<status status="PASS" endtime="20190401 12:29:10.151" starttime="20190401 12:29:10.151"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${data1if}</arg>
</arguments>
<msg timestamp="20190401 12:29:10.151" level="INFO">${data1if} = enp24s0f1</msg>
<status status="PASS" endtime="20190401 12:29:10.151" starttime="20190401 12:29:10.151"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:10.151" starttime="20190401 12:29:10.149"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:10.152" starttime="20190401 12:29:08.565"></status>
</kw>
<test id="s1-t1" name="Provisioning Duplex System">
<kw name="Set NTP Server" library="Utils">
<doc>Setup the NTP servers for the system.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>0.pool.ntp.org,1.pool.ntp.org</arg>
</arguments>
<assign>
<var>${ntp_servers}</var>
</assign>
<msg timestamp="20190401 12:29:10.152" level="INFO">${ntp_servers} = 0.pool.ntp.org,1.pool.ntp.org</msg>
<status status="PASS" endtime="20190401 12:29:10.152" starttime="20190401 12:29:10.152"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system ntp-modify ntpservers=${ntp_servers}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:10.153" starttime="20190401 12:29:10.153"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:10.154" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:10.154" starttime="20190401 12:29:10.153"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:10.154" starttime="20190401 12:29:10.154"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:10.155" starttime="20190401 12:29:10.154"></status>
</kw>
<msg timestamp="20190401 12:29:10.155" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:10.155" starttime="20190401 12:29:10.153"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:10.155" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:10.155" starttime="20190401 12:29:10.155"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:10.164" level="INFO">system ntp-modify ntpservers=0.pool.nt p.org,1.pool.ntp.org</msg>
<status status="PASS" endtime="20190401 12:29:10.164" starttime="20190401 12:29:10.155"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:11.380" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| uuid         | 1a8f19bb-94ae-44a6-adea-fc62cf163b64 |
| enabled      | True                                 |
| ntpservers   | 0.pool.ntp.org,1.pool.ntp.org        |
| isystem_uuid | 70f7a398-43e0-494a-9841-7c2400ea887d |
| created_at   | 2019-04-01T12:39:33.550494+00:00     |
| updated_at   | None                                 |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:11.380" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| uuid         | 1a8f19bb-94a...</msg>
<status status="PASS" endtime="20190401 12:29:11.380" starttime="20190401 12:29:10.164"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:11.381" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:11.381" starttime="20190401 12:29:11.380"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:11.381" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| uuid         | 1a8f19bb-94a...</msg>
<status status="PASS" endtime="20190401 12:29:11.381" starttime="20190401 12:29:11.381"></status>
</kw>
<msg timestamp="20190401 12:29:11.381" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| uuid         | 1a8f19bb-94a...</msg>
<status status="PASS" endtime="20190401 12:29:11.381" starttime="20190401 12:29:11.380"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:11.383" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:11.383" starttime="20190401 12:29:11.382"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:11.384" level="INFO">0</msg>
<msg timestamp="20190401 12:29:11.384" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:11.384" starttime="20190401 12:29:11.383"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:11.385" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:11.385" starttime="20190401 12:29:11.384"></status>
</kw>
<msg timestamp="20190401 12:29:11.385" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:11.385" starttime="20190401 12:29:11.381"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:11.386" starttime="20190401 12:29:11.385"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:11.386" starttime="20190401 12:29:11.385"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:11.386" starttime="20190401 12:29:11.386"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:11.386" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| uuid         | 1a8f19bb-94ae-44a6-adea-fc62cf163b64 |
| enabled      | True                                 |
| ntpservers   | 0.pool.ntp.org,1.pool.ntp.org        |
| isystem_uuid | 70f7a398-43e0-494a-9841-7c2400ea887d |
| created_at   | 2019-04-01T12:39:33.550494+00:00     |
| updated_at   | None                                 |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:11.386" starttime="20190401 12:29:11.386"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:11.386" starttime="20190401 12:29:10.153"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:11.387" starttime="20190401 12:29:10.152"></status>
</kw>
<kw name="Configure Data Interfaces" library="Utils">
<doc>Configure data interfaces with proper values.</doc>
<arguments>
<arg>${master_controller}</arg>
<arg>${data0if}</arg>
<arg>${data1if}</arg>
<arg>${physnet0}</arg>
<arg>${physnet1}</arg>
<arg>${mtu}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>Run Keywords</arg>
<arg>Provide OAM Network Interface</arg>
<arg>${host}</arg>
<arg>AND</arg>
<arg>Setup Cluster-host Interfaces</arg>
<arg>${host}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:11.388" starttime="20190401 12:29:11.387"></status>
</kw>
<kw name="Get Interface Information" library="Utils">
<doc>Returns a dictionary with the values of the spcecified
interface.</doc>
<arguments>
<arg>${host}</arg>
<arg>${data0if}</arg>
</arguments>
<assign>
<var>${iface_info}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-port-list ${host} --nowrap</arg>
<arg>grep ${interface}</arg>
<arg>awk '{ print $2,$4,$8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:29:11.388" level="INFO">${cmd} = system host-port-list controller-0 --nowrap|grep enp24s0f0|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190401 12:29:11.388" starttime="20190401 12:29:11.388"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:11.389" starttime="20190401 12:29:11.389"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:11.390" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:11.390" starttime="20190401 12:29:11.389"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:11.390" starttime="20190401 12:29:11.390"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:11.390" starttime="20190401 12:29:11.390"></status>
</kw>
<msg timestamp="20190401 12:29:11.390" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:11.391" starttime="20190401 12:29:11.389"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:11.391" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:11.391" starttime="20190401 12:29:11.391"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:11.402" level="INFO">system host-port-list controller-0 --n owrap|grep enp24s0f0|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190401 12:29:11.402" starttime="20190401 12:29:11.391"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:12.472" level="INFO">88540f4d-5965-4d05-9d76-879dcf791d23 enp24s0f0 0000:18:00.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:12.472" level="INFO">${output} = 88540f4d-5965-4d05-9d76-879dcf791d23 enp24s0f0 0000:18:00.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:12.472" starttime="20190401 12:29:11.402"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:12.473" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:12.473" starttime="20190401 12:29:12.473"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:12.474" level="INFO">${clean_out} = 88540f4d-5965-4d05-9d76-879dcf791d23 enp24s0f0 0000:18:00.0
</msg>
<status status="PASS" endtime="20190401 12:29:12.474" starttime="20190401 12:29:12.473"></status>
</kw>
<msg timestamp="20190401 12:29:12.474" level="INFO">${output} = 88540f4d-5965-4d05-9d76-879dcf791d23 enp24s0f0 0000:18:00.0
</msg>
<status status="PASS" endtime="20190401 12:29:12.474" starttime="20190401 12:29:12.473"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:12.476" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:12.476" starttime="20190401 12:29:12.474"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:12.477" level="INFO">0</msg>
<msg timestamp="20190401 12:29:12.477" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:12.477" starttime="20190401 12:29:12.476"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:12.477" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:12.477" starttime="20190401 12:29:12.477"></status>
</kw>
<msg timestamp="20190401 12:29:12.477" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:12.477" starttime="20190401 12:29:12.474"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:12.478" starttime="20190401 12:29:12.478"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:12.478" starttime="20190401 12:29:12.477"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:12.478" starttime="20190401 12:29:12.478"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:12.479" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 88540f4d-5965-4d05-9d76-879dcf791d23 enp24s0f0 0000:18:00.0</msg>
<status status="PASS" endtime="20190401 12:29:12.479" starttime="20190401 12:29:12.478"></status>
</kw>
<msg timestamp="20190401 12:29:12.479" level="INFO">${info} = {u'stdout': u'88540f4d-5965-4d05-9d76-879dcf791d23 enp24s0f0 0000:18:00.0', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:29:12.479" starttime="20190401 12:29:11.388"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${info}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 12:29:12.479" level="INFO">${response} = 88540f4d-5965-4d05-9d76-879dcf791d23 enp24s0f0 0000:18:00.0</msg>
<status status="PASS" endtime="20190401 12:29:12.479" starttime="20190401 12:29:12.479"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 12:29:12.480" level="INFO">@{res_in_list} = [ 88540f4d-5965-4d05-9d76-879dcf791d23 | enp24s0f0 | 0000:18:00.0 ]</msg>
<status status="PASS" endtime="20190401 12:29:12.480" starttime="20190401 12:29:12.480"></status>
</kw>
<msg timestamp="20190401 12:29:12.480" level="INFO">${info} = [u'88540f4d-5965-4d05-9d76-879dcf791d23', u'enp24s0f0', u'0000:18:00.0']</msg>
<status status="PASS" endtime="20190401 12:29:12.480" starttime="20190401 12:29:12.479"></status>
</kw>
<msg timestamp="20190401 12:29:12.480" level="INFO">${iface_info} = [u'88540f4d-5965-4d05-9d76-879dcf791d23', u'enp24s0f0', u'0000:18:00.0']</msg>
<status status="PASS" endtime="20190401 12:29:12.480" starttime="20190401 12:29:11.388"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data0portuuid}</var>
</assign>
<msg timestamp="20190401 12:29:12.480" level="INFO">${data0portuuid} = 88540f4d-5965-4d05-9d76-879dcf791d23</msg>
<status status="PASS" endtime="20190401 12:29:12.480" starttime="20190401 12:29:12.480"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data0portname}</var>
</assign>
<msg timestamp="20190401 12:29:12.481" level="INFO">${data0portname} = enp24s0f0</msg>
<status status="PASS" endtime="20190401 12:29:12.481" starttime="20190401 12:29:12.481"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>2</arg>
</arguments>
<assign>
<var>${data0pciaddr}</var>
</assign>
<msg timestamp="20190401 12:29:12.481" level="INFO">${data0pciaddr} = 0000:18:00.0</msg>
<status status="PASS" endtime="20190401 12:29:12.481" starttime="20190401 12:29:12.481"></status>
</kw>
<kw name="Get Interface Information" library="Utils">
<doc>Returns a dictionary with the values of the spcecified
interface.</doc>
<arguments>
<arg>${host}</arg>
<arg>${data1if}</arg>
</arguments>
<assign>
<var>${iface_info}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-port-list ${host} --nowrap</arg>
<arg>grep ${interface}</arg>
<arg>awk '{ print $2,$4,$8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:29:12.482" level="INFO">${cmd} = system host-port-list controller-0 --nowrap|grep enp24s0f1|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190401 12:29:12.482" starttime="20190401 12:29:12.482"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:12.483" starttime="20190401 12:29:12.482"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:12.483" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:12.483" starttime="20190401 12:29:12.483"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:12.484" starttime="20190401 12:29:12.483"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:12.484" starttime="20190401 12:29:12.484"></status>
</kw>
<msg timestamp="20190401 12:29:12.484" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:12.484" starttime="20190401 12:29:12.483"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:12.485" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:12.485" starttime="20190401 12:29:12.484"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:12.497" level="INFO">system host-port-list controller-0 --n owrap|grep enp24s0f1|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190401 12:29:12.497" starttime="20190401 12:29:12.485"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:13.529" level="INFO">4ad15bb3-9cb9-4f10-ae6d-149e064a196e enp24s0f1 0000:18:00.1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:13.529" level="INFO">${output} = 4ad15bb3-9cb9-4f10-ae6d-149e064a196e enp24s0f1 0000:18:00.1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:13.529" starttime="20190401 12:29:12.497"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:13.530" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:13.530" starttime="20190401 12:29:13.529"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:13.530" level="INFO">${clean_out} = 4ad15bb3-9cb9-4f10-ae6d-149e064a196e enp24s0f1 0000:18:00.1
</msg>
<status status="PASS" endtime="20190401 12:29:13.530" starttime="20190401 12:29:13.530"></status>
</kw>
<msg timestamp="20190401 12:29:13.530" level="INFO">${output} = 4ad15bb3-9cb9-4f10-ae6d-149e064a196e enp24s0f1 0000:18:00.1
</msg>
<status status="PASS" endtime="20190401 12:29:13.530" starttime="20190401 12:29:13.529"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:13.532" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:13.532" starttime="20190401 12:29:13.531"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:13.533" level="INFO">0</msg>
<msg timestamp="20190401 12:29:13.533" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:13.533" starttime="20190401 12:29:13.532"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:13.533" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:13.533" starttime="20190401 12:29:13.533"></status>
</kw>
<msg timestamp="20190401 12:29:13.534" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:13.534" starttime="20190401 12:29:13.530"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:13.534" starttime="20190401 12:29:13.534"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:13.534" starttime="20190401 12:29:13.534"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:13.535" starttime="20190401 12:29:13.534"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:13.535" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 4ad15bb3-9cb9-4f10-ae6d-149e064a196e enp24s0f1 0000:18:00.1</msg>
<status status="PASS" endtime="20190401 12:29:13.535" starttime="20190401 12:29:13.535"></status>
</kw>
<msg timestamp="20190401 12:29:13.535" level="INFO">${info} = {u'stdout': u'4ad15bb3-9cb9-4f10-ae6d-149e064a196e enp24s0f1 0000:18:00.1', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:29:13.535" starttime="20190401 12:29:12.482"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${info}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 12:29:13.536" level="INFO">${response} = 4ad15bb3-9cb9-4f10-ae6d-149e064a196e enp24s0f1 0000:18:00.1</msg>
<status status="PASS" endtime="20190401 12:29:13.536" starttime="20190401 12:29:13.536"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 12:29:13.536" level="INFO">@{res_in_list} = [ 4ad15bb3-9cb9-4f10-ae6d-149e064a196e | enp24s0f1 | 0000:18:00.1 ]</msg>
<status status="PASS" endtime="20190401 12:29:13.536" starttime="20190401 12:29:13.536"></status>
</kw>
<msg timestamp="20190401 12:29:13.536" level="INFO">${info} = [u'4ad15bb3-9cb9-4f10-ae6d-149e064a196e', u'enp24s0f1', u'0000:18:00.1']</msg>
<status status="PASS" endtime="20190401 12:29:13.536" starttime="20190401 12:29:13.535"></status>
</kw>
<msg timestamp="20190401 12:29:13.537" level="INFO">${iface_info} = [u'4ad15bb3-9cb9-4f10-ae6d-149e064a196e', u'enp24s0f1', u'0000:18:00.1']</msg>
<status status="PASS" endtime="20190401 12:29:13.537" starttime="20190401 12:29:12.481"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data1portuuid}</var>
</assign>
<msg timestamp="20190401 12:29:13.537" level="INFO">${data1portuuid} = 4ad15bb3-9cb9-4f10-ae6d-149e064a196e</msg>
<status status="PASS" endtime="20190401 12:29:13.537" starttime="20190401 12:29:13.537"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data1portname}</var>
</assign>
<msg timestamp="20190401 12:29:13.537" level="INFO">${data1portname} = enp24s0f1</msg>
<status status="PASS" endtime="20190401 12:29:13.537" starttime="20190401 12:29:13.537"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>2</arg>
</arguments>
<assign>
<var>${data1pciaddr}</var>
</assign>
<msg timestamp="20190401 12:29:13.538" level="INFO">${data1pciaddr} = 0000:18:00.1</msg>
<status status="PASS" endtime="20190401 12:29:13.538" starttime="20190401 12:29:13.538"></status>
</kw>
<kw name="Get Interface UUID" library="Utils">
<doc>Get Interface id of the specified host and port</doc>
<arguments>
<arg>${host}</arg>
<arg>${data0portname}</arg>
</arguments>
<assign>
<var>${data0ifuuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-if-list -a ${host}</arg>
<arg>grep ${port_name}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:29:13.538" level="INFO">${cmd} = system host-if-list -a controller-0|grep enp24s0f0|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:29:13.538" starttime="20190401 12:29:13.538"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${uuid}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:13.539" starttime="20190401 12:29:13.539"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:13.540" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:13.540" starttime="20190401 12:29:13.539"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:13.540" starttime="20190401 12:29:13.540"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:13.540" starttime="20190401 12:29:13.540"></status>
</kw>
<msg timestamp="20190401 12:29:13.541" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:13.541" starttime="20190401 12:29:13.539"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:13.541" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:13.541" starttime="20190401 12:29:13.541"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:13.552" level="INFO">system host-if-list -a controller-0|gr ep enp24s0f0|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:29:13.552" starttime="20190401 12:29:13.541"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:14.716" level="INFO">346fc6f9-06d4-4da0-a94e-7527e852f07e
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:14.716" level="INFO">${output} = 346fc6f9-06d4-4da0-a94e-7527e852f07e
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:14.716" starttime="20190401 12:29:13.552"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:14.717" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:14.717" starttime="20190401 12:29:14.717"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:14.717" level="INFO">${clean_out} = 346fc6f9-06d4-4da0-a94e-7527e852f07e
</msg>
<status status="PASS" endtime="20190401 12:29:14.717" starttime="20190401 12:29:14.717"></status>
</kw>
<msg timestamp="20190401 12:29:14.717" level="INFO">${output} = 346fc6f9-06d4-4da0-a94e-7527e852f07e
</msg>
<status status="PASS" endtime="20190401 12:29:14.717" starttime="20190401 12:29:14.716"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:14.719" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:14.719" starttime="20190401 12:29:14.718"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:14.720" level="INFO">0</msg>
<msg timestamp="20190401 12:29:14.720" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:14.720" starttime="20190401 12:29:14.720"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:14.721" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:14.721" starttime="20190401 12:29:14.720"></status>
</kw>
<msg timestamp="20190401 12:29:14.721" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:14.721" starttime="20190401 12:29:14.717"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:14.722" starttime="20190401 12:29:14.721"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:14.722" starttime="20190401 12:29:14.721"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:14.722" starttime="20190401 12:29:14.722"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:14.722" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 346fc6f9-06d4-4da0-a94e-7527e852f07e</msg>
<status status="PASS" endtime="20190401 12:29:14.722" starttime="20190401 12:29:14.722"></status>
</kw>
<msg timestamp="20190401 12:29:14.722" level="INFO">${uuid} = {u'stdout': u'346fc6f9-06d4-4da0-a94e-7527e852f07e', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:29:14.722" starttime="20190401 12:29:13.539"></status>
</kw>
<msg timestamp="20190401 12:29:14.723" level="INFO">${data0ifuuid} = 346fc6f9-06d4-4da0-a94e-7527e852f07e</msg>
<status status="PASS" endtime="20190401 12:29:14.723" starttime="20190401 12:29:13.538"></status>
</kw>
<kw name="Get Interface UUID" library="Utils">
<doc>Get Interface id of the specified host and port</doc>
<arguments>
<arg>${host}</arg>
<arg>${data1portname}</arg>
</arguments>
<assign>
<var>${data1ifuuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-if-list -a ${host}</arg>
<arg>grep ${port_name}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:29:14.723" level="INFO">${cmd} = system host-if-list -a controller-0|grep enp24s0f1|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:29:14.723" starttime="20190401 12:29:14.723"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${uuid}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:14.725" starttime="20190401 12:29:14.725"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:14.726" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:14.726" starttime="20190401 12:29:14.725"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:14.726" starttime="20190401 12:29:14.726"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:14.726" starttime="20190401 12:29:14.726"></status>
</kw>
<msg timestamp="20190401 12:29:14.726" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:14.727" starttime="20190401 12:29:14.725"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:14.727" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:14.727" starttime="20190401 12:29:14.727"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:14.737" level="INFO">system host-if-list -a controller-0|gr ep enp24s0f1|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:29:14.737" starttime="20190401 12:29:14.727"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:15.882" level="INFO">7031ca08-1ddc-40dd-8486-d701c782a78e
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:15.882" level="INFO">${output} = 7031ca08-1ddc-40dd-8486-d701c782a78e
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:15.882" starttime="20190401 12:29:14.737"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:15.883" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:15.883" starttime="20190401 12:29:15.883"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:15.883" level="INFO">${clean_out} = 7031ca08-1ddc-40dd-8486-d701c782a78e
</msg>
<status status="PASS" endtime="20190401 12:29:15.883" starttime="20190401 12:29:15.883"></status>
</kw>
<msg timestamp="20190401 12:29:15.884" level="INFO">${output} = 7031ca08-1ddc-40dd-8486-d701c782a78e
</msg>
<status status="PASS" endtime="20190401 12:29:15.884" starttime="20190401 12:29:15.883"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:15.886" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:15.886" starttime="20190401 12:29:15.884"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:15.886" level="INFO">0</msg>
<msg timestamp="20190401 12:29:15.886" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:15.886" starttime="20190401 12:29:15.886"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:15.887" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:15.887" starttime="20190401 12:29:15.886"></status>
</kw>
<msg timestamp="20190401 12:29:15.887" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:15.887" starttime="20190401 12:29:15.884"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:15.887" starttime="20190401 12:29:15.887"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:15.888" starttime="20190401 12:29:15.887"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:15.888" starttime="20190401 12:29:15.888"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:15.888" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 7031ca08-1ddc-40dd-8486-d701c782a78e</msg>
<status status="PASS" endtime="20190401 12:29:15.888" starttime="20190401 12:29:15.888"></status>
</kw>
<msg timestamp="20190401 12:29:15.888" level="INFO">${uuid} = {u'stdout': u'7031ca08-1ddc-40dd-8486-d701c782a78e', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:29:15.888" starttime="20190401 12:29:14.724"></status>
</kw>
<msg timestamp="20190401 12:29:15.889" level="INFO">${data1ifuuid} = 7031ca08-1ddc-40dd-8486-d701c782a78e</msg>
<status status="PASS" endtime="20190401 12:29:15.889" starttime="20190401 12:29:14.723"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-0' or '${host}'=='compute-0'</arg>
<arg>Run Keywords</arg>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet0} vlan</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet1} vlan</arg>
<arg>True</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet0} vlan</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet1} vlan</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system datanetwork-add ${physnet0} vlan</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:15.890" starttime="20190401 12:29:15.890"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:15.891" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:15.891" starttime="20190401 12:29:15.890"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:15.891" starttime="20190401 12:29:15.891"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:15.891" starttime="20190401 12:29:15.891"></status>
</kw>
<msg timestamp="20190401 12:29:15.892" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:15.892" starttime="20190401 12:29:15.890"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:15.892" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:15.892" starttime="20190401 12:29:15.892"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:15.897" level="INFO">system datanetwork-add physnet0 vlan</msg>
<status status="PASS" endtime="20190401 12:29:15.897" starttime="20190401 12:29:15.892"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:16.918" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 1                                    |
| uuid         | b2523c22-0181-4364-921e-44055f394a7e |
| name         | physnet0                             |
| network_type | vlan                                 |
| mtu          | 1500                                 |
| description  | None                                 |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:16.918" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 1           ...</msg>
<status status="PASS" endtime="20190401 12:29:16.918" starttime="20190401 12:29:15.898"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:16.919" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:16.919" starttime="20190401 12:29:16.919"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:16.920" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 1           ...</msg>
<status status="PASS" endtime="20190401 12:29:16.920" starttime="20190401 12:29:16.919"></status>
</kw>
<msg timestamp="20190401 12:29:16.920" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 1           ...</msg>
<status status="PASS" endtime="20190401 12:29:16.920" starttime="20190401 12:29:16.919"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:16.922" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:16.922" starttime="20190401 12:29:16.920"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:16.922" level="INFO">0</msg>
<msg timestamp="20190401 12:29:16.922" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:16.922" starttime="20190401 12:29:16.922"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:16.923" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:16.923" starttime="20190401 12:29:16.923"></status>
</kw>
<msg timestamp="20190401 12:29:16.923" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:16.923" starttime="20190401 12:29:16.920"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:16.924" starttime="20190401 12:29:16.923"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:16.924" starttime="20190401 12:29:16.923"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:16.924" starttime="20190401 12:29:16.924"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:16.924" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 1                                    |
| uuid         | b2523c22-0181-4364-921e-44055f394a7e |
| name         | physnet0                             |
| network_type | vlan                                 |
| mtu          | 1500                                 |
| description  | None                                 |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:16.924" starttime="20190401 12:29:16.924"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:16.924" starttime="20190401 12:29:15.889"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system datanetwork-add ${physnet1} vlan</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:16.925" starttime="20190401 12:29:16.925"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:16.926" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:16.926" starttime="20190401 12:29:16.926"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:16.926" starttime="20190401 12:29:16.926"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:16.927" starttime="20190401 12:29:16.926"></status>
</kw>
<msg timestamp="20190401 12:29:16.927" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:16.927" starttime="20190401 12:29:16.925"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:16.927" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:16.927" starttime="20190401 12:29:16.927"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:16.933" level="INFO">system datanetwork-add physnet1 vlan</msg>
<status status="PASS" endtime="20190401 12:29:16.933" starttime="20190401 12:29:16.927"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:17.962" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 2                                    |
| uuid         | c417debc-e74f-42d0-b7a2-0a159b28c60c |
| name         | physnet1                             |
| network_type | vlan                                 |
| mtu          | 1500                                 |
| description  | None                                 |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:17.962" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 2           ...</msg>
<status status="PASS" endtime="20190401 12:29:17.962" starttime="20190401 12:29:16.933"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:17.963" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:17.963" starttime="20190401 12:29:17.963"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:17.963" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 2           ...</msg>
<status status="PASS" endtime="20190401 12:29:17.963" starttime="20190401 12:29:17.963"></status>
</kw>
<msg timestamp="20190401 12:29:17.963" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 2           ...</msg>
<status status="PASS" endtime="20190401 12:29:17.963" starttime="20190401 12:29:17.962"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:17.966" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:17.966" starttime="20190401 12:29:17.964"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:17.966" level="INFO">0</msg>
<msg timestamp="20190401 12:29:17.966" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:17.966" starttime="20190401 12:29:17.966"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:17.967" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:17.967" starttime="20190401 12:29:17.967"></status>
</kw>
<msg timestamp="20190401 12:29:17.967" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:17.967" starttime="20190401 12:29:17.963"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:17.968" starttime="20190401 12:29:17.968"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:17.968" starttime="20190401 12:29:17.967"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:17.968" starttime="20190401 12:29:17.968"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:17.968" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| id           | 2                                    |
| uuid         | c417debc-e74f-42d0-b7a2-0a159b28c60c |
| name         | physnet1                             |
| network_type | vlan                                 |
| mtu          | 1500                                 |
| description  | None                                 |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:17.968" starttime="20190401 12:29:17.968"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:17.969" starttime="20190401 12:29:16.925"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:17.969" starttime="20190401 12:29:15.889"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:17.969" starttime="20190401 12:29:15.889"></status>
</kw>
<kw name="Add Interface To Data Network" library="Utils">
<doc>Adds an interface to the specified data network.</doc>
<arguments>
<arg>${mtu}</arg>
<arg>data0</arg>
<arg>${physnet0}</arg>
<arg>${host}</arg>
<arg>${data0ifuuid}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controler-0'</arg>
<arg>-d</arg>
<arg>-p</arg>
</arguments>
<assign>
<var>${option}</var>
</assign>
<msg timestamp="20190401 12:29:17.969" level="INFO">${option} = -p</msg>
<status status="PASS" endtime="20190401 12:29:17.969" starttime="20190401 12:29:17.969"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system host-if-modify</arg>
<arg>-m ${mtu}</arg>
<arg>-n ${if_name}</arg>
<arg>${option} ${datanetwork}</arg>
<arg>-c data</arg>
<arg>${host}</arg>
<arg>${uuid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:29:17.970" level="INFO">${cmd} = system host-if-modify -m 1500 -n data0 -p physnet0 -c data controller-0 346fc6f9-06d4-4da0-a94e-7527e852f07e</msg>
<status status="PASS" endtime="20190401 12:29:17.970" starttime="20190401 12:29:17.970"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:17.971" starttime="20190401 12:29:17.970"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:17.971" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:17.971" starttime="20190401 12:29:17.971"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:17.972" starttime="20190401 12:29:17.971"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:17.972" starttime="20190401 12:29:17.972"></status>
</kw>
<msg timestamp="20190401 12:29:17.972" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:17.972" starttime="20190401 12:29:17.971"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:17.972" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:17.972" starttime="20190401 12:29:17.972"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:17.985" level="INFO">system host-if-modify -m 1500 -n data0  -p physnet0 -c data controller-0 346fc6f9-06d4-4da0-a94e-7527e852f07e</msg>
<status status="PASS" endtime="20190401 12:29:17.985" starttime="20190401 12:29:17.973"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:19.638" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f0']                       |
| datanetworks | [u'physnet0']                        |
| imac         | 3c:fd:fe:be:e0:cc                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 346fc6f9-06d4-4da0-a94e-7527e852f07e |
| ihost_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T12:40:22.969704+00:00     |
| updated_at   | 2019-04-01T18:18:04.205141+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:19.638" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190401 12:29:19.638" starttime="20190401 12:29:17.985"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:19.639" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:19.639" starttime="20190401 12:29:19.638"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:19.639" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190401 12:29:19.639" starttime="20190401 12:29:19.639"></status>
</kw>
<msg timestamp="20190401 12:29:19.639" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190401 12:29:19.639" starttime="20190401 12:29:19.638"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:19.641" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:19.641" starttime="20190401 12:29:19.639"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:19.642" level="INFO">0</msg>
<msg timestamp="20190401 12:29:19.642" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:19.642" starttime="20190401 12:29:19.641"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:19.643" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:19.643" starttime="20190401 12:29:19.642"></status>
</kw>
<msg timestamp="20190401 12:29:19.643" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:19.643" starttime="20190401 12:29:19.639"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:19.644" starttime="20190401 12:29:19.643"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:19.644" starttime="20190401 12:29:19.643"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:19.644" starttime="20190401 12:29:19.644"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:19.644" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f0']                       |
| datanetworks | [u'physnet0']                        |
| imac         | 3c:fd:fe:be:e0:cc                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 346fc6f9-06d4-4da0-a94e-7527e852f07e |
| ihost_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T12:40:22.969704+00:00     |
| updated_at   | 2019-04-01T18:18:04.205141+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:19.644" starttime="20190401 12:29:19.644"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:19.645" starttime="20190401 12:29:17.970"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:19.645" starttime="20190401 12:29:17.969"></status>
</kw>
<kw name="Add Interface To Data Network" library="Utils">
<doc>Adds an interface to the specified data network.</doc>
<arguments>
<arg>${mtu}</arg>
<arg>data1</arg>
<arg>${physnet1}</arg>
<arg>${host}</arg>
<arg>${data1ifuuid}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controler-0'</arg>
<arg>-d</arg>
<arg>-p</arg>
</arguments>
<assign>
<var>${option}</var>
</assign>
<msg timestamp="20190401 12:29:19.645" level="INFO">${option} = -p</msg>
<status status="PASS" endtime="20190401 12:29:19.645" starttime="20190401 12:29:19.645"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system host-if-modify</arg>
<arg>-m ${mtu}</arg>
<arg>-n ${if_name}</arg>
<arg>${option} ${datanetwork}</arg>
<arg>-c data</arg>
<arg>${host}</arg>
<arg>${uuid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:29:19.646" level="INFO">${cmd} = system host-if-modify -m 1500 -n data1 -p physnet1 -c data controller-0 7031ca08-1ddc-40dd-8486-d701c782a78e</msg>
<status status="PASS" endtime="20190401 12:29:19.646" starttime="20190401 12:29:19.646"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:19.647" starttime="20190401 12:29:19.646"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:19.647" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:19.647" starttime="20190401 12:29:19.647"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:19.648" starttime="20190401 12:29:19.647"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:19.648" starttime="20190401 12:29:19.648"></status>
</kw>
<msg timestamp="20190401 12:29:19.648" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:19.648" starttime="20190401 12:29:19.647"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:19.648" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:19.649" starttime="20190401 12:29:19.648"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:19.659" level="INFO">system host-if-modify -m 1500 -n data1  -p physnet1 -c data controller-0 7031ca08-1ddc-40dd-8486-d701c782a78e</msg>
<status status="PASS" endtime="20190401 12:29:19.659" starttime="20190401 12:29:19.649"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:21.231" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f1']                       |
| datanetworks | [u'physnet1']                        |
| imac         | 3c:fd:fe:be:e0:cd                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 7031ca08-1ddc-40dd-8486-d701c782a78e |
| ihost_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T12:40:23.059345+00:00     |
| updated_at   | 2019-04-01T18:18:05.716810+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:21.231" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190401 12:29:21.231" starttime="20190401 12:29:19.659"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:21.232" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:21.232" starttime="20190401 12:29:21.232"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:21.233" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190401 12:29:21.233" starttime="20190401 12:29:21.232"></status>
</kw>
<msg timestamp="20190401 12:29:21.233" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190401 12:29:21.233" starttime="20190401 12:29:21.232"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:21.234" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:21.234" starttime="20190401 12:29:21.233"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:21.236" level="INFO">0</msg>
<msg timestamp="20190401 12:29:21.236" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:21.236" starttime="20190401 12:29:21.234"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:21.236" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:21.236" starttime="20190401 12:29:21.236"></status>
</kw>
<msg timestamp="20190401 12:29:21.236" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:21.237" starttime="20190401 12:29:21.233"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:21.237" starttime="20190401 12:29:21.237"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:21.237" starttime="20190401 12:29:21.237"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:21.238" starttime="20190401 12:29:21.237"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:21.238" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f1']                       |
| datanetworks | [u'physnet1']                        |
| imac         | 3c:fd:fe:be:e0:cd                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 7031ca08-1ddc-40dd-8486-d701c782a78e |
| ihost_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T12:40:23.059345+00:00     |
| updated_at   | 2019-04-01T18:18:05.716810+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:21.238" starttime="20190401 12:29:21.238"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:21.238" starttime="20190401 12:29:19.646"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:21.238" starttime="20190401 12:29:19.645"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:21.238" starttime="20190401 12:29:11.387"></status>
</kw>
<kw name="Enable Containerized Services" library="Utils">
<doc>apply all the node labels for each controller
and compute functions.</doc>
<arguments>
<arg>${master_controller}</arg>
</arguments>
<kw name="Evaluate" library="BuiltIn">
<doc>Evaluates the given expression in Python and returns the results.</doc>
<arguments>
<arg>"controller" in """${host}"""</arg>
</arguments>
<assign>
<var>${is_controller}</var>
</assign>
<msg timestamp="20190401 12:29:21.239" level="INFO">${is_controller} = True</msg>
<status status="PASS" endtime="20190401 12:29:21.239" starttime="20190401 12:29:21.239"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-control-plane=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openstack-control-plane=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:21.240" starttime="20190401 12:29:21.240"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:21.241" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:21.241" starttime="20190401 12:29:21.240"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:21.241" starttime="20190401 12:29:21.241"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:21.242" starttime="20190401 12:29:21.241"></status>
</kw>
<msg timestamp="20190401 12:29:21.242" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:21.242" starttime="20190401 12:29:21.240"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:21.242" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:21.242" starttime="20190401 12:29:21.242"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:21.252" level="INFO">system host-label-assign controller-0  openstack-control-plane=enabled</msg>
<status status="PASS" endtime="20190401 12:29:21.252" starttime="20190401 12:29:21.242"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:22.348" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | ec7399f0-49fe-4b16-883e-8501d8e6c907 |
| host_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| label_key   | openstack-control-plane              |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:22.348" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | ec7399f0-49fe-4b...</msg>
<status status="PASS" endtime="20190401 12:29:22.348" starttime="20190401 12:29:21.252"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:22.349" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:22.349" starttime="20190401 12:29:22.349"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:22.350" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | ec7399f0-49fe-4b...</msg>
<status status="PASS" endtime="20190401 12:29:22.350" starttime="20190401 12:29:22.349"></status>
</kw>
<msg timestamp="20190401 12:29:22.350" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | ec7399f0-49fe-4b...</msg>
<status status="PASS" endtime="20190401 12:29:22.350" starttime="20190401 12:29:22.349"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:22.352" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:22.352" starttime="20190401 12:29:22.350"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:22.352" level="INFO">0</msg>
<msg timestamp="20190401 12:29:22.352" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:22.352" starttime="20190401 12:29:22.352"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:22.353" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:22.353" starttime="20190401 12:29:22.353"></status>
</kw>
<msg timestamp="20190401 12:29:22.353" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:22.353" starttime="20190401 12:29:22.350"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:22.354" starttime="20190401 12:29:22.354"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:22.354" starttime="20190401 12:29:22.353"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:22.354" starttime="20190401 12:29:22.354"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:22.355" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | ec7399f0-49fe-4b16-883e-8501d8e6c907 |
| host_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| label_key   | openstack-control-plane              |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:22.355" starttime="20190401 12:29:22.354"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:22.355" starttime="20190401 12:29:21.239"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:22.355" starttime="20190401 12:29:21.239"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}'=='Simplex' or '${CONFIGURATION_TYPE}'=='Duplex' or ${is_controller}==False</arg>
<arg>Run Keywords</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:22.356" starttime="20190401 12:29:22.356"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:22.357" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:22.357" starttime="20190401 12:29:22.357"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:22.358" starttime="20190401 12:29:22.357"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:22.358" starttime="20190401 12:29:22.358"></status>
</kw>
<msg timestamp="20190401 12:29:22.358" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:22.358" starttime="20190401 12:29:22.356"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:22.358" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:22.358" starttime="20190401 12:29:22.358"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:22.368" level="INFO">system host-label-assign controller-0  openstack-compute-node=enabled</msg>
<status status="PASS" endtime="20190401 12:29:22.368" starttime="20190401 12:29:22.358"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:23.448" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 5ba8f8ef-ac7d-4ed0-a807-9b8f51ea164b |
| host_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| label_key   | openstack-compute-node               |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:23.448" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 5ba8f8ef-ac7d-4e...</msg>
<status status="PASS" endtime="20190401 12:29:23.448" starttime="20190401 12:29:22.368"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:23.449" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:23.449" starttime="20190401 12:29:23.449"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:23.449" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 5ba8f8ef-ac7d-4e...</msg>
<status status="PASS" endtime="20190401 12:29:23.449" starttime="20190401 12:29:23.449"></status>
</kw>
<msg timestamp="20190401 12:29:23.450" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 5ba8f8ef-ac7d-4e...</msg>
<status status="PASS" endtime="20190401 12:29:23.450" starttime="20190401 12:29:23.449"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:23.452" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:23.452" starttime="20190401 12:29:23.450"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:23.452" level="INFO">0</msg>
<msg timestamp="20190401 12:29:23.452" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:23.452" starttime="20190401 12:29:23.452"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:23.453" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:23.453" starttime="20190401 12:29:23.452"></status>
</kw>
<msg timestamp="20190401 12:29:23.453" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:23.453" starttime="20190401 12:29:23.450"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:23.454" starttime="20190401 12:29:23.453"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:23.454" starttime="20190401 12:29:23.453"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:23.454" starttime="20190401 12:29:23.454"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:23.454" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 5ba8f8ef-ac7d-4ed0-a807-9b8f51ea164b |
| host_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| label_key   | openstack-compute-node               |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:23.454" starttime="20190401 12:29:23.454"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:23.454" starttime="20190401 12:29:22.356"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:23.455" starttime="20190401 12:29:23.455"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:23.456" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:23.456" starttime="20190401 12:29:23.455"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:23.456" starttime="20190401 12:29:23.456"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:23.456" starttime="20190401 12:29:23.456"></status>
</kw>
<msg timestamp="20190401 12:29:23.457" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:23.457" starttime="20190401 12:29:23.455"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:23.457" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:23.457" starttime="20190401 12:29:23.457"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:23.466" level="INFO">system host-label-assign controller-0  openvswitch=enabled</msg>
<status status="PASS" endtime="20190401 12:29:23.467" starttime="20190401 12:29:23.457"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:24.569" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 67efcd2c-03ec-4098-838d-1f9e1a5c3c64 |
| host_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| label_key   | openvswitch                          |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:24.569" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 67efcd2c-03ec-40...</msg>
<status status="PASS" endtime="20190401 12:29:24.569" starttime="20190401 12:29:23.467"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:24.570" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:24.570" starttime="20190401 12:29:24.570"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:24.570" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 67efcd2c-03ec-40...</msg>
<status status="PASS" endtime="20190401 12:29:24.570" starttime="20190401 12:29:24.570"></status>
</kw>
<msg timestamp="20190401 12:29:24.570" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 67efcd2c-03ec-40...</msg>
<status status="PASS" endtime="20190401 12:29:24.571" starttime="20190401 12:29:24.569"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:24.572" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:24.573" starttime="20190401 12:29:24.571"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:24.573" level="INFO">0</msg>
<msg timestamp="20190401 12:29:24.573" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:24.573" starttime="20190401 12:29:24.573"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:24.574" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:24.574" starttime="20190401 12:29:24.573"></status>
</kw>
<msg timestamp="20190401 12:29:24.574" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:24.574" starttime="20190401 12:29:24.571"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:24.575" starttime="20190401 12:29:24.574"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:24.575" starttime="20190401 12:29:24.574"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:24.575" starttime="20190401 12:29:24.575"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:24.575" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 67efcd2c-03ec-4098-838d-1f9e1a5c3c64 |
| host_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| label_key   | openvswitch                          |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:24.575" starttime="20190401 12:29:24.575"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:24.575" starttime="20190401 12:29:23.454"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:24.576" starttime="20190401 12:29:24.576"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:24.577" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:24.577" starttime="20190401 12:29:24.576"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:24.577" starttime="20190401 12:29:24.577"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:24.577" starttime="20190401 12:29:24.577"></status>
</kw>
<msg timestamp="20190401 12:29:24.578" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:24.578" starttime="20190401 12:29:24.576"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:24.578" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:24.578" starttime="20190401 12:29:24.578"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:24.586" level="INFO">system host-label-assign controller-0  sriov=enabled</msg>
<status status="PASS" endtime="20190401 12:29:24.586" starttime="20190401 12:29:24.578"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:25.675" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 8f7df1ec-0721-445b-9b2c-f3755ae895c3 |
| host_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| label_key   | sriov                                |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:25.675" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 8f7df1ec-0721-44...</msg>
<status status="PASS" endtime="20190401 12:29:25.675" starttime="20190401 12:29:24.586"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:25.676" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:25.676" starttime="20190401 12:29:25.675"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:25.676" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 8f7df1ec-0721-44...</msg>
<status status="PASS" endtime="20190401 12:29:25.676" starttime="20190401 12:29:25.676"></status>
</kw>
<msg timestamp="20190401 12:29:25.676" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 8f7df1ec-0721-44...</msg>
<status status="PASS" endtime="20190401 12:29:25.676" starttime="20190401 12:29:25.675"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:25.678" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:25.678" starttime="20190401 12:29:25.676"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:25.678" level="INFO">0</msg>
<msg timestamp="20190401 12:29:25.678" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:25.679" starttime="20190401 12:29:25.678"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:25.679" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:25.679" starttime="20190401 12:29:25.679"></status>
</kw>
<msg timestamp="20190401 12:29:25.679" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:25.679" starttime="20190401 12:29:25.676"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:25.680" starttime="20190401 12:29:25.680"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:25.680" starttime="20190401 12:29:25.679"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:25.680" starttime="20190401 12:29:25.680"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:25.680" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 8f7df1ec-0721-445b-9b2c-f3755ae895c3 |
| host_uuid   | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6 |
| label_key   | sriov                                |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:25.680" starttime="20190401 12:29:25.680"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:25.681" starttime="20190401 12:29:24.576"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:25.681" starttime="20190401 12:29:22.355"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:25.681" starttime="20190401 12:29:22.355"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:25.681" starttime="20190401 12:29:21.238"></status>
</kw>
<kw name="Setup Partitions" library="Utils">
<doc>Setup required partition on specified host.</doc>
<arguments>
<arg>${master_controller}</arg>
<arg>${lgv_name}</arg>
<arg>${nova_size}</arg>
<arg>${cgts_part_size}</arg>
</arguments>
<kw name="Get Root Disk Device" library="Utils">
<doc>Get the root disk partition assigned to the specified
node</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<assign>
<var>${root_disk_device}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${host}</arg>
<arg>grep rootfs</arg>
<arg>awk '{print $4}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:29:25.682" level="INFO">${cmd} = system host-show controller-0|grep rootfs|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:29:25.682" starttime="20190401 12:29:25.682"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:25.683" starttime="20190401 12:29:25.683"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:25.683" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:25.683" starttime="20190401 12:29:25.683"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:25.684" starttime="20190401 12:29:25.684"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:25.684" starttime="20190401 12:29:25.684"></status>
</kw>
<msg timestamp="20190401 12:29:25.684" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:25.684" starttime="20190401 12:29:25.683"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:25.685" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:25.685" starttime="20190401 12:29:25.685"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:25.694" level="INFO">system host-show controller-0|grep roo tfs|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:29:25.694" starttime="20190401 12:29:25.685"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:26.729" level="INFO">/dev/disk/by-path/pci-0000:00:17.0-ata-1.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:26.729" level="INFO">${output} = /dev/disk/by-path/pci-0000:00:17.0-ata-1.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:26.729" starttime="20190401 12:29:25.694"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:26.730" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:26.730" starttime="20190401 12:29:26.730"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:26.730" level="INFO">${clean_out} = /dev/disk/by-path/pci-0000:00:17.0-ata-1.0
</msg>
<status status="PASS" endtime="20190401 12:29:26.730" starttime="20190401 12:29:26.730"></status>
</kw>
<msg timestamp="20190401 12:29:26.731" level="INFO">${output} = /dev/disk/by-path/pci-0000:00:17.0-ata-1.0
</msg>
<status status="PASS" endtime="20190401 12:29:26.731" starttime="20190401 12:29:26.729"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:26.733" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:26.733" starttime="20190401 12:29:26.731"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:26.733" level="INFO">0</msg>
<msg timestamp="20190401 12:29:26.733" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:26.733" starttime="20190401 12:29:26.733"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:26.734" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:26.734" starttime="20190401 12:29:26.734"></status>
</kw>
<msg timestamp="20190401 12:29:26.734" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:26.734" starttime="20190401 12:29:26.731"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:26.735" starttime="20190401 12:29:26.734"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:26.735" starttime="20190401 12:29:26.734"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:26.735" starttime="20190401 12:29:26.735"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:26.735" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: /dev/disk/by-path/pci-0000:00:17.0-ata-1.0</msg>
<status status="PASS" endtime="20190401 12:29:26.735" starttime="20190401 12:29:26.735"></status>
</kw>
<msg timestamp="20190401 12:29:26.736" level="INFO">${result} = {u'stdout': u'/dev/disk/by-path/pci-0000:00:17.0-ata-1.0', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:29:26.736" starttime="20190401 12:29:25.682"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${result.stdout.strip()}</arg>
</arguments>
<assign>
<var>${root_disk}</var>
</assign>
<msg timestamp="20190401 12:29:26.736" level="INFO">${root_disk} = /dev/disk/by-path/pci-0000:00:17.0-ata-1.0</msg>
<status status="PASS" endtime="20190401 12:29:26.736" starttime="20190401 12:29:26.736"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host} --nowrap</arg>
<arg>grep ${root_disk}</arg>
<arg>awk '{print $4}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:29:26.736" level="INFO">${cmd} = system host-disk-list controller-0 --nowrap|grep /dev/disk/by-path/pci-0000:00:17.0-ata-1.0|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:29:26.736" starttime="20190401 12:29:26.736"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${root_disk_device}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:26.737" starttime="20190401 12:29:26.737"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:26.738" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:26.738" starttime="20190401 12:29:26.737"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:26.738" starttime="20190401 12:29:26.738"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:26.739" starttime="20190401 12:29:26.738"></status>
</kw>
<msg timestamp="20190401 12:29:26.739" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:26.739" starttime="20190401 12:29:26.737"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:26.739" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:26.739" starttime="20190401 12:29:26.739"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:26.756" level="INFO">system host-disk-list controller-0 --n owrap|grep /dev/disk/by-path/pci-0000:00:17.0-ata-1.0|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:29:26.756" starttime="20190401 12:29:26.739"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:27.811" level="INFO">/dev/sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:27.811" level="INFO">${output} = /dev/sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:27.811" starttime="20190401 12:29:26.756"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:27.812" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:27.812" starttime="20190401 12:29:27.812"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:27.812" level="INFO">${clean_out} = /dev/sda
</msg>
<status status="PASS" endtime="20190401 12:29:27.812" starttime="20190401 12:29:27.812"></status>
</kw>
<msg timestamp="20190401 12:29:27.812" level="INFO">${output} = /dev/sda
</msg>
<status status="PASS" endtime="20190401 12:29:27.812" starttime="20190401 12:29:27.811"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:27.814" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:27.815" starttime="20190401 12:29:27.813"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:27.815" level="INFO">0</msg>
<msg timestamp="20190401 12:29:27.815" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:27.815" starttime="20190401 12:29:27.815"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:27.816" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:27.816" starttime="20190401 12:29:27.816"></status>
</kw>
<msg timestamp="20190401 12:29:27.816" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:27.816" starttime="20190401 12:29:27.813"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:27.817" starttime="20190401 12:29:27.816"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:27.817" starttime="20190401 12:29:27.816"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:27.817" starttime="20190401 12:29:27.817"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:27.817" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: /dev/sda</msg>
<status status="PASS" endtime="20190401 12:29:27.817" starttime="20190401 12:29:27.817"></status>
</kw>
<msg timestamp="20190401 12:29:27.818" level="INFO">${root_disk_device} = {u'stdout': u'/dev/sda', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:29:27.818" starttime="20190401 12:29:26.736"></status>
</kw>
<msg timestamp="20190401 12:29:27.818" level="INFO">${root_disk_device} = /dev/sda</msg>
<status status="PASS" endtime="20190401 12:29:27.818" starttime="20190401 12:29:25.681"></status>
</kw>
<kw name="Get Disk List UID" library="Utils">
<doc>Returns the UID of the disk given the device node and
host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_device}</arg>
</arguments>
<assign>
<var>${root_disk_uuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host}</arg>
<arg>grep ${device_node}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:29:27.818" level="INFO">${system_cmd} = system host-disk-list controller-0|grep /dev/sda|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:29:27.818" starttime="20190401 12:29:27.818"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:27.819" starttime="20190401 12:29:27.819"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:27.820" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:27.820" starttime="20190401 12:29:27.820"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:27.820" starttime="20190401 12:29:27.820"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:27.821" starttime="20190401 12:29:27.820"></status>
</kw>
<msg timestamp="20190401 12:29:27.821" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:27.821" starttime="20190401 12:29:27.819"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:27.821" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:27.821" starttime="20190401 12:29:27.821"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:27.830" level="INFO">system host-disk-list controller-0|gre p /dev/sda|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:29:27.830" starttime="20190401 12:29:27.821"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:28.876" level="INFO">ec871e4b-becb-4b45-9c37-a93e2b763b54
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:28.876" level="INFO">${output} = ec871e4b-becb-4b45-9c37-a93e2b763b54
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:28.876" starttime="20190401 12:29:27.830"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:28.877" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:28.877" starttime="20190401 12:29:28.877"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:28.877" level="INFO">${clean_out} = ec871e4b-becb-4b45-9c37-a93e2b763b54
</msg>
<status status="PASS" endtime="20190401 12:29:28.877" starttime="20190401 12:29:28.877"></status>
</kw>
<msg timestamp="20190401 12:29:28.878" level="INFO">${output} = ec871e4b-becb-4b45-9c37-a93e2b763b54
</msg>
<status status="PASS" endtime="20190401 12:29:28.878" starttime="20190401 12:29:28.876"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:28.880" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:28.880" starttime="20190401 12:29:28.878"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:28.881" level="INFO">0</msg>
<msg timestamp="20190401 12:29:28.881" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:28.881" starttime="20190401 12:29:28.880"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:28.881" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:28.881" starttime="20190401 12:29:28.881"></status>
</kw>
<msg timestamp="20190401 12:29:28.881" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:28.881" starttime="20190401 12:29:28.878"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:28.882" starttime="20190401 12:29:28.882"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:28.882" starttime="20190401 12:29:28.881"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:28.882" starttime="20190401 12:29:28.882"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:28.883" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ec871e4b-becb-4b45-9c37-a93e2b763b54</msg>
<status status="PASS" endtime="20190401 12:29:28.883" starttime="20190401 12:29:28.883"></status>
</kw>
<msg timestamp="20190401 12:29:28.883" level="INFO">&amp;{result} = { stdout=ec871e4b-becb-4b45-9c37-a93e2b763b54 | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 12:29:28.883" starttime="20190401 12:29:27.819"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${uid}</var>
</assign>
<msg timestamp="20190401 12:29:28.883" level="INFO">${uid} = ec871e4b-becb-4b45-9c37-a93e2b763b54</msg>
<status status="PASS" endtime="20190401 12:29:28.883" starttime="20190401 12:29:28.883"></status>
</kw>
<msg timestamp="20190401 12:29:28.883" level="INFO">${root_disk_uuid} = ec871e4b-becb-4b45-9c37-a93e2b763b54</msg>
<status status="PASS" endtime="20190401 12:29:28.884" starttime="20190401 12:29:27.818"></status>
</kw>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controller-0'</arg>
<arg>Ready</arg>
<arg>Creating</arg>
</arguments>
<assign>
<var>${part_status}</var>
</assign>
<msg timestamp="20190401 12:29:28.884" level="INFO">${part_status} = Ready</msg>
<status status="PASS" endtime="20190401 12:29:28.884" starttime="20190401 12:29:28.884"></status>
</kw>
<kw name="Evaluate" library="BuiltIn">
<doc>Evaluates the given expression in Python and returns the results.</doc>
<arguments>
<arg>"controller" in """${host}"""</arg>
</arguments>
<assign>
<var>${is_controller}</var>
</assign>
<msg timestamp="20190401 12:29:28.884" level="INFO">${is_controller} = True</msg>
<status status="PASS" endtime="20190401 12:29:28.884" starttime="20190401 12:29:28.884"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${nova_size}==True</arg>
<arg>Calcultae Nova Partition Size For Computes</arg>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>ELSE</arg>
<arg>Set Variable</arg>
<arg>${nova_size}</arg>
</arguments>
<assign>
<var>${nova_size}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${nova_size}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:28.885" starttime="20190401 12:29:28.885"></status>
</kw>
<msg timestamp="20190401 12:29:28.885" level="INFO">${nova_size} = 100</msg>
<status status="PASS" endtime="20190401 12:29:28.885" starttime="20190401 12:29:28.884"></status>
</kw>
<kw name="Add Disk Partition" library="Utils">
<doc>Add a partition for specified disk on the specified host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${nova_size}</arg>
<arg>${part_status}</arg>
</arguments>
<assign>
<var>${nova_partition_uuid}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-disk-partition-add ${host} ${uid} ${size} -t lvm_phys_vol</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:28.886" starttime="20190401 12:29:28.886"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:28.887" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:28.887" starttime="20190401 12:29:28.886"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:28.887" starttime="20190401 12:29:28.887"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:28.887" starttime="20190401 12:29:28.887"></status>
</kw>
<msg timestamp="20190401 12:29:28.888" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:28.888" starttime="20190401 12:29:28.886"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:28.888" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:28.888" starttime="20190401 12:29:28.888"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:28.902" level="INFO">system host-disk-partition-add control ler-0 ec871e4b-becb-4b45-9c37-a93e2b763b54 100 -t lvm_phys_vol</msg>
<status status="PASS" endtime="20190401 12:29:28.902" starttime="20190401 12:29:28.888"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:30.052" level="INFO">+-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| device_node | /dev/sda5                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 102400                                           |
| uuid        | f951e4ac-bfef-44a5-969d-fb1787d42f42             |
| ihost_uuid  | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6             |
| idisk_uuid  | ec871e4b-becb-4b45-9c37-a93e2b763b54             |
| ipv_uuid    | None                                             |
| status      | Creating                                         |
| created_at  | 2019-04-01T18:18:14.673489+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:30.052" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:29:30.052" starttime="20190401 12:29:28.903"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:30.053" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:30.053" starttime="20190401 12:29:30.053"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:30.054" level="INFO">${clean_out} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:29:30.054" starttime="20190401 12:29:30.053"></status>
</kw>
<msg timestamp="20190401 12:29:30.054" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:29:30.054" starttime="20190401 12:29:30.053"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:30.056" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:30.056" starttime="20190401 12:29:30.054"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:30.056" level="INFO">0</msg>
<msg timestamp="20190401 12:29:30.056" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:30.057" starttime="20190401 12:29:30.056"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:30.057" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:30.057" starttime="20190401 12:29:30.057"></status>
</kw>
<msg timestamp="20190401 12:29:30.057" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:30.057" starttime="20190401 12:29:30.054"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:30.058" starttime="20190401 12:29:30.058"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:30.058" starttime="20190401 12:29:30.057"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:30.058" starttime="20190401 12:29:30.058"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:30.059" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| device_node | /dev/sda5                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 102400                                           |
| uuid        | f951e4ac-bfef-44a5-969d-fb1787d42f42             |
| ihost_uuid  | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6             |
| idisk_uuid  | ec871e4b-becb-4b45-9c37-a93e2b763b54             |
| ipv_uuid    | None                                             |
| status      | Creating                                         |
| created_at  | 2019-04-01T18:18:14.673489+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:30.059" starttime="20190401 12:29:30.058"></status>
</kw>
<msg timestamp="20190401 12:29:30.059" level="INFO">${result} = {u'stdout': u'+-------------+--------------------------------------------------+\r\n| Property    | Value                                            |\r\n+-------------+-------------------------------...</msg>
<status status="PASS" endtime="20190401 12:29:30.059" starttime="20190401 12:29:28.885"></status>
</kw>
<kw name="Get Property From Result" library="Utils">
<arguments>
<arg>${result}</arg>
<arg>uuid</arg>
</arguments>
<assign>
<var>${new_uid}</var>
</assign>
<kw name="String To Dict" library="common">
<doc>Convert string table to dictionary</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:29:30.060" level="INFO">${dict} = {'Property': {'status': {'Value': 'Creating'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': 'f951e4ac-bfef-44a5-969d-...</msg>
<status status="PASS" endtime="20190401 12:29:30.060" starttime="20190401 12:29:30.059"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Property</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:29:30.060" level="INFO">${dict} = {'status': {'Value': 'Creating'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': 'f951e4ac-bfef-44a5-969d-fb1787d42f42'...</msg>
<status status="PASS" endtime="20190401 12:29:30.060" starttime="20190401 12:29:30.060"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:29:30.060" level="INFO">${dict} = {'Value': 'f951e4ac-bfef-44a5-969d-fb1787d42f42'}</msg>
<status status="PASS" endtime="20190401 12:29:30.060" starttime="20190401 12:29:30.060"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Value</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:29:30.061" level="INFO">${dict} = f951e4ac-bfef-44a5-969d-fb1787d42f42</msg>
<status status="PASS" endtime="20190401 12:29:30.061" starttime="20190401 12:29:30.060"></status>
</kw>
<msg timestamp="20190401 12:29:30.061" level="INFO">${new_uid} = f951e4ac-bfef-44a5-969d-fb1787d42f42</msg>
<status status="PASS" endtime="20190401 12:29:30.061" starttime="20190401 12:29:30.059"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>30 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value Of Command</arg>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:30.063" starttime="20190401 12:29:30.062"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:30.063" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:30.063" starttime="20190401 12:29:30.063"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:30.064" starttime="20190401 12:29:30.064"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:30.064" starttime="20190401 12:29:30.064"></status>
</kw>
<msg timestamp="20190401 12:29:30.064" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:30.064" starttime="20190401 12:29:30.063"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:30.065" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:30.065" starttime="20190401 12:29:30.065"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:30.082" level="INFO">system host-disk-partition-show contro ller-0 f951e4ac-bfef-44a5-969d-fb1787d42f42 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:29:30.082" starttime="20190401 12:29:30.065"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:31.136" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:31.136" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:31.136" starttime="20190401 12:29:30.082"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:31.137" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:31.137" starttime="20190401 12:29:31.137"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:31.137" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190401 12:29:31.137" starttime="20190401 12:29:31.137"></status>
</kw>
<msg timestamp="20190401 12:29:31.137" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190401 12:29:31.137" starttime="20190401 12:29:31.136"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:31.139" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:31.139" starttime="20190401 12:29:31.138"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:31.140" level="INFO">0</msg>
<msg timestamp="20190401 12:29:31.140" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:31.140" starttime="20190401 12:29:31.139"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:31.140" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:31.140" starttime="20190401 12:29:31.140"></status>
</kw>
<msg timestamp="20190401 12:29:31.140" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:31.140" starttime="20190401 12:29:31.137"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:31.141" starttime="20190401 12:29:31.141"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:31.141" starttime="20190401 12:29:31.140"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:31.141" starttime="20190401 12:29:31.141"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:31.142" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190401 12:29:31.142" starttime="20190401 12:29:31.141"></status>
</kw>
<msg timestamp="20190401 12:29:31.142" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:29:31.142" starttime="20190401 12:29:30.062"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:29:31.142" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190401 12:29:31.142" starttime="20190401 12:29:31.142"></status>
</kw>
<msg timestamp="20190401 12:29:31.142" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190401 12:29:31.143" starttime="20190401 12:29:30.062"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:29:31.143" level="FAIL">Creating != Ready</msg>
<status status="FAIL" endtime="20190401 12:29:31.143" starttime="20190401 12:29:31.143"></status>
</kw>
<status status="FAIL" endtime="20190401 12:29:31.143" starttime="20190401 12:29:30.061"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:41.145" starttime="20190401 12:29:41.145"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:41.146" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:41.146" starttime="20190401 12:29:41.145"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:41.146" starttime="20190401 12:29:41.146"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:41.146" starttime="20190401 12:29:41.146"></status>
</kw>
<msg timestamp="20190401 12:29:41.147" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:41.147" starttime="20190401 12:29:41.145"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:41.147" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:41.147" starttime="20190401 12:29:41.147"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:41.165" level="INFO">system host-disk-partition-show contro ller-0 f951e4ac-bfef-44a5-969d-fb1787d42f42 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:29:41.165" starttime="20190401 12:29:41.147"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:42.190" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:42.190" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:42.190" starttime="20190401 12:29:41.165"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:42.191" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:42.191" starttime="20190401 12:29:42.191"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:42.191" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190401 12:29:42.191" starttime="20190401 12:29:42.191"></status>
</kw>
<msg timestamp="20190401 12:29:42.191" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190401 12:29:42.191" starttime="20190401 12:29:42.190"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:42.193" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:42.193" starttime="20190401 12:29:42.192"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:42.194" level="INFO">0</msg>
<msg timestamp="20190401 12:29:42.194" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:42.194" starttime="20190401 12:29:42.193"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:42.195" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:42.195" starttime="20190401 12:29:42.194"></status>
</kw>
<msg timestamp="20190401 12:29:42.195" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:42.195" starttime="20190401 12:29:42.192"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:42.195" starttime="20190401 12:29:42.195"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:42.196" starttime="20190401 12:29:42.195"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:42.196" starttime="20190401 12:29:42.196"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:42.196" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190401 12:29:42.196" starttime="20190401 12:29:42.196"></status>
</kw>
<msg timestamp="20190401 12:29:42.196" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:29:42.196" starttime="20190401 12:29:41.144"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:29:42.197" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190401 12:29:42.197" starttime="20190401 12:29:42.196"></status>
</kw>
<msg timestamp="20190401 12:29:42.197" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190401 12:29:42.197" starttime="20190401 12:29:41.144"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:29:42.197" level="FAIL">Creating != Ready</msg>
<status status="FAIL" endtime="20190401 12:29:42.197" starttime="20190401 12:29:42.197"></status>
</kw>
<status status="FAIL" endtime="20190401 12:29:42.197" starttime="20190401 12:29:41.143"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:52.199" starttime="20190401 12:29:52.199"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:52.200" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:52.200" starttime="20190401 12:29:52.200"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:52.200" starttime="20190401 12:29:52.200"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:52.201" starttime="20190401 12:29:52.201"></status>
</kw>
<msg timestamp="20190401 12:29:52.201" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:52.201" starttime="20190401 12:29:52.199"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:52.201" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:52.201" starttime="20190401 12:29:52.201"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:52.214" level="INFO">system host-disk-partition-show contro ller-0 f951e4ac-bfef-44a5-969d-fb1787d42f42 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:29:52.214" starttime="20190401 12:29:52.201"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:53.249" level="INFO">Ready
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:53.249" level="INFO">${output} = Ready
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:53.249" starttime="20190401 12:29:52.214"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:53.250" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:53.250" starttime="20190401 12:29:53.249"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:53.250" level="INFO">${clean_out} = Ready
</msg>
<status status="PASS" endtime="20190401 12:29:53.250" starttime="20190401 12:29:53.250"></status>
</kw>
<msg timestamp="20190401 12:29:53.250" level="INFO">${output} = Ready
</msg>
<status status="PASS" endtime="20190401 12:29:53.250" starttime="20190401 12:29:53.249"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:53.252" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:53.252" starttime="20190401 12:29:53.251"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:53.253" level="INFO">0</msg>
<msg timestamp="20190401 12:29:53.253" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:53.253" starttime="20190401 12:29:53.253"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:53.253" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:53.253" starttime="20190401 12:29:53.253"></status>
</kw>
<msg timestamp="20190401 12:29:53.254" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:53.254" starttime="20190401 12:29:53.251"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:53.254" starttime="20190401 12:29:53.254"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:53.254" starttime="20190401 12:29:53.254"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:53.255" starttime="20190401 12:29:53.254"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:53.255" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Ready</msg>
<status status="PASS" endtime="20190401 12:29:53.255" starttime="20190401 12:29:53.255"></status>
</kw>
<msg timestamp="20190401 12:29:53.255" level="INFO">${result} = {u'stdout': u'Ready', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:29:53.255" starttime="20190401 12:29:52.199"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:29:53.255" level="INFO">${value} = Ready</msg>
<status status="PASS" endtime="20190401 12:29:53.256" starttime="20190401 12:29:53.255"></status>
</kw>
<msg timestamp="20190401 12:29:53.256" level="INFO">${current_value} = Ready</msg>
<status status="PASS" endtime="20190401 12:29:53.256" starttime="20190401 12:29:52.198"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:53.256" starttime="20190401 12:29:53.256"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:53.256" starttime="20190401 12:29:52.198"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:53.256" starttime="20190401 12:29:30.061"></status>
</kw>
<msg timestamp="20190401 12:29:53.256" level="INFO">${nova_partition_uuid} = f951e4ac-bfef-44a5-969d-fb1787d42f42</msg>
<status status="PASS" endtime="20190401 12:29:53.256" starttime="20190401 12:29:28.885"></status>
</kw>
<kw name="Add Local Volume Group" library="Utils">
<doc>Adds a local volume group according to given options.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-lvg-add ${host} ${lvg_name}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:53.257" starttime="20190401 12:29:53.257"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:53.258" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:53.258" starttime="20190401 12:29:53.258"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:53.258" starttime="20190401 12:29:53.258"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:53.259" starttime="20190401 12:29:53.259"></status>
</kw>
<msg timestamp="20190401 12:29:53.259" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:53.259" starttime="20190401 12:29:53.258"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:53.259" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:53.259" starttime="20190401 12:29:53.259"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:53.262" level="INFO">system host-lvg-add controller-0 nova- local</msg>
<status status="PASS" endtime="20190401 12:29:53.262" starttime="20190401 12:29:53.259"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:54.329" level="INFO">+-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+-----------------------+-------------------------------------------------------------------+
| lvm_vg_name           | nova-local                                                        |
| vg_state              | adding                                                            |
| uuid                  | e5984349-579c-4315-825b-20a48d70fdb2                              |
| ihost_uuid            | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6                              |
| lvm_vg_access         | None                                                              |
| lvm_max_lv            | 0                                                                 |
| lvm_cur_lv            | 0                                                                 |
| lvm_max_pv            | 0                                                                 |
| lvm_cur_pv            | 0                                                                 |
| lvm_vg_size_gib       | 0.0                                                               |
| lvm_vg_avail_size_gib | 0.0                                                               |
| lvm_vg_total_pe       | 0                                                                 |
| lvm_vg_free_pe        | 0                                                                 |
| created_at            | 2019-04-01T18:18:38.956369+00:00                                  |
| updated_at            | None                                                              |
| parameters            | {u'concurrent_disk_operations': 2, u'instance_backing': u'image'} |
+-----------------------+-------------------------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:54.329" level="INFO">${output} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190401 12:29:54.329" starttime="20190401 12:29:53.262"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:54.330" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:54.330" starttime="20190401 12:29:54.330"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:54.330" level="INFO">${clean_out} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190401 12:29:54.330" starttime="20190401 12:29:54.330"></status>
</kw>
<msg timestamp="20190401 12:29:54.330" level="INFO">${output} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190401 12:29:54.330" starttime="20190401 12:29:54.329"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:54.332" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:54.332" starttime="20190401 12:29:54.331"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:54.333" level="INFO">0</msg>
<msg timestamp="20190401 12:29:54.333" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:54.333" starttime="20190401 12:29:54.332"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:54.333" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:54.333" starttime="20190401 12:29:54.333"></status>
</kw>
<msg timestamp="20190401 12:29:54.333" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:54.333" starttime="20190401 12:29:54.330"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:54.334" starttime="20190401 12:29:54.334"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:54.334" starttime="20190401 12:29:54.333"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:54.334" starttime="20190401 12:29:54.334"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:54.335" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+-----------------------+-------------------------------------------------------------------+
| lvm_vg_name           | nova-local                                                        |
| vg_state              | adding                                                            |
| uuid                  | e5984349-579c-4315-825b-20a48d70fdb2                              |
| ihost_uuid            | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6                              |
| lvm_vg_access         | None                                                              |
| lvm_max_lv            | 0                                                                 |
| lvm_cur_lv            | 0                                                                 |
| lvm_max_pv            | 0                                                                 |
| lvm_cur_pv            | 0                                                                 |
| lvm_vg_size_gib       | 0.0                                                               |
| lvm_vg_avail_size_gib | 0.0                                                               |
| lvm_vg_total_pe       | 0                                                                 |
| lvm_vg_free_pe        | 0                                                                 |
| created_at            | 2019-04-01T18:18:38.956369+00:00                                  |
| updated_at            | None                                                              |
| parameters            | {u'concurrent_disk_operations': 2, u'instance_backing': u'image'} |
+-----------------------+-------------------------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:54.335" starttime="20190401 12:29:54.334"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:54.335" starttime="20190401 12:29:53.257"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:54.335" starttime="20190401 12:29:53.257"></status>
</kw>
<kw name="Add Physical Volume" library="Utils">
<doc>Adds a physical volume to the specified host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${nova_partition_uuid}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-pv-add ${host} ${lvg name} ${uid}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:54.336" starttime="20190401 12:29:54.336"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:54.337" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:54.337" starttime="20190401 12:29:54.337"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:54.337" starttime="20190401 12:29:54.337"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:54.338" starttime="20190401 12:29:54.338"></status>
</kw>
<msg timestamp="20190401 12:29:54.338" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:54.338" starttime="20190401 12:29:54.336"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:54.338" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:54.338" starttime="20190401 12:29:54.338"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:54.344" level="INFO">system host-pv-add controller-0 nova-l ocal f951e4ac-bfef-44a5-969d-fb1787d42f42</msg>
<status status="PASS" endtime="20190401 12:29:54.344" starttime="20190401 12:29:54.338"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:55.512" level="INFO">+--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | 997c00c6-9604-44fd-994c-f4db7e1d9bbe             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | f951e4ac-bfef-44a5-969d-fb1787d42f42             |
| disk_or_part_device_node | /dev/sda5                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| lvm_pv_name              | /dev/sda5                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6             |
| created_at               | 2019-04-01T18:18:40.124341+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:55.512" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:29:55.512" starttime="20190401 12:29:54.345"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:55.513" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:55.513" starttime="20190401 12:29:55.513"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:55.513" level="INFO">${clean_out} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:29:55.513" starttime="20190401 12:29:55.513"></status>
</kw>
<msg timestamp="20190401 12:29:55.513" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:29:55.513" starttime="20190401 12:29:55.512"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:55.516" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:55.516" starttime="20190401 12:29:55.514"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:55.516" level="INFO">0</msg>
<msg timestamp="20190401 12:29:55.516" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:55.516" starttime="20190401 12:29:55.516"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:55.517" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:55.517" starttime="20190401 12:29:55.516"></status>
</kw>
<msg timestamp="20190401 12:29:55.517" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:55.517" starttime="20190401 12:29:55.514"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:55.518" starttime="20190401 12:29:55.517"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:55.518" starttime="20190401 12:29:55.517"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:55.518" starttime="20190401 12:29:55.518"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:55.518" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | 997c00c6-9604-44fd-994c-f4db7e1d9bbe             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | f951e4ac-bfef-44a5-969d-fb1787d42f42             |
| disk_or_part_device_node | /dev/sda5                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| lvm_pv_name              | /dev/sda5                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6             |
| created_at               | 2019-04-01T18:18:40.124341+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:55.518" starttime="20190401 12:29:55.518"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:55.518" starttime="20190401 12:29:54.336"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:55.519" starttime="20190401 12:29:54.335"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==False</arg>
<arg>Modify LVG Attributes</arg>
<arg>-b image</arg>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:55.519" starttime="20190401 12:29:55.519"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True or ${setup_cgts}==True</arg>
<arg>Add Disk Partition</arg>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>${part_status}</arg>
</arguments>
<assign>
<var>${cgts_partition_uuid}</var>
</assign>
<kw name="Add Disk Partition" library="Utils">
<doc>Add a partition for specified disk on the specified host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>${part_status}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-disk-partition-add ${host} ${uid} ${size} -t lvm_phys_vol</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:55.520" starttime="20190401 12:29:55.520"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:55.521" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:55.521" starttime="20190401 12:29:55.521"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:55.522" starttime="20190401 12:29:55.521"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:55.522" starttime="20190401 12:29:55.522"></status>
</kw>
<msg timestamp="20190401 12:29:55.522" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:55.522" starttime="20190401 12:29:55.520"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:55.522" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:55.522" starttime="20190401 12:29:55.522"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:55.538" level="INFO">system host-disk-partition-add control ler-0 ec871e4b-becb-4b45-9c37-a93e2b763b54 20 -t lvm_phys_vol</msg>
<status status="PASS" endtime="20190401 12:29:55.538" starttime="20190401 12:29:55.522"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:56.733" level="INFO">+-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| device_node | /dev/sda6                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 20480                                            |
| uuid        | 1e42ad81-7019-47fc-b07c-8be2b48cef66             |
| ihost_uuid  | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6             |
| idisk_uuid  | ec871e4b-becb-4b45-9c37-a93e2b763b54             |
| ipv_uuid    | None                                             |
| status      | Creating                                         |
| created_at  | 2019-04-01T18:18:41.352531+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:56.733" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:29:56.733" starttime="20190401 12:29:55.538"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:56.734" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:56.734" starttime="20190401 12:29:56.734"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:56.734" level="INFO">${clean_out} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:29:56.734" starttime="20190401 12:29:56.734"></status>
</kw>
<msg timestamp="20190401 12:29:56.734" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:29:56.734" starttime="20190401 12:29:56.733"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:56.737" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:56.737" starttime="20190401 12:29:56.735"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:56.737" level="INFO">0</msg>
<msg timestamp="20190401 12:29:56.737" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:56.737" starttime="20190401 12:29:56.737"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:56.738" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:56.738" starttime="20190401 12:29:56.738"></status>
</kw>
<msg timestamp="20190401 12:29:56.738" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:56.738" starttime="20190401 12:29:56.735"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:56.739" starttime="20190401 12:29:56.738"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:56.739" starttime="20190401 12:29:56.738"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:56.739" starttime="20190401 12:29:56.739"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:56.739" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| device_node | /dev/sda6                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 20480                                            |
| uuid        | 1e42ad81-7019-47fc-b07c-8be2b48cef66             |
| ihost_uuid  | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6             |
| idisk_uuid  | ec871e4b-becb-4b45-9c37-a93e2b763b54             |
| ipv_uuid    | None                                             |
| status      | Creating                                         |
| created_at  | 2019-04-01T18:18:41.352531+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:29:56.739" starttime="20190401 12:29:56.739"></status>
</kw>
<msg timestamp="20190401 12:29:56.740" level="INFO">${result} = {u'stdout': u'+-------------+--------------------------------------------------+\r\n| Property    | Value                                            |\r\n+-------------+-------------------------------...</msg>
<status status="PASS" endtime="20190401 12:29:56.740" starttime="20190401 12:29:55.520"></status>
</kw>
<kw name="Get Property From Result" library="Utils">
<arguments>
<arg>${result}</arg>
<arg>uuid</arg>
</arguments>
<assign>
<var>${new_uid}</var>
</assign>
<kw name="String To Dict" library="common">
<doc>Convert string table to dictionary</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:29:56.740" level="INFO">${dict} = {'Property': {'status': {'Value': 'Creating'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '1e42ad81-7019-47fc-b07c-...</msg>
<status status="PASS" endtime="20190401 12:29:56.740" starttime="20190401 12:29:56.740"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Property</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:29:56.741" level="INFO">${dict} = {'status': {'Value': 'Creating'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '1e42ad81-7019-47fc-b07c-8be2b48cef66'...</msg>
<status status="PASS" endtime="20190401 12:29:56.741" starttime="20190401 12:29:56.740"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:29:56.741" level="INFO">${dict} = {'Value': '1e42ad81-7019-47fc-b07c-8be2b48cef66'}</msg>
<status status="PASS" endtime="20190401 12:29:56.741" starttime="20190401 12:29:56.741"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Value</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:29:56.741" level="INFO">${dict} = 1e42ad81-7019-47fc-b07c-8be2b48cef66</msg>
<status status="PASS" endtime="20190401 12:29:56.741" starttime="20190401 12:29:56.741"></status>
</kw>
<msg timestamp="20190401 12:29:56.741" level="INFO">${new_uid} = 1e42ad81-7019-47fc-b07c-8be2b48cef66</msg>
<status status="PASS" endtime="20190401 12:29:56.742" starttime="20190401 12:29:56.740"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>30 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value Of Command</arg>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:56.743" starttime="20190401 12:29:56.743"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:29:56.744" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:29:56.744" starttime="20190401 12:29:56.744"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:56.744" starttime="20190401 12:29:56.744"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:56.745" starttime="20190401 12:29:56.745"></status>
</kw>
<msg timestamp="20190401 12:29:56.745" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:29:56.745" starttime="20190401 12:29:56.743"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:29:56.745" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:56.745" starttime="20190401 12:29:56.745"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:29:56.764" level="INFO">system host-disk-partition-show contro ller-0 1e42ad81-7019-47fc-b07c-8be2b48cef66 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:29:56.764" starttime="20190401 12:29:56.745"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:29:57.801" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:29:57.801" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:57.801" starttime="20190401 12:29:56.764"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:29:57.802" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:29:57.802" starttime="20190401 12:29:57.801"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:29:57.802" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190401 12:29:57.802" starttime="20190401 12:29:57.802"></status>
</kw>
<msg timestamp="20190401 12:29:57.802" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190401 12:29:57.803" starttime="20190401 12:29:57.801"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:29:57.805" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:29:57.805" starttime="20190401 12:29:57.803"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:29:57.805" level="INFO">0</msg>
<msg timestamp="20190401 12:29:57.805" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:57.805" starttime="20190401 12:29:57.805"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:29:57.806" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:29:57.806" starttime="20190401 12:29:57.805"></status>
</kw>
<msg timestamp="20190401 12:29:57.806" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:29:57.806" starttime="20190401 12:29:57.803"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:57.807" starttime="20190401 12:29:57.806"></status>
</kw>
<status status="PASS" endtime="20190401 12:29:57.807" starttime="20190401 12:29:57.806"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:29:57.807" starttime="20190401 12:29:57.807"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:29:57.807" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190401 12:29:57.807" starttime="20190401 12:29:57.807"></status>
</kw>
<msg timestamp="20190401 12:29:57.808" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:29:57.808" starttime="20190401 12:29:56.743"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:29:57.808" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190401 12:29:57.808" starttime="20190401 12:29:57.808"></status>
</kw>
<msg timestamp="20190401 12:29:57.808" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190401 12:29:57.808" starttime="20190401 12:29:56.742"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:29:57.809" level="FAIL">Creating != Ready</msg>
<status status="FAIL" endtime="20190401 12:29:57.809" starttime="20190401 12:29:57.808"></status>
</kw>
<status status="FAIL" endtime="20190401 12:29:57.809" starttime="20190401 12:29:56.742"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:07.811" starttime="20190401 12:30:07.810"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:30:07.812" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:30:07.812" starttime="20190401 12:30:07.811"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:07.812" starttime="20190401 12:30:07.812"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:07.812" starttime="20190401 12:30:07.812"></status>
</kw>
<msg timestamp="20190401 12:30:07.812" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:30:07.812" starttime="20190401 12:30:07.811"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:30:07.813" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:07.813" starttime="20190401 12:30:07.813"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:30:07.828" level="INFO">system host-disk-partition-show contro ller-0 1e42ad81-7019-47fc-b07c-8be2b48cef66 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:30:07.828" starttime="20190401 12:30:07.813"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:30:08.862" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:30:08.862" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:08.862" starttime="20190401 12:30:07.828"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:30:08.863" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:08.863" starttime="20190401 12:30:08.863"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:30:08.863" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190401 12:30:08.863" starttime="20190401 12:30:08.863"></status>
</kw>
<msg timestamp="20190401 12:30:08.863" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190401 12:30:08.863" starttime="20190401 12:30:08.862"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:30:08.865" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:30:08.865" starttime="20190401 12:30:08.864"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:30:08.866" level="INFO">0</msg>
<msg timestamp="20190401 12:30:08.866" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:08.866" starttime="20190401 12:30:08.865"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:30:08.867" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:30:08.867" starttime="20190401 12:30:08.867"></status>
</kw>
<msg timestamp="20190401 12:30:08.867" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:08.867" starttime="20190401 12:30:08.864"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:08.868" starttime="20190401 12:30:08.868"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:08.868" starttime="20190401 12:30:08.867"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:08.868" starttime="20190401 12:30:08.868"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:30:08.868" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190401 12:30:08.868" starttime="20190401 12:30:08.868"></status>
</kw>
<msg timestamp="20190401 12:30:08.869" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:30:08.869" starttime="20190401 12:30:07.810"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:30:08.869" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190401 12:30:08.869" starttime="20190401 12:30:08.869"></status>
</kw>
<msg timestamp="20190401 12:30:08.869" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190401 12:30:08.869" starttime="20190401 12:30:07.810"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:30:08.870" level="FAIL">Creating != Ready</msg>
<status status="FAIL" endtime="20190401 12:30:08.870" starttime="20190401 12:30:08.869"></status>
</kw>
<status status="FAIL" endtime="20190401 12:30:08.870" starttime="20190401 12:30:07.809"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:18.872" starttime="20190401 12:30:18.871"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:30:18.872" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:30:18.872" starttime="20190401 12:30:18.872"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:18.873" starttime="20190401 12:30:18.873"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:18.873" starttime="20190401 12:30:18.873"></status>
</kw>
<msg timestamp="20190401 12:30:18.874" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:30:18.874" starttime="20190401 12:30:18.872"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:30:18.874" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:18.874" starttime="20190401 12:30:18.874"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:30:18.891" level="INFO">system host-disk-partition-show contro ller-0 1e42ad81-7019-47fc-b07c-8be2b48cef66 | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:30:18.891" starttime="20190401 12:30:18.874"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:30:19.934" level="INFO">Ready
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:30:19.934" level="INFO">${output} = Ready
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:19.934" starttime="20190401 12:30:18.891"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:30:19.935" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:19.935" starttime="20190401 12:30:19.935"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:30:19.935" level="INFO">${clean_out} = Ready
</msg>
<status status="PASS" endtime="20190401 12:30:19.935" starttime="20190401 12:30:19.935"></status>
</kw>
<msg timestamp="20190401 12:30:19.935" level="INFO">${output} = Ready
</msg>
<status status="PASS" endtime="20190401 12:30:19.935" starttime="20190401 12:30:19.934"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:30:19.937" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:30:19.937" starttime="20190401 12:30:19.936"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:30:19.938" level="INFO">0</msg>
<msg timestamp="20190401 12:30:19.938" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:19.938" starttime="20190401 12:30:19.937"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:30:19.938" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:30:19.938" starttime="20190401 12:30:19.938"></status>
</kw>
<msg timestamp="20190401 12:30:19.938" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:19.939" starttime="20190401 12:30:19.935"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:19.939" starttime="20190401 12:30:19.939"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:19.939" starttime="20190401 12:30:19.939"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:19.940" starttime="20190401 12:30:19.939"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:30:19.940" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Ready</msg>
<status status="PASS" endtime="20190401 12:30:19.940" starttime="20190401 12:30:19.940"></status>
</kw>
<msg timestamp="20190401 12:30:19.940" level="INFO">${result} = {u'stdout': u'Ready', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:30:19.940" starttime="20190401 12:30:18.871"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:30:19.940" level="INFO">${value} = Ready</msg>
<status status="PASS" endtime="20190401 12:30:19.940" starttime="20190401 12:30:19.940"></status>
</kw>
<msg timestamp="20190401 12:30:19.941" level="INFO">${current_value} = Ready</msg>
<status status="PASS" endtime="20190401 12:30:19.941" starttime="20190401 12:30:18.871"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:19.941" starttime="20190401 12:30:19.941"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:19.941" starttime="20190401 12:30:18.870"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:19.941" starttime="20190401 12:29:56.742"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:19.941" starttime="20190401 12:29:55.519"></status>
</kw>
<msg timestamp="20190401 12:30:19.941" level="INFO">${cgts_partition_uuid} = 1e42ad81-7019-47fc-b07c-8be2b48cef66</msg>
<status status="PASS" endtime="20190401 12:30:19.941" starttime="20190401 12:29:55.519"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True or ${setup_cgts}==True</arg>
<arg>Add Physical Volume</arg>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${cgts_partition_uuid}</arg>
</arguments>
<kw name="Add Physical Volume" library="Utils">
<doc>Adds a physical volume to the specified host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${cgts_partition_uuid}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-pv-add ${host} ${lvg name} ${uid}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:19.943" starttime="20190401 12:30:19.943"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:30:19.943" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:30:19.943" starttime="20190401 12:30:19.943"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:19.944" starttime="20190401 12:30:19.944"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:19.944" starttime="20190401 12:30:19.944"></status>
</kw>
<msg timestamp="20190401 12:30:19.944" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:30:19.944" starttime="20190401 12:30:19.943"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:30:19.945" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:19.945" starttime="20190401 12:30:19.945"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:30:19.957" level="INFO">system host-pv-add controller-0 nova-l ocal 1e42ad81-7019-47fc-b07c-8be2b48cef66</msg>
<status status="PASS" endtime="20190401 12:30:19.957" starttime="20190401 12:30:19.945"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:30:21.206" level="INFO">+--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | e6ae084c-9805-43ad-b8bc-dc5cdbed75fb             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 1e42ad81-7019-47fc-b07c-8be2b48cef66             |
| disk_or_part_device_node | /dev/sda6                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| lvm_pv_name              | /dev/sda6                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6             |
| created_at               | 2019-04-01T18:19:05.813864+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:30:21.206" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:30:21.206" starttime="20190401 12:30:19.957"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:30:21.207" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:21.207" starttime="20190401 12:30:21.206"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:30:21.207" level="INFO">${clean_out} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:30:21.207" starttime="20190401 12:30:21.207"></status>
</kw>
<msg timestamp="20190401 12:30:21.207" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:30:21.207" starttime="20190401 12:30:21.206"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:30:21.209" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:30:21.209" starttime="20190401 12:30:21.208"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:30:21.210" level="INFO">0</msg>
<msg timestamp="20190401 12:30:21.210" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:21.210" starttime="20190401 12:30:21.209"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:30:21.211" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:30:21.211" starttime="20190401 12:30:21.211"></status>
</kw>
<msg timestamp="20190401 12:30:21.211" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:21.211" starttime="20190401 12:30:21.208"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:21.212" starttime="20190401 12:30:21.211"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:21.212" starttime="20190401 12:30:21.211"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:21.212" starttime="20190401 12:30:21.212"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:30:21.212" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | e6ae084c-9805-43ad-b8bc-dc5cdbed75fb             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 1e42ad81-7019-47fc-b07c-8be2b48cef66             |
| disk_or_part_device_node | /dev/sda6                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| lvm_pv_name              | /dev/sda6                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6             |
| created_at               | 2019-04-01T18:19:05.813864+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:30:21.212" starttime="20190401 12:30:21.212"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:21.213" starttime="20190401 12:30:19.942"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:21.213" starttime="20190401 12:30:19.942"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:21.213" starttime="20190401 12:30:19.942"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:21.213" starttime="20190401 12:29:25.681"></status>
</kw>
<kw name="Configure Ceph" library="Utils">
<doc>Enable CEPH partition on the specified node</doc>
<arguments>
<arg>${master_controller}</arg>
<arg>${backend_type}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-0'</arg>
<arg>Run Keywords</arg>
<arg>Add LVM Storage Backend</arg>
<arg>${backend_type}</arg>
<arg>--confirmed</arg>
<arg>AND</arg>
<arg>Check Ceph Status</arg>
<arg>HEALTH_ERR</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Add LVM Storage Backend</arg>
<arg>${backend_type}</arg>
<arg>--confirmed</arg>
<arg>AND</arg>
<arg>Check Ceph Status</arg>
<arg>HEALTH_ERR</arg>
</arguments>
<kw name="Add LVM Storage Backend" library="Utils">
<doc>Adds the LVM storage backend with specified arguments</doc>
<arguments>
<arg>${backend_type}</arg>
<arg>--confirmed</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system storage-backend-add ${backend} ${args}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:21.215" starttime="20190401 12:30:21.214"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:30:21.215" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:30:21.215" starttime="20190401 12:30:21.215"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:21.216" starttime="20190401 12:30:21.216"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:21.216" starttime="20190401 12:30:21.216"></status>
</kw>
<msg timestamp="20190401 12:30:21.216" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:30:21.216" starttime="20190401 12:30:21.215"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:30:21.217" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:21.217" starttime="20190401 12:30:21.216"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:30:21.223" level="INFO">system storage-backend-add ceph --conf irmed</msg>
<status status="PASS" endtime="20190401 12:30:21.223" starttime="20190401 12:30:21.217"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:30:24.887" level="INFO">System configuration has changed.
Please follow the administrator guide to complete configuring the system.

+--------------------------------------+------------+---------+-------------+------+----------+--------------------+
| uuid                                 | name       | backend | state       | task | services | capabilities       |
+--------------------------------------+------------+---------+-------------+------+----------+--------------------+
| 1a8f19bb-94ae-44a6-adea-fc62cf163b64 | file-store | file    | configured  | None | glance   |                    |
| 46a52408-c2d3-4cbb-b843-80682aa791a6 | ceph-store | ceph    | configuring | {}   | None     | min_replication: 1 |
|                                      |            |         |             |      |          | replication: 2     |
+--------------------------------------+------------+---------+-------------+------+----------+--------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:30:24.887" level="INFO">${output} = 
System configuration has changed.
Please follow the administrator guide to complete configuring the system.

+--------------------------------------+------------+---------+-------------+------+--...</msg>
<status status="PASS" endtime="20190401 12:30:24.887" starttime="20190401 12:30:21.223"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:30:24.888" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:24.888" starttime="20190401 12:30:24.888"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:30:24.889" level="INFO">${clean_out} = 
System configuration has changed.
Please follow the administrator guide to complete configuring the system.

+--------------------------------------+------------+---------+-------------+------+--...</msg>
<status status="PASS" endtime="20190401 12:30:24.889" starttime="20190401 12:30:24.888"></status>
</kw>
<msg timestamp="20190401 12:30:24.889" level="INFO">${output} = 
System configuration has changed.
Please follow the administrator guide to complete configuring the system.

+--------------------------------------+------------+---------+-------------+------+--...</msg>
<status status="PASS" endtime="20190401 12:30:24.889" starttime="20190401 12:30:24.888"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:30:24.890" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:30:24.890" starttime="20190401 12:30:24.889"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:30:24.891" level="INFO">0</msg>
<msg timestamp="20190401 12:30:24.891" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:24.891" starttime="20190401 12:30:24.891"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:30:24.892" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:30:24.892" starttime="20190401 12:30:24.891"></status>
</kw>
<msg timestamp="20190401 12:30:24.892" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:24.892" starttime="20190401 12:30:24.889"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:24.893" starttime="20190401 12:30:24.892"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:24.893" starttime="20190401 12:30:24.892"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:24.893" starttime="20190401 12:30:24.893"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:30:24.893" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: System configuration has changed.
Please follow the administrator guide to complete configuring the system.

+--------------------------------------+------------+---------+-------------+------+----------+--------------------+
| uuid                                 | name       | backend | state       | task | services | capabilities       |
+--------------------------------------+------------+---------+-------------+------+----------+--------------------+
| 1a8f19bb-94ae-44a6-adea-fc62cf163b64 | file-store | file    | configured  | None | glance   |                    |
| 46a52408-c2d3-4cbb-b843-80682aa791a6 | ceph-store | ceph    | configuring | {}   | None     | min_replication: 1 |
|                                      |            |         |             |      |          | replication: 2     |
+--------------------------------------+------------+---------+-------------+------+----------+--------------------+</msg>
<status status="PASS" endtime="20190401 12:30:24.893" starttime="20190401 12:30:24.893"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:24.893" starttime="20190401 12:30:21.214"></status>
</kw>
<kw name="Get LVM Storage Backend UID" library="Utils">
<doc>Returns the UID of the specified Backend.</doc>
<arguments>
<arg>${backend}</arg>
</arguments>
<assign>
<var>${name}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system storage-backend-list | grep ${backend} | awk '{print $2}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:24.894" starttime="20190401 12:30:24.894"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:30:24.895" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:30:24.895" starttime="20190401 12:30:24.895"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:24.895" starttime="20190401 12:30:24.895"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:24.896" starttime="20190401 12:30:24.895"></status>
</kw>
<msg timestamp="20190401 12:30:24.896" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:30:24.896" starttime="20190401 12:30:24.894"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:30:24.896" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:24.896" starttime="20190401 12:30:24.896"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:30:24.906" level="INFO">system storage-backend-list | grep cep h | awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:30:24.906" starttime="20190401 12:30:24.896"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:30:25.935" level="INFO">46a52408-c2d3-4cbb-b843-80682aa791a6
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:30:25.936" level="INFO">${output} = 46a52408-c2d3-4cbb-b843-80682aa791a6
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:25.936" starttime="20190401 12:30:24.906"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:30:25.936" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:25.936" starttime="20190401 12:30:25.936"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:30:25.937" level="INFO">${clean_out} = 46a52408-c2d3-4cbb-b843-80682aa791a6
</msg>
<status status="PASS" endtime="20190401 12:30:25.937" starttime="20190401 12:30:25.937"></status>
</kw>
<msg timestamp="20190401 12:30:25.937" level="INFO">${output} = 46a52408-c2d3-4cbb-b843-80682aa791a6
</msg>
<status status="PASS" endtime="20190401 12:30:25.937" starttime="20190401 12:30:25.936"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:30:25.939" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:30:25.939" starttime="20190401 12:30:25.937"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:30:25.939" level="INFO">0</msg>
<msg timestamp="20190401 12:30:25.940" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:25.940" starttime="20190401 12:30:25.939"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:30:25.940" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:30:25.940" starttime="20190401 12:30:25.940"></status>
</kw>
<msg timestamp="20190401 12:30:25.940" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:25.940" starttime="20190401 12:30:25.937"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:25.941" starttime="20190401 12:30:25.940"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:25.941" starttime="20190401 12:30:25.940"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:25.941" starttime="20190401 12:30:25.941"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:30:25.941" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 46a52408-c2d3-4cbb-b843-80682aa791a6</msg>
<status status="PASS" endtime="20190401 12:30:25.941" starttime="20190401 12:30:25.941"></status>
</kw>
<msg timestamp="20190401 12:30:25.942" level="INFO">${result} = {u'stdout': u'46a52408-c2d3-4cbb-b843-80682aa791a6', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:30:25.942" starttime="20190401 12:30:24.894"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:30:25.942" level="INFO">${value} = 46a52408-c2d3-4cbb-b843-80682aa791a6</msg>
<status status="PASS" endtime="20190401 12:30:25.942" starttime="20190401 12:30:25.942"></status>
</kw>
<msg timestamp="20190401 12:30:25.942" level="INFO">${name} = 46a52408-c2d3-4cbb-b843-80682aa791a6</msg>
<status status="PASS" endtime="20190401 12:30:25.942" starttime="20190401 12:30:24.894"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>30 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value Of Command</arg>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:25.944" starttime="20190401 12:30:25.944"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:30:25.945" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:30:25.945" starttime="20190401 12:30:25.944"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:25.945" starttime="20190401 12:30:25.945"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:25.945" starttime="20190401 12:30:25.945"></status>
</kw>
<msg timestamp="20190401 12:30:25.946" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:30:25.946" starttime="20190401 12:30:25.944"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:30:25.946" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:25.946" starttime="20190401 12:30:25.946"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:30:25.961" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:30:25.961" starttime="20190401 12:30:25.946"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:30:27.032" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:30:27.032" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:27.032" starttime="20190401 12:30:25.961"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:30:27.033" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:27.033" starttime="20190401 12:30:27.032"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:30:27.033" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:30:27.033" starttime="20190401 12:30:27.033"></status>
</kw>
<msg timestamp="20190401 12:30:27.033" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:30:27.033" starttime="20190401 12:30:27.032"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:30:27.035" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:30:27.035" starttime="20190401 12:30:27.033"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:30:27.035" level="INFO">0</msg>
<msg timestamp="20190401 12:30:27.036" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:27.036" starttime="20190401 12:30:27.035"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:30:27.036" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:30:27.036" starttime="20190401 12:30:27.036"></status>
</kw>
<msg timestamp="20190401 12:30:27.036" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:27.036" starttime="20190401 12:30:27.033"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:27.037" starttime="20190401 12:30:27.037"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:27.037" starttime="20190401 12:30:27.036"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:27.037" starttime="20190401 12:30:27.037"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:30:27.038" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:30:27.038" starttime="20190401 12:30:27.037"></status>
</kw>
<msg timestamp="20190401 12:30:27.038" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:30:27.038" starttime="20190401 12:30:25.943"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:30:27.038" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:30:27.038" starttime="20190401 12:30:27.038"></status>
</kw>
<msg timestamp="20190401 12:30:27.038" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:30:27.038" starttime="20190401 12:30:25.943"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:30:27.039" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:30:27.039" starttime="20190401 12:30:27.038"></status>
</kw>
<status status="FAIL" endtime="20190401 12:30:27.039" starttime="20190401 12:30:25.943"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:37.041" starttime="20190401 12:30:37.041"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:30:37.042" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:30:37.042" starttime="20190401 12:30:37.041"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:37.042" starttime="20190401 12:30:37.042"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:37.042" starttime="20190401 12:30:37.042"></status>
</kw>
<msg timestamp="20190401 12:30:37.043" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:30:37.043" starttime="20190401 12:30:37.041"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:30:37.043" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:37.043" starttime="20190401 12:30:37.043"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:30:37.057" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:30:37.057" starttime="20190401 12:30:37.043"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:30:38.144" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:30:38.144" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:38.144" starttime="20190401 12:30:37.057"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:30:38.145" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:38.145" starttime="20190401 12:30:38.145"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:30:38.146" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:30:38.146" starttime="20190401 12:30:38.145"></status>
</kw>
<msg timestamp="20190401 12:30:38.146" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:30:38.146" starttime="20190401 12:30:38.145"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:30:38.147" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:30:38.147" starttime="20190401 12:30:38.146"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:30:38.148" level="INFO">0</msg>
<msg timestamp="20190401 12:30:38.148" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:38.149" starttime="20190401 12:30:38.148"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:30:38.149" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:30:38.149" starttime="20190401 12:30:38.149"></status>
</kw>
<msg timestamp="20190401 12:30:38.149" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:38.149" starttime="20190401 12:30:38.146"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:38.150" starttime="20190401 12:30:38.150"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:38.150" starttime="20190401 12:30:38.149"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:38.150" starttime="20190401 12:30:38.150"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:30:38.150" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:30:38.151" starttime="20190401 12:30:38.150"></status>
</kw>
<msg timestamp="20190401 12:30:38.151" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:30:38.151" starttime="20190401 12:30:37.040"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:30:38.151" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:30:38.151" starttime="20190401 12:30:38.151"></status>
</kw>
<msg timestamp="20190401 12:30:38.151" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:30:38.151" starttime="20190401 12:30:37.040"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:30:38.152" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:30:38.152" starttime="20190401 12:30:38.151"></status>
</kw>
<status status="FAIL" endtime="20190401 12:30:38.152" starttime="20190401 12:30:37.039"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:48.154" starttime="20190401 12:30:48.153"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:30:48.155" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:30:48.155" starttime="20190401 12:30:48.154"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:48.155" starttime="20190401 12:30:48.155"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:48.155" starttime="20190401 12:30:48.155"></status>
</kw>
<msg timestamp="20190401 12:30:48.156" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:30:48.156" starttime="20190401 12:30:48.154"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:30:48.156" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:48.156" starttime="20190401 12:30:48.156"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:30:48.171" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:30:48.171" starttime="20190401 12:30:48.156"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:30:49.326" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:30:49.327" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:49.327" starttime="20190401 12:30:48.171"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:30:49.327" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:49.327" starttime="20190401 12:30:49.327"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:30:49.328" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:30:49.328" starttime="20190401 12:30:49.328"></status>
</kw>
<msg timestamp="20190401 12:30:49.328" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:30:49.328" starttime="20190401 12:30:49.327"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:30:49.330" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:30:49.330" starttime="20190401 12:30:49.328"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:30:49.331" level="INFO">0</msg>
<msg timestamp="20190401 12:30:49.331" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:49.331" starttime="20190401 12:30:49.330"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:30:49.331" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:30:49.331" starttime="20190401 12:30:49.331"></status>
</kw>
<msg timestamp="20190401 12:30:49.331" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:30:49.331" starttime="20190401 12:30:49.328"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:49.332" starttime="20190401 12:30:49.332"></status>
</kw>
<status status="PASS" endtime="20190401 12:30:49.332" starttime="20190401 12:30:49.331"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:49.332" starttime="20190401 12:30:49.332"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:30:49.333" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:30:49.333" starttime="20190401 12:30:49.333"></status>
</kw>
<msg timestamp="20190401 12:30:49.333" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:30:49.333" starttime="20190401 12:30:48.153"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:30:49.333" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:30:49.333" starttime="20190401 12:30:49.333"></status>
</kw>
<msg timestamp="20190401 12:30:49.333" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:30:49.334" starttime="20190401 12:30:48.153"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:30:49.334" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:30:49.334" starttime="20190401 12:30:49.334"></status>
</kw>
<status status="FAIL" endtime="20190401 12:30:49.334" starttime="20190401 12:30:48.152"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:59.336" starttime="20190401 12:30:59.336"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:30:59.337" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:30:59.337" starttime="20190401 12:30:59.336"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:59.338" starttime="20190401 12:30:59.337"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:30:59.338" starttime="20190401 12:30:59.338"></status>
</kw>
<msg timestamp="20190401 12:30:59.338" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:30:59.338" starttime="20190401 12:30:59.336"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:30:59.338" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:30:59.339" starttime="20190401 12:30:59.338"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:30:59.351" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:30:59.351" starttime="20190401 12:30:59.339"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:31:00.435" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:31:00.436" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:00.436" starttime="20190401 12:30:59.351"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:31:00.436" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:00.436" starttime="20190401 12:31:00.436"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:31:00.437" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:00.437" starttime="20190401 12:31:00.437"></status>
</kw>
<msg timestamp="20190401 12:31:00.437" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:00.437" starttime="20190401 12:31:00.436"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:31:00.438" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:31:00.438" starttime="20190401 12:31:00.437"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:31:00.439" level="INFO">0</msg>
<msg timestamp="20190401 12:31:00.439" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:00.439" starttime="20190401 12:31:00.439"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:31:00.440" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:31:00.440" starttime="20190401 12:31:00.439"></status>
</kw>
<msg timestamp="20190401 12:31:00.440" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:00.440" starttime="20190401 12:31:00.437"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:00.441" starttime="20190401 12:31:00.440"></status>
</kw>
<status status="PASS" endtime="20190401 12:31:00.441" starttime="20190401 12:31:00.440"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:00.441" starttime="20190401 12:31:00.441"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:31:00.441" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:31:00.441" starttime="20190401 12:31:00.441"></status>
</kw>
<msg timestamp="20190401 12:31:00.441" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:31:00.441" starttime="20190401 12:30:59.335"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:31:00.442" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:00.442" starttime="20190401 12:31:00.442"></status>
</kw>
<msg timestamp="20190401 12:31:00.442" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:00.442" starttime="20190401 12:30:59.335"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:31:00.442" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:31:00.443" starttime="20190401 12:31:00.442"></status>
</kw>
<status status="FAIL" endtime="20190401 12:31:00.443" starttime="20190401 12:30:59.334"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:10.444" starttime="20190401 12:31:10.444"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:31:10.445" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:31:10.445" starttime="20190401 12:31:10.445"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:10.445" starttime="20190401 12:31:10.445"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:10.446" starttime="20190401 12:31:10.446"></status>
</kw>
<msg timestamp="20190401 12:31:10.446" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:31:10.446" starttime="20190401 12:31:10.445"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:31:10.446" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:10.446" starttime="20190401 12:31:10.446"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:31:10.458" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:31:10.458" starttime="20190401 12:31:10.446"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:31:11.556" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:31:11.556" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:11.556" starttime="20190401 12:31:10.458"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:31:11.557" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:11.557" starttime="20190401 12:31:11.557"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:31:11.557" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:11.557" starttime="20190401 12:31:11.557"></status>
</kw>
<msg timestamp="20190401 12:31:11.557" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:11.557" starttime="20190401 12:31:11.556"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:31:11.559" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:31:11.559" starttime="20190401 12:31:11.558"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:31:11.560" level="INFO">0</msg>
<msg timestamp="20190401 12:31:11.560" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:11.560" starttime="20190401 12:31:11.559"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:31:11.560" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:31:11.560" starttime="20190401 12:31:11.560"></status>
</kw>
<msg timestamp="20190401 12:31:11.560" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:11.560" starttime="20190401 12:31:11.557"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:11.561" starttime="20190401 12:31:11.561"></status>
</kw>
<status status="PASS" endtime="20190401 12:31:11.561" starttime="20190401 12:31:11.560"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:11.561" starttime="20190401 12:31:11.561"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:31:11.562" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:31:11.562" starttime="20190401 12:31:11.561"></status>
</kw>
<msg timestamp="20190401 12:31:11.562" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:31:11.562" starttime="20190401 12:31:10.444"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:31:11.562" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:11.562" starttime="20190401 12:31:11.562"></status>
</kw>
<msg timestamp="20190401 12:31:11.562" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:11.562" starttime="20190401 12:31:10.443"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:31:11.563" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:31:11.563" starttime="20190401 12:31:11.562"></status>
</kw>
<status status="FAIL" endtime="20190401 12:31:11.563" starttime="20190401 12:31:10.443"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:21.565" starttime="20190401 12:31:21.565"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:31:21.567" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:31:21.567" starttime="20190401 12:31:21.566"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:21.567" starttime="20190401 12:31:21.567"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:21.568" starttime="20190401 12:31:21.567"></status>
</kw>
<msg timestamp="20190401 12:31:21.568" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:31:21.568" starttime="20190401 12:31:21.566"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:31:21.568" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:21.569" starttime="20190401 12:31:21.568"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:31:21.590" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:31:21.590" starttime="20190401 12:31:21.569"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:31:22.664" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:31:22.664" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:22.664" starttime="20190401 12:31:21.590"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:31:22.665" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:22.665" starttime="20190401 12:31:22.664"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:31:22.665" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:22.665" starttime="20190401 12:31:22.665"></status>
</kw>
<msg timestamp="20190401 12:31:22.665" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:22.665" starttime="20190401 12:31:22.664"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:31:22.667" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:31:22.667" starttime="20190401 12:31:22.666"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:31:22.668" level="INFO">0</msg>
<msg timestamp="20190401 12:31:22.668" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:22.668" starttime="20190401 12:31:22.667"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:31:22.668" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:31:22.668" starttime="20190401 12:31:22.668"></status>
</kw>
<msg timestamp="20190401 12:31:22.668" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:22.668" starttime="20190401 12:31:22.665"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:22.669" starttime="20190401 12:31:22.669"></status>
</kw>
<status status="PASS" endtime="20190401 12:31:22.669" starttime="20190401 12:31:22.668"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:22.669" starttime="20190401 12:31:22.669"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:31:22.670" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:31:22.670" starttime="20190401 12:31:22.669"></status>
</kw>
<msg timestamp="20190401 12:31:22.670" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:31:22.670" starttime="20190401 12:31:21.564"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:31:22.670" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:22.670" starttime="20190401 12:31:22.670"></status>
</kw>
<msg timestamp="20190401 12:31:22.670" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:22.670" starttime="20190401 12:31:21.564"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:31:22.671" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:31:22.671" starttime="20190401 12:31:22.671"></status>
</kw>
<status status="FAIL" endtime="20190401 12:31:22.671" starttime="20190401 12:31:21.563"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:32.673" starttime="20190401 12:31:32.673"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:31:32.674" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:31:32.674" starttime="20190401 12:31:32.673"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:32.674" starttime="20190401 12:31:32.674"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:32.674" starttime="20190401 12:31:32.674"></status>
</kw>
<msg timestamp="20190401 12:31:32.674" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:31:32.675" starttime="20190401 12:31:32.673"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:31:32.675" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:32.675" starttime="20190401 12:31:32.675"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:31:32.690" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:31:32.690" starttime="20190401 12:31:32.675"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:31:33.774" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:31:33.774" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:33.774" starttime="20190401 12:31:32.690"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:31:33.775" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:33.775" starttime="20190401 12:31:33.775"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:31:33.775" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:33.775" starttime="20190401 12:31:33.775"></status>
</kw>
<msg timestamp="20190401 12:31:33.775" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:33.775" starttime="20190401 12:31:33.774"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:31:33.777" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:31:33.777" starttime="20190401 12:31:33.776"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:31:33.778" level="INFO">0</msg>
<msg timestamp="20190401 12:31:33.778" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:33.778" starttime="20190401 12:31:33.777"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:31:33.778" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:31:33.778" starttime="20190401 12:31:33.778"></status>
</kw>
<msg timestamp="20190401 12:31:33.779" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:33.779" starttime="20190401 12:31:33.775"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:33.779" starttime="20190401 12:31:33.779"></status>
</kw>
<status status="PASS" endtime="20190401 12:31:33.779" starttime="20190401 12:31:33.779"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:33.780" starttime="20190401 12:31:33.779"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:31:33.780" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:31:33.780" starttime="20190401 12:31:33.780"></status>
</kw>
<msg timestamp="20190401 12:31:33.780" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:31:33.780" starttime="20190401 12:31:32.672"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:31:33.780" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:33.780" starttime="20190401 12:31:33.780"></status>
</kw>
<msg timestamp="20190401 12:31:33.781" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:33.781" starttime="20190401 12:31:32.672"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:31:33.781" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:31:33.781" starttime="20190401 12:31:33.781"></status>
</kw>
<status status="FAIL" endtime="20190401 12:31:33.781" starttime="20190401 12:31:32.671"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:43.783" starttime="20190401 12:31:43.783"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:31:43.784" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:31:43.784" starttime="20190401 12:31:43.784"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:43.784" starttime="20190401 12:31:43.784"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:43.785" starttime="20190401 12:31:43.784"></status>
</kw>
<msg timestamp="20190401 12:31:43.785" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:31:43.785" starttime="20190401 12:31:43.783"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:31:43.785" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:43.785" starttime="20190401 12:31:43.785"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:31:43.795" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:31:43.795" starttime="20190401 12:31:43.785"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:31:44.880" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:31:44.881" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:44.881" starttime="20190401 12:31:43.795"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:31:44.881" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:44.881" starttime="20190401 12:31:44.881"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:31:44.882" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:44.882" starttime="20190401 12:31:44.882"></status>
</kw>
<msg timestamp="20190401 12:31:44.882" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:44.882" starttime="20190401 12:31:44.881"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:31:44.883" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:31:44.883" starttime="20190401 12:31:44.882"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:31:44.884" level="INFO">0</msg>
<msg timestamp="20190401 12:31:44.885" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:44.885" starttime="20190401 12:31:44.884"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:31:44.885" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:31:44.885" starttime="20190401 12:31:44.885"></status>
</kw>
<msg timestamp="20190401 12:31:44.885" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:44.885" starttime="20190401 12:31:44.882"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:44.886" starttime="20190401 12:31:44.886"></status>
</kw>
<status status="PASS" endtime="20190401 12:31:44.886" starttime="20190401 12:31:44.885"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:44.887" starttime="20190401 12:31:44.886"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:31:44.887" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:31:44.887" starttime="20190401 12:31:44.887"></status>
</kw>
<msg timestamp="20190401 12:31:44.887" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:31:44.887" starttime="20190401 12:31:43.783"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:31:44.887" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:44.887" starttime="20190401 12:31:44.887"></status>
</kw>
<msg timestamp="20190401 12:31:44.888" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:44.888" starttime="20190401 12:31:43.782"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:31:44.888" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:31:44.888" starttime="20190401 12:31:44.888"></status>
</kw>
<status status="FAIL" endtime="20190401 12:31:44.888" starttime="20190401 12:31:43.782"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:54.890" starttime="20190401 12:31:54.890"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:31:54.891" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:31:54.891" starttime="20190401 12:31:54.890"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:54.891" starttime="20190401 12:31:54.891"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:54.891" starttime="20190401 12:31:54.891"></status>
</kw>
<msg timestamp="20190401 12:31:54.892" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:31:54.892" starttime="20190401 12:31:54.890"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:31:54.892" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:54.892" starttime="20190401 12:31:54.892"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:31:54.906" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:31:54.906" starttime="20190401 12:31:54.892"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:31:55.977" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:31:55.977" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:55.977" starttime="20190401 12:31:54.906"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:31:55.978" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:31:55.978" starttime="20190401 12:31:55.978"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:31:55.979" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:55.979" starttime="20190401 12:31:55.978"></status>
</kw>
<msg timestamp="20190401 12:31:55.979" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:31:55.979" starttime="20190401 12:31:55.978"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:31:55.981" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:31:55.981" starttime="20190401 12:31:55.979"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:31:55.981" level="INFO">0</msg>
<msg timestamp="20190401 12:31:55.981" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:55.982" starttime="20190401 12:31:55.981"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:31:55.982" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:31:55.982" starttime="20190401 12:31:55.982"></status>
</kw>
<msg timestamp="20190401 12:31:55.982" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:31:55.982" starttime="20190401 12:31:55.979"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:55.983" starttime="20190401 12:31:55.983"></status>
</kw>
<status status="PASS" endtime="20190401 12:31:55.983" starttime="20190401 12:31:55.982"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:31:55.983" starttime="20190401 12:31:55.983"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:31:55.983" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:31:55.984" starttime="20190401 12:31:55.983"></status>
</kw>
<msg timestamp="20190401 12:31:55.984" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:31:55.984" starttime="20190401 12:31:54.889"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:31:55.984" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:55.984" starttime="20190401 12:31:55.984"></status>
</kw>
<msg timestamp="20190401 12:31:55.984" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:31:55.984" starttime="20190401 12:31:54.889"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:31:55.985" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:31:55.985" starttime="20190401 12:31:55.984"></status>
</kw>
<status status="FAIL" endtime="20190401 12:31:55.985" starttime="20190401 12:31:54.889"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:05.988" starttime="20190401 12:32:05.987"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:05.989" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:05.989" starttime="20190401 12:32:05.988"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:05.990" starttime="20190401 12:32:05.989"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:05.990" starttime="20190401 12:32:05.990"></status>
</kw>
<msg timestamp="20190401 12:32:05.991" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:05.991" starttime="20190401 12:32:05.988"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:05.991" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:05.991" starttime="20190401 12:32:05.991"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:06.014" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:32:06.014" starttime="20190401 12:32:05.991"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:07.090" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:07.090" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:07.090" starttime="20190401 12:32:06.014"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:07.091" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:07.091" starttime="20190401 12:32:07.090"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:07.091" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:32:07.091" starttime="20190401 12:32:07.091"></status>
</kw>
<msg timestamp="20190401 12:32:07.091" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:32:07.091" starttime="20190401 12:32:07.090"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:07.093" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:07.093" starttime="20190401 12:32:07.091"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:07.094" level="INFO">0</msg>
<msg timestamp="20190401 12:32:07.094" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:07.094" starttime="20190401 12:32:07.093"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:07.094" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:07.094" starttime="20190401 12:32:07.094"></status>
</kw>
<msg timestamp="20190401 12:32:07.094" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:07.094" starttime="20190401 12:32:07.091"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:07.095" starttime="20190401 12:32:07.095"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:07.095" starttime="20190401 12:32:07.095"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:07.096" starttime="20190401 12:32:07.095"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:07.096" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:32:07.096" starttime="20190401 12:32:07.096"></status>
</kw>
<msg timestamp="20190401 12:32:07.096" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:32:07.096" starttime="20190401 12:32:05.987"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:32:07.096" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:32:07.096" starttime="20190401 12:32:07.096"></status>
</kw>
<msg timestamp="20190401 12:32:07.097" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:32:07.097" starttime="20190401 12:32:05.986"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:32:07.097" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:32:07.097" starttime="20190401 12:32:07.097"></status>
</kw>
<status status="FAIL" endtime="20190401 12:32:07.097" starttime="20190401 12:32:05.985"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:17.099" starttime="20190401 12:32:17.099"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:17.100" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:17.100" starttime="20190401 12:32:17.100"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:17.100" starttime="20190401 12:32:17.100"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:17.101" starttime="20190401 12:32:17.100"></status>
</kw>
<msg timestamp="20190401 12:32:17.101" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:17.101" starttime="20190401 12:32:17.099"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:17.101" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:17.101" starttime="20190401 12:32:17.101"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:17.116" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:32:17.116" starttime="20190401 12:32:17.101"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:18.201" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:18.201" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:18.201" starttime="20190401 12:32:17.116"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:18.202" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:18.202" starttime="20190401 12:32:18.202"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:18.203" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:32:18.203" starttime="20190401 12:32:18.202"></status>
</kw>
<msg timestamp="20190401 12:32:18.203" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:32:18.203" starttime="20190401 12:32:18.202"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:18.204" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:18.204" starttime="20190401 12:32:18.203"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:18.205" level="INFO">0</msg>
<msg timestamp="20190401 12:32:18.205" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:18.205" starttime="20190401 12:32:18.204"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:18.206" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:18.206" starttime="20190401 12:32:18.206"></status>
</kw>
<msg timestamp="20190401 12:32:18.206" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:18.206" starttime="20190401 12:32:18.203"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:18.207" starttime="20190401 12:32:18.206"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:18.207" starttime="20190401 12:32:18.206"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:18.207" starttime="20190401 12:32:18.207"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:18.207" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:32:18.207" starttime="20190401 12:32:18.207"></status>
</kw>
<msg timestamp="20190401 12:32:18.207" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:32:18.208" starttime="20190401 12:32:17.098"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:32:18.208" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:32:18.208" starttime="20190401 12:32:18.208"></status>
</kw>
<msg timestamp="20190401 12:32:18.208" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:32:18.208" starttime="20190401 12:32:17.098"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:32:18.209" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:32:18.209" starttime="20190401 12:32:18.208"></status>
</kw>
<status status="FAIL" endtime="20190401 12:32:18.209" starttime="20190401 12:32:17.098"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:28.210" starttime="20190401 12:32:28.210"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:28.211" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:28.211" starttime="20190401 12:32:28.211"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:28.212" starttime="20190401 12:32:28.212"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:28.212" starttime="20190401 12:32:28.212"></status>
</kw>
<msg timestamp="20190401 12:32:28.212" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:28.212" starttime="20190401 12:32:28.211"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:28.213" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:28.213" starttime="20190401 12:32:28.213"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:28.226" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:32:28.226" starttime="20190401 12:32:28.213"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:29.320" level="INFO">configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:29.320" level="INFO">${output} = configuring
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:29.320" starttime="20190401 12:32:28.227"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:29.321" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:29.321" starttime="20190401 12:32:29.321"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:29.321" level="INFO">${clean_out} = configuring
</msg>
<status status="PASS" endtime="20190401 12:32:29.322" starttime="20190401 12:32:29.321"></status>
</kw>
<msg timestamp="20190401 12:32:29.322" level="INFO">${output} = configuring
</msg>
<status status="PASS" endtime="20190401 12:32:29.322" starttime="20190401 12:32:29.321"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:29.323" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:29.323" starttime="20190401 12:32:29.322"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:29.324" level="INFO">0</msg>
<msg timestamp="20190401 12:32:29.324" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:29.324" starttime="20190401 12:32:29.323"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:29.324" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:29.324" starttime="20190401 12:32:29.324"></status>
</kw>
<msg timestamp="20190401 12:32:29.324" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:29.324" starttime="20190401 12:32:29.322"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:29.325" starttime="20190401 12:32:29.325"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:29.325" starttime="20190401 12:32:29.325"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:29.326" starttime="20190401 12:32:29.325"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:29.326" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configuring</msg>
<status status="PASS" endtime="20190401 12:32:29.326" starttime="20190401 12:32:29.326"></status>
</kw>
<msg timestamp="20190401 12:32:29.326" level="INFO">${result} = {u'stdout': u'configuring', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:32:29.326" starttime="20190401 12:32:28.210"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:32:29.326" level="INFO">${value} = configuring</msg>
<status status="PASS" endtime="20190401 12:32:29.326" starttime="20190401 12:32:29.326"></status>
</kw>
<msg timestamp="20190401 12:32:29.327" level="INFO">${current_value} = configuring</msg>
<status status="PASS" endtime="20190401 12:32:29.327" starttime="20190401 12:32:28.209"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:32:29.327" level="FAIL">configuring != configured</msg>
<status status="FAIL" endtime="20190401 12:32:29.327" starttime="20190401 12:32:29.327"></status>
</kw>
<status status="FAIL" endtime="20190401 12:32:29.327" starttime="20190401 12:32:28.209"></status>
</kw>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system storage-backend-show ${name}</arg>
<arg>state</arg>
<arg>configured</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:39.329" starttime="20190401 12:32:39.329"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:39.330" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:39.330" starttime="20190401 12:32:39.329"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:39.330" starttime="20190401 12:32:39.330"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:39.331" starttime="20190401 12:32:39.330"></status>
</kw>
<msg timestamp="20190401 12:32:39.331" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:39.331" starttime="20190401 12:32:39.329"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:39.331" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:39.331" starttime="20190401 12:32:39.331"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:39.348" level="INFO">system storage-backend-show 46a52408-c 2d3-4cbb-b843-80682aa791a6 | grep -w state | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:32:39.348" starttime="20190401 12:32:39.331"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:40.482" level="INFO">configured
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:40.483" level="INFO">${output} = configured
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:40.483" starttime="20190401 12:32:39.348"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:40.483" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:40.483" starttime="20190401 12:32:40.483"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:40.484" level="INFO">${clean_out} = configured
</msg>
<status status="PASS" endtime="20190401 12:32:40.484" starttime="20190401 12:32:40.483"></status>
</kw>
<msg timestamp="20190401 12:32:40.484" level="INFO">${output} = configured
</msg>
<status status="PASS" endtime="20190401 12:32:40.484" starttime="20190401 12:32:40.483"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:40.486" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:40.486" starttime="20190401 12:32:40.484"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:40.487" level="INFO">0</msg>
<msg timestamp="20190401 12:32:40.487" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:40.487" starttime="20190401 12:32:40.486"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:40.487" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:40.487" starttime="20190401 12:32:40.487"></status>
</kw>
<msg timestamp="20190401 12:32:40.487" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:40.487" starttime="20190401 12:32:40.484"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.488" starttime="20190401 12:32:40.488"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:40.488" starttime="20190401 12:32:40.488"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.488" starttime="20190401 12:32:40.488"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:40.489" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: configured</msg>
<status status="PASS" endtime="20190401 12:32:40.489" starttime="20190401 12:32:40.489"></status>
</kw>
<msg timestamp="20190401 12:32:40.489" level="INFO">${result} = {u'stdout': u'configured', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:32:40.489" starttime="20190401 12:32:39.328"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:32:40.489" level="INFO">${value} = configured</msg>
<status status="PASS" endtime="20190401 12:32:40.489" starttime="20190401 12:32:40.489"></status>
</kw>
<msg timestamp="20190401 12:32:40.489" level="INFO">${current_value} = configured</msg>
<status status="PASS" endtime="20190401 12:32:40.490" starttime="20190401 12:32:39.328"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.490" starttime="20190401 12:32:40.490"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:40.490" starttime="20190401 12:32:39.328"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:40.490" starttime="20190401 12:30:25.942"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:40.490" starttime="20190401 12:30:21.214"></status>
</kw>
<kw name="Check Ceph Status" library="Utils">
<doc>Verifies the status of the CEPH feature.</doc>
<arguments>
<arg>HEALTH_ERR</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph -s</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.491" starttime="20190401 12:32:40.491"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:40.492" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:40.492" starttime="20190401 12:32:40.491"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.492" starttime="20190401 12:32:40.492"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.492" starttime="20190401 12:32:40.492"></status>
</kw>
<msg timestamp="20190401 12:32:40.493" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:40.493" starttime="20190401 12:32:40.491"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:40.493" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:40.493" starttime="20190401 12:32:40.493"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:40.495" level="INFO">ceph -s</msg>
<status status="PASS" endtime="20190401 12:32:40.495" starttime="20190401 12:32:40.493"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:40.640" level="INFO">cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_ERR
            no osds
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 3, quorum 0 controller
     osdmap e2: 0 osds: 0 up, 0 in
            flags sortbitwise,require_jewel_osds
      pgmap v3: 64 pgs, 1 pools, 0 bytes data, 0 objects
            0 kB used, 0 kB / 0 kB avail
                  64 creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:40.640" level="INFO">${output} =     cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_ERR
            no osds
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 3, quorum 0 controll...</msg>
<status status="PASS" endtime="20190401 12:32:40.640" starttime="20190401 12:32:40.495"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:40.641" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:40.641" starttime="20190401 12:32:40.641"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:40.641" level="INFO">${clean_out} =     cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_ERR
            no osds
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 3, quorum 0 controll...</msg>
<status status="PASS" endtime="20190401 12:32:40.641" starttime="20190401 12:32:40.641"></status>
</kw>
<msg timestamp="20190401 12:32:40.641" level="INFO">${output} =     cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_ERR
            no osds
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 3, quorum 0 controll...</msg>
<status status="PASS" endtime="20190401 12:32:40.641" starttime="20190401 12:32:40.640"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:40.643" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:40.643" starttime="20190401 12:32:40.642"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:40.644" level="INFO">0</msg>
<msg timestamp="20190401 12:32:40.644" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:40.644" starttime="20190401 12:32:40.643"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:40.644" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:40.645" starttime="20190401 12:32:40.644"></status>
</kw>
<msg timestamp="20190401 12:32:40.645" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:40.645" starttime="20190401 12:32:40.641"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.645" starttime="20190401 12:32:40.645"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:40.645" starttime="20190401 12:32:40.645"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.646" starttime="20190401 12:32:40.646"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:40.646" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_ERR
            no osds
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 3, quorum 0 controller
     osdmap e2: 0 osds: 0 up, 0 in
            flags sortbitwise,require_jewel_osds
      pgmap v3: 64 pgs, 1 pools, 0 bytes data, 0 objects
            0 kB used, 0 kB / 0 kB avail
                  64 creating</msg>
<status status="PASS" endtime="20190401 12:32:40.646" starttime="20190401 12:32:40.646"></status>
</kw>
<msg timestamp="20190401 12:32:40.646" level="INFO">${result} = {u'stdout': u'cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8\r\n     health HEALTH_ERR\r\n            no osds\r\n     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}\r\n            election epoch 3,...</msg>
<status status="PASS" endtime="20190401 12:32:40.646" starttime="20190401 12:32:40.490"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${result.stdout}</arg>
<arg>${status}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.647" starttime="20190401 12:32:40.646"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd tree</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.647" starttime="20190401 12:32:40.647"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:40.648" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:40.648" starttime="20190401 12:32:40.648"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.648" starttime="20190401 12:32:40.648"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.649" starttime="20190401 12:32:40.648"></status>
</kw>
<msg timestamp="20190401 12:32:40.649" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:40.649" starttime="20190401 12:32:40.647"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:40.649" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:40.649" starttime="20190401 12:32:40.649"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:40.652" level="INFO">ceph osd tree</msg>
<status status="PASS" endtime="20190401 12:32:40.652" starttime="20190401 12:32:40.649"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:40.795" level="INFO">ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                                         
-4      0         host controller-0                                   
-3      0         host controller-1                                   
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:40.795" level="INFO">${output} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190401 12:32:40.795" starttime="20190401 12:32:40.652"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:40.796" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:40.796" starttime="20190401 12:32:40.796"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:40.797" level="INFO">${clean_out} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190401 12:32:40.797" starttime="20190401 12:32:40.796"></status>
</kw>
<msg timestamp="20190401 12:32:40.797" level="INFO">${output} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190401 12:32:40.797" starttime="20190401 12:32:40.796"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:40.799" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:40.799" starttime="20190401 12:32:40.797"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:40.799" level="INFO">0</msg>
<msg timestamp="20190401 12:32:40.799" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:40.799" starttime="20190401 12:32:40.799"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:40.800" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:40.800" starttime="20190401 12:32:40.799"></status>
</kw>
<msg timestamp="20190401 12:32:40.800" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:40.800" starttime="20190401 12:32:40.797"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.801" starttime="20190401 12:32:40.800"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:40.801" starttime="20190401 12:32:40.800"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.801" starttime="20190401 12:32:40.801"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:40.801" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                                         
-4      0         host controller-0                                   
-3      0         host controller-1</msg>
<status status="PASS" endtime="20190401 12:32:40.801" starttime="20190401 12:32:40.801"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:40.801" starttime="20190401 12:32:40.647"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:40.802" starttime="20190401 12:32:40.490"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:40.802" starttime="20190401 12:30:21.214"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:40.802" starttime="20190401 12:30:21.213"></status>
</kw>
<kw name="Add ODS To Tier" library="Utils">
<doc>Enable the ODS on the specified node.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>/dev/sdb</arg>
</arguments>
<assign>
<var>${device}</var>
</assign>
<msg timestamp="20190401 12:32:40.802" level="INFO">${device} = /dev/sdb</msg>
<status status="PASS" endtime="20190401 12:32:40.802" starttime="20190401 12:32:40.802"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>ceph_cluster</arg>
</arguments>
<assign>
<var>${tier_name}</var>
</assign>
<msg timestamp="20190401 12:32:40.802" level="INFO">${tier_name} = ceph_cluster</msg>
<status status="PASS" endtime="20190401 12:32:40.802" starttime="20190401 12:32:40.802"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${SPACE}</arg>
</arguments>
<assign>
<var>${tier_opt}</var>
</assign>
<msg timestamp="20190401 12:32:40.803" level="INFO">${tier_opt} =  </msg>
<status status="PASS" endtime="20190401 12:32:40.803" starttime="20190401 12:32:40.803"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host}</arg>
<arg>grep ${device}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:32:40.803" level="INFO">${cmd} = system host-disk-list controller-0|grep /dev/sdb|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:32:40.803" starttime="20190401 12:32:40.803"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.804" starttime="20190401 12:32:40.804"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:40.805" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:40.805" starttime="20190401 12:32:40.804"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.805" starttime="20190401 12:32:40.805"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:40.805" starttime="20190401 12:32:40.805"></status>
</kw>
<msg timestamp="20190401 12:32:40.806" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:40.806" starttime="20190401 12:32:40.804"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:40.806" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:40.806" starttime="20190401 12:32:40.806"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:40.816" level="INFO">system host-disk-list controller-0|gre p /dev/sdb|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:32:40.816" starttime="20190401 12:32:40.806"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:41.878" level="INFO">6a3db990-bffb-4d9e-914a-f43c95fbba4a
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:41.878" level="INFO">${output} = 6a3db990-bffb-4d9e-914a-f43c95fbba4a
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:41.878" starttime="20190401 12:32:40.817"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:41.879" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:41.879" starttime="20190401 12:32:41.879"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:41.879" level="INFO">${clean_out} = 6a3db990-bffb-4d9e-914a-f43c95fbba4a
</msg>
<status status="PASS" endtime="20190401 12:32:41.880" starttime="20190401 12:32:41.879"></status>
</kw>
<msg timestamp="20190401 12:32:41.880" level="INFO">${output} = 6a3db990-bffb-4d9e-914a-f43c95fbba4a
</msg>
<status status="PASS" endtime="20190401 12:32:41.880" starttime="20190401 12:32:41.879"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:41.881" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:41.881" starttime="20190401 12:32:41.880"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:41.882" level="INFO">0</msg>
<msg timestamp="20190401 12:32:41.882" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:41.882" starttime="20190401 12:32:41.882"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:41.883" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:41.883" starttime="20190401 12:32:41.883"></status>
</kw>
<msg timestamp="20190401 12:32:41.883" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:41.883" starttime="20190401 12:32:41.880"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:41.884" starttime="20190401 12:32:41.884"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:41.884" starttime="20190401 12:32:41.883"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:41.884" starttime="20190401 12:32:41.884"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:41.884" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 6a3db990-bffb-4d9e-914a-f43c95fbba4a</msg>
<status status="PASS" endtime="20190401 12:32:41.884" starttime="20190401 12:32:41.884"></status>
</kw>
<msg timestamp="20190401 12:32:41.885" level="INFO">${result} = {u'stdout': u'6a3db990-bffb-4d9e-914a-f43c95fbba4a', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:32:41.885" starttime="20190401 12:32:40.803"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>Get Tier UUID</arg>
<arg>${tier_name}</arg>
</arguments>
<assign>
<var>${tier_uuid}</var>
</assign>
<msg timestamp="20190401 12:32:41.885" level="INFO">${tier_uuid} = None</msg>
<status status="PASS" endtime="20190401 12:32:41.885" starttime="20190401 12:32:41.885"></status>
</kw>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>--tier-uuid ${tier_uuid}</arg>
<arg>${EMPTY}</arg>
</arguments>
<assign>
<var>${tier_opt}</var>
</assign>
<msg timestamp="20190401 12:32:41.885" level="INFO">${tier_opt} = </msg>
<status status="PASS" endtime="20190401 12:32:41.885" starttime="20190401 12:32:41.885"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-stor-add ${host} ${result.stdout.strip()} ${tier_opt}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:41.886" starttime="20190401 12:32:41.886"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:41.887" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:41.887" starttime="20190401 12:32:41.887"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:41.887" starttime="20190401 12:32:41.887"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:41.888" starttime="20190401 12:32:41.887"></status>
</kw>
<msg timestamp="20190401 12:32:41.888" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:41.888" starttime="20190401 12:32:41.886"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:41.888" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:41.888" starttime="20190401 12:32:41.888"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:41.895" level="INFO">system host-stor-add controller-0 6a3d b990-bffb-4d9e-914a-f43c95fbba4a</msg>
<status status="PASS" endtime="20190401 12:32:41.895" starttime="20190401 12:32:41.888"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:43.421" level="INFO">+------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+--------------------------------------------------+
| osdid            | 0                                                |
| function         | osd                                              |
| state            | configuring-on-unlock                            |
| journal_location | b5067822-ded8-424b-af26-b8f3be67fe73             |
| journal_size_gib | 1024                                             |
| journal_path     | /dev/disk/by-path/pci-0000:00:17.0-ata-2.0-part2 |
| journal_node     | /dev/sdb2                                        |
| uuid             | b5067822-ded8-424b-af26-b8f3be67fe73             |
| ihost_uuid       | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6             |
| idisk_uuid       | 6a3db990-bffb-4d9e-914a-f43c95fbba4a             |
| tier_uuid        | 3c727df7-e614-4c0a-8c2c-d456f04ca631             |
| tier_name        | storage                                          |
| created_at       | 2019-04-01T18:21:27.639964+00:00                 |
| updated_at       | 2019-04-01T18:21:27.767959+00:00                 |
+------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:43.421" level="INFO">${output} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190401 12:32:43.422" starttime="20190401 12:32:41.895"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:43.422" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:43.422" starttime="20190401 12:32:43.422"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:43.423" level="INFO">${clean_out} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190401 12:32:43.423" starttime="20190401 12:32:43.422"></status>
</kw>
<msg timestamp="20190401 12:32:43.423" level="INFO">${output} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190401 12:32:43.423" starttime="20190401 12:32:43.422"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:43.425" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:43.425" starttime="20190401 12:32:43.423"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:43.426" level="INFO">0</msg>
<msg timestamp="20190401 12:32:43.426" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:43.426" starttime="20190401 12:32:43.425"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:43.426" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:43.426" starttime="20190401 12:32:43.426"></status>
</kw>
<msg timestamp="20190401 12:32:43.426" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:43.426" starttime="20190401 12:32:43.423"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.427" starttime="20190401 12:32:43.427"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:43.427" starttime="20190401 12:32:43.427"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.428" starttime="20190401 12:32:43.427"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:43.428" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+--------------------------------------------------+
| osdid            | 0                                                |
| function         | osd                                              |
| state            | configuring-on-unlock                            |
| journal_location | b5067822-ded8-424b-af26-b8f3be67fe73             |
| journal_size_gib | 1024                                             |
| journal_path     | /dev/disk/by-path/pci-0000:00:17.0-ata-2.0-part2 |
| journal_node     | /dev/sdb2                                        |
| uuid             | b5067822-ded8-424b-af26-b8f3be67fe73             |
| ihost_uuid       | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6             |
| idisk_uuid       | 6a3db990-bffb-4d9e-914a-f43c95fbba4a             |
| tier_uuid        | 3c727df7-e614-4c0a-8c2c-d456f04ca631             |
| tier_name        | storage                                          |
| created_at       | 2019-04-01T18:21:27.639964+00:00                 |
| updated_at       | 2019-04-01T18:21:27.767959+00:00                 |
+------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:32:43.428" starttime="20190401 12:32:43.428"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:43.428" starttime="20190401 12:32:41.886"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd tree</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.429" starttime="20190401 12:32:43.428"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:43.429" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:43.429" starttime="20190401 12:32:43.429"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.430" starttime="20190401 12:32:43.430"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.430" starttime="20190401 12:32:43.430"></status>
</kw>
<msg timestamp="20190401 12:32:43.430" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:43.430" starttime="20190401 12:32:43.429"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:43.431" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:43.431" starttime="20190401 12:32:43.430"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:43.433" level="INFO">ceph osd tree</msg>
<status status="PASS" endtime="20190401 12:32:43.433" starttime="20190401 12:32:43.431"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:43.574" level="INFO">ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                                         
-4      0         host controller-0                                   
-3      0         host controller-1                                   
 0      0 osd.0                        down        0          1.00000 
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:43.575" level="INFO">${output} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190401 12:32:43.575" starttime="20190401 12:32:43.433"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:43.575" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:43.575" starttime="20190401 12:32:43.575"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:43.576" level="INFO">${clean_out} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190401 12:32:43.576" starttime="20190401 12:32:43.575"></status>
</kw>
<msg timestamp="20190401 12:32:43.576" level="INFO">${output} = ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                           ...</msg>
<status status="PASS" endtime="20190401 12:32:43.576" starttime="20190401 12:32:43.575"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:43.577" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:43.577" starttime="20190401 12:32:43.576"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:43.578" level="INFO">0</msg>
<msg timestamp="20190401 12:32:43.578" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:43.578" starttime="20190401 12:32:43.578"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:43.579" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:43.579" starttime="20190401 12:32:43.578"></status>
</kw>
<msg timestamp="20190401 12:32:43.579" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:43.579" starttime="20190401 12:32:43.576"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.580" starttime="20190401 12:32:43.580"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:43.580" starttime="20190401 12:32:43.579"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.580" starttime="20190401 12:32:43.580"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:43.581" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ID WEIGHT TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1      0 root storage-tier                                           
-2      0     chassis group-0                                         
-4      0         host controller-0                                   
-3      0         host controller-1                                   
 0      0 osd.0                        down        0          1.00000</msg>
<status status="PASS" endtime="20190401 12:32:43.581" starttime="20190401 12:32:43.580"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:43.581" starttime="20190401 12:32:43.428"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:43.581" starttime="20190401 12:32:40.802"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}'=='Simplex'</arg>
<arg>Set Ceph Pool Replication</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.581" starttime="20190401 12:32:43.581"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:43.581" starttime="20190401 12:30:21.213"></status>
</kw>
<kw name="Unlock Master Controller" library="Utils">
<doc>Verify that controller with ACTIVE ssh connection
is unlocked and reestablish the ssh connection on the suite.</doc>
<arguments>
<arg>${master_controller}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>*Socket is closed*</arg>
</arguments>
<assign>
<var>${error_expected}</var>
</assign>
<msg timestamp="20190401 12:32:43.582" level="INFO">${error_expected} = *Socket is closed*</msg>
<status status="PASS" endtime="20190401 12:32:43.582" starttime="20190401 12:32:43.582"></status>
</kw>
<kw name="Unlock Controller" library="Utils">
<doc>Unlocks specified controller.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>15 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value</arg>
<arg>${controller_name}</arg>
<arg>availability</arg>
<arg>online</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>availability</arg>
<arg>online</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:32:43.583" level="INFO">${system_cmd} = system host-show controller-0|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:32:43.583" starttime="20190401 12:32:43.583"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.584" starttime="20190401 12:32:43.584"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:43.585" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:43.585" starttime="20190401 12:32:43.584"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.585" starttime="20190401 12:32:43.585"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:43.585" starttime="20190401 12:32:43.585"></status>
</kw>
<msg timestamp="20190401 12:32:43.586" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:43.586" starttime="20190401 12:32:43.584"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:43.586" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:43.586" starttime="20190401 12:32:43.586"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:43.597" level="INFO">system host-show controller-0|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:32:43.597" starttime="20190401 12:32:43.586"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:44.654" level="INFO">online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:44.654" level="INFO">${output} = online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:44.654" starttime="20190401 12:32:43.597"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:44.655" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:44.655" starttime="20190401 12:32:44.655"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:44.655" level="INFO">${clean_out} = online
</msg>
<status status="PASS" endtime="20190401 12:32:44.655" starttime="20190401 12:32:44.655"></status>
</kw>
<msg timestamp="20190401 12:32:44.655" level="INFO">${output} = online
</msg>
<status status="PASS" endtime="20190401 12:32:44.655" starttime="20190401 12:32:44.654"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:44.657" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:44.658" starttime="20190401 12:32:44.656"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:44.658" level="INFO">0</msg>
<msg timestamp="20190401 12:32:44.658" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:44.658" starttime="20190401 12:32:44.658"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:44.659" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:44.659" starttime="20190401 12:32:44.658"></status>
</kw>
<msg timestamp="20190401 12:32:44.659" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:44.659" starttime="20190401 12:32:44.655"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:44.660" starttime="20190401 12:32:44.659"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:44.660" starttime="20190401 12:32:44.659"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:44.660" starttime="20190401 12:32:44.660"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:44.660" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: online</msg>
<status status="PASS" endtime="20190401 12:32:44.660" starttime="20190401 12:32:44.660"></status>
</kw>
<msg timestamp="20190401 12:32:44.660" level="INFO">${result} = {u'stdout': u'online', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:32:44.660" starttime="20190401 12:32:43.583"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:32:44.661" level="INFO">${value} = online</msg>
<status status="PASS" endtime="20190401 12:32:44.661" starttime="20190401 12:32:44.661"></status>
</kw>
<msg timestamp="20190401 12:32:44.661" level="INFO">${current_value} = online</msg>
<status status="PASS" endtime="20190401 12:32:44.661" starttime="20190401 12:32:43.583"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:44.661" starttime="20190401 12:32:44.661"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:44.661" starttime="20190401 12:32:43.582"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:44.661" starttime="20190401 12:32:43.582"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-unlock ${controller_name}</arg>
<arg>True</arg>
<arg>60</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:44.662" starttime="20190401 12:32:44.662"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:44.663" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:44.663" starttime="20190401 12:32:44.663"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:44.663" starttime="20190401 12:32:44.663"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:44.664" starttime="20190401 12:32:44.663"></status>
</kw>
<msg timestamp="20190401 12:32:44.664" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:44.664" starttime="20190401 12:32:44.662"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:44.664" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:44.664" starttime="20190401 12:32:44.664"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:44.670" level="INFO">system host-unlock controller-0</msg>
<status status="PASS" endtime="20190401 12:32:44.670" starttime="20190401 12:32:44.665"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:49.314" level="INFO">+---------------------+--------------------------------------------+
| Property            | Value                                      |
+---------------------+--------------------------------------------+
| action              | none                                       |
| administrative      | locked                                     |
| availability        | online                                     |
| bm_ip               | None                                       |
| bm_type             | None                                       |
| bm_username         | None                                       |
| boot_device         | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0 |
| capabilities        | {}                                         |
| config_applied      | 55b3ec75-94e3-4494-9177-b2742d16a7a5       |
| config_status       | Config out-of-date                         |
| config_target       | 9668290c-3fab-4c9f-8a02-93f35c0720bc       |
| console             | ttyS0,115200                               |
| created_at          | 2019-04-01T12:40:16.272417+00:00           |
| hostname            | controller-0                               |
| id                  | 1                                          |
| install_output      | text                                       |
| install_state       | None                                       |
| install_state_info  | None                                       |
| invprovision        | provisioned                                |
| location            | {}                                         |
| mgmt_ip             | 10.10.53.3                                 |
| mgmt_mac            | a4:bf:01:55:03:28                          |
| operational         | disabled                                   |
| personality         | controller                                 |
| reserved            | False                                      |
| rootfs_device       | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0 |
| serialid            | None                                       |
| software_load       | 19.01                                      |
| subfunction_avail   | online                                     |
| subfunction_oper    | disabled                                   |
| subfunctions        | controller,worker                          |
| task                | Unlocking                                  |
| tboot               | false                                      |
| ttys_dcd            | None                                       |
| updated_at          | 2019-04-01T18:21:27.944079+00:00           |
| uptime              | 20651                                      |
| uuid                | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6       |
| vim_progress_status | None                                       |
+---------------------+--------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:49.314" level="INFO">${output} = +---------------------+--------------------------------------------+
| Property            | Value                                      |
+---------------------+-------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:32:49.315" starttime="20190401 12:32:44.670"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:49.315" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:49.315" starttime="20190401 12:32:49.315"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:49.316" level="INFO">${clean_out} = +---------------------+--------------------------------------------+
| Property            | Value                                      |
+---------------------+-------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:32:49.316" starttime="20190401 12:32:49.315"></status>
</kw>
<msg timestamp="20190401 12:32:49.316" level="INFO">${output} = +---------------------+--------------------------------------------+
| Property            | Value                                      |
+---------------------+-------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:32:49.316" starttime="20190401 12:32:49.315"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:49.318" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:49.318" starttime="20190401 12:32:49.316"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:49.319" level="INFO">0</msg>
<msg timestamp="20190401 12:32:49.319" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:49.319" starttime="20190401 12:32:49.318"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:49.319" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:49.319" starttime="20190401 12:32:49.319"></status>
</kw>
<msg timestamp="20190401 12:32:49.319" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:49.319" starttime="20190401 12:32:49.316"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:49.320" starttime="20190401 12:32:49.320"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:49.320" starttime="20190401 12:32:49.319"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:49.321" starttime="20190401 12:32:49.320"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:49.321" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +---------------------+--------------------------------------------+
| Property            | Value                                      |
+---------------------+--------------------------------------------+
| action              | none                                       |
| administrative      | locked                                     |
| availability        | online                                     |
| bm_ip               | None                                       |
| bm_type             | None                                       |
| bm_username         | None                                       |
| boot_device         | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0 |
| capabilities        | {}                                         |
| config_applied      | 55b3ec75-94e3-4494-9177-b2742d16a7a5       |
| config_status       | Config out-of-date                         |
| config_target       | 9668290c-3fab-4c9f-8a02-93f35c0720bc       |
| console             | ttyS0,115200                               |
| created_at          | 2019-04-01T12:40:16.272417+00:00           |
| hostname            | controller-0                               |
| id                  | 1                                          |
| install_output      | text                                       |
| install_state       | None                                       |
| install_state_info  | None                                       |
| invprovision        | provisioned                                |
| location            | {}                                         |
| mgmt_ip             | 10.10.53.3                                 |
| mgmt_mac            | a4:bf:01:55:03:28                          |
| operational         | disabled                                   |
| personality         | controller                                 |
| reserved            | False                                      |
| rootfs_device       | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0 |
| serialid            | None                                       |
| software_load       | 19.01                                      |
| subfunction_avail   | online                                     |
| subfunction_oper    | disabled                                   |
| subfunctions        | controller,worker                          |
| task                | Unlocking                                  |
| tboot               | false                                      |
| ttys_dcd            | None                                       |
| updated_at          | 2019-04-01T18:21:27.944079+00:00           |
| uptime              | 20651                                      |
| uuid                | d43eb9e7-5c80-45e8-97e0-7b26ac228fc6       |
| vim_progress_status | None                                       |
+---------------------+--------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:32:49.321" starttime="20190401 12:32:49.321"></status>
</kw>
<msg timestamp="20190401 12:32:49.321" level="INFO">${result} = {u'stdout': u'+---------------------+--------------------------------------------+\r\n| Property            | Value                                      |\r\n+---------------------+-------------------...</msg>
<status status="PASS" endtime="20190401 12:32:49.321" starttime="20190401 12:32:44.662"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:49.321" starttime="20190401 12:32:43.582"></status>
</kw>
<kw name="Wait Until Keyword Fails" library="Utils">
<doc>Waits until executed keyword returns the expected error.</doc>
<arguments>
<arg>10 min</arg>
<arg>20 sec</arg>
<arg>${error_expected}</arg>
<arg>Run Command</arg>
<arg>whoami</arg>
</arguments>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>${timeout}</arg>
<arg>${retry}</arg>
<arg>Run Keyword And Expect Error</arg>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:49.324" starttime="20190401 12:32:49.323"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:32:49.324" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:32:49.324" starttime="20190401 12:32:49.324"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:49.325" starttime="20190401 12:32:49.324"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:49.325" starttime="20190401 12:32:49.325"></status>
</kw>
<msg timestamp="20190401 12:32:49.325" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:32:49.325" starttime="20190401 12:32:49.324"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:32:49.325" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:49.326" starttime="20190401 12:32:49.325"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:32:49.327" level="INFO">whoami</msg>
<status status="PASS" endtime="20190401 12:32:49.327" starttime="20190401 12:32:49.326"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:32:49.330" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:32:49.330" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:49.330" starttime="20190401 12:32:49.328"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:32:49.330" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:32:49.330" starttime="20190401 12:32:49.330"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:32:49.331" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:32:49.331" starttime="20190401 12:32:49.331"></status>
</kw>
<msg timestamp="20190401 12:32:49.331" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:32:49.331" starttime="20190401 12:32:49.330"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:32:49.333" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:32:49.334" starttime="20190401 12:32:49.331"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:32:49.334" level="INFO">0</msg>
<msg timestamp="20190401 12:32:49.334" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:49.334" starttime="20190401 12:32:49.334"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:32:49.335" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:32:49.335" starttime="20190401 12:32:49.335"></status>
</kw>
<msg timestamp="20190401 12:32:49.335" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:32:49.335" starttime="20190401 12:32:49.331"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:49.336" starttime="20190401 12:32:49.335"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:49.336" starttime="20190401 12:32:49.335"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:32:49.336" starttime="20190401 12:32:49.336"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:32:49.336" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190401 12:32:49.336" starttime="20190401 12:32:49.336"></status>
</kw>
<status status="PASS" endtime="20190401 12:32:49.337" starttime="20190401 12:32:49.323"></status>
</kw>
<msg timestamp="20190401 12:32:49.337" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190401 12:32:49.337" starttime="20190401 12:32:49.322"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:09.338" starttime="20190401 12:33:09.338"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:33:09.339" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:33:09.339" starttime="20190401 12:33:09.338"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:09.339" starttime="20190401 12:33:09.339"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:09.340" starttime="20190401 12:33:09.340"></status>
</kw>
<msg timestamp="20190401 12:33:09.340" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:33:09.340" starttime="20190401 12:33:09.338"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:33:09.340" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:33:09.340" starttime="20190401 12:33:09.340"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:33:09.342" level="INFO">whoami</msg>
<status status="PASS" endtime="20190401 12:33:09.342" starttime="20190401 12:33:09.340"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:33:09.344" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:33:09.344" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:33:09.344" starttime="20190401 12:33:09.342"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:33:09.345" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:33:09.345" starttime="20190401 12:33:09.345"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:33:09.345" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:33:09.345" starttime="20190401 12:33:09.345"></status>
</kw>
<msg timestamp="20190401 12:33:09.346" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:33:09.346" starttime="20190401 12:33:09.344"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:33:09.347" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:33:09.348" starttime="20190401 12:33:09.346"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:33:09.348" level="INFO">0</msg>
<msg timestamp="20190401 12:33:09.348" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:33:09.348" starttime="20190401 12:33:09.348"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:33:09.348" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:33:09.348" starttime="20190401 12:33:09.348"></status>
</kw>
<msg timestamp="20190401 12:33:09.349" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:33:09.349" starttime="20190401 12:33:09.346"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:09.349" starttime="20190401 12:33:09.349"></status>
</kw>
<status status="PASS" endtime="20190401 12:33:09.349" starttime="20190401 12:33:09.349"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:09.350" starttime="20190401 12:33:09.350"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:33:09.350" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190401 12:33:09.350" starttime="20190401 12:33:09.350"></status>
</kw>
<status status="PASS" endtime="20190401 12:33:09.350" starttime="20190401 12:33:09.337"></status>
</kw>
<msg timestamp="20190401 12:33:09.350" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190401 12:33:09.350" starttime="20190401 12:33:09.337"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:29.352" starttime="20190401 12:33:29.352"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:33:29.353" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:33:29.353" starttime="20190401 12:33:29.352"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:29.353" starttime="20190401 12:33:29.353"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:29.353" starttime="20190401 12:33:29.353"></status>
</kw>
<msg timestamp="20190401 12:33:29.353" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:33:29.354" starttime="20190401 12:33:29.352"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:33:29.354" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:33:29.354" starttime="20190401 12:33:29.354"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:33:29.355" level="INFO">whoami</msg>
<status status="PASS" endtime="20190401 12:33:29.355" starttime="20190401 12:33:29.354"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:33:29.357" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:33:29.357" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:33:29.357" starttime="20190401 12:33:29.355"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:33:29.358" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:33:29.358" starttime="20190401 12:33:29.358"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:33:29.358" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:33:29.359" starttime="20190401 12:33:29.358"></status>
</kw>
<msg timestamp="20190401 12:33:29.359" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:33:29.359" starttime="20190401 12:33:29.357"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:33:29.361" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:33:29.361" starttime="20190401 12:33:29.359"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:33:29.362" level="INFO">0</msg>
<msg timestamp="20190401 12:33:29.362" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:33:29.362" starttime="20190401 12:33:29.361"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:33:29.362" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:33:29.362" starttime="20190401 12:33:29.362"></status>
</kw>
<msg timestamp="20190401 12:33:29.362" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:33:29.362" starttime="20190401 12:33:29.359"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:29.363" starttime="20190401 12:33:29.363"></status>
</kw>
<status status="PASS" endtime="20190401 12:33:29.363" starttime="20190401 12:33:29.362"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:29.363" starttime="20190401 12:33:29.363"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:33:29.363" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190401 12:33:29.363" starttime="20190401 12:33:29.363"></status>
</kw>
<status status="PASS" endtime="20190401 12:33:29.364" starttime="20190401 12:33:29.351"></status>
</kw>
<msg timestamp="20190401 12:33:29.364" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190401 12:33:29.364" starttime="20190401 12:33:29.351"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:49.365" starttime="20190401 12:33:49.365"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:33:49.366" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:33:49.366" starttime="20190401 12:33:49.366"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:49.366" starttime="20190401 12:33:49.366"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:49.367" starttime="20190401 12:33:49.366"></status>
</kw>
<msg timestamp="20190401 12:33:49.367" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:33:49.367" starttime="20190401 12:33:49.365"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:33:49.367" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:33:49.367" starttime="20190401 12:33:49.367"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:33:49.369" level="INFO">whoami</msg>
<status status="PASS" endtime="20190401 12:33:49.369" starttime="20190401 12:33:49.367"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:33:49.371" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:33:49.371" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:33:49.371" starttime="20190401 12:33:49.369"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:33:49.371" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:33:49.371" starttime="20190401 12:33:49.371"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:33:49.372" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:33:49.372" starttime="20190401 12:33:49.371"></status>
</kw>
<msg timestamp="20190401 12:33:49.372" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:33:49.372" starttime="20190401 12:33:49.371"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:33:49.373" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:33:49.373" starttime="20190401 12:33:49.372"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:33:49.374" level="INFO">0</msg>
<msg timestamp="20190401 12:33:49.374" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:33:49.374" starttime="20190401 12:33:49.374"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:33:49.374" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:33:49.374" starttime="20190401 12:33:49.374"></status>
</kw>
<msg timestamp="20190401 12:33:49.374" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:33:49.375" starttime="20190401 12:33:49.372"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:49.375" starttime="20190401 12:33:49.375"></status>
</kw>
<status status="PASS" endtime="20190401 12:33:49.375" starttime="20190401 12:33:49.375"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:33:49.376" starttime="20190401 12:33:49.375"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:33:49.376" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190401 12:33:49.376" starttime="20190401 12:33:49.376"></status>
</kw>
<status status="PASS" endtime="20190401 12:33:49.376" starttime="20190401 12:33:49.365"></status>
</kw>
<msg timestamp="20190401 12:33:49.376" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190401 12:33:49.376" starttime="20190401 12:33:49.364"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:09.378" starttime="20190401 12:34:09.378"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:34:09.380" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:34:09.380" starttime="20190401 12:34:09.379"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:09.380" starttime="20190401 12:34:09.380"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:09.381" starttime="20190401 12:34:09.380"></status>
</kw>
<msg timestamp="20190401 12:34:09.381" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:34:09.381" starttime="20190401 12:34:09.379"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:34:09.382" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:34:09.382" starttime="20190401 12:34:09.382"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:34:09.384" level="INFO">whoami</msg>
<status status="PASS" endtime="20190401 12:34:09.384" starttime="20190401 12:34:09.382"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:34:09.386" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:34:09.386" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:34:09.386" starttime="20190401 12:34:09.384"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:34:09.387" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:34:09.387" starttime="20190401 12:34:09.387"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:34:09.388" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:34:09.388" starttime="20190401 12:34:09.387"></status>
</kw>
<msg timestamp="20190401 12:34:09.388" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:34:09.388" starttime="20190401 12:34:09.386"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:34:09.390" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:34:09.390" starttime="20190401 12:34:09.389"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:34:09.390" level="INFO">0</msg>
<msg timestamp="20190401 12:34:09.391" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:34:09.391" starttime="20190401 12:34:09.390"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:34:09.391" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:34:09.391" starttime="20190401 12:34:09.391"></status>
</kw>
<msg timestamp="20190401 12:34:09.391" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:34:09.391" starttime="20190401 12:34:09.388"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:09.393" starttime="20190401 12:34:09.392"></status>
</kw>
<status status="PASS" endtime="20190401 12:34:09.393" starttime="20190401 12:34:09.392"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:09.393" starttime="20190401 12:34:09.393"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:34:09.394" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190401 12:34:09.394" starttime="20190401 12:34:09.393"></status>
</kw>
<status status="PASS" endtime="20190401 12:34:09.394" starttime="20190401 12:34:09.377"></status>
</kw>
<msg timestamp="20190401 12:34:09.394" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190401 12:34:09.394" starttime="20190401 12:34:09.377"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:29.396" starttime="20190401 12:34:29.395"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:34:29.397" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:34:29.397" starttime="20190401 12:34:29.396"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:29.397" starttime="20190401 12:34:29.397"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:29.397" starttime="20190401 12:34:29.397"></status>
</kw>
<msg timestamp="20190401 12:34:29.398" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:34:29.398" starttime="20190401 12:34:29.396"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:34:29.398" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:34:29.398" starttime="20190401 12:34:29.398"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:34:29.399" level="INFO">whoami</msg>
<status status="PASS" endtime="20190401 12:34:29.399" starttime="20190401 12:34:29.398"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:34:29.401" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:34:29.401" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:34:29.401" starttime="20190401 12:34:29.399"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:34:29.402" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:34:29.402" starttime="20190401 12:34:29.402"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:34:29.402" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:34:29.402" starttime="20190401 12:34:29.402"></status>
</kw>
<msg timestamp="20190401 12:34:29.403" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:34:29.403" starttime="20190401 12:34:29.402"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:34:29.404" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:34:29.404" starttime="20190401 12:34:29.403"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:34:29.405" level="INFO">0</msg>
<msg timestamp="20190401 12:34:29.405" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:34:29.405" starttime="20190401 12:34:29.404"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:34:29.405" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:34:29.405" starttime="20190401 12:34:29.405"></status>
</kw>
<msg timestamp="20190401 12:34:29.405" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:34:29.405" starttime="20190401 12:34:29.403"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:29.406" starttime="20190401 12:34:29.406"></status>
</kw>
<status status="PASS" endtime="20190401 12:34:29.406" starttime="20190401 12:34:29.405"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:29.406" starttime="20190401 12:34:29.406"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:34:29.407" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190401 12:34:29.407" starttime="20190401 12:34:29.406"></status>
</kw>
<status status="PASS" endtime="20190401 12:34:29.407" starttime="20190401 12:34:29.395"></status>
</kw>
<msg timestamp="20190401 12:34:29.407" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190401 12:34:29.407" starttime="20190401 12:34:29.395"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:49.408" starttime="20190401 12:34:49.408"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:34:49.409" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:34:49.409" starttime="20190401 12:34:49.409"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:49.409" starttime="20190401 12:34:49.409"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:49.410" starttime="20190401 12:34:49.409"></status>
</kw>
<msg timestamp="20190401 12:34:49.410" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:34:49.410" starttime="20190401 12:34:49.408"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:34:49.410" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:34:49.410" starttime="20190401 12:34:49.410"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:34:49.411" level="INFO">whoami</msg>
<status status="PASS" endtime="20190401 12:34:49.412" starttime="20190401 12:34:49.410"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:34:49.413" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:34:49.413" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:34:49.413" starttime="20190401 12:34:49.412"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:34:49.414" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:34:49.414" starttime="20190401 12:34:49.414"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:34:49.415" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:34:49.415" starttime="20190401 12:34:49.415"></status>
</kw>
<msg timestamp="20190401 12:34:49.415" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190401 12:34:49.415" starttime="20190401 12:34:49.414"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:34:49.416" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:34:49.416" starttime="20190401 12:34:49.415"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:34:49.417" level="INFO">0</msg>
<msg timestamp="20190401 12:34:49.417" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:34:49.417" starttime="20190401 12:34:49.416"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:34:49.417" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:34:49.418" starttime="20190401 12:34:49.417"></status>
</kw>
<msg timestamp="20190401 12:34:49.418" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:34:49.418" starttime="20190401 12:34:49.415"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:49.418" starttime="20190401 12:34:49.418"></status>
</kw>
<status status="PASS" endtime="20190401 12:34:49.418" starttime="20190401 12:34:49.418"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:34:49.419" starttime="20190401 12:34:49.419"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:34:49.419" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190401 12:34:49.419" starttime="20190401 12:34:49.419"></status>
</kw>
<status status="PASS" endtime="20190401 12:34:49.419" starttime="20190401 12:34:49.408"></status>
</kw>
<msg timestamp="20190401 12:34:49.419" level="FAIL">Expected error '*Socket is closed*' did not occur.</msg>
<status status="FAIL" endtime="20190401 12:34:49.419" starttime="20190401 12:34:49.407"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:35:09.421" starttime="20190401 12:35:09.421"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:35:09.421" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:35:09.422" starttime="20190401 12:35:09.421"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:35:09.422" starttime="20190401 12:35:09.422"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:35:09.422" starttime="20190401 12:35:09.422"></status>
</kw>
<msg timestamp="20190401 12:35:09.422" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:35:09.422" starttime="20190401 12:35:09.421"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:35:09.423" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:35:09.423" starttime="20190401 12:35:09.423"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:36:09.424" level="FAIL">No match found for '
' in 1 minute
Output:
.</msg>
<status status="FAIL" endtime="20190401 12:36:09.424" starttime="20190401 12:35:09.423"></status>
</kw>
<status status="FAIL" endtime="20190401 12:36:09.424" starttime="20190401 12:35:09.420"></status>
</kw>
<msg timestamp="20190401 12:36:09.424" level="FAIL">Expected error '*Socket is closed*' but got 'No match found for '
' in 1 minute
Output:
.'.</msg>
<status status="FAIL" endtime="20190401 12:36:09.424" starttime="20190401 12:35:09.420"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:36:29.426" starttime="20190401 12:36:29.425"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:36:29.426" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:36:29.426" starttime="20190401 12:36:29.426"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:36:29.427" starttime="20190401 12:36:29.427"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:36:29.427" starttime="20190401 12:36:29.427"></status>
</kw>
<msg timestamp="20190401 12:36:29.427" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:36:29.427" starttime="20190401 12:36:29.426"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190401 12:36:29.428" starttime="20190401 12:36:29.427"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:37:29.428" level="FAIL">No match found for '
' in 1 minute
Output:
.</msg>
<status status="FAIL" endtime="20190401 12:37:29.429" starttime="20190401 12:36:29.428"></status>
</kw>
<status status="FAIL" endtime="20190401 12:37:29.429" starttime="20190401 12:36:29.425"></status>
</kw>
<msg timestamp="20190401 12:37:29.429" level="FAIL">Expected error '*Socket is closed*' but got 'No match found for '
' in 1 minute
Output:
.'.</msg>
<status status="FAIL" endtime="20190401 12:37:29.429" starttime="20190401 12:36:29.425"></status>
</kw>
<kw name="Run Keyword And Expect Error" library="BuiltIn">
<doc>Runs the keyword and checks that the expected error occurred.</doc>
<arguments>
<arg>${error}</arg>
<arg>${keyword}</arg>
<arg>@{args}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>@{args}</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:49.431" starttime="20190401 12:37:49.430"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:37:49.431" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:37:49.431" starttime="20190401 12:37:49.431"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:49.432" starttime="20190401 12:37:49.431"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:49.432" starttime="20190401 12:37:49.432"></status>
</kw>
<msg timestamp="20190401 12:37:49.432" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:37:49.432" starttime="20190401 12:37:49.431"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190401 12:37:49.433" starttime="20190401 12:37:49.432"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:37:49.433" level="FAIL">error: Socket is closed</msg>
<status status="FAIL" endtime="20190401 12:37:49.433" starttime="20190401 12:37:49.433"></status>
</kw>
<status status="FAIL" endtime="20190401 12:37:49.433" starttime="20190401 12:37:49.430"></status>
</kw>
<status status="PASS" endtime="20190401 12:37:49.434" starttime="20190401 12:37:49.429"></status>
</kw>
<status status="PASS" endtime="20190401 12:37:49.434" starttime="20190401 12:32:49.322"></status>
</kw>
<status status="PASS" endtime="20190401 12:37:49.434" starttime="20190401 12:32:49.321"></status>
</kw>
<kw name="Close Connection" library="SSHLibrary">
<doc>Closes the current connection.</doc>
<status status="PASS" endtime="20190401 12:37:49.434" starttime="20190401 12:37:49.434"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>10 min</arg>
<arg>30 sec</arg>
<arg>Open Master Controller Connection</arg>
</arguments>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190401 12:37:49.435" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 12:37:49.435" starttime="20190401 12:37:49.435"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190401 12:37:49.436" level="INFO">Length is 10</msg>
<msg timestamp="20190401 12:37:49.436" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190401 12:37:49.436" starttime="20190401 12:37:49.436"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190401 12:37:49.437" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190401 12:37:50.586" level="INFO">Read output: Last login: Mon Apr  1 18:17:53 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:37:50.586" starttime="20190401 12:37:49.437"></status>
</kw>
<msg timestamp="20190401 12:37:50.586" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 12:37:50.586" starttime="20190401 12:37:49.436"></status>
</kw>
<status status="PASS" endtime="20190401 12:37:50.586" starttime="20190401 12:37:49.436"></status>
</kw>
<msg timestamp="20190401 12:37:50.586" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 12:37:50.586" starttime="20190401 12:37:49.435"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 12:37:50.587" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 12:37:50.587" starttime="20190401 12:37:50.587"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 12:37:50.587" level="INFO">1</msg>
<status status="PASS" endtime="20190401 12:37:50.587" starttime="20190401 12:37:50.587"></status>
</kw>
<status status="PASS" endtime="20190401 12:37:50.587" starttime="20190401 12:37:49.434"></status>
</kw>
<status status="PASS" endtime="20190401 12:37:50.587" starttime="20190401 12:37:49.434"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>25 min</arg>
<arg>30 sec</arg>
<arg>Check Controller Is Unlocked</arg>
<arg>${controller}</arg>
</arguments>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:50.590" starttime="20190401 12:37:50.589"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:37:50.590" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:37:50.590" starttime="20190401 12:37:50.590"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:50.591" starttime="20190401 12:37:50.590"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:50.591" starttime="20190401 12:37:50.591"></status>
</kw>
<msg timestamp="20190401 12:37:50.591" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:37:50.591" starttime="20190401 12:37:50.590"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190401 12:37:50.592" starttime="20190401 12:37:50.591"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:37:50.595" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:37:50.595" starttime="20190401 12:37:50.592"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:37:50.596" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:37:50.596" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:37:50.596" starttime="20190401 12:37:50.595"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:37:50.597" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:37:50.597" starttime="20190401 12:37:50.597"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:37:50.597" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:37:50.597" starttime="20190401 12:37:50.597"></status>
</kw>
<msg timestamp="20190401 12:37:50.597" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:37:50.597" starttime="20190401 12:37:50.596"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:37:50.599" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:37:50.599" starttime="20190401 12:37:50.598"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:37:50.600" level="INFO">0</msg>
<msg timestamp="20190401 12:37:50.600" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:37:50.600" starttime="20190401 12:37:50.600"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:37:50.600" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:37:50.600" starttime="20190401 12:37:50.600"></status>
</kw>
<msg timestamp="20190401 12:37:50.600" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:37:50.600" starttime="20190401 12:37:50.598"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:50.601" starttime="20190401 12:37:50.601"></status>
</kw>
<status status="PASS" endtime="20190401 12:37:50.601" starttime="20190401 12:37:50.600"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:50.601" starttime="20190401 12:37:50.601"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:37:50.602" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:37:50.602" starttime="20190401 12:37:50.602"></status>
</kw>
<status status="PASS" endtime="20190401 12:37:50.602" starttime="20190401 12:37:50.589"></status>
</kw>
<status status="PASS" endtime="20190401 12:37:50.602" starttime="20190401 12:37:50.588"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:37:50.603" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:37:50.603" starttime="20190401 12:37:50.603"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:50.604" starttime="20190401 12:37:50.604"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:37:50.605" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:37:50.605" starttime="20190401 12:37:50.604"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:50.605" starttime="20190401 12:37:50.605"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:50.605" starttime="20190401 12:37:50.605"></status>
</kw>
<msg timestamp="20190401 12:37:50.606" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:37:50.606" starttime="20190401 12:37:50.604"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:37:50.606" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:37:50.606" starttime="20190401 12:37:50.606"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:37:50.616" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:37:50.616" starttime="20190401 12:37:50.606"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:37:51.090" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:37:51.091" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:37:51.091" starttime="20190401 12:37:50.616"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:37:51.091" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:37:51.091" starttime="20190401 12:37:51.091"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:37:51.092" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:37:51.092" starttime="20190401 12:37:51.092"></status>
</kw>
<msg timestamp="20190401 12:37:51.092" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:37:51.092" starttime="20190401 12:37:51.091"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:37:51.093" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:37:51.093" starttime="20190401 12:37:51.092"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:37:51.094" level="INFO">0</msg>
<msg timestamp="20190401 12:37:51.094" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:37:51.094" starttime="20190401 12:37:51.093"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:37:51.095" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:37:51.095" starttime="20190401 12:37:51.094"></status>
</kw>
<msg timestamp="20190401 12:37:51.095" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:37:51.095" starttime="20190401 12:37:51.092"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:51.095" starttime="20190401 12:37:51.095"></status>
</kw>
<status status="PASS" endtime="20190401 12:37:51.096" starttime="20190401 12:37:51.095"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:37:51.096" starttime="20190401 12:37:51.096"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:37:51.096" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:37:51.096" starttime="20190401 12:37:51.096"></status>
</kw>
<msg timestamp="20190401 12:37:51.096" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:37:51.096" starttime="20190401 12:37:50.603"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:37:51.097" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:37:51.097" starttime="20190401 12:37:51.096"></status>
</kw>
<msg timestamp="20190401 12:37:51.097" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:37:51.097" starttime="20190401 12:37:50.602"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:37:51.097" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:37:51.097" starttime="20190401 12:37:51.097"></status>
</kw>
<status status="FAIL" endtime="20190401 12:37:51.098" starttime="20190401 12:37:50.602"></status>
</kw>
<status status="FAIL" endtime="20190401 12:37:51.098" starttime="20190401 12:37:50.588"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:21.099" starttime="20190401 12:38:21.099"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:38:21.100" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:38:21.100" starttime="20190401 12:38:21.100"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:21.100" starttime="20190401 12:38:21.100"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:21.101" starttime="20190401 12:38:21.101"></status>
</kw>
<msg timestamp="20190401 12:38:21.101" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:38:21.101" starttime="20190401 12:38:21.099"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:38:21.101" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:21.101" starttime="20190401 12:38:21.101"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:38:21.103" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:38:21.103" starttime="20190401 12:38:21.101"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:38:21.109" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:38:21.110" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:21.110" starttime="20190401 12:38:21.103"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:38:21.110" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:21.110" starttime="20190401 12:38:21.110"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:38:21.111" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:38:21.111" starttime="20190401 12:38:21.110"></status>
</kw>
<msg timestamp="20190401 12:38:21.111" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:38:21.111" starttime="20190401 12:38:21.110"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:38:21.112" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:38:21.112" starttime="20190401 12:38:21.111"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:38:21.112" level="INFO">0</msg>
<msg timestamp="20190401 12:38:21.112" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:38:21.112" starttime="20190401 12:38:21.112"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:38:21.113" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:38:21.113" starttime="20190401 12:38:21.113"></status>
</kw>
<msg timestamp="20190401 12:38:21.113" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:38:21.113" starttime="20190401 12:38:21.111"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:21.114" starttime="20190401 12:38:21.113"></status>
</kw>
<status status="PASS" endtime="20190401 12:38:21.114" starttime="20190401 12:38:21.113"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:21.114" starttime="20190401 12:38:21.114"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:38:21.114" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:38:21.114" starttime="20190401 12:38:21.114"></status>
</kw>
<status status="PASS" endtime="20190401 12:38:21.114" starttime="20190401 12:38:21.099"></status>
</kw>
<status status="PASS" endtime="20190401 12:38:21.115" starttime="20190401 12:38:21.098"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:38:21.115" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:38:21.116" starttime="20190401 12:38:21.115"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:21.116" starttime="20190401 12:38:21.116"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:38:21.117" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:38:21.117" starttime="20190401 12:38:21.117"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:21.117" starttime="20190401 12:38:21.117"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:21.118" starttime="20190401 12:38:21.117"></status>
</kw>
<msg timestamp="20190401 12:38:21.118" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:38:21.118" starttime="20190401 12:38:21.116"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:38:21.118" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:21.118" starttime="20190401 12:38:21.118"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:38:21.120" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:38:21.120" starttime="20190401 12:38:21.118"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:38:21.438" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:38:21.438" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:21.438" starttime="20190401 12:38:21.120"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:38:21.439" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:21.439" starttime="20190401 12:38:21.439"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:38:21.440" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:38:21.440" starttime="20190401 12:38:21.439"></status>
</kw>
<msg timestamp="20190401 12:38:21.440" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:38:21.440" starttime="20190401 12:38:21.439"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:38:21.442" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:38:21.442" starttime="20190401 12:38:21.441"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:38:21.443" level="INFO">0</msg>
<msg timestamp="20190401 12:38:21.443" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:38:21.443" starttime="20190401 12:38:21.443"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:38:21.443" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:38:21.443" starttime="20190401 12:38:21.443"></status>
</kw>
<msg timestamp="20190401 12:38:21.443" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:38:21.443" starttime="20190401 12:38:21.441"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:21.444" starttime="20190401 12:38:21.444"></status>
</kw>
<status status="PASS" endtime="20190401 12:38:21.444" starttime="20190401 12:38:21.443"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:21.444" starttime="20190401 12:38:21.444"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:38:21.445" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:38:21.445" starttime="20190401 12:38:21.444"></status>
</kw>
<msg timestamp="20190401 12:38:21.445" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:38:21.445" starttime="20190401 12:38:21.116"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:38:21.445" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:38:21.445" starttime="20190401 12:38:21.445"></status>
</kw>
<msg timestamp="20190401 12:38:21.445" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:38:21.445" starttime="20190401 12:38:21.115"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:38:21.446" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:38:21.446" starttime="20190401 12:38:21.446"></status>
</kw>
<status status="FAIL" endtime="20190401 12:38:21.446" starttime="20190401 12:38:21.115"></status>
</kw>
<status status="FAIL" endtime="20190401 12:38:21.446" starttime="20190401 12:38:21.098"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:51.448" starttime="20190401 12:38:51.448"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:38:51.449" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:38:51.449" starttime="20190401 12:38:51.449"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:51.450" starttime="20190401 12:38:51.449"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:51.450" starttime="20190401 12:38:51.450"></status>
</kw>
<msg timestamp="20190401 12:38:51.450" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:38:51.450" starttime="20190401 12:38:51.448"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:38:51.451" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:51.451" starttime="20190401 12:38:51.450"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:38:51.456" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:38:51.456" starttime="20190401 12:38:51.451"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:38:51.457" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:38:51.457" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:51.457" starttime="20190401 12:38:51.456"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:38:51.458" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:51.458" starttime="20190401 12:38:51.457"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:38:51.458" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:38:51.458" starttime="20190401 12:38:51.458"></status>
</kw>
<msg timestamp="20190401 12:38:51.458" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:38:51.458" starttime="20190401 12:38:51.457"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:38:51.460" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:38:51.460" starttime="20190401 12:38:51.459"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:38:51.460" level="INFO">0</msg>
<msg timestamp="20190401 12:38:51.461" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:38:51.461" starttime="20190401 12:38:51.460"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:38:51.461" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:38:51.461" starttime="20190401 12:38:51.461"></status>
</kw>
<msg timestamp="20190401 12:38:51.461" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:38:51.461" starttime="20190401 12:38:51.458"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:51.462" starttime="20190401 12:38:51.462"></status>
</kw>
<status status="PASS" endtime="20190401 12:38:51.462" starttime="20190401 12:38:51.461"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:51.463" starttime="20190401 12:38:51.463"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:38:51.463" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:38:51.463" starttime="20190401 12:38:51.463"></status>
</kw>
<status status="PASS" endtime="20190401 12:38:51.463" starttime="20190401 12:38:51.447"></status>
</kw>
<status status="PASS" endtime="20190401 12:38:51.463" starttime="20190401 12:38:51.447"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:38:51.464" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:38:51.464" starttime="20190401 12:38:51.464"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:51.465" starttime="20190401 12:38:51.465"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:38:51.466" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:38:51.466" starttime="20190401 12:38:51.465"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:51.466" starttime="20190401 12:38:51.466"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:51.466" starttime="20190401 12:38:51.466"></status>
</kw>
<msg timestamp="20190401 12:38:51.466" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:38:51.467" starttime="20190401 12:38:51.465"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:38:51.467" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:51.467" starttime="20190401 12:38:51.467"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:38:51.476" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:38:51.476" starttime="20190401 12:38:51.467"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:38:51.781" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:38:51.781" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:51.781" starttime="20190401 12:38:51.477"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:38:51.782" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:38:51.782" starttime="20190401 12:38:51.781"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:38:51.782" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:38:51.782" starttime="20190401 12:38:51.782"></status>
</kw>
<msg timestamp="20190401 12:38:51.782" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:38:51.782" starttime="20190401 12:38:51.781"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:38:51.784" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:38:51.784" starttime="20190401 12:38:51.782"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:38:51.784" level="INFO">0</msg>
<msg timestamp="20190401 12:38:51.784" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:38:51.784" starttime="20190401 12:38:51.784"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:38:51.785" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:38:51.785" starttime="20190401 12:38:51.785"></status>
</kw>
<msg timestamp="20190401 12:38:51.785" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:38:51.785" starttime="20190401 12:38:51.782"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:51.786" starttime="20190401 12:38:51.785"></status>
</kw>
<status status="PASS" endtime="20190401 12:38:51.786" starttime="20190401 12:38:51.785"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:38:51.786" starttime="20190401 12:38:51.786"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:38:51.786" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:38:51.786" starttime="20190401 12:38:51.786"></status>
</kw>
<msg timestamp="20190401 12:38:51.786" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:38:51.786" starttime="20190401 12:38:51.464"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:38:51.787" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:38:51.787" starttime="20190401 12:38:51.787"></status>
</kw>
<msg timestamp="20190401 12:38:51.787" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:38:51.787" starttime="20190401 12:38:51.464"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:38:51.787" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:38:51.787" starttime="20190401 12:38:51.787"></status>
</kw>
<status status="FAIL" endtime="20190401 12:38:51.788" starttime="20190401 12:38:51.463"></status>
</kw>
<status status="FAIL" endtime="20190401 12:38:51.788" starttime="20190401 12:38:51.446"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:21.789" starttime="20190401 12:39:21.789"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:39:21.790" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:39:21.790" starttime="20190401 12:39:21.790"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:21.791" starttime="20190401 12:39:21.790"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:21.791" starttime="20190401 12:39:21.791"></status>
</kw>
<msg timestamp="20190401 12:39:21.791" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:39:21.791" starttime="20190401 12:39:21.790"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:39:21.791" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:21.791" starttime="20190401 12:39:21.791"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:39:21.796" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:39:21.796" starttime="20190401 12:39:21.792"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:39:21.797" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:39:21.797" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:21.797" starttime="20190401 12:39:21.797"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:39:21.798" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:21.798" starttime="20190401 12:39:21.798"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:39:21.798" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:39:21.798" starttime="20190401 12:39:21.798"></status>
</kw>
<msg timestamp="20190401 12:39:21.798" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:39:21.798" starttime="20190401 12:39:21.797"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:39:21.799" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:39:21.800" starttime="20190401 12:39:21.799"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:39:21.800" level="INFO">0</msg>
<msg timestamp="20190401 12:39:21.800" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:39:21.801" starttime="20190401 12:39:21.800"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:39:21.801" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:39:21.801" starttime="20190401 12:39:21.801"></status>
</kw>
<msg timestamp="20190401 12:39:21.801" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:39:21.801" starttime="20190401 12:39:21.799"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:21.802" starttime="20190401 12:39:21.802"></status>
</kw>
<status status="PASS" endtime="20190401 12:39:21.802" starttime="20190401 12:39:21.801"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:21.802" starttime="20190401 12:39:21.802"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:39:21.802" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:39:21.802" starttime="20190401 12:39:21.802"></status>
</kw>
<status status="PASS" endtime="20190401 12:39:21.803" starttime="20190401 12:39:21.789"></status>
</kw>
<status status="PASS" endtime="20190401 12:39:21.803" starttime="20190401 12:39:21.788"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:39:21.804" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:39:21.804" starttime="20190401 12:39:21.803"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:21.804" starttime="20190401 12:39:21.804"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:39:21.805" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:39:21.805" starttime="20190401 12:39:21.805"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:21.806" starttime="20190401 12:39:21.805"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:21.806" starttime="20190401 12:39:21.806"></status>
</kw>
<msg timestamp="20190401 12:39:21.806" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:39:21.806" starttime="20190401 12:39:21.804"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:39:21.806" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:21.806" starttime="20190401 12:39:21.806"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:39:21.815" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:39:21.816" starttime="20190401 12:39:21.806"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:39:22.119" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:39:22.119" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:22.119" starttime="20190401 12:39:21.816"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:39:22.120" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:22.120" starttime="20190401 12:39:22.120"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:39:22.120" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:39:22.121" starttime="20190401 12:39:22.120"></status>
</kw>
<msg timestamp="20190401 12:39:22.121" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:39:22.121" starttime="20190401 12:39:22.120"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:39:22.122" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:39:22.122" starttime="20190401 12:39:22.121"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:39:22.123" level="INFO">0</msg>
<msg timestamp="20190401 12:39:22.123" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:39:22.123" starttime="20190401 12:39:22.123"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:39:22.123" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:39:22.123" starttime="20190401 12:39:22.123"></status>
</kw>
<msg timestamp="20190401 12:39:22.123" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:39:22.123" starttime="20190401 12:39:22.121"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:22.124" starttime="20190401 12:39:22.124"></status>
</kw>
<status status="PASS" endtime="20190401 12:39:22.124" starttime="20190401 12:39:22.123"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:22.124" starttime="20190401 12:39:22.124"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:39:22.125" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:39:22.125" starttime="20190401 12:39:22.125"></status>
</kw>
<msg timestamp="20190401 12:39:22.125" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:39:22.125" starttime="20190401 12:39:21.804"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:39:22.125" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:39:22.125" starttime="20190401 12:39:22.125"></status>
</kw>
<msg timestamp="20190401 12:39:22.125" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:39:22.126" starttime="20190401 12:39:21.803"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:39:22.126" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:39:22.126" starttime="20190401 12:39:22.126"></status>
</kw>
<status status="FAIL" endtime="20190401 12:39:22.126" starttime="20190401 12:39:21.803"></status>
</kw>
<status status="FAIL" endtime="20190401 12:39:22.126" starttime="20190401 12:39:21.788"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:52.128" starttime="20190401 12:39:52.128"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:39:52.129" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:39:52.129" starttime="20190401 12:39:52.128"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:52.129" starttime="20190401 12:39:52.129"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:52.129" starttime="20190401 12:39:52.129"></status>
</kw>
<msg timestamp="20190401 12:39:52.130" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:39:52.130" starttime="20190401 12:39:52.128"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:39:52.130" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:52.130" starttime="20190401 12:39:52.130"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:39:52.135" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:39:52.135" starttime="20190401 12:39:52.130"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:39:52.136" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:39:52.136" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:52.136" starttime="20190401 12:39:52.135"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:39:52.136" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:52.136" starttime="20190401 12:39:52.136"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:39:52.137" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:39:52.137" starttime="20190401 12:39:52.136"></status>
</kw>
<msg timestamp="20190401 12:39:52.137" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:39:52.137" starttime="20190401 12:39:52.136"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:39:52.139" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:39:52.139" starttime="20190401 12:39:52.137"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:39:52.139" level="INFO">0</msg>
<msg timestamp="20190401 12:39:52.139" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:39:52.139" starttime="20190401 12:39:52.139"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:39:52.140" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:39:52.140" starttime="20190401 12:39:52.139"></status>
</kw>
<msg timestamp="20190401 12:39:52.140" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:39:52.140" starttime="20190401 12:39:52.137"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:52.140" starttime="20190401 12:39:52.140"></status>
</kw>
<status status="PASS" endtime="20190401 12:39:52.141" starttime="20190401 12:39:52.140"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:52.141" starttime="20190401 12:39:52.141"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:39:52.141" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:39:52.141" starttime="20190401 12:39:52.141"></status>
</kw>
<status status="PASS" endtime="20190401 12:39:52.141" starttime="20190401 12:39:52.127"></status>
</kw>
<status status="PASS" endtime="20190401 12:39:52.141" starttime="20190401 12:39:52.127"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:39:52.142" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:39:52.142" starttime="20190401 12:39:52.142"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:52.143" starttime="20190401 12:39:52.143"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:39:52.144" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:39:52.144" starttime="20190401 12:39:52.143"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:52.144" starttime="20190401 12:39:52.144"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:52.144" starttime="20190401 12:39:52.144"></status>
</kw>
<msg timestamp="20190401 12:39:52.145" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:39:52.145" starttime="20190401 12:39:52.143"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:39:52.145" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:52.145" starttime="20190401 12:39:52.145"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:39:52.146" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:39:52.146" starttime="20190401 12:39:52.145"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:39:52.492" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:39:52.492" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:52.492" starttime="20190401 12:39:52.147"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:39:52.493" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:39:52.493" starttime="20190401 12:39:52.493"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:39:52.493" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:39:52.493" starttime="20190401 12:39:52.493"></status>
</kw>
<msg timestamp="20190401 12:39:52.494" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:39:52.494" starttime="20190401 12:39:52.492"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:39:52.495" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:39:52.495" starttime="20190401 12:39:52.494"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:39:52.496" level="INFO">0</msg>
<msg timestamp="20190401 12:39:52.496" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:39:52.496" starttime="20190401 12:39:52.495"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:39:52.496" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:39:52.496" starttime="20190401 12:39:52.496"></status>
</kw>
<msg timestamp="20190401 12:39:52.496" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:39:52.496" starttime="20190401 12:39:52.494"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:52.497" starttime="20190401 12:39:52.497"></status>
</kw>
<status status="PASS" endtime="20190401 12:39:52.497" starttime="20190401 12:39:52.496"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:39:52.497" starttime="20190401 12:39:52.497"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:39:52.498" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:39:52.498" starttime="20190401 12:39:52.497"></status>
</kw>
<msg timestamp="20190401 12:39:52.498" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:39:52.498" starttime="20190401 12:39:52.142"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:39:52.498" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:39:52.498" starttime="20190401 12:39:52.498"></status>
</kw>
<msg timestamp="20190401 12:39:52.498" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:39:52.498" starttime="20190401 12:39:52.142"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:39:52.499" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:39:52.499" starttime="20190401 12:39:52.498"></status>
</kw>
<status status="FAIL" endtime="20190401 12:39:52.499" starttime="20190401 12:39:52.141"></status>
</kw>
<status status="FAIL" endtime="20190401 12:39:52.499" starttime="20190401 12:39:52.127"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:22.501" starttime="20190401 12:40:22.500"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:40:22.501" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:40:22.501" starttime="20190401 12:40:22.501"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:22.502" starttime="20190401 12:40:22.501"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:22.502" starttime="20190401 12:40:22.502"></status>
</kw>
<msg timestamp="20190401 12:40:22.502" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:40:22.502" starttime="20190401 12:40:22.501"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:40:22.503" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:22.503" starttime="20190401 12:40:22.502"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:40:22.507" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:40:22.508" starttime="20190401 12:40:22.503"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:40:22.508" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:40:22.509" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:22.509" starttime="20190401 12:40:22.508"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:40:22.509" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:22.509" starttime="20190401 12:40:22.509"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:40:22.510" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:40:22.510" starttime="20190401 12:40:22.509"></status>
</kw>
<msg timestamp="20190401 12:40:22.510" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:40:22.510" starttime="20190401 12:40:22.509"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:40:22.512" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:40:22.512" starttime="20190401 12:40:22.510"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:40:22.512" level="INFO">0</msg>
<msg timestamp="20190401 12:40:22.512" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:40:22.512" starttime="20190401 12:40:22.512"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:40:22.513" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:40:22.513" starttime="20190401 12:40:22.513"></status>
</kw>
<msg timestamp="20190401 12:40:22.513" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:40:22.513" starttime="20190401 12:40:22.510"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:22.514" starttime="20190401 12:40:22.514"></status>
</kw>
<status status="PASS" endtime="20190401 12:40:22.514" starttime="20190401 12:40:22.513"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:22.514" starttime="20190401 12:40:22.514"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:40:22.515" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:40:22.515" starttime="20190401 12:40:22.514"></status>
</kw>
<status status="PASS" endtime="20190401 12:40:22.515" starttime="20190401 12:40:22.500"></status>
</kw>
<status status="PASS" endtime="20190401 12:40:22.515" starttime="20190401 12:40:22.500"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:40:22.516" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:40:22.516" starttime="20190401 12:40:22.515"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:22.516" starttime="20190401 12:40:22.516"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:40:22.517" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:40:22.517" starttime="20190401 12:40:22.517"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:22.517" starttime="20190401 12:40:22.517"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:22.518" starttime="20190401 12:40:22.518"></status>
</kw>
<msg timestamp="20190401 12:40:22.518" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:40:22.518" starttime="20190401 12:40:22.517"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:40:22.518" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:22.518" starttime="20190401 12:40:22.518"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:40:22.529" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:40:22.529" starttime="20190401 12:40:22.518"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:40:22.846" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:40:22.847" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:22.847" starttime="20190401 12:40:22.529"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:40:22.847" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:22.847" starttime="20190401 12:40:22.847"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:40:22.848" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:40:22.848" starttime="20190401 12:40:22.847"></status>
</kw>
<msg timestamp="20190401 12:40:22.848" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:40:22.848" starttime="20190401 12:40:22.847"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:40:22.849" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:40:22.849" starttime="20190401 12:40:22.848"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:40:22.850" level="INFO">0</msg>
<msg timestamp="20190401 12:40:22.850" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:40:22.850" starttime="20190401 12:40:22.849"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:40:22.850" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:40:22.850" starttime="20190401 12:40:22.850"></status>
</kw>
<msg timestamp="20190401 12:40:22.850" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:40:22.850" starttime="20190401 12:40:22.848"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:22.851" starttime="20190401 12:40:22.851"></status>
</kw>
<status status="PASS" endtime="20190401 12:40:22.851" starttime="20190401 12:40:22.851"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:22.851" starttime="20190401 12:40:22.851"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:40:22.852" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:40:22.852" starttime="20190401 12:40:22.852"></status>
</kw>
<msg timestamp="20190401 12:40:22.852" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:40:22.852" starttime="20190401 12:40:22.516"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:40:22.852" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:40:22.853" starttime="20190401 12:40:22.852"></status>
</kw>
<msg timestamp="20190401 12:40:22.853" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:40:22.853" starttime="20190401 12:40:22.515"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:40:22.853" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:40:22.853" starttime="20190401 12:40:22.853"></status>
</kw>
<status status="FAIL" endtime="20190401 12:40:22.853" starttime="20190401 12:40:22.515"></status>
</kw>
<status status="FAIL" endtime="20190401 12:40:22.853" starttime="20190401 12:40:22.499"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:52.855" starttime="20190401 12:40:52.855"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:40:52.856" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:40:52.856" starttime="20190401 12:40:52.855"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:52.856" starttime="20190401 12:40:52.856"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:52.856" starttime="20190401 12:40:52.856"></status>
</kw>
<msg timestamp="20190401 12:40:52.857" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:40:52.857" starttime="20190401 12:40:52.855"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:40:52.857" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:52.857" starttime="20190401 12:40:52.857"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:40:52.861" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:40:52.862" starttime="20190401 12:40:52.857"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:40:52.863" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:40:52.863" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:52.863" starttime="20190401 12:40:52.862"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:40:52.863" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:52.863" starttime="20190401 12:40:52.863"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:40:52.864" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:40:52.864" starttime="20190401 12:40:52.863"></status>
</kw>
<msg timestamp="20190401 12:40:52.864" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:40:52.864" starttime="20190401 12:40:52.863"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:40:52.865" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:40:52.865" starttime="20190401 12:40:52.864"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:40:52.865" level="INFO">0</msg>
<msg timestamp="20190401 12:40:52.865" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:40:52.865" starttime="20190401 12:40:52.865"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:40:52.866" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:40:52.866" starttime="20190401 12:40:52.866"></status>
</kw>
<msg timestamp="20190401 12:40:52.866" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:40:52.866" starttime="20190401 12:40:52.864"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:52.867" starttime="20190401 12:40:52.867"></status>
</kw>
<status status="PASS" endtime="20190401 12:40:52.867" starttime="20190401 12:40:52.866"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:52.867" starttime="20190401 12:40:52.867"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:40:52.868" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:40:52.868" starttime="20190401 12:40:52.867"></status>
</kw>
<status status="PASS" endtime="20190401 12:40:52.868" starttime="20190401 12:40:52.854"></status>
</kw>
<status status="PASS" endtime="20190401 12:40:52.868" starttime="20190401 12:40:52.854"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:40:52.869" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:40:52.869" starttime="20190401 12:40:52.868"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:52.870" starttime="20190401 12:40:52.869"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:40:52.870" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:40:52.870" starttime="20190401 12:40:52.870"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:52.871" starttime="20190401 12:40:52.870"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:52.871" starttime="20190401 12:40:52.871"></status>
</kw>
<msg timestamp="20190401 12:40:52.871" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:40:52.871" starttime="20190401 12:40:52.870"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:40:52.872" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:52.872" starttime="20190401 12:40:52.871"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:40:52.874" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:40:52.874" starttime="20190401 12:40:52.872"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:40:53.233" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:40:53.233" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:53.233" starttime="20190401 12:40:52.874"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:40:53.234" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:40:53.234" starttime="20190401 12:40:53.234"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:40:53.234" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:40:53.235" starttime="20190401 12:40:53.234"></status>
</kw>
<msg timestamp="20190401 12:40:53.235" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:40:53.235" starttime="20190401 12:40:53.234"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:40:53.236" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:40:53.236" starttime="20190401 12:40:53.235"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:40:53.237" level="INFO">0</msg>
<msg timestamp="20190401 12:40:53.237" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:40:53.237" starttime="20190401 12:40:53.237"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:40:53.237" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:40:53.237" starttime="20190401 12:40:53.237"></status>
</kw>
<msg timestamp="20190401 12:40:53.237" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:40:53.237" starttime="20190401 12:40:53.235"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:53.238" starttime="20190401 12:40:53.238"></status>
</kw>
<status status="PASS" endtime="20190401 12:40:53.238" starttime="20190401 12:40:53.238"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:40:53.239" starttime="20190401 12:40:53.238"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:40:53.239" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:40:53.239" starttime="20190401 12:40:53.239"></status>
</kw>
<msg timestamp="20190401 12:40:53.239" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:40:53.239" starttime="20190401 12:40:52.869"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:40:53.239" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:40:53.239" starttime="20190401 12:40:53.239"></status>
</kw>
<msg timestamp="20190401 12:40:53.240" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:40:53.240" starttime="20190401 12:40:52.868"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:40:53.240" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:40:53.240" starttime="20190401 12:40:53.240"></status>
</kw>
<status status="FAIL" endtime="20190401 12:40:53.240" starttime="20190401 12:40:52.868"></status>
</kw>
<status status="FAIL" endtime="20190401 12:40:53.240" starttime="20190401 12:40:52.854"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:23.242" starttime="20190401 12:41:23.242"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:41:23.243" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:41:23.243" starttime="20190401 12:41:23.242"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:23.243" starttime="20190401 12:41:23.243"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:23.244" starttime="20190401 12:41:23.243"></status>
</kw>
<msg timestamp="20190401 12:41:23.244" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:41:23.244" starttime="20190401 12:41:23.242"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:41:23.244" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:23.244" starttime="20190401 12:41:23.244"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:41:23.249" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:41:23.249" starttime="20190401 12:41:23.244"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:41:23.250" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:41:23.250" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:23.250" starttime="20190401 12:41:23.249"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:41:23.250" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:23.250" starttime="20190401 12:41:23.250"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:41:23.251" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:41:23.251" starttime="20190401 12:41:23.251"></status>
</kw>
<msg timestamp="20190401 12:41:23.251" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:41:23.251" starttime="20190401 12:41:23.250"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:41:23.253" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:41:23.253" starttime="20190401 12:41:23.251"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:41:23.253" level="INFO">0</msg>
<msg timestamp="20190401 12:41:23.254" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:41:23.254" starttime="20190401 12:41:23.253"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:41:23.254" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:41:23.254" starttime="20190401 12:41:23.254"></status>
</kw>
<msg timestamp="20190401 12:41:23.254" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:41:23.254" starttime="20190401 12:41:23.251"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:23.255" starttime="20190401 12:41:23.255"></status>
</kw>
<status status="PASS" endtime="20190401 12:41:23.255" starttime="20190401 12:41:23.254"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:23.255" starttime="20190401 12:41:23.255"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:41:23.255" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:41:23.256" starttime="20190401 12:41:23.255"></status>
</kw>
<status status="PASS" endtime="20190401 12:41:23.256" starttime="20190401 12:41:23.241"></status>
</kw>
<status status="PASS" endtime="20190401 12:41:23.256" starttime="20190401 12:41:23.241"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:41:23.257" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:41:23.257" starttime="20190401 12:41:23.256"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:23.257" starttime="20190401 12:41:23.257"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:41:23.258" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:41:23.258" starttime="20190401 12:41:23.258"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:23.258" starttime="20190401 12:41:23.258"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:23.259" starttime="20190401 12:41:23.259"></status>
</kw>
<msg timestamp="20190401 12:41:23.259" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:41:23.259" starttime="20190401 12:41:23.258"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:41:23.259" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:23.259" starttime="20190401 12:41:23.259"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:41:23.269" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:41:23.269" starttime="20190401 12:41:23.259"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:41:23.574" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:41:23.574" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:23.575" starttime="20190401 12:41:23.270"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:41:23.575" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:23.575" starttime="20190401 12:41:23.575"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:41:23.576" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:41:23.576" starttime="20190401 12:41:23.575"></status>
</kw>
<msg timestamp="20190401 12:41:23.576" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:41:23.576" starttime="20190401 12:41:23.575"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:41:23.577" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:41:23.578" starttime="20190401 12:41:23.576"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:41:23.578" level="INFO">0</msg>
<msg timestamp="20190401 12:41:23.578" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:41:23.578" starttime="20190401 12:41:23.578"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:41:23.578" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:41:23.578" starttime="20190401 12:41:23.578"></status>
</kw>
<msg timestamp="20190401 12:41:23.579" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:41:23.579" starttime="20190401 12:41:23.576"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:23.579" starttime="20190401 12:41:23.579"></status>
</kw>
<status status="PASS" endtime="20190401 12:41:23.579" starttime="20190401 12:41:23.579"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:23.580" starttime="20190401 12:41:23.579"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:41:23.580" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:41:23.580" starttime="20190401 12:41:23.580"></status>
</kw>
<msg timestamp="20190401 12:41:23.580" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:41:23.580" starttime="20190401 12:41:23.257"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:41:23.580" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:41:23.581" starttime="20190401 12:41:23.580"></status>
</kw>
<msg timestamp="20190401 12:41:23.581" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:41:23.581" starttime="20190401 12:41:23.256"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:41:23.581" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:41:23.581" starttime="20190401 12:41:23.581"></status>
</kw>
<status status="FAIL" endtime="20190401 12:41:23.581" starttime="20190401 12:41:23.256"></status>
</kw>
<status status="FAIL" endtime="20190401 12:41:23.581" starttime="20190401 12:41:23.241"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:53.583" starttime="20190401 12:41:53.583"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:41:53.584" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:41:53.584" starttime="20190401 12:41:53.583"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:53.584" starttime="20190401 12:41:53.584"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:53.584" starttime="20190401 12:41:53.584"></status>
</kw>
<msg timestamp="20190401 12:41:53.585" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:41:53.585" starttime="20190401 12:41:53.583"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:41:53.585" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:53.585" starttime="20190401 12:41:53.585"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:41:53.586" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:41:53.586" starttime="20190401 12:41:53.585"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:41:53.589" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:41:53.589" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:53.589" starttime="20190401 12:41:53.586"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:41:53.589" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:53.589" starttime="20190401 12:41:53.589"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:41:53.590" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:41:53.590" starttime="20190401 12:41:53.589"></status>
</kw>
<msg timestamp="20190401 12:41:53.590" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:41:53.590" starttime="20190401 12:41:53.589"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:41:53.591" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:41:53.591" starttime="20190401 12:41:53.590"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:41:53.592" level="INFO">0</msg>
<msg timestamp="20190401 12:41:53.592" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:41:53.592" starttime="20190401 12:41:53.591"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:41:53.592" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:41:53.592" starttime="20190401 12:41:53.592"></status>
</kw>
<msg timestamp="20190401 12:41:53.592" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:41:53.592" starttime="20190401 12:41:53.590"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:53.593" starttime="20190401 12:41:53.593"></status>
</kw>
<status status="PASS" endtime="20190401 12:41:53.593" starttime="20190401 12:41:53.592"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:53.593" starttime="20190401 12:41:53.593"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:41:53.594" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:41:53.594" starttime="20190401 12:41:53.593"></status>
</kw>
<status status="PASS" endtime="20190401 12:41:53.594" starttime="20190401 12:41:53.582"></status>
</kw>
<status status="PASS" endtime="20190401 12:41:53.594" starttime="20190401 12:41:53.582"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:41:53.595" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:41:53.595" starttime="20190401 12:41:53.595"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:53.595" starttime="20190401 12:41:53.595"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:41:53.596" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:41:53.596" starttime="20190401 12:41:53.596"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:53.596" starttime="20190401 12:41:53.596"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:53.597" starttime="20190401 12:41:53.597"></status>
</kw>
<msg timestamp="20190401 12:41:53.597" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:41:53.597" starttime="20190401 12:41:53.596"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:41:53.597" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:53.597" starttime="20190401 12:41:53.597"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:41:53.599" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:41:53.600" starttime="20190401 12:41:53.597"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:41:53.911" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:41:53.911" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:53.911" starttime="20190401 12:41:53.600"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:41:53.912" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:41:53.912" starttime="20190401 12:41:53.912"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:41:53.912" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:41:53.912" starttime="20190401 12:41:53.912"></status>
</kw>
<msg timestamp="20190401 12:41:53.913" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:41:53.913" starttime="20190401 12:41:53.911"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:41:53.914" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:41:53.915" starttime="20190401 12:41:53.913"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:41:53.915" level="INFO">0</msg>
<msg timestamp="20190401 12:41:53.915" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:41:53.915" starttime="20190401 12:41:53.915"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:41:53.916" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:41:53.916" starttime="20190401 12:41:53.915"></status>
</kw>
<msg timestamp="20190401 12:41:53.916" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:41:53.916" starttime="20190401 12:41:53.913"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:53.917" starttime="20190401 12:41:53.917"></status>
</kw>
<status status="PASS" endtime="20190401 12:41:53.917" starttime="20190401 12:41:53.916"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:41:53.917" starttime="20190401 12:41:53.917"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:41:53.917" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:41:53.918" starttime="20190401 12:41:53.917"></status>
</kw>
<msg timestamp="20190401 12:41:53.918" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:41:53.918" starttime="20190401 12:41:53.595"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:41:53.918" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:41:53.918" starttime="20190401 12:41:53.918"></status>
</kw>
<msg timestamp="20190401 12:41:53.918" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:41:53.918" starttime="20190401 12:41:53.594"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:41:53.919" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:41:53.919" starttime="20190401 12:41:53.918"></status>
</kw>
<status status="FAIL" endtime="20190401 12:41:53.919" starttime="20190401 12:41:53.594"></status>
</kw>
<status status="FAIL" endtime="20190401 12:41:53.919" starttime="20190401 12:41:53.582"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:23.921" starttime="20190401 12:42:23.921"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:42:23.922" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:42:23.923" starttime="20190401 12:42:23.922"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:23.923" starttime="20190401 12:42:23.923"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:23.924" starttime="20190401 12:42:23.923"></status>
</kw>
<msg timestamp="20190401 12:42:23.924" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:42:23.924" starttime="20190401 12:42:23.921"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:42:23.925" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:23.925" starttime="20190401 12:42:23.924"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:42:23.933" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:42:23.933" starttime="20190401 12:42:23.925"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:42:23.934" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:42:23.934" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:23.935" starttime="20190401 12:42:23.933"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:42:23.935" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:23.936" starttime="20190401 12:42:23.935"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:42:23.936" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:42:23.936" starttime="20190401 12:42:23.936"></status>
</kw>
<msg timestamp="20190401 12:42:23.936" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:42:23.936" starttime="20190401 12:42:23.935"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:42:23.938" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:42:23.938" starttime="20190401 12:42:23.937"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:42:23.939" level="INFO">0</msg>
<msg timestamp="20190401 12:42:23.939" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:42:23.939" starttime="20190401 12:42:23.938"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:42:23.940" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:42:23.940" starttime="20190401 12:42:23.939"></status>
</kw>
<msg timestamp="20190401 12:42:23.940" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:42:23.940" starttime="20190401 12:42:23.937"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:23.941" starttime="20190401 12:42:23.941"></status>
</kw>
<status status="PASS" endtime="20190401 12:42:23.941" starttime="20190401 12:42:23.940"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:23.942" starttime="20190401 12:42:23.941"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:42:23.942" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:42:23.942" starttime="20190401 12:42:23.942"></status>
</kw>
<status status="PASS" endtime="20190401 12:42:23.943" starttime="20190401 12:42:23.920"></status>
</kw>
<status status="PASS" endtime="20190401 12:42:23.943" starttime="20190401 12:42:23.920"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:42:23.945" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:42:23.945" starttime="20190401 12:42:23.944"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:23.946" starttime="20190401 12:42:23.945"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:42:23.947" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:42:23.947" starttime="20190401 12:42:23.946"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:23.947" starttime="20190401 12:42:23.947"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:23.948" starttime="20190401 12:42:23.948"></status>
</kw>
<msg timestamp="20190401 12:42:23.948" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:42:23.949" starttime="20190401 12:42:23.946"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:42:23.949" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:23.949" starttime="20190401 12:42:23.949"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:42:23.951" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:42:23.952" starttime="20190401 12:42:23.949"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:42:24.281" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:42:24.281" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:24.281" starttime="20190401 12:42:23.952"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:42:24.282" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:24.282" starttime="20190401 12:42:24.281"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:42:24.282" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:42:24.282" starttime="20190401 12:42:24.282"></status>
</kw>
<msg timestamp="20190401 12:42:24.282" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:42:24.282" starttime="20190401 12:42:24.281"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:42:24.284" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:42:24.284" starttime="20190401 12:42:24.282"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:42:24.285" level="INFO">0</msg>
<msg timestamp="20190401 12:42:24.285" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:42:24.285" starttime="20190401 12:42:24.284"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:42:24.285" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:42:24.285" starttime="20190401 12:42:24.285"></status>
</kw>
<msg timestamp="20190401 12:42:24.285" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:42:24.285" starttime="20190401 12:42:24.282"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:24.286" starttime="20190401 12:42:24.286"></status>
</kw>
<status status="PASS" endtime="20190401 12:42:24.286" starttime="20190401 12:42:24.285"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:24.286" starttime="20190401 12:42:24.286"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:42:24.286" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:42:24.287" starttime="20190401 12:42:24.286"></status>
</kw>
<msg timestamp="20190401 12:42:24.287" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:42:24.287" starttime="20190401 12:42:23.945"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:42:24.287" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:42:24.287" starttime="20190401 12:42:24.287"></status>
</kw>
<msg timestamp="20190401 12:42:24.287" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:42:24.287" starttime="20190401 12:42:23.943"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:42:24.288" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:42:24.288" starttime="20190401 12:42:24.287"></status>
</kw>
<status status="FAIL" endtime="20190401 12:42:24.288" starttime="20190401 12:42:23.943"></status>
</kw>
<status status="FAIL" endtime="20190401 12:42:24.288" starttime="20190401 12:42:23.919"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:54.291" starttime="20190401 12:42:54.290"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:42:54.292" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:42:54.292" starttime="20190401 12:42:54.291"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:54.293" starttime="20190401 12:42:54.292"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:54.293" starttime="20190401 12:42:54.293"></status>
</kw>
<msg timestamp="20190401 12:42:54.293" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:42:54.294" starttime="20190401 12:42:54.291"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:42:54.294" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:54.294" starttime="20190401 12:42:54.294"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:42:54.297" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:42:54.297" starttime="20190401 12:42:54.294"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:42:54.299" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:42:54.299" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:54.299" starttime="20190401 12:42:54.297"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:42:54.300" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:54.300" starttime="20190401 12:42:54.300"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:42:54.301" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:42:54.301" starttime="20190401 12:42:54.301"></status>
</kw>
<msg timestamp="20190401 12:42:54.301" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:42:54.301" starttime="20190401 12:42:54.300"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:42:54.303" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:42:54.303" starttime="20190401 12:42:54.302"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:42:54.304" level="INFO">0</msg>
<msg timestamp="20190401 12:42:54.304" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:42:54.304" starttime="20190401 12:42:54.303"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:42:54.304" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:42:54.304" starttime="20190401 12:42:54.304"></status>
</kw>
<msg timestamp="20190401 12:42:54.304" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:42:54.304" starttime="20190401 12:42:54.301"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:54.305" starttime="20190401 12:42:54.305"></status>
</kw>
<status status="PASS" endtime="20190401 12:42:54.305" starttime="20190401 12:42:54.304"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:54.306" starttime="20190401 12:42:54.305"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:42:54.306" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:42:54.306" starttime="20190401 12:42:54.306"></status>
</kw>
<status status="PASS" endtime="20190401 12:42:54.306" starttime="20190401 12:42:54.289"></status>
</kw>
<status status="PASS" endtime="20190401 12:42:54.306" starttime="20190401 12:42:54.289"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:42:54.307" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:42:54.307" starttime="20190401 12:42:54.307"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:54.308" starttime="20190401 12:42:54.308"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:42:54.309" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:42:54.309" starttime="20190401 12:42:54.308"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:54.309" starttime="20190401 12:42:54.309"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:54.310" starttime="20190401 12:42:54.309"></status>
</kw>
<msg timestamp="20190401 12:42:54.310" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:42:54.310" starttime="20190401 12:42:54.308"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:42:54.310" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:54.310" starttime="20190401 12:42:54.310"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:42:54.312" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:42:54.312" starttime="20190401 12:42:54.310"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:42:54.633" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:42:54.633" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:54.633" starttime="20190401 12:42:54.312"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:42:54.634" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:42:54.634" starttime="20190401 12:42:54.634"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:42:54.634" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:42:54.634" starttime="20190401 12:42:54.634"></status>
</kw>
<msg timestamp="20190401 12:42:54.634" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:42:54.634" starttime="20190401 12:42:54.633"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:42:54.636" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:42:54.636" starttime="20190401 12:42:54.635"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:42:54.637" level="INFO">0</msg>
<msg timestamp="20190401 12:42:54.637" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:42:54.637" starttime="20190401 12:42:54.637"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:42:54.637" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:42:54.637" starttime="20190401 12:42:54.637"></status>
</kw>
<msg timestamp="20190401 12:42:54.637" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:42:54.637" starttime="20190401 12:42:54.634"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:54.638" starttime="20190401 12:42:54.638"></status>
</kw>
<status status="PASS" endtime="20190401 12:42:54.638" starttime="20190401 12:42:54.637"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:42:54.638" starttime="20190401 12:42:54.638"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:42:54.639" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:42:54.639" starttime="20190401 12:42:54.639"></status>
</kw>
<msg timestamp="20190401 12:42:54.639" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:42:54.639" starttime="20190401 12:42:54.307"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:42:54.639" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:42:54.639" starttime="20190401 12:42:54.639"></status>
</kw>
<msg timestamp="20190401 12:42:54.639" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:42:54.639" starttime="20190401 12:42:54.307"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:42:54.640" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:42:54.640" starttime="20190401 12:42:54.640"></status>
</kw>
<status status="FAIL" endtime="20190401 12:42:54.640" starttime="20190401 12:42:54.306"></status>
</kw>
<status status="FAIL" endtime="20190401 12:42:54.640" starttime="20190401 12:42:54.288"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:24.642" starttime="20190401 12:43:24.642"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:43:24.644" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:43:24.644" starttime="20190401 12:43:24.643"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:24.644" starttime="20190401 12:43:24.644"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:24.645" starttime="20190401 12:43:24.644"></status>
</kw>
<msg timestamp="20190401 12:43:24.645" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:43:24.645" starttime="20190401 12:43:24.643"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:43:24.646" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:24.646" starttime="20190401 12:43:24.645"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:43:24.653" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:43:24.653" starttime="20190401 12:43:24.646"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:43:24.655" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:43:24.655" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:24.655" starttime="20190401 12:43:24.654"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:43:24.656" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:24.657" starttime="20190401 12:43:24.656"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:43:24.657" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:43:24.657" starttime="20190401 12:43:24.657"></status>
</kw>
<msg timestamp="20190401 12:43:24.657" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:43:24.658" starttime="20190401 12:43:24.655"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:43:24.660" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:43:24.660" starttime="20190401 12:43:24.658"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:43:24.661" level="INFO">0</msg>
<msg timestamp="20190401 12:43:24.661" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:43:24.661" starttime="20190401 12:43:24.661"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:43:24.662" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:43:24.662" starttime="20190401 12:43:24.661"></status>
</kw>
<msg timestamp="20190401 12:43:24.662" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:43:24.662" starttime="20190401 12:43:24.658"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:24.663" starttime="20190401 12:43:24.663"></status>
</kw>
<status status="PASS" endtime="20190401 12:43:24.663" starttime="20190401 12:43:24.662"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:24.664" starttime="20190401 12:43:24.663"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:43:24.664" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:43:24.664" starttime="20190401 12:43:24.664"></status>
</kw>
<status status="PASS" endtime="20190401 12:43:24.664" starttime="20190401 12:43:24.641"></status>
</kw>
<status status="PASS" endtime="20190401 12:43:24.665" starttime="20190401 12:43:24.641"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:43:24.666" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:43:24.666" starttime="20190401 12:43:24.666"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:24.667" starttime="20190401 12:43:24.666"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:43:24.667" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:43:24.667" starttime="20190401 12:43:24.667"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:24.668" starttime="20190401 12:43:24.667"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:24.668" starttime="20190401 12:43:24.668"></status>
</kw>
<msg timestamp="20190401 12:43:24.668" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:43:24.668" starttime="20190401 12:43:24.667"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:43:24.668" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:24.669" starttime="20190401 12:43:24.668"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:43:24.678" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:43:24.678" starttime="20190401 12:43:24.669"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:43:24.981" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:43:24.982" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:24.982" starttime="20190401 12:43:24.678"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:43:24.982" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:24.982" starttime="20190401 12:43:24.982"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:43:24.983" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:43:24.983" starttime="20190401 12:43:24.982"></status>
</kw>
<msg timestamp="20190401 12:43:24.983" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:43:24.983" starttime="20190401 12:43:24.982"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:43:24.985" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:43:24.985" starttime="20190401 12:43:24.983"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:43:24.986" level="INFO">0</msg>
<msg timestamp="20190401 12:43:24.986" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:43:24.986" starttime="20190401 12:43:24.985"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:43:24.986" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:43:24.986" starttime="20190401 12:43:24.986"></status>
</kw>
<msg timestamp="20190401 12:43:24.986" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:43:24.986" starttime="20190401 12:43:24.983"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:24.987" starttime="20190401 12:43:24.987"></status>
</kw>
<status status="PASS" endtime="20190401 12:43:24.987" starttime="20190401 12:43:24.987"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:24.988" starttime="20190401 12:43:24.987"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:43:24.988" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:43:24.988" starttime="20190401 12:43:24.988"></status>
</kw>
<msg timestamp="20190401 12:43:24.988" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:43:24.988" starttime="20190401 12:43:24.666"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:43:24.988" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:43:24.988" starttime="20190401 12:43:24.988"></status>
</kw>
<msg timestamp="20190401 12:43:24.989" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:43:24.989" starttime="20190401 12:43:24.665"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:43:24.989" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:43:24.989" starttime="20190401 12:43:24.989"></status>
</kw>
<status status="FAIL" endtime="20190401 12:43:24.989" starttime="20190401 12:43:24.665"></status>
</kw>
<status status="FAIL" endtime="20190401 12:43:24.989" starttime="20190401 12:43:24.640"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:54.992" starttime="20190401 12:43:54.991"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:43:54.993" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:43:54.993" starttime="20190401 12:43:54.992"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:54.993" starttime="20190401 12:43:54.993"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:54.994" starttime="20190401 12:43:54.994"></status>
</kw>
<msg timestamp="20190401 12:43:54.994" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:43:54.994" starttime="20190401 12:43:54.992"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:43:54.995" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:54.995" starttime="20190401 12:43:54.995"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:43:55.003" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:43:55.003" starttime="20190401 12:43:54.995"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:43:55.005" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:43:55.005" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:55.005" starttime="20190401 12:43:55.003"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:43:55.006" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:55.006" starttime="20190401 12:43:55.005"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:43:55.006" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:43:55.006" starttime="20190401 12:43:55.006"></status>
</kw>
<msg timestamp="20190401 12:43:55.007" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:43:55.007" starttime="20190401 12:43:55.005"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:43:55.008" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:43:55.008" starttime="20190401 12:43:55.007"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:43:55.009" level="INFO">0</msg>
<msg timestamp="20190401 12:43:55.009" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:43:55.009" starttime="20190401 12:43:55.008"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:43:55.009" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:43:55.010" starttime="20190401 12:43:55.009"></status>
</kw>
<msg timestamp="20190401 12:43:55.010" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:43:55.010" starttime="20190401 12:43:55.007"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:55.011" starttime="20190401 12:43:55.011"></status>
</kw>
<status status="PASS" endtime="20190401 12:43:55.011" starttime="20190401 12:43:55.010"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:55.012" starttime="20190401 12:43:55.011"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:43:55.012" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:43:55.012" starttime="20190401 12:43:55.012"></status>
</kw>
<status status="PASS" endtime="20190401 12:43:55.012" starttime="20190401 12:43:54.991"></status>
</kw>
<status status="PASS" endtime="20190401 12:43:55.013" starttime="20190401 12:43:54.990"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:43:55.014" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:43:55.015" starttime="20190401 12:43:55.014"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:55.016" starttime="20190401 12:43:55.015"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:43:55.017" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:43:55.017" starttime="20190401 12:43:55.016"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:55.017" starttime="20190401 12:43:55.017"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:55.018" starttime="20190401 12:43:55.018"></status>
</kw>
<msg timestamp="20190401 12:43:55.018" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:43:55.018" starttime="20190401 12:43:55.016"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:43:55.019" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:55.019" starttime="20190401 12:43:55.019"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:43:55.036" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:43:55.036" starttime="20190401 12:43:55.019"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:43:55.355" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:43:55.355" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:55.355" starttime="20190401 12:43:55.036"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:43:55.356" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:43:55.356" starttime="20190401 12:43:55.356"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:43:55.356" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:43:55.356" starttime="20190401 12:43:55.356"></status>
</kw>
<msg timestamp="20190401 12:43:55.357" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:43:55.357" starttime="20190401 12:43:55.355"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:43:55.359" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:43:55.359" starttime="20190401 12:43:55.357"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:43:55.359" level="INFO">0</msg>
<msg timestamp="20190401 12:43:55.359" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:43:55.359" starttime="20190401 12:43:55.359"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:43:55.359" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:43:55.359" starttime="20190401 12:43:55.359"></status>
</kw>
<msg timestamp="20190401 12:43:55.360" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:43:55.360" starttime="20190401 12:43:55.357"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:55.360" starttime="20190401 12:43:55.360"></status>
</kw>
<status status="PASS" endtime="20190401 12:43:55.360" starttime="20190401 12:43:55.360"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:43:55.361" starttime="20190401 12:43:55.361"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:43:55.361" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:43:55.361" starttime="20190401 12:43:55.361"></status>
</kw>
<msg timestamp="20190401 12:43:55.361" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:43:55.361" starttime="20190401 12:43:55.015"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:43:55.362" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:43:55.362" starttime="20190401 12:43:55.361"></status>
</kw>
<msg timestamp="20190401 12:43:55.362" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:43:55.362" starttime="20190401 12:43:55.013"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:43:55.362" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:43:55.362" starttime="20190401 12:43:55.362"></status>
</kw>
<status status="FAIL" endtime="20190401 12:43:55.362" starttime="20190401 12:43:55.013"></status>
</kw>
<status status="FAIL" endtime="20190401 12:43:55.362" starttime="20190401 12:43:54.990"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:25.364" starttime="20190401 12:44:25.364"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:44:25.365" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:44:25.365" starttime="20190401 12:44:25.365"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:25.365" starttime="20190401 12:44:25.365"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:25.366" starttime="20190401 12:44:25.366"></status>
</kw>
<msg timestamp="20190401 12:44:25.366" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:44:25.366" starttime="20190401 12:44:25.364"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:44:25.366" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:25.366" starttime="20190401 12:44:25.366"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:44:25.368" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:44:25.368" starttime="20190401 12:44:25.366"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:44:25.371" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:44:25.371" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:25.371" starttime="20190401 12:44:25.368"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:44:25.371" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:25.371" starttime="20190401 12:44:25.371"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:44:25.372" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:44:25.372" starttime="20190401 12:44:25.371"></status>
</kw>
<msg timestamp="20190401 12:44:25.372" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:44:25.372" starttime="20190401 12:44:25.371"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:44:25.373" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:44:25.373" starttime="20190401 12:44:25.372"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:44:25.374" level="INFO">0</msg>
<msg timestamp="20190401 12:44:25.374" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:44:25.374" starttime="20190401 12:44:25.373"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:44:25.375" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:44:25.375" starttime="20190401 12:44:25.374"></status>
</kw>
<msg timestamp="20190401 12:44:25.375" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:44:25.375" starttime="20190401 12:44:25.372"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:25.375" starttime="20190401 12:44:25.375"></status>
</kw>
<status status="PASS" endtime="20190401 12:44:25.376" starttime="20190401 12:44:25.375"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:25.376" starttime="20190401 12:44:25.376"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:44:25.376" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:44:25.376" starttime="20190401 12:44:25.376"></status>
</kw>
<status status="PASS" endtime="20190401 12:44:25.376" starttime="20190401 12:44:25.363"></status>
</kw>
<status status="PASS" endtime="20190401 12:44:25.376" starttime="20190401 12:44:25.363"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:44:25.377" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:44:25.377" starttime="20190401 12:44:25.377"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:25.378" starttime="20190401 12:44:25.378"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:44:25.379" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:44:25.379" starttime="20190401 12:44:25.378"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:25.379" starttime="20190401 12:44:25.379"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:25.380" starttime="20190401 12:44:25.379"></status>
</kw>
<msg timestamp="20190401 12:44:25.380" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:44:25.380" starttime="20190401 12:44:25.378"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:44:25.380" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:25.380" starttime="20190401 12:44:25.380"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:44:25.382" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:44:25.382" starttime="20190401 12:44:25.380"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:44:25.694" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:44:25.694" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:25.694" starttime="20190401 12:44:25.382"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:44:25.695" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:25.695" starttime="20190401 12:44:25.695"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:44:25.696" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:44:25.696" starttime="20190401 12:44:25.695"></status>
</kw>
<msg timestamp="20190401 12:44:25.696" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:44:25.696" starttime="20190401 12:44:25.695"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:44:25.698" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:44:25.698" starttime="20190401 12:44:25.696"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:44:25.698" level="INFO">0</msg>
<msg timestamp="20190401 12:44:25.698" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:44:25.698" starttime="20190401 12:44:25.698"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:44:25.698" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:44:25.698" starttime="20190401 12:44:25.698"></status>
</kw>
<msg timestamp="20190401 12:44:25.698" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:44:25.698" starttime="20190401 12:44:25.696"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:25.699" starttime="20190401 12:44:25.699"></status>
</kw>
<status status="PASS" endtime="20190401 12:44:25.699" starttime="20190401 12:44:25.699"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:25.700" starttime="20190401 12:44:25.699"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:44:25.700" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:44:25.700" starttime="20190401 12:44:25.700"></status>
</kw>
<msg timestamp="20190401 12:44:25.700" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:44:25.700" starttime="20190401 12:44:25.377"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:44:25.700" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:44:25.700" starttime="20190401 12:44:25.700"></status>
</kw>
<msg timestamp="20190401 12:44:25.701" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:44:25.701" starttime="20190401 12:44:25.377"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:44:25.701" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:44:25.701" starttime="20190401 12:44:25.701"></status>
</kw>
<status status="FAIL" endtime="20190401 12:44:25.701" starttime="20190401 12:44:25.376"></status>
</kw>
<status status="FAIL" endtime="20190401 12:44:25.701" starttime="20190401 12:44:25.363"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:55.703" starttime="20190401 12:44:55.703"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:44:55.704" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:44:55.704" starttime="20190401 12:44:55.703"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:55.704" starttime="20190401 12:44:55.704"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:55.704" starttime="20190401 12:44:55.704"></status>
</kw>
<msg timestamp="20190401 12:44:55.705" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:44:55.705" starttime="20190401 12:44:55.703"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:44:55.705" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:55.705" starttime="20190401 12:44:55.705"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:44:55.707" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:44:55.707" starttime="20190401 12:44:55.705"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:44:55.709" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:44:55.709" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:55.709" starttime="20190401 12:44:55.707"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:44:55.710" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:55.710" starttime="20190401 12:44:55.709"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:44:55.710" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:44:55.710" starttime="20190401 12:44:55.710"></status>
</kw>
<msg timestamp="20190401 12:44:55.710" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:44:55.710" starttime="20190401 12:44:55.709"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:44:55.711" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:44:55.711" starttime="20190401 12:44:55.711"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:44:55.712" level="INFO">0</msg>
<msg timestamp="20190401 12:44:55.712" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:44:55.712" starttime="20190401 12:44:55.712"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:44:55.713" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:44:55.713" starttime="20190401 12:44:55.712"></status>
</kw>
<msg timestamp="20190401 12:44:55.713" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:44:55.713" starttime="20190401 12:44:55.710"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:55.714" starttime="20190401 12:44:55.713"></status>
</kw>
<status status="PASS" endtime="20190401 12:44:55.714" starttime="20190401 12:44:55.713"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:55.714" starttime="20190401 12:44:55.714"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:44:55.714" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:44:55.714" starttime="20190401 12:44:55.714"></status>
</kw>
<status status="PASS" endtime="20190401 12:44:55.714" starttime="20190401 12:44:55.702"></status>
</kw>
<status status="PASS" endtime="20190401 12:44:55.714" starttime="20190401 12:44:55.702"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:44:55.715" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:44:55.715" starttime="20190401 12:44:55.715"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:55.716" starttime="20190401 12:44:55.716"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:44:55.717" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:44:55.717" starttime="20190401 12:44:55.716"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:55.717" starttime="20190401 12:44:55.717"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:55.718" starttime="20190401 12:44:55.717"></status>
</kw>
<msg timestamp="20190401 12:44:55.718" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:44:55.718" starttime="20190401 12:44:55.716"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:44:55.718" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:55.718" starttime="20190401 12:44:55.718"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:44:55.720" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:44:55.720" starttime="20190401 12:44:55.718"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:44:56.029" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:44:56.029" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:56.029" starttime="20190401 12:44:55.721"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:44:56.030" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:44:56.030" starttime="20190401 12:44:56.030"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:44:56.030" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:44:56.030" starttime="20190401 12:44:56.030"></status>
</kw>
<msg timestamp="20190401 12:44:56.030" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:44:56.030" starttime="20190401 12:44:56.029"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:44:56.032" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:44:56.032" starttime="20190401 12:44:56.031"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:44:56.033" level="INFO">0</msg>
<msg timestamp="20190401 12:44:56.033" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:44:56.033" starttime="20190401 12:44:56.032"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:44:56.033" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:44:56.033" starttime="20190401 12:44:56.033"></status>
</kw>
<msg timestamp="20190401 12:44:56.033" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:44:56.033" starttime="20190401 12:44:56.030"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:56.034" starttime="20190401 12:44:56.034"></status>
</kw>
<status status="PASS" endtime="20190401 12:44:56.034" starttime="20190401 12:44:56.033"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:44:56.034" starttime="20190401 12:44:56.034"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:44:56.035" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:44:56.035" starttime="20190401 12:44:56.034"></status>
</kw>
<msg timestamp="20190401 12:44:56.035" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:44:56.035" starttime="20190401 12:44:55.716"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:44:56.035" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:44:56.035" starttime="20190401 12:44:56.035"></status>
</kw>
<msg timestamp="20190401 12:44:56.035" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:44:56.035" starttime="20190401 12:44:55.715"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:44:56.036" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:44:56.036" starttime="20190401 12:44:56.036"></status>
</kw>
<status status="FAIL" endtime="20190401 12:44:56.036" starttime="20190401 12:44:55.715"></status>
</kw>
<status status="FAIL" endtime="20190401 12:44:56.036" starttime="20190401 12:44:55.702"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:26.038" starttime="20190401 12:45:26.038"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:45:26.038" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:45:26.039" starttime="20190401 12:45:26.038"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:26.039" starttime="20190401 12:45:26.039"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:26.039" starttime="20190401 12:45:26.039"></status>
</kw>
<msg timestamp="20190401 12:45:26.039" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:45:26.039" starttime="20190401 12:45:26.038"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:45:26.040" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:26.040" starttime="20190401 12:45:26.040"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:45:26.044" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:45:26.045" starttime="20190401 12:45:26.040"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:45:26.045" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:45:26.046" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:26.046" starttime="20190401 12:45:26.045"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:45:26.046" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:26.046" starttime="20190401 12:45:26.046"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:45:26.046" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:45:26.047" starttime="20190401 12:45:26.046"></status>
</kw>
<msg timestamp="20190401 12:45:26.047" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:45:26.047" starttime="20190401 12:45:26.046"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:45:26.048" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:45:26.048" starttime="20190401 12:45:26.047"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:45:26.048" level="INFO">0</msg>
<msg timestamp="20190401 12:45:26.048" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:45:26.048" starttime="20190401 12:45:26.048"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:45:26.049" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:45:26.049" starttime="20190401 12:45:26.049"></status>
</kw>
<msg timestamp="20190401 12:45:26.049" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:45:26.049" starttime="20190401 12:45:26.047"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:26.050" starttime="20190401 12:45:26.049"></status>
</kw>
<status status="PASS" endtime="20190401 12:45:26.050" starttime="20190401 12:45:26.049"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:26.050" starttime="20190401 12:45:26.050"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:45:26.050" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:45:26.050" starttime="20190401 12:45:26.050"></status>
</kw>
<status status="PASS" endtime="20190401 12:45:26.050" starttime="20190401 12:45:26.037"></status>
</kw>
<status status="PASS" endtime="20190401 12:45:26.050" starttime="20190401 12:45:26.037"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:45:26.052" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:45:26.052" starttime="20190401 12:45:26.051"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:26.052" starttime="20190401 12:45:26.052"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:45:26.053" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:45:26.053" starttime="20190401 12:45:26.053"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:26.053" starttime="20190401 12:45:26.053"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:26.054" starttime="20190401 12:45:26.053"></status>
</kw>
<msg timestamp="20190401 12:45:26.054" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:45:26.054" starttime="20190401 12:45:26.052"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:45:26.054" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:26.054" starttime="20190401 12:45:26.054"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:45:26.056" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:45:26.056" starttime="20190401 12:45:26.054"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:45:26.371" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:45:26.371" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:26.372" starttime="20190401 12:45:26.057"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:45:26.372" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:26.372" starttime="20190401 12:45:26.372"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:45:26.373" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:45:26.373" starttime="20190401 12:45:26.372"></status>
</kw>
<msg timestamp="20190401 12:45:26.373" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:45:26.373" starttime="20190401 12:45:26.372"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:45:26.375" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:45:26.375" starttime="20190401 12:45:26.373"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:45:26.375" level="INFO">0</msg>
<msg timestamp="20190401 12:45:26.375" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:45:26.375" starttime="20190401 12:45:26.375"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:45:26.376" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:45:26.376" starttime="20190401 12:45:26.375"></status>
</kw>
<msg timestamp="20190401 12:45:26.376" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:45:26.376" starttime="20190401 12:45:26.373"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:26.377" starttime="20190401 12:45:26.376"></status>
</kw>
<status status="PASS" endtime="20190401 12:45:26.377" starttime="20190401 12:45:26.376"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:26.377" starttime="20190401 12:45:26.377"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:45:26.377" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:45:26.377" starttime="20190401 12:45:26.377"></status>
</kw>
<msg timestamp="20190401 12:45:26.377" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:45:26.377" starttime="20190401 12:45:26.052"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:45:26.378" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:45:26.378" starttime="20190401 12:45:26.378"></status>
</kw>
<msg timestamp="20190401 12:45:26.378" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:45:26.378" starttime="20190401 12:45:26.051"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:45:26.378" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:45:26.378" starttime="20190401 12:45:26.378"></status>
</kw>
<status status="FAIL" endtime="20190401 12:45:26.379" starttime="20190401 12:45:26.051"></status>
</kw>
<status status="FAIL" endtime="20190401 12:45:26.379" starttime="20190401 12:45:26.036"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:56.381" starttime="20190401 12:45:56.381"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:45:56.382" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:45:56.382" starttime="20190401 12:45:56.381"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:56.382" starttime="20190401 12:45:56.382"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:56.382" starttime="20190401 12:45:56.382"></status>
</kw>
<msg timestamp="20190401 12:45:56.383" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:45:56.383" starttime="20190401 12:45:56.381"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:45:56.383" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:56.383" starttime="20190401 12:45:56.383"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:45:56.388" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:45:56.388" starttime="20190401 12:45:56.383"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:45:56.389" level="INFO">Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<msg timestamp="20190401 12:45:56.389" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:56.389" starttime="20190401 12:45:56.388"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:45:56.389" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:56.389" starttime="20190401 12:45:56.389"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:45:56.390" level="INFO">${clean_out} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:45:56.390" starttime="20190401 12:45:56.389"></status>
</kw>
<msg timestamp="20190401 12:45:56.390" level="INFO">${output} = Openstack Admin credentials can only be loaded from the active controller.
</msg>
<status status="PASS" endtime="20190401 12:45:56.390" starttime="20190401 12:45:56.389"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:45:56.391" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:45:56.391" starttime="20190401 12:45:56.390"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:45:56.392" level="INFO">0</msg>
<msg timestamp="20190401 12:45:56.392" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:45:56.392" starttime="20190401 12:45:56.391"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:45:56.392" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:45:56.392" starttime="20190401 12:45:56.392"></status>
</kw>
<msg timestamp="20190401 12:45:56.392" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:45:56.392" starttime="20190401 12:45:56.390"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:56.393" starttime="20190401 12:45:56.393"></status>
</kw>
<status status="PASS" endtime="20190401 12:45:56.393" starttime="20190401 12:45:56.392"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:56.393" starttime="20190401 12:45:56.393"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:45:56.394" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Openstack Admin credentials can only be loaded from the active controller.</msg>
<status status="PASS" endtime="20190401 12:45:56.394" starttime="20190401 12:45:56.393"></status>
</kw>
<status status="PASS" endtime="20190401 12:45:56.394" starttime="20190401 12:45:56.380"></status>
</kw>
<status status="PASS" endtime="20190401 12:45:56.394" starttime="20190401 12:45:56.379"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:45:56.395" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:45:56.395" starttime="20190401 12:45:56.395"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:56.396" starttime="20190401 12:45:56.395"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:45:56.396" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:45:56.396" starttime="20190401 12:45:56.396"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:56.397" starttime="20190401 12:45:56.396"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:56.397" starttime="20190401 12:45:56.397"></status>
</kw>
<msg timestamp="20190401 12:45:56.397" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:45:56.397" starttime="20190401 12:45:56.396"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:45:56.398" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:56.398" starttime="20190401 12:45:56.397"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:45:56.400" level="INFO">system host-show controller-0|grep -w administrative|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:45:56.400" starttime="20190401 12:45:56.398"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:45:56.728" level="INFO">You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<msg timestamp="20190401 12:45:56.728" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:56.728" starttime="20190401 12:45:56.400"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:45:56.728" level="INFO">${line_to_remove} = controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:45:56.729" starttime="20190401 12:45:56.728"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:45:56.729" level="INFO">${clean_out} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:45:56.729" starttime="20190401 12:45:56.729"></status>
</kw>
<msg timestamp="20190401 12:45:56.729" level="INFO">${output} = You must provide a password via either --os-password or via env[OS_PASSWORD]
</msg>
<status status="PASS" endtime="20190401 12:45:56.729" starttime="20190401 12:45:56.728"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:45:56.731" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:45:56.731" starttime="20190401 12:45:56.729"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:45:56.731" level="INFO">0</msg>
<msg timestamp="20190401 12:45:56.731" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:45:56.732" starttime="20190401 12:45:56.731"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:45:56.732" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:45:56.732" starttime="20190401 12:45:56.732"></status>
</kw>
<msg timestamp="20190401 12:45:56.732" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:45:56.732" starttime="20190401 12:45:56.729"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:56.733" starttime="20190401 12:45:56.733"></status>
</kw>
<status status="PASS" endtime="20190401 12:45:56.733" starttime="20190401 12:45:56.732"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:45:56.733" starttime="20190401 12:45:56.733"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:45:56.733" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:45:56.734" starttime="20190401 12:45:56.733"></status>
</kw>
<msg timestamp="20190401 12:45:56.734" level="INFO">${result} = {u'stdout': u'You must provide a password via either --os-password or via env[OS_PASSWORD]', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:45:56.734" starttime="20190401 12:45:56.395"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:45:56.734" level="INFO">${value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:45:56.734" starttime="20190401 12:45:56.734"></status>
</kw>
<msg timestamp="20190401 12:45:56.734" level="INFO">${current_value} = You must provide a password via either --os-password or via env[OS_PASSWORD]</msg>
<status status="PASS" endtime="20190401 12:45:56.734" starttime="20190401 12:45:56.394"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:45:56.735" level="FAIL">You must provide a password via either --os-password or via env[OS_PASSWORD] != unlocked</msg>
<status status="FAIL" endtime="20190401 12:45:56.735" starttime="20190401 12:45:56.734"></status>
</kw>
<status status="FAIL" endtime="20190401 12:45:56.735" starttime="20190401 12:45:56.394"></status>
</kw>
<status status="FAIL" endtime="20190401 12:45:56.735" starttime="20190401 12:45:56.379"></status>
</kw>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:26.737" starttime="20190401 12:46:26.736"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:46:26.737" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:46:26.737" starttime="20190401 12:46:26.737"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:26.738" starttime="20190401 12:46:26.737"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:26.738" starttime="20190401 12:46:26.738"></status>
</kw>
<msg timestamp="20190401 12:46:26.738" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:46:26.738" starttime="20190401 12:46:26.737"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:46:26.738" level="INFO">controller-0:~$</msg>
<status status="PASS" endtime="20190401 12:46:26.739" starttime="20190401 12:46:26.738"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:46:26.745" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:46:26.745" starttime="20190401 12:46:26.739"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:46:27.355" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:46:27.355" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:27.355" starttime="20190401 12:46:26.745"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:46:27.356" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:27.356" starttime="20190401 12:46:27.356"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:46:27.357" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 12:46:27.357" starttime="20190401 12:46:27.356"></status>
</kw>
<msg timestamp="20190401 12:46:27.357" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 12:46:27.357" starttime="20190401 12:46:27.355"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:46:27.360" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:46:27.360" starttime="20190401 12:46:27.357"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:46:27.360" level="INFO">0</msg>
<msg timestamp="20190401 12:46:27.360" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:27.360" starttime="20190401 12:46:27.360"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:46:27.360" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:46:27.360" starttime="20190401 12:46:27.360"></status>
</kw>
<msg timestamp="20190401 12:46:27.361" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:27.361" starttime="20190401 12:46:27.357"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:27.361" starttime="20190401 12:46:27.361"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:27.361" starttime="20190401 12:46:27.361"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:27.362" starttime="20190401 12:46:27.362"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:46:27.362" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 12:46:27.362" starttime="20190401 12:46:27.362"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:27.362" starttime="20190401 12:46:26.736"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:27.362" starttime="20190401 12:46:26.736"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:46:27.363" level="INFO">${system_cmd} = system host-show controller-0|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:27.363" starttime="20190401 12:46:27.363"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:27.364" starttime="20190401 12:46:27.364"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:46:27.365" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:46:27.365" starttime="20190401 12:46:27.364"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:27.365" starttime="20190401 12:46:27.365"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:27.365" starttime="20190401 12:46:27.365"></status>
</kw>
<msg timestamp="20190401 12:46:27.366" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:46:27.366" starttime="20190401 12:46:27.364"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:46:27.366" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:27.366" starttime="20190401 12:46:27.366"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:46:27.381" level="INFO">system host-show controller-0|grep -w  administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:27.381" starttime="20190401 12:46:27.366"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:46:28.697" level="INFO">unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:46:28.697" level="INFO">${output} = unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:28.697" starttime="20190401 12:46:27.381"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:46:28.698" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:28.698" starttime="20190401 12:46:28.698"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:46:28.698" level="INFO">${clean_out} = unlocked
</msg>
<status status="PASS" endtime="20190401 12:46:28.698" starttime="20190401 12:46:28.698"></status>
</kw>
<msg timestamp="20190401 12:46:28.699" level="INFO">${output} = unlocked
</msg>
<status status="PASS" endtime="20190401 12:46:28.699" starttime="20190401 12:46:28.697"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:46:28.700" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:46:28.700" starttime="20190401 12:46:28.699"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:46:28.702" level="INFO">0</msg>
<msg timestamp="20190401 12:46:28.702" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:28.702" starttime="20190401 12:46:28.701"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:46:28.702" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:46:28.703" starttime="20190401 12:46:28.702"></status>
</kw>
<msg timestamp="20190401 12:46:28.703" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:28.703" starttime="20190401 12:46:28.699"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.703" starttime="20190401 12:46:28.703"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:28.703" starttime="20190401 12:46:28.703"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.704" starttime="20190401 12:46:28.704"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:46:28.704" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: unlocked</msg>
<status status="PASS" endtime="20190401 12:46:28.704" starttime="20190401 12:46:28.704"></status>
</kw>
<msg timestamp="20190401 12:46:28.704" level="INFO">${result} = {u'stdout': u'unlocked', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:46:28.704" starttime="20190401 12:46:27.363"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:46:28.705" level="INFO">${value} = unlocked</msg>
<status status="PASS" endtime="20190401 12:46:28.705" starttime="20190401 12:46:28.704"></status>
</kw>
<msg timestamp="20190401 12:46:28.705" level="INFO">${current_value} = unlocked</msg>
<status status="PASS" endtime="20190401 12:46:28.705" starttime="20190401 12:46:27.363"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.705" starttime="20190401 12:46:28.705"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:28.705" starttime="20190401 12:46:27.362"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:28.705" starttime="20190401 12:46:26.735"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:28.705" starttime="20190401 12:37:50.588"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:28.706" starttime="20190401 12:32:43.581"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Check Ceph Status</arg>
<arg>HEALTH_WARN</arg>
</arguments>
<kw name="Check Ceph Status" library="Utils">
<doc>Verifies the status of the CEPH feature.</doc>
<arguments>
<arg>HEALTH_WARN</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph -s</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.707" starttime="20190401 12:46:28.707"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:46:28.707" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:46:28.707" starttime="20190401 12:46:28.707"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.708" starttime="20190401 12:46:28.708"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.708" starttime="20190401 12:46:28.708"></status>
</kw>
<msg timestamp="20190401 12:46:28.708" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:46:28.708" starttime="20190401 12:46:28.707"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:46:28.709" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:28.709" starttime="20190401 12:46:28.708"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:46:28.711" level="INFO">ceph -s</msg>
<status status="PASS" endtime="20190401 12:46:28.711" starttime="20190401 12:46:28.709"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:46:28.956" level="INFO">cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_WARN
            384 pgs degraded
            64 pgs stuck unclean
            384 pgs undersized
            recovery 1116/2232 objects degraded (50.000%)
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e15: 1 osds: 1 up, 1 in
            flags sortbitwise,require_jewel_osds
      pgmap v19: 384 pgs, 6 pools, 1588 bytes data, 1116 objects
            43392 kB used, 445 GB / 445 GB avail
            1116/2232 objects degraded (50.000%)
                 384 active+undersized+degraded
  client io 303 kB/s rd, 0 B/s wr, 454 op/s rd, 303 op/s wr
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:46:28.956" level="INFO">${output} =     cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_WARN
            384 pgs degraded
            64 pgs stuck unclean
            384 pgs undersized
            recovery 1116/223...</msg>
<status status="PASS" endtime="20190401 12:46:28.956" starttime="20190401 12:46:28.711"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:46:28.957" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:28.957" starttime="20190401 12:46:28.957"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:46:28.957" level="INFO">${clean_out} =     cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_WARN
            384 pgs degraded
            64 pgs stuck unclean
            384 pgs undersized
            recovery 1116/223...</msg>
<status status="PASS" endtime="20190401 12:46:28.957" starttime="20190401 12:46:28.957"></status>
</kw>
<msg timestamp="20190401 12:46:28.958" level="INFO">${output} =     cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_WARN
            384 pgs degraded
            64 pgs stuck unclean
            384 pgs undersized
            recovery 1116/223...</msg>
<status status="PASS" endtime="20190401 12:46:28.958" starttime="20190401 12:46:28.956"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:46:28.959" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:46:28.959" starttime="20190401 12:46:28.958"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:46:28.961" level="INFO">0</msg>
<msg timestamp="20190401 12:46:28.961" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:28.961" starttime="20190401 12:46:28.959"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:46:28.962" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:46:28.962" starttime="20190401 12:46:28.961"></status>
</kw>
<msg timestamp="20190401 12:46:28.962" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:28.962" starttime="20190401 12:46:28.958"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.963" starttime="20190401 12:46:28.962"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:28.963" starttime="20190401 12:46:28.962"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.963" starttime="20190401 12:46:28.963"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:46:28.964" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_WARN
            384 pgs degraded
            64 pgs stuck unclean
            384 pgs undersized
            recovery 1116/2232 objects degraded (50.000%)
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e15: 1 osds: 1 up, 1 in
            flags sortbitwise,require_jewel_osds
      pgmap v19: 384 pgs, 6 pools, 1588 bytes data, 1116 objects
            43392 kB used, 445 GB / 445 GB avail
            1116/2232 objects degraded (50.000%)
                 384 active+undersized+degraded
  client io 303 kB/s rd, 0 B/s wr, 454 op/s rd, 303 op/s wr</msg>
<status status="PASS" endtime="20190401 12:46:28.964" starttime="20190401 12:46:28.963"></status>
</kw>
<msg timestamp="20190401 12:46:28.964" level="INFO">${result} = {u'stdout': u'cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8\r\n     health HEALTH_WARN\r\n            384 pgs degraded\r\n            64 pgs stuck unclean\r\n            384 pgs undersized\r\n         ...</msg>
<status status="PASS" endtime="20190401 12:46:28.964" starttime="20190401 12:46:28.706"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${result.stdout}</arg>
<arg>${status}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.964" starttime="20190401 12:46:28.964"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd tree</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.965" starttime="20190401 12:46:28.965"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:46:28.966" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:46:28.966" starttime="20190401 12:46:28.965"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.966" starttime="20190401 12:46:28.966"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:28.966" starttime="20190401 12:46:28.966"></status>
</kw>
<msg timestamp="20190401 12:46:28.967" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:46:28.967" starttime="20190401 12:46:28.965"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:46:28.967" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:28.967" starttime="20190401 12:46:28.967"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:46:28.969" level="INFO">ceph osd tree</msg>
<status status="PASS" endtime="20190401 12:46:28.969" starttime="20190401 12:46:28.967"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:46:29.194" level="INFO">ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3       0         host controller-1                                   
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:46:29.194" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190401 12:46:29.194" starttime="20190401 12:46:28.970"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:46:29.195" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:29.195" starttime="20190401 12:46:29.194"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:46:29.195" level="INFO">${clean_out} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190401 12:46:29.195" starttime="20190401 12:46:29.195"></status>
</kw>
<msg timestamp="20190401 12:46:29.195" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190401 12:46:29.195" starttime="20190401 12:46:29.194"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:46:29.197" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:46:29.197" starttime="20190401 12:46:29.195"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:46:29.199" level="INFO">0</msg>
<msg timestamp="20190401 12:46:29.199" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:29.199" starttime="20190401 12:46:29.197"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:46:29.200" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:46:29.200" starttime="20190401 12:46:29.200"></status>
</kw>
<msg timestamp="20190401 12:46:29.200" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:29.200" starttime="20190401 12:46:29.195"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:29.201" starttime="20190401 12:46:29.200"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:29.201" starttime="20190401 12:46:29.200"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:29.201" starttime="20190401 12:46:29.201"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:46:29.201" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3       0         host controller-1</msg>
<status status="PASS" endtime="20190401 12:46:29.201" starttime="20190401 12:46:29.201"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:29.202" starttime="20190401 12:46:28.964"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:29.202" starttime="20190401 12:46:28.706"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:29.202" starttime="20190401 12:46:28.706"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${ENVIRONMENT}'=='virtual'</arg>
<arg>Install Remaining Nodes Virtual</arg>
<arg>ELSE</arg>
<arg>Install Remaining Nodes Baremetal</arg>
</arguments>
<kw name="Install Remaining Nodes Baremetal" library="provisioning">
<doc>Install rest of the nodes according to the info on the
installation yaml file.</doc>
<kw name="Get List Of Installation Nodes" library="provisioning">
<doc>Return a list of nodes candidate to be installed,
controller-0 is removed by default</doc>
<assign>
<var>@{nodes_list}</var>
</assign>
<kw name="Get Dictionary Keys" library="Collections">
<doc>Returns keys of the given ``dictionary``.</doc>
<arguments>
<arg>${NODES}</arg>
</arguments>
<assign>
<var>${nodes_list}</var>
</assign>
<msg timestamp="20190401 12:46:29.203" level="INFO">${nodes_list} = ['controller-0', 'controller-1']</msg>
<status status="PASS" endtime="20190401 12:46:29.203" starttime="20190401 12:46:29.203"></status>
</kw>
<kw name="Remove Values From List" library="Collections">
<doc>Removes all occurrences of given ``values`` from ``list``.</doc>
<arguments>
<arg>${nodes_list}</arg>
<arg>controller-0</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:29.203" starttime="20190401 12:46:29.203"></status>
</kw>
<msg timestamp="20190401 12:46:29.203" level="INFO">@{nodes_list} = [ controller-1 ]</msg>
<status status="PASS" endtime="20190401 12:46:29.203" starttime="20190401 12:46:29.202"></status>
</kw>
<kw type="for" name="${node} IN [ @{nodes_list} ]">
<kw type="foritem" name="${node} = controller-1">
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{NODES}[${node}]</arg>
</arguments>
<assign>
<var>&amp;{node_data}</var>
</assign>
<msg timestamp="20190401 12:46:29.204" level="INFO">&amp;{node_data} = { bmc_user=starlingx | bmc_ip=192.168.100.77 | name=controller-1 | pxe_nic_mac=a4:bf:01:55:03:bb | bmc_pswd=Passw0rd | personality=controller }</msg>
<status status="PASS" endtime="20190401 12:46:29.204" starttime="20190401 12:46:29.204"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[bmc_ip]</arg>
</arguments>
<assign>
<var>${bmc_ip}</var>
</assign>
<msg timestamp="20190401 12:46:29.204" level="INFO">${bmc_ip} = 192.168.100.77</msg>
<status status="PASS" endtime="20190401 12:46:29.204" starttime="20190401 12:46:29.204"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[bmc_user]</arg>
</arguments>
<assign>
<var>${bmc_user}</var>
</assign>
<msg timestamp="20190401 12:46:29.205" level="INFO">${bmc_user} = starlingx</msg>
<status status="PASS" endtime="20190401 12:46:29.205" starttime="20190401 12:46:29.205"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[bmc_pswd]</arg>
</arguments>
<assign>
<var>${pswd}</var>
</assign>
<msg timestamp="20190401 12:46:29.205" level="INFO">${pswd} = Passw0rd</msg>
<status status="PASS" endtime="20190401 12:46:29.205" starttime="20190401 12:46:29.205"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>ipmitool -H ${bmc_ip}</arg>
<arg>-U ${bmc_user} -P ${pswd}</arg>
<arg>-I lanplus chassis bootparam set bootflag force_pxe</arg>
</arguments>
<assign>
<var>${set_pxe_boot_device}</var>
</assign>
<msg timestamp="20190401 12:46:29.206" level="INFO">${set_pxe_boot_device} = ipmitool -H 192.168.100.77 -U starlingx -P Passw0rd -I lanplus chassis bootparam set bootflag force_pxe</msg>
<status status="PASS" endtime="20190401 12:46:29.206" starttime="20190401 12:46:29.206"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>ipmitool -H ${bmc_ip} -U ${bmc_user}</arg>
<arg>-P ${pswd} -I lanplus chassis power on</arg>
</arguments>
<assign>
<var>${turn_on_node}</var>
</assign>
<msg timestamp="20190401 12:46:29.206" level="INFO">${turn_on_node} = ipmitool -H 192.168.100.77 -U starlingx -P Passw0rd -I lanplus chassis power on</msg>
<status status="PASS" endtime="20190401 12:46:29.206" starttime="20190401 12:46:29.206"></status>
</kw>
<kw name="Run" library="OperatingSystem">
<doc>Runs the given command in the system and returns the output.</doc>
<arguments>
<arg>${set_pxe_boot_device}</arg>
</arguments>
<msg timestamp="20190401 12:46:29.208" level="INFO">Running command 'ipmitool -H 192.168.100.77 -U starlingx -P Passw0rd -I lanplus chassis bootparam set bootflag force_pxe 2&gt;&amp;1'.</msg>
<status status="PASS" endtime="20190401 12:46:29.255" starttime="20190401 12:46:29.206"></status>
</kw>
<kw name="Run" library="OperatingSystem">
<doc>Runs the given command in the system and returns the output.</doc>
<arguments>
<arg>${turn_on_node}</arg>
</arguments>
<msg timestamp="20190401 12:46:29.257" level="INFO">Running command 'ipmitool -H 192.168.100.77 -U starlingx -P Passw0rd -I lanplus chassis power on 2&gt;&amp;1'.</msg>
<status status="PASS" endtime="20190401 12:46:29.286" starttime="20190401 12:46:29.256"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:29.286" starttime="20190401 12:46:29.204"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:29.286" starttime="20190401 12:46:29.203"></status>
</kw>
<kw type="for" name="${node} IN [ @{nodes_list} ]">
<kw type="foritem" name="${node} = controller-1">
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{NODES}[${node}]</arg>
</arguments>
<assign>
<var>&amp;{node_data}</var>
</assign>
<msg timestamp="20190401 12:46:29.287" level="INFO">&amp;{node_data} = { bmc_user=starlingx | bmc_ip=192.168.100.77 | name=controller-1 | pxe_nic_mac=a4:bf:01:55:03:bb | bmc_pswd=Passw0rd | personality=controller }</msg>
<status status="PASS" endtime="20190401 12:46:29.287" starttime="20190401 12:46:29.286"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[name]</arg>
</arguments>
<assign>
<var>${name}</var>
</assign>
<msg timestamp="20190401 12:46:29.287" level="INFO">${name} = controller-1</msg>
<status status="PASS" endtime="20190401 12:46:29.287" starttime="20190401 12:46:29.287"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[personality]</arg>
</arguments>
<assign>
<var>${personality}</var>
</assign>
<msg timestamp="20190401 12:46:29.288" level="INFO">${personality} = controller</msg>
<status status="PASS" endtime="20190401 12:46:29.288" starttime="20190401 12:46:29.288"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[pxe_nic_mac]</arg>
</arguments>
<assign>
<var>${mac_address}</var>
</assign>
<msg timestamp="20190401 12:46:29.288" level="INFO">${mac_address} = a4:bf:01:55:03:bb</msg>
<status status="PASS" endtime="20190401 12:46:29.288" starttime="20190401 12:46:29.288"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Run Command</arg>
<arg>system host-add -n ${name} -p ${personality} -m ${mac_address}</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-add -n ${name} -p ${personality} -m ${mac_address}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:29.290" starttime="20190401 12:46:29.289"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:46:29.290" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:46:29.290" starttime="20190401 12:46:29.290"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:29.291" starttime="20190401 12:46:29.291"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:29.291" starttime="20190401 12:46:29.291"></status>
</kw>
<msg timestamp="20190401 12:46:29.291" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:46:29.291" starttime="20190401 12:46:29.290"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:46:29.292" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:29.292" starttime="20190401 12:46:29.292"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:46:29.295" level="INFO">system host-add -n controller-1 -p con troller -m a4:bf:01:55:03:bb</msg>
<status status="PASS" endtime="20190401 12:46:29.295" starttime="20190401 12:46:29.292"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:46:33.731" level="INFO">+---------------------+-----------------------------------------+
| Property            | Value                                   |
+---------------------+-----------------------------------------+
| action              | none                                    |
| administrative      | locked                                  |
| availability        | offline                                 |
| bm_ip               | None                                    |
| bm_type             | None                                    |
| bm_username         | None                                    |
| boot_device         | sda                                     |
| capabilities        | {u'Personality': u'Controller-Standby'} |
| config_applied      | None                                    |
| config_status       | None                                    |
| config_target       | None                                    |
| console             | ttyS0,115200                            |
| created_at          | 2019-04-01T18:35:17.435156+00:00        |
| hostname            | controller-1                            |
| id                  | 2                                       |
| install_output      | text                                    |
| install_state       | None                                    |
| install_state_info  | None                                    |
| invprovision        | None                                    |
| location            | {}                                      |
| mgmt_ip             | 10.10.53.4                              |
| mgmt_mac            | a4:bf:01:55:03:bb                       |
| operational         | disabled                                |
| personality         | controller                              |
| reserved            | False                                   |
| rootfs_device       | sda                                     |
| serialid            | None                                    |
| software_load       | 19.01                                   |
| subfunction_avail   | not-installed                           |
| subfunction_oper    | disabled                                |
| subfunctions        | controller,worker                       |
| task                | None                                    |
| tboot               | false                                   |
| ttys_dcd            | None                                    |
| updated_at          | None                                    |
| uptime              | 0                                       |
| uuid                | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb    |
| vim_progress_status | None                                    |
+---------------------+-----------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:46:33.731" level="INFO">${output} = +---------------------+-----------------------------------------+
| Property            | Value                                   |
+---------------------+-----------------------------------------+...</msg>
<status status="PASS" endtime="20190401 12:46:33.731" starttime="20190401 12:46:29.295"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:46:33.732" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:33.732" starttime="20190401 12:46:33.732"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:46:33.733" level="INFO">${clean_out} = +---------------------+-----------------------------------------+
| Property            | Value                                   |
+---------------------+-----------------------------------------+...</msg>
<status status="PASS" endtime="20190401 12:46:33.733" starttime="20190401 12:46:33.732"></status>
</kw>
<msg timestamp="20190401 12:46:33.733" level="INFO">${output} = +---------------------+-----------------------------------------+
| Property            | Value                                   |
+---------------------+-----------------------------------------+...</msg>
<status status="PASS" endtime="20190401 12:46:33.733" starttime="20190401 12:46:33.732"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:46:33.734" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:46:33.734" starttime="20190401 12:46:33.734"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:46:33.743" level="INFO">0</msg>
<msg timestamp="20190401 12:46:33.743" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:33.743" starttime="20190401 12:46:33.734"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:46:33.743" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:46:33.743" starttime="20190401 12:46:33.743"></status>
</kw>
<msg timestamp="20190401 12:46:33.743" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:33.744" starttime="20190401 12:46:33.733"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:33.744" starttime="20190401 12:46:33.744"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:33.744" starttime="20190401 12:46:33.744"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:33.745" starttime="20190401 12:46:33.744"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:46:33.745" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +---------------------+-----------------------------------------+
| Property            | Value                                   |
+---------------------+-----------------------------------------+
| action              | none                                    |
| administrative      | locked                                  |
| availability        | offline                                 |
| bm_ip               | None                                    |
| bm_type             | None                                    |
| bm_username         | None                                    |
| boot_device         | sda                                     |
| capabilities        | {u'Personality': u'Controller-Standby'} |
| config_applied      | None                                    |
| config_status       | None                                    |
| config_target       | None                                    |
| console             | ttyS0,115200                            |
| created_at          | 2019-04-01T18:35:17.435156+00:00        |
| hostname            | controller-1                            |
| id                  | 2                                       |
| install_output      | text                                    |
| install_state       | None                                    |
| install_state_info  | None                                    |
| invprovision        | None                                    |
| location            | {}                                      |
| mgmt_ip             | 10.10.53.4                              |
| mgmt_mac            | a4:bf:01:55:03:bb                       |
| operational         | disabled                                |
| personality         | controller                              |
| reserved            | False                                   |
| rootfs_device       | sda                                     |
| serialid            | None                                    |
| software_load       | 19.01                                   |
| subfunction_avail   | not-installed                           |
| subfunction_oper    | disabled                                |
| subfunctions        | controller,worker                       |
| task                | None                                    |
| tboot               | false                                   |
| ttys_dcd            | None                                    |
| updated_at          | None                                    |
| uptime              | 0                                       |
| uuid                | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb    |
| vim_progress_status | None                                    |
+---------------------+-----------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:46:33.745" starttime="20190401 12:46:33.745"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:33.745" starttime="20190401 12:46:29.289"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:33.745" starttime="20190401 12:46:29.288"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:33.745" starttime="20190401 12:46:29.286"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:33.745" starttime="20190401 12:46:29.286"></status>
</kw>
<kw type="for" name="${node} IN [ @{nodes_list} ]">
<kw type="foritem" name="${node} = controller-1">
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{NODES}[${node}]</arg>
</arguments>
<assign>
<var>&amp;{node_data}</var>
</assign>
<msg timestamp="20190401 12:46:33.746" level="INFO">&amp;{node_data} = { bmc_user=starlingx | bmc_ip=192.168.100.77 | name=controller-1 | pxe_nic_mac=a4:bf:01:55:03:bb | bmc_pswd=Passw0rd | personality=controller }</msg>
<status status="PASS" endtime="20190401 12:46:33.746" starttime="20190401 12:46:33.746"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>&amp;{node_data}[name]</arg>
</arguments>
<assign>
<var>${name}</var>
</assign>
<msg timestamp="20190401 12:46:33.746" level="INFO">${name} = controller-1</msg>
<status status="PASS" endtime="20190401 12:46:33.746" starttime="20190401 12:46:33.746"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>20 min</arg>
<arg>5 sec</arg>
<arg>Check Property Value</arg>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:46:33.748" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:33.748" starttime="20190401 12:46:33.747"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:33.748" starttime="20190401 12:46:33.748"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:46:33.749" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:46:33.749" starttime="20190401 12:46:33.749"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:33.749" starttime="20190401 12:46:33.749"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:33.750" starttime="20190401 12:46:33.750"></status>
</kw>
<msg timestamp="20190401 12:46:33.750" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:46:33.750" starttime="20190401 12:46:33.749"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:46:33.750" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:33.750" starttime="20190401 12:46:33.750"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:46:33.760" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:33.760" starttime="20190401 12:46:33.750"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:46:35.248" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:46:35.248" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:35.249" starttime="20190401 12:46:33.760"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:46:35.250" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:35.250" starttime="20190401 12:46:35.249"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:46:35.250" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:46:35.250" starttime="20190401 12:46:35.250"></status>
</kw>
<msg timestamp="20190401 12:46:35.250" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:46:35.250" starttime="20190401 12:46:35.249"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:46:35.252" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:46:35.252" starttime="20190401 12:46:35.250"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:46:35.252" level="INFO">0</msg>
<msg timestamp="20190401 12:46:35.253" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:35.253" starttime="20190401 12:46:35.252"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:46:35.253" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:46:35.253" starttime="20190401 12:46:35.253"></status>
</kw>
<msg timestamp="20190401 12:46:35.253" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:35.253" starttime="20190401 12:46:35.250"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:35.254" starttime="20190401 12:46:35.254"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:35.254" starttime="20190401 12:46:35.253"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:35.254" starttime="20190401 12:46:35.254"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:46:35.254" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:46:35.255" starttime="20190401 12:46:35.254"></status>
</kw>
<msg timestamp="20190401 12:46:35.255" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:46:35.255" starttime="20190401 12:46:33.748"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:46:35.255" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:46:35.255" starttime="20190401 12:46:35.255"></status>
</kw>
<msg timestamp="20190401 12:46:35.255" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:46:35.255" starttime="20190401 12:46:33.747"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:46:35.256" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:46:35.256" starttime="20190401 12:46:35.255"></status>
</kw>
<status status="FAIL" endtime="20190401 12:46:35.256" starttime="20190401 12:46:33.747"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:46:40.257" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:40.257" starttime="20190401 12:46:40.257"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:40.258" starttime="20190401 12:46:40.258"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:46:40.259" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:46:40.259" starttime="20190401 12:46:40.258"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:40.259" starttime="20190401 12:46:40.259"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:40.259" starttime="20190401 12:46:40.259"></status>
</kw>
<msg timestamp="20190401 12:46:40.260" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:46:40.260" starttime="20190401 12:46:40.258"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:46:40.260" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:40.260" starttime="20190401 12:46:40.260"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:46:40.270" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:40.270" starttime="20190401 12:46:40.260"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:46:41.971" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:46:41.971" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:41.971" starttime="20190401 12:46:40.270"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:46:41.972" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:41.972" starttime="20190401 12:46:41.972"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:46:41.972" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:46:41.972" starttime="20190401 12:46:41.972"></status>
</kw>
<msg timestamp="20190401 12:46:41.972" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:46:41.972" starttime="20190401 12:46:41.971"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:46:41.975" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:46:41.975" starttime="20190401 12:46:41.973"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:46:41.976" level="INFO">0</msg>
<msg timestamp="20190401 12:46:41.976" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:41.976" starttime="20190401 12:46:41.975"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:46:41.976" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:46:41.976" starttime="20190401 12:46:41.976"></status>
</kw>
<msg timestamp="20190401 12:46:41.976" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:41.976" starttime="20190401 12:46:41.972"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:41.977" starttime="20190401 12:46:41.977"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:41.977" starttime="20190401 12:46:41.977"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:41.978" starttime="20190401 12:46:41.977"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:46:41.978" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:46:41.978" starttime="20190401 12:46:41.978"></status>
</kw>
<msg timestamp="20190401 12:46:41.978" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:46:41.978" starttime="20190401 12:46:40.257"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:46:41.978" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:46:41.978" starttime="20190401 12:46:41.978"></status>
</kw>
<msg timestamp="20190401 12:46:41.979" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:46:41.979" starttime="20190401 12:46:40.257"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:46:41.979" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:46:41.979" starttime="20190401 12:46:41.979"></status>
</kw>
<status status="FAIL" endtime="20190401 12:46:41.979" starttime="20190401 12:46:40.256"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:46:46.981" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:46.981" starttime="20190401 12:46:46.980"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:46.981" starttime="20190401 12:46:46.981"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:46:46.982" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:46:46.982" starttime="20190401 12:46:46.982"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:46.983" starttime="20190401 12:46:46.982"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:46.983" starttime="20190401 12:46:46.983"></status>
</kw>
<msg timestamp="20190401 12:46:46.983" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:46:46.983" starttime="20190401 12:46:46.982"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:46:46.983" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:46.984" starttime="20190401 12:46:46.983"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:46:46.997" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:46.997" starttime="20190401 12:46:46.984"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:46:48.065" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:46:48.065" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:48.065" starttime="20190401 12:46:46.997"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:46:48.066" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:48.066" starttime="20190401 12:46:48.066"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:46:48.066" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:46:48.066" starttime="20190401 12:46:48.066"></status>
</kw>
<msg timestamp="20190401 12:46:48.066" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:46:48.066" starttime="20190401 12:46:48.065"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:46:48.069" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:46:48.069" starttime="20190401 12:46:48.067"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:46:48.069" level="INFO">0</msg>
<msg timestamp="20190401 12:46:48.070" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:48.070" starttime="20190401 12:46:48.069"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:46:48.070" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:46:48.070" starttime="20190401 12:46:48.070"></status>
</kw>
<msg timestamp="20190401 12:46:48.070" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:48.070" starttime="20190401 12:46:48.066"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:48.071" starttime="20190401 12:46:48.071"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:48.071" starttime="20190401 12:46:48.070"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:48.071" starttime="20190401 12:46:48.071"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:46:48.072" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:46:48.072" starttime="20190401 12:46:48.071"></status>
</kw>
<msg timestamp="20190401 12:46:48.072" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:46:48.072" starttime="20190401 12:46:46.981"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:46:48.072" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:46:48.072" starttime="20190401 12:46:48.072"></status>
</kw>
<msg timestamp="20190401 12:46:48.072" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:46:48.072" starttime="20190401 12:46:46.980"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:46:48.073" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:46:48.073" starttime="20190401 12:46:48.073"></status>
</kw>
<status status="FAIL" endtime="20190401 12:46:48.073" starttime="20190401 12:46:46.980"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:46:53.075" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:53.075" starttime="20190401 12:46:53.075"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:53.076" starttime="20190401 12:46:53.076"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:46:53.078" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:46:53.078" starttime="20190401 12:46:53.077"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:53.078" starttime="20190401 12:46:53.078"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:53.079" starttime="20190401 12:46:53.078"></status>
</kw>
<msg timestamp="20190401 12:46:53.079" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:46:53.079" starttime="20190401 12:46:53.077"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:46:53.080" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:53.080" starttime="20190401 12:46:53.080"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:46:53.095" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:53.095" starttime="20190401 12:46:53.080"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:46:54.284" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:46:54.284" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:54.285" starttime="20190401 12:46:53.095"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:46:54.285" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:54.285" starttime="20190401 12:46:54.285"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:46:54.286" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:46:54.286" starttime="20190401 12:46:54.285"></status>
</kw>
<msg timestamp="20190401 12:46:54.286" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:46:54.286" starttime="20190401 12:46:54.285"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:46:54.288" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:46:54.288" starttime="20190401 12:46:54.286"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:46:54.288" level="INFO">0</msg>
<msg timestamp="20190401 12:46:54.288" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:54.288" starttime="20190401 12:46:54.288"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:46:54.289" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:46:54.289" starttime="20190401 12:46:54.289"></status>
</kw>
<msg timestamp="20190401 12:46:54.289" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:46:54.289" starttime="20190401 12:46:54.286"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:54.290" starttime="20190401 12:46:54.290"></status>
</kw>
<status status="PASS" endtime="20190401 12:46:54.290" starttime="20190401 12:46:54.289"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:54.291" starttime="20190401 12:46:54.290"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:46:54.291" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:46:54.291" starttime="20190401 12:46:54.291"></status>
</kw>
<msg timestamp="20190401 12:46:54.291" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:46:54.291" starttime="20190401 12:46:53.075"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:46:54.292" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:46:54.292" starttime="20190401 12:46:54.292"></status>
</kw>
<msg timestamp="20190401 12:46:54.292" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:46:54.292" starttime="20190401 12:46:53.074"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:46:54.293" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:46:54.293" starttime="20190401 12:46:54.292"></status>
</kw>
<status status="FAIL" endtime="20190401 12:46:54.293" starttime="20190401 12:46:53.073"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:46:59.294" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:59.294" starttime="20190401 12:46:59.294"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:59.295" starttime="20190401 12:46:59.295"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:46:59.296" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:46:59.296" starttime="20190401 12:46:59.295"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:59.296" starttime="20190401 12:46:59.296"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:46:59.296" starttime="20190401 12:46:59.296"></status>
</kw>
<msg timestamp="20190401 12:46:59.297" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:46:59.297" starttime="20190401 12:46:59.295"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:46:59.297" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:46:59.297" starttime="20190401 12:46:59.297"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:46:59.310" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:46:59.310" starttime="20190401 12:46:59.297"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:47:00.339" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:47:00.339" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:00.339" starttime="20190401 12:46:59.310"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:47:00.340" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:00.340" starttime="20190401 12:47:00.340"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:47:00.341" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:47:00.341" starttime="20190401 12:47:00.340"></status>
</kw>
<msg timestamp="20190401 12:47:00.341" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:47:00.341" starttime="20190401 12:47:00.340"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:47:00.343" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:47:00.343" starttime="20190401 12:47:00.341"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:47:00.343" level="INFO">0</msg>
<msg timestamp="20190401 12:47:00.343" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:00.343" starttime="20190401 12:47:00.343"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:47:00.344" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:47:00.344" starttime="20190401 12:47:00.343"></status>
</kw>
<msg timestamp="20190401 12:47:00.344" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:00.344" starttime="20190401 12:47:00.341"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:00.345" starttime="20190401 12:47:00.344"></status>
</kw>
<status status="PASS" endtime="20190401 12:47:00.345" starttime="20190401 12:47:00.344"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:00.345" starttime="20190401 12:47:00.345"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:47:00.345" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:47:00.345" starttime="20190401 12:47:00.345"></status>
</kw>
<msg timestamp="20190401 12:47:00.345" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:47:00.345" starttime="20190401 12:46:59.294"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:47:00.346" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:47:00.346" starttime="20190401 12:47:00.346"></status>
</kw>
<msg timestamp="20190401 12:47:00.346" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:47:00.346" starttime="20190401 12:46:59.294"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:47:00.347" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:47:00.347" starttime="20190401 12:47:00.346"></status>
</kw>
<status status="FAIL" endtime="20190401 12:47:00.347" starttime="20190401 12:46:59.293"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:47:05.348" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:05.348" starttime="20190401 12:47:05.348"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:05.349" starttime="20190401 12:47:05.349"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:47:05.350" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:47:05.350" starttime="20190401 12:47:05.349"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:05.350" starttime="20190401 12:47:05.350"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:05.350" starttime="20190401 12:47:05.350"></status>
</kw>
<msg timestamp="20190401 12:47:05.351" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:47:05.351" starttime="20190401 12:47:05.349"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:47:05.351" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:05.351" starttime="20190401 12:47:05.351"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:47:05.362" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:05.362" starttime="20190401 12:47:05.351"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:47:06.334" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:47:06.334" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:06.334" starttime="20190401 12:47:05.362"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:47:06.335" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:06.335" starttime="20190401 12:47:06.334"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:47:06.335" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:47:06.335" starttime="20190401 12:47:06.335"></status>
</kw>
<msg timestamp="20190401 12:47:06.335" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:47:06.335" starttime="20190401 12:47:06.334"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:47:06.336" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:47:06.336" starttime="20190401 12:47:06.336"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:47:06.337" level="INFO">0</msg>
<msg timestamp="20190401 12:47:06.337" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:06.337" starttime="20190401 12:47:06.336"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:47:06.338" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:47:06.338" starttime="20190401 12:47:06.337"></status>
</kw>
<msg timestamp="20190401 12:47:06.338" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:06.338" starttime="20190401 12:47:06.335"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:06.338" starttime="20190401 12:47:06.338"></status>
</kw>
<status status="PASS" endtime="20190401 12:47:06.339" starttime="20190401 12:47:06.338"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:06.339" starttime="20190401 12:47:06.339"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:47:06.339" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:47:06.339" starttime="20190401 12:47:06.339"></status>
</kw>
<msg timestamp="20190401 12:47:06.339" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:47:06.339" starttime="20190401 12:47:05.348"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:47:06.340" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:47:06.340" starttime="20190401 12:47:06.339"></status>
</kw>
<msg timestamp="20190401 12:47:06.340" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:47:06.340" starttime="20190401 12:47:05.348"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:47:06.340" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:47:06.340" starttime="20190401 12:47:06.340"></status>
</kw>
<status status="FAIL" endtime="20190401 12:47:06.341" starttime="20190401 12:47:05.347"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:47:11.343" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:11.343" starttime="20190401 12:47:11.342"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:11.343" starttime="20190401 12:47:11.343"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:47:11.344" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:47:11.344" starttime="20190401 12:47:11.344"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:11.345" starttime="20190401 12:47:11.344"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:11.345" starttime="20190401 12:47:11.345"></status>
</kw>
<msg timestamp="20190401 12:47:11.345" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:47:11.345" starttime="20190401 12:47:11.344"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:47:11.346" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:11.346" starttime="20190401 12:47:11.345"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:47:11.348" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:11.348" starttime="20190401 12:47:11.346"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:47:12.362" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:47:12.362" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:12.362" starttime="20190401 12:47:11.348"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:47:12.363" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:12.363" starttime="20190401 12:47:12.363"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:47:12.364" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:47:12.364" starttime="20190401 12:47:12.363"></status>
</kw>
<msg timestamp="20190401 12:47:12.364" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:47:12.364" starttime="20190401 12:47:12.363"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:47:12.366" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:47:12.366" starttime="20190401 12:47:12.364"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:47:12.366" level="INFO">0</msg>
<msg timestamp="20190401 12:47:12.366" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:12.366" starttime="20190401 12:47:12.366"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:47:12.367" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:47:12.367" starttime="20190401 12:47:12.367"></status>
</kw>
<msg timestamp="20190401 12:47:12.367" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:12.367" starttime="20190401 12:47:12.364"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:12.368" starttime="20190401 12:47:12.367"></status>
</kw>
<status status="PASS" endtime="20190401 12:47:12.368" starttime="20190401 12:47:12.367"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:12.368" starttime="20190401 12:47:12.368"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:47:12.368" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:47:12.368" starttime="20190401 12:47:12.368"></status>
</kw>
<msg timestamp="20190401 12:47:12.369" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:47:12.369" starttime="20190401 12:47:11.343"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:47:12.369" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:47:12.369" starttime="20190401 12:47:12.369"></status>
</kw>
<msg timestamp="20190401 12:47:12.369" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:47:12.369" starttime="20190401 12:47:11.341"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:47:12.370" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:47:12.370" starttime="20190401 12:47:12.369"></status>
</kw>
<status status="FAIL" endtime="20190401 12:47:12.370" starttime="20190401 12:47:11.341"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:47:17.371" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:17.371" starttime="20190401 12:47:17.371"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:17.372" starttime="20190401 12:47:17.372"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:47:17.373" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:47:17.373" starttime="20190401 12:47:17.372"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:17.373" starttime="20190401 12:47:17.373"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:17.374" starttime="20190401 12:47:17.373"></status>
</kw>
<msg timestamp="20190401 12:47:17.374" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:47:17.374" starttime="20190401 12:47:17.372"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:47:17.374" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:17.374" starttime="20190401 12:47:17.374"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:47:17.383" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:17.383" starttime="20190401 12:47:17.374"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:47:18.366" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:47:18.366" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:18.366" starttime="20190401 12:47:17.384"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:47:18.367" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:18.367" starttime="20190401 12:47:18.367"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:47:18.367" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:47:18.367" starttime="20190401 12:47:18.367"></status>
</kw>
<msg timestamp="20190401 12:47:18.368" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:47:18.368" starttime="20190401 12:47:18.366"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:47:18.370" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:47:18.370" starttime="20190401 12:47:18.368"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:47:18.370" level="INFO">0</msg>
<msg timestamp="20190401 12:47:18.370" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:18.370" starttime="20190401 12:47:18.370"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:47:18.370" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:47:18.371" starttime="20190401 12:47:18.370"></status>
</kw>
<msg timestamp="20190401 12:47:18.371" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:18.371" starttime="20190401 12:47:18.368"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:18.371" starttime="20190401 12:47:18.371"></status>
</kw>
<status status="PASS" endtime="20190401 12:47:18.372" starttime="20190401 12:47:18.371"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:18.372" starttime="20190401 12:47:18.372"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:47:18.372" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:47:18.372" starttime="20190401 12:47:18.372"></status>
</kw>
<msg timestamp="20190401 12:47:18.372" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:47:18.372" starttime="20190401 12:47:17.372"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:47:18.373" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:47:18.373" starttime="20190401 12:47:18.372"></status>
</kw>
<msg timestamp="20190401 12:47:18.373" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:47:18.373" starttime="20190401 12:47:17.371"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:47:18.373" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:47:18.373" starttime="20190401 12:47:18.373"></status>
</kw>
<status status="FAIL" endtime="20190401 12:47:18.373" starttime="20190401 12:47:17.370"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:47:23.375" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:23.375" starttime="20190401 12:47:23.375"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:23.376" starttime="20190401 12:47:23.375"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:47:23.377" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:47:23.377" starttime="20190401 12:47:23.376"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:23.377" starttime="20190401 12:47:23.377"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:23.377" starttime="20190401 12:47:23.377"></status>
</kw>
<msg timestamp="20190401 12:47:23.378" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:47:23.378" starttime="20190401 12:47:23.376"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:47:23.378" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:23.378" starttime="20190401 12:47:23.378"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:47:23.388" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:23.388" starttime="20190401 12:47:23.378"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:47:24.564" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:47:24.564" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:24.564" starttime="20190401 12:47:23.388"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:47:24.565" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:24.565" starttime="20190401 12:47:24.565"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:47:24.566" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:47:24.566" starttime="20190401 12:47:24.565"></status>
</kw>
<msg timestamp="20190401 12:47:24.566" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:47:24.566" starttime="20190401 12:47:24.565"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:47:24.568" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:47:24.568" starttime="20190401 12:47:24.566"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:47:24.568" level="INFO">0</msg>
<msg timestamp="20190401 12:47:24.568" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:24.568" starttime="20190401 12:47:24.568"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:47:24.568" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:47:24.568" starttime="20190401 12:47:24.568"></status>
</kw>
<msg timestamp="20190401 12:47:24.569" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:24.569" starttime="20190401 12:47:24.566"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:24.569" starttime="20190401 12:47:24.569"></status>
</kw>
<status status="PASS" endtime="20190401 12:47:24.569" starttime="20190401 12:47:24.569"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:24.570" starttime="20190401 12:47:24.570"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:47:24.570" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:47:24.570" starttime="20190401 12:47:24.570"></status>
</kw>
<msg timestamp="20190401 12:47:24.570" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:47:24.570" starttime="20190401 12:47:23.375"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:47:24.571" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:47:24.571" starttime="20190401 12:47:24.570"></status>
</kw>
<msg timestamp="20190401 12:47:24.571" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:47:24.571" starttime="20190401 12:47:23.374"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:47:24.571" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:47:24.571" starttime="20190401 12:47:24.571"></status>
</kw>
<status status="FAIL" endtime="20190401 12:47:24.571" starttime="20190401 12:47:23.374"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:47:29.573" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:29.573" starttime="20190401 12:47:29.573"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:29.574" starttime="20190401 12:47:29.573"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:47:29.575" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:47:29.575" starttime="20190401 12:47:29.574"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:29.575" starttime="20190401 12:47:29.575"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:29.575" starttime="20190401 12:47:29.575"></status>
</kw>
<msg timestamp="20190401 12:47:29.576" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:47:29.576" starttime="20190401 12:47:29.574"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:47:29.576" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:29.576" starttime="20190401 12:47:29.576"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:47:29.586" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:29.586" starttime="20190401 12:47:29.576"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:47:30.616" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:47:30.616" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:30.616" starttime="20190401 12:47:29.587"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:47:30.617" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:30.617" starttime="20190401 12:47:30.616"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:47:30.617" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:47:30.617" starttime="20190401 12:47:30.617"></status>
</kw>
<msg timestamp="20190401 12:47:30.617" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:47:30.617" starttime="20190401 12:47:30.616"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:47:30.619" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:47:30.619" starttime="20190401 12:47:30.618"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:47:30.619" level="INFO">0</msg>
<msg timestamp="20190401 12:47:30.620" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:30.620" starttime="20190401 12:47:30.619"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:47:30.620" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:47:30.620" starttime="20190401 12:47:30.620"></status>
</kw>
<msg timestamp="20190401 12:47:30.620" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:30.620" starttime="20190401 12:47:30.617"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:30.621" starttime="20190401 12:47:30.621"></status>
</kw>
<status status="PASS" endtime="20190401 12:47:30.621" starttime="20190401 12:47:30.620"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:30.621" starttime="20190401 12:47:30.621"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:47:30.622" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:47:30.622" starttime="20190401 12:47:30.621"></status>
</kw>
<msg timestamp="20190401 12:47:30.622" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:47:30.622" starttime="20190401 12:47:29.573"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:47:30.622" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:47:30.622" starttime="20190401 12:47:30.622"></status>
</kw>
<msg timestamp="20190401 12:47:30.622" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:47:30.622" starttime="20190401 12:47:29.572"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:47:30.623" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:47:30.623" starttime="20190401 12:47:30.622"></status>
</kw>
<status status="FAIL" endtime="20190401 12:47:30.623" starttime="20190401 12:47:29.572"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:47:35.624" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:35.625" starttime="20190401 12:47:35.624"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:35.625" starttime="20190401 12:47:35.625"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:47:35.626" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:47:35.626" starttime="20190401 12:47:35.626"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:35.626" starttime="20190401 12:47:35.626"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:35.627" starttime="20190401 12:47:35.626"></status>
</kw>
<msg timestamp="20190401 12:47:35.627" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:47:35.627" starttime="20190401 12:47:35.625"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:47:35.627" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:35.627" starttime="20190401 12:47:35.627"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:47:35.636" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:35.636" starttime="20190401 12:47:35.628"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:47:36.679" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:47:36.680" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:36.680" starttime="20190401 12:47:35.636"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:47:36.681" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:36.681" starttime="20190401 12:47:36.680"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:47:36.681" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:47:36.681" starttime="20190401 12:47:36.681"></status>
</kw>
<msg timestamp="20190401 12:47:36.681" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:47:36.681" starttime="20190401 12:47:36.680"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:47:36.683" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:47:36.683" starttime="20190401 12:47:36.681"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:47:36.683" level="INFO">0</msg>
<msg timestamp="20190401 12:47:36.683" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:36.683" starttime="20190401 12:47:36.683"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:47:36.684" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:47:36.684" starttime="20190401 12:47:36.684"></status>
</kw>
<msg timestamp="20190401 12:47:36.684" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:36.684" starttime="20190401 12:47:36.681"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:36.685" starttime="20190401 12:47:36.684"></status>
</kw>
<status status="PASS" endtime="20190401 12:47:36.685" starttime="20190401 12:47:36.684"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:36.685" starttime="20190401 12:47:36.685"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:47:36.685" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:47:36.685" starttime="20190401 12:47:36.685"></status>
</kw>
<msg timestamp="20190401 12:47:36.686" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:47:36.686" starttime="20190401 12:47:35.625"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:47:36.686" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:47:36.686" starttime="20190401 12:47:36.686"></status>
</kw>
<msg timestamp="20190401 12:47:36.686" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:47:36.686" starttime="20190401 12:47:35.624"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:47:36.687" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:47:36.687" starttime="20190401 12:47:36.686"></status>
</kw>
<status status="FAIL" endtime="20190401 12:47:36.687" starttime="20190401 12:47:35.623"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:47:41.688" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:41.688" starttime="20190401 12:47:41.688"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:41.689" starttime="20190401 12:47:41.689"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:47:41.690" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:47:41.690" starttime="20190401 12:47:41.689"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:41.690" starttime="20190401 12:47:41.690"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:41.691" starttime="20190401 12:47:41.690"></status>
</kw>
<msg timestamp="20190401 12:47:41.691" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:47:41.691" starttime="20190401 12:47:41.689"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:47:41.691" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:41.691" starttime="20190401 12:47:41.691"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:47:41.703" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:41.703" starttime="20190401 12:47:41.691"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:47:42.908" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:47:42.908" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:42.908" starttime="20190401 12:47:41.703"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:47:42.909" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:42.909" starttime="20190401 12:47:42.909"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:47:42.910" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:47:42.910" starttime="20190401 12:47:42.909"></status>
</kw>
<msg timestamp="20190401 12:47:42.910" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:47:42.910" starttime="20190401 12:47:42.909"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:47:42.912" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:47:42.912" starttime="20190401 12:47:42.910"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:47:42.912" level="INFO">0</msg>
<msg timestamp="20190401 12:47:42.912" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:42.912" starttime="20190401 12:47:42.912"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:47:42.913" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:47:42.913" starttime="20190401 12:47:42.913"></status>
</kw>
<msg timestamp="20190401 12:47:42.913" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:42.913" starttime="20190401 12:47:42.910"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:42.914" starttime="20190401 12:47:42.913"></status>
</kw>
<status status="PASS" endtime="20190401 12:47:42.914" starttime="20190401 12:47:42.913"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:42.914" starttime="20190401 12:47:42.914"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:47:42.914" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:47:42.914" starttime="20190401 12:47:42.914"></status>
</kw>
<msg timestamp="20190401 12:47:42.914" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:47:42.914" starttime="20190401 12:47:41.688"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:47:42.915" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:47:42.915" starttime="20190401 12:47:42.915"></status>
</kw>
<msg timestamp="20190401 12:47:42.915" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:47:42.915" starttime="20190401 12:47:41.688"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:47:42.915" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:47:42.916" starttime="20190401 12:47:42.915"></status>
</kw>
<status status="FAIL" endtime="20190401 12:47:42.916" starttime="20190401 12:47:41.687"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:47:47.917" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:47.917" starttime="20190401 12:47:47.917"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:47.918" starttime="20190401 12:47:47.918"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:47:47.918" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:47:47.919" starttime="20190401 12:47:47.918"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:47.919" starttime="20190401 12:47:47.919"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:47.919" starttime="20190401 12:47:47.919"></status>
</kw>
<msg timestamp="20190401 12:47:47.920" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:47:47.920" starttime="20190401 12:47:47.918"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:47:47.920" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:47.920" starttime="20190401 12:47:47.920"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:47:47.935" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:47.935" starttime="20190401 12:47:47.920"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:47:48.989" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:47:48.989" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:48.989" starttime="20190401 12:47:47.935"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:47:48.990" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:48.990" starttime="20190401 12:47:48.989"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:47:48.990" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:47:48.990" starttime="20190401 12:47:48.990"></status>
</kw>
<msg timestamp="20190401 12:47:48.990" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:47:48.990" starttime="20190401 12:47:48.989"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:47:48.992" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:47:48.992" starttime="20190401 12:47:48.991"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:47:48.993" level="INFO">0</msg>
<msg timestamp="20190401 12:47:48.993" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:48.993" starttime="20190401 12:47:48.992"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:47:48.993" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:47:48.993" starttime="20190401 12:47:48.993"></status>
</kw>
<msg timestamp="20190401 12:47:48.993" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:48.993" starttime="20190401 12:47:48.991"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:48.994" starttime="20190401 12:47:48.994"></status>
</kw>
<status status="PASS" endtime="20190401 12:47:48.994" starttime="20190401 12:47:48.993"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:48.994" starttime="20190401 12:47:48.994"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:47:48.995" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:47:48.995" starttime="20190401 12:47:48.994"></status>
</kw>
<msg timestamp="20190401 12:47:48.995" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:47:48.995" starttime="20190401 12:47:47.917"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:47:48.995" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:47:48.995" starttime="20190401 12:47:48.995"></status>
</kw>
<msg timestamp="20190401 12:47:48.995" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:47:48.995" starttime="20190401 12:47:47.916"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:47:48.996" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:47:48.996" starttime="20190401 12:47:48.996"></status>
</kw>
<status status="FAIL" endtime="20190401 12:47:48.996" starttime="20190401 12:47:47.916"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:47:53.997" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:53.997" starttime="20190401 12:47:53.997"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:53.998" starttime="20190401 12:47:53.998"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:47:53.999" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:47:53.999" starttime="20190401 12:47:53.998"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:53.999" starttime="20190401 12:47:53.999"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:54.000" starttime="20190401 12:47:53.999"></status>
</kw>
<msg timestamp="20190401 12:47:54.000" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:47:54.000" starttime="20190401 12:47:53.998"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:47:54.000" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:54.000" starttime="20190401 12:47:54.000"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:47:54.009" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:47:54.009" starttime="20190401 12:47:54.000"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:47:55.198" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:47:55.199" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:55.199" starttime="20190401 12:47:54.009"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:47:55.199" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:47:55.199" starttime="20190401 12:47:55.199"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:47:55.200" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:47:55.200" starttime="20190401 12:47:55.200"></status>
</kw>
<msg timestamp="20190401 12:47:55.200" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:47:55.200" starttime="20190401 12:47:55.199"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:47:55.202" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:47:55.202" starttime="20190401 12:47:55.200"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:47:55.203" level="INFO">0</msg>
<msg timestamp="20190401 12:47:55.203" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:55.203" starttime="20190401 12:47:55.202"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:47:55.203" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:47:55.203" starttime="20190401 12:47:55.203"></status>
</kw>
<msg timestamp="20190401 12:47:55.203" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:47:55.203" starttime="20190401 12:47:55.200"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:55.204" starttime="20190401 12:47:55.204"></status>
</kw>
<status status="PASS" endtime="20190401 12:47:55.204" starttime="20190401 12:47:55.203"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:47:55.204" starttime="20190401 12:47:55.204"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:47:55.205" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:47:55.205" starttime="20190401 12:47:55.204"></status>
</kw>
<msg timestamp="20190401 12:47:55.205" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:47:55.205" starttime="20190401 12:47:53.998"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:47:55.205" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:47:55.205" starttime="20190401 12:47:55.205"></status>
</kw>
<msg timestamp="20190401 12:47:55.205" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:47:55.205" starttime="20190401 12:47:53.997"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:47:55.206" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:47:55.206" starttime="20190401 12:47:55.205"></status>
</kw>
<status status="FAIL" endtime="20190401 12:47:55.206" starttime="20190401 12:47:53.996"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:48:00.207" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:00.207" starttime="20190401 12:48:00.207"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:00.208" starttime="20190401 12:48:00.208"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:48:00.209" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:48:00.209" starttime="20190401 12:48:00.208"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:00.209" starttime="20190401 12:48:00.209"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:00.210" starttime="20190401 12:48:00.209"></status>
</kw>
<msg timestamp="20190401 12:48:00.210" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:48:00.210" starttime="20190401 12:48:00.208"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:48:00.210" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:00.210" starttime="20190401 12:48:00.210"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:48:00.220" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:00.220" starttime="20190401 12:48:00.210"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:48:01.315" level="INFO">None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:48:01.316" level="INFO">${output} = None
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:01.316" starttime="20190401 12:48:00.220"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:48:01.316" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:01.317" starttime="20190401 12:48:01.316"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:48:01.317" level="INFO">${clean_out} = None
</msg>
<status status="PASS" endtime="20190401 12:48:01.317" starttime="20190401 12:48:01.317"></status>
</kw>
<msg timestamp="20190401 12:48:01.317" level="INFO">${output} = None
</msg>
<status status="PASS" endtime="20190401 12:48:01.317" starttime="20190401 12:48:01.316"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:48:01.319" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:48:01.319" starttime="20190401 12:48:01.317"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:48:01.319" level="INFO">0</msg>
<msg timestamp="20190401 12:48:01.319" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:01.319" starttime="20190401 12:48:01.319"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:48:01.320" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:48:01.320" starttime="20190401 12:48:01.320"></status>
</kw>
<msg timestamp="20190401 12:48:01.320" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:01.320" starttime="20190401 12:48:01.317"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:01.321" starttime="20190401 12:48:01.320"></status>
</kw>
<status status="PASS" endtime="20190401 12:48:01.321" starttime="20190401 12:48:01.320"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:01.321" starttime="20190401 12:48:01.321"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:48:01.322" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: None</msg>
<status status="PASS" endtime="20190401 12:48:01.322" starttime="20190401 12:48:01.321"></status>
</kw>
<msg timestamp="20190401 12:48:01.322" level="INFO">${result} = {u'stdout': u'None', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:48:01.322" starttime="20190401 12:48:00.208"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:48:01.322" level="INFO">${value} = None</msg>
<status status="PASS" endtime="20190401 12:48:01.322" starttime="20190401 12:48:01.322"></status>
</kw>
<msg timestamp="20190401 12:48:01.322" level="INFO">${current_value} = None</msg>
<status status="PASS" endtime="20190401 12:48:01.322" starttime="20190401 12:48:00.207"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:48:01.323" level="FAIL">None != completed</msg>
<status status="FAIL" endtime="20190401 12:48:01.323" starttime="20190401 12:48:01.322"></status>
</kw>
<status status="FAIL" endtime="20190401 12:48:01.323" starttime="20190401 12:48:00.206"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:48:06.324" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:06.324" starttime="20190401 12:48:06.324"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:06.325" starttime="20190401 12:48:06.325"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:48:06.326" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:48:06.326" starttime="20190401 12:48:06.325"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:06.326" starttime="20190401 12:48:06.326"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:06.327" starttime="20190401 12:48:06.326"></status>
</kw>
<msg timestamp="20190401 12:48:06.327" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:48:06.327" starttime="20190401 12:48:06.325"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:48:06.327" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:06.327" starttime="20190401 12:48:06.327"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:48:06.337" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:06.337" starttime="20190401 12:48:06.327"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:48:07.570" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:48:07.571" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:07.571" starttime="20190401 12:48:06.337"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:48:07.571" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:07.571" starttime="20190401 12:48:07.571"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:48:07.572" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:07.572" starttime="20190401 12:48:07.572"></status>
</kw>
<msg timestamp="20190401 12:48:07.572" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:07.572" starttime="20190401 12:48:07.571"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:48:07.574" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:48:07.574" starttime="20190401 12:48:07.572"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:48:07.574" level="INFO">0</msg>
<msg timestamp="20190401 12:48:07.574" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:07.574" starttime="20190401 12:48:07.574"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:48:07.575" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:48:07.575" starttime="20190401 12:48:07.574"></status>
</kw>
<msg timestamp="20190401 12:48:07.575" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:07.575" starttime="20190401 12:48:07.572"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:07.576" starttime="20190401 12:48:07.575"></status>
</kw>
<status status="PASS" endtime="20190401 12:48:07.576" starttime="20190401 12:48:07.575"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:07.576" starttime="20190401 12:48:07.576"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:48:07.576" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190401 12:48:07.576" starttime="20190401 12:48:07.576"></status>
</kw>
<msg timestamp="20190401 12:48:07.576" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:48:07.576" starttime="20190401 12:48:06.324"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:48:07.577" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:07.577" starttime="20190401 12:48:07.577"></status>
</kw>
<msg timestamp="20190401 12:48:07.577" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:07.577" starttime="20190401 12:48:06.324"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:48:07.578" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:48:07.578" starttime="20190401 12:48:07.577"></status>
</kw>
<status status="FAIL" endtime="20190401 12:48:07.578" starttime="20190401 12:48:06.323"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:48:12.579" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:12.579" starttime="20190401 12:48:12.579"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:12.580" starttime="20190401 12:48:12.580"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:48:12.581" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:48:12.581" starttime="20190401 12:48:12.580"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:12.581" starttime="20190401 12:48:12.581"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:12.581" starttime="20190401 12:48:12.581"></status>
</kw>
<msg timestamp="20190401 12:48:12.582" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:48:12.582" starttime="20190401 12:48:12.580"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:48:12.582" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:12.582" starttime="20190401 12:48:12.582"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:48:12.593" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:12.593" starttime="20190401 12:48:12.582"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:48:13.650" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:48:13.650" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:13.651" starttime="20190401 12:48:12.593"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:48:13.651" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:13.651" starttime="20190401 12:48:13.651"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:48:13.652" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:13.652" starttime="20190401 12:48:13.651"></status>
</kw>
<msg timestamp="20190401 12:48:13.652" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:13.652" starttime="20190401 12:48:13.651"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:48:13.654" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:48:13.654" starttime="20190401 12:48:13.652"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:48:13.654" level="INFO">0</msg>
<msg timestamp="20190401 12:48:13.654" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:13.654" starttime="20190401 12:48:13.654"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:48:13.655" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:48:13.655" starttime="20190401 12:48:13.654"></status>
</kw>
<msg timestamp="20190401 12:48:13.655" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:13.655" starttime="20190401 12:48:13.652"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:13.656" starttime="20190401 12:48:13.655"></status>
</kw>
<status status="PASS" endtime="20190401 12:48:13.656" starttime="20190401 12:48:13.655"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:13.656" starttime="20190401 12:48:13.656"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:48:13.656" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190401 12:48:13.656" starttime="20190401 12:48:13.656"></status>
</kw>
<msg timestamp="20190401 12:48:13.656" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:48:13.656" starttime="20190401 12:48:12.579"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:48:13.657" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:13.657" starttime="20190401 12:48:13.656"></status>
</kw>
<msg timestamp="20190401 12:48:13.657" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:13.657" starttime="20190401 12:48:12.579"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:48:13.657" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:48:13.657" starttime="20190401 12:48:13.657"></status>
</kw>
<status status="FAIL" endtime="20190401 12:48:13.658" starttime="20190401 12:48:12.578"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:48:18.659" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:18.659" starttime="20190401 12:48:18.659"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:18.660" starttime="20190401 12:48:18.660"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:48:18.661" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:48:18.661" starttime="20190401 12:48:18.660"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:18.661" starttime="20190401 12:48:18.661"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:18.661" starttime="20190401 12:48:18.661"></status>
</kw>
<msg timestamp="20190401 12:48:18.662" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:48:18.662" starttime="20190401 12:48:18.660"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:48:18.662" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:18.662" starttime="20190401 12:48:18.662"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:48:18.672" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:18.672" starttime="20190401 12:48:18.662"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:48:19.837" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:48:19.837" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:19.837" starttime="20190401 12:48:18.672"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:48:19.838" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:19.838" starttime="20190401 12:48:19.838"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:48:19.838" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:19.838" starttime="20190401 12:48:19.838"></status>
</kw>
<msg timestamp="20190401 12:48:19.838" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:19.838" starttime="20190401 12:48:19.837"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:48:19.840" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:48:19.840" starttime="20190401 12:48:19.839"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:48:19.841" level="INFO">0</msg>
<msg timestamp="20190401 12:48:19.841" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:19.841" starttime="20190401 12:48:19.840"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:48:19.841" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:48:19.841" starttime="20190401 12:48:19.841"></status>
</kw>
<msg timestamp="20190401 12:48:19.841" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:19.841" starttime="20190401 12:48:19.838"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:19.842" starttime="20190401 12:48:19.842"></status>
</kw>
<status status="PASS" endtime="20190401 12:48:19.842" starttime="20190401 12:48:19.841"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:19.842" starttime="20190401 12:48:19.842"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:48:19.843" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190401 12:48:19.843" starttime="20190401 12:48:19.842"></status>
</kw>
<msg timestamp="20190401 12:48:19.843" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:48:19.843" starttime="20190401 12:48:18.659"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:48:19.843" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:19.843" starttime="20190401 12:48:19.843"></status>
</kw>
<msg timestamp="20190401 12:48:19.843" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:19.843" starttime="20190401 12:48:18.658"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:48:19.844" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:48:19.844" starttime="20190401 12:48:19.843"></status>
</kw>
<status status="FAIL" endtime="20190401 12:48:19.844" starttime="20190401 12:48:18.658"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:48:24.845" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:24.845" starttime="20190401 12:48:24.845"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:24.846" starttime="20190401 12:48:24.846"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:48:24.847" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:48:24.847" starttime="20190401 12:48:24.847"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:24.847" starttime="20190401 12:48:24.847"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:24.848" starttime="20190401 12:48:24.848"></status>
</kw>
<msg timestamp="20190401 12:48:24.848" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:48:24.848" starttime="20190401 12:48:24.846"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:48:24.848" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:24.848" starttime="20190401 12:48:24.848"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:48:24.857" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:24.857" starttime="20190401 12:48:24.849"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:48:25.923" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:48:25.923" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:25.923" starttime="20190401 12:48:24.857"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:48:25.924" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:25.924" starttime="20190401 12:48:25.924"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:48:25.924" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:25.924" starttime="20190401 12:48:25.924"></status>
</kw>
<msg timestamp="20190401 12:48:25.925" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:25.925" starttime="20190401 12:48:25.924"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:48:25.926" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:48:25.926" starttime="20190401 12:48:25.925"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:48:25.927" level="INFO">0</msg>
<msg timestamp="20190401 12:48:25.927" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:25.927" starttime="20190401 12:48:25.927"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:48:25.927" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:48:25.927" starttime="20190401 12:48:25.927"></status>
</kw>
<msg timestamp="20190401 12:48:25.927" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:25.927" starttime="20190401 12:48:25.925"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:25.928" starttime="20190401 12:48:25.928"></status>
</kw>
<status status="PASS" endtime="20190401 12:48:25.928" starttime="20190401 12:48:25.928"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:25.928" starttime="20190401 12:48:25.928"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:48:25.929" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190401 12:48:25.929" starttime="20190401 12:48:25.929"></status>
</kw>
<msg timestamp="20190401 12:48:25.929" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:48:25.929" starttime="20190401 12:48:24.845"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:48:25.929" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:25.929" starttime="20190401 12:48:25.929"></status>
</kw>
<msg timestamp="20190401 12:48:25.929" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:25.930" starttime="20190401 12:48:24.845"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:48:25.930" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:48:25.930" starttime="20190401 12:48:25.930"></status>
</kw>
<status status="FAIL" endtime="20190401 12:48:25.930" starttime="20190401 12:48:24.844"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:48:30.932" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:30.932" starttime="20190401 12:48:30.931"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:30.932" starttime="20190401 12:48:30.932"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:48:30.934" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:48:30.934" starttime="20190401 12:48:30.933"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:30.934" starttime="20190401 12:48:30.934"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:30.934" starttime="20190401 12:48:30.934"></status>
</kw>
<msg timestamp="20190401 12:48:30.935" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:48:30.935" starttime="20190401 12:48:30.932"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:48:30.935" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:30.935" starttime="20190401 12:48:30.935"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:48:30.944" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:30.944" starttime="20190401 12:48:30.935"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:48:32.014" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:48:32.014" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:32.014" starttime="20190401 12:48:30.944"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:48:32.015" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:32.015" starttime="20190401 12:48:32.015"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:48:32.015" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:32.015" starttime="20190401 12:48:32.015"></status>
</kw>
<msg timestamp="20190401 12:48:32.016" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:32.016" starttime="20190401 12:48:32.015"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:48:32.018" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:48:32.018" starttime="20190401 12:48:32.016"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:48:32.018" level="INFO">0</msg>
<msg timestamp="20190401 12:48:32.018" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:32.018" starttime="20190401 12:48:32.018"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:48:32.019" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:48:32.019" starttime="20190401 12:48:32.018"></status>
</kw>
<msg timestamp="20190401 12:48:32.019" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:32.019" starttime="20190401 12:48:32.016"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:32.020" starttime="20190401 12:48:32.019"></status>
</kw>
<status status="PASS" endtime="20190401 12:48:32.020" starttime="20190401 12:48:32.019"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:32.020" starttime="20190401 12:48:32.020"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:48:32.020" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190401 12:48:32.020" starttime="20190401 12:48:32.020"></status>
</kw>
<msg timestamp="20190401 12:48:32.020" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:48:32.020" starttime="20190401 12:48:30.932"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:48:32.021" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:32.021" starttime="20190401 12:48:32.021"></status>
</kw>
<msg timestamp="20190401 12:48:32.021" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:32.021" starttime="20190401 12:48:30.931"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:48:32.021" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:48:32.022" starttime="20190401 12:48:32.021"></status>
</kw>
<status status="FAIL" endtime="20190401 12:48:32.022" starttime="20190401 12:48:30.930"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:48:37.023" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:37.023" starttime="20190401 12:48:37.023"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:37.024" starttime="20190401 12:48:37.024"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:48:37.041" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:48:37.041" starttime="20190401 12:48:37.024"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:37.041" starttime="20190401 12:48:37.041"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:37.042" starttime="20190401 12:48:37.041"></status>
</kw>
<msg timestamp="20190401 12:48:37.042" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:48:37.042" starttime="20190401 12:48:37.024"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:48:37.042" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:37.042" starttime="20190401 12:48:37.042"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:48:37.057" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:37.057" starttime="20190401 12:48:37.042"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:48:38.072" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:48:38.072" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:38.072" starttime="20190401 12:48:37.057"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:48:38.073" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:38.073" starttime="20190401 12:48:38.072"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:48:38.073" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:38.073" starttime="20190401 12:48:38.073"></status>
</kw>
<msg timestamp="20190401 12:48:38.073" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:38.073" starttime="20190401 12:48:38.072"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:48:38.075" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:48:38.075" starttime="20190401 12:48:38.073"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:48:38.076" level="INFO">0</msg>
<msg timestamp="20190401 12:48:38.076" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:38.076" starttime="20190401 12:48:38.076"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:48:38.076" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:48:38.076" starttime="20190401 12:48:38.076"></status>
</kw>
<msg timestamp="20190401 12:48:38.076" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:38.077" starttime="20190401 12:48:38.073"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:38.077" starttime="20190401 12:48:38.077"></status>
</kw>
<status status="PASS" endtime="20190401 12:48:38.077" starttime="20190401 12:48:38.077"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:38.078" starttime="20190401 12:48:38.077"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:48:38.078" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190401 12:48:38.078" starttime="20190401 12:48:38.078"></status>
</kw>
<msg timestamp="20190401 12:48:38.078" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:48:38.078" starttime="20190401 12:48:37.023"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:48:38.078" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:38.078" starttime="20190401 12:48:38.078"></status>
</kw>
<msg timestamp="20190401 12:48:38.079" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:38.079" starttime="20190401 12:48:37.022"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:48:38.079" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:48:38.079" starttime="20190401 12:48:38.079"></status>
</kw>
<status status="FAIL" endtime="20190401 12:48:38.079" starttime="20190401 12:48:37.022"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:48:43.081" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:43.081" starttime="20190401 12:48:43.080"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:43.081" starttime="20190401 12:48:43.081"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:48:43.082" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:48:43.082" starttime="20190401 12:48:43.082"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:43.083" starttime="20190401 12:48:43.083"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:43.083" starttime="20190401 12:48:43.083"></status>
</kw>
<msg timestamp="20190401 12:48:43.083" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:48:43.083" starttime="20190401 12:48:43.082"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:48:43.084" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:43.084" starttime="20190401 12:48:43.084"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:48:43.086" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:43.086" starttime="20190401 12:48:43.084"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:48:44.098" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:48:44.098" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:44.099" starttime="20190401 12:48:43.086"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:48:44.099" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:44.099" starttime="20190401 12:48:44.099"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:48:44.100" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:44.100" starttime="20190401 12:48:44.099"></status>
</kw>
<msg timestamp="20190401 12:48:44.100" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:44.100" starttime="20190401 12:48:44.099"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:48:44.102" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:48:44.102" starttime="20190401 12:48:44.100"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:48:44.104" level="INFO">0</msg>
<msg timestamp="20190401 12:48:44.104" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:44.104" starttime="20190401 12:48:44.102"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:48:44.105" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:48:44.105" starttime="20190401 12:48:44.104"></status>
</kw>
<msg timestamp="20190401 12:48:44.105" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:44.105" starttime="20190401 12:48:44.100"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:44.106" starttime="20190401 12:48:44.105"></status>
</kw>
<status status="PASS" endtime="20190401 12:48:44.106" starttime="20190401 12:48:44.105"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:44.106" starttime="20190401 12:48:44.106"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:48:44.106" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190401 12:48:44.106" starttime="20190401 12:48:44.106"></status>
</kw>
<msg timestamp="20190401 12:48:44.107" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:48:44.107" starttime="20190401 12:48:43.081"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:48:44.107" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:44.107" starttime="20190401 12:48:44.107"></status>
</kw>
<msg timestamp="20190401 12:48:44.107" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:44.107" starttime="20190401 12:48:43.080"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:48:44.108" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:48:44.108" starttime="20190401 12:48:44.107"></status>
</kw>
<status status="FAIL" endtime="20190401 12:48:44.108" starttime="20190401 12:48:43.080"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:48:49.109" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:49.109" starttime="20190401 12:48:49.109"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:49.110" starttime="20190401 12:48:49.110"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:48:49.111" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:48:49.111" starttime="20190401 12:48:49.110"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:49.111" starttime="20190401 12:48:49.111"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:49.112" starttime="20190401 12:48:49.111"></status>
</kw>
<msg timestamp="20190401 12:48:49.112" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:48:49.112" starttime="20190401 12:48:49.110"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:48:49.112" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:49.112" starttime="20190401 12:48:49.112"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:48:49.121" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:49.121" starttime="20190401 12:48:49.112"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:48:50.120" level="INFO">preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:48:50.120" level="INFO">${output} = preinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:50.120" starttime="20190401 12:48:49.121"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:48:50.121" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:50.121" starttime="20190401 12:48:50.121"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:48:50.121" level="INFO">${clean_out} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:50.121" starttime="20190401 12:48:50.121"></status>
</kw>
<msg timestamp="20190401 12:48:50.121" level="INFO">${output} = preinstall
</msg>
<status status="PASS" endtime="20190401 12:48:50.121" starttime="20190401 12:48:50.120"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:48:50.123" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:48:50.123" starttime="20190401 12:48:50.122"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:48:50.124" level="INFO">0</msg>
<msg timestamp="20190401 12:48:50.124" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:50.124" starttime="20190401 12:48:50.124"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:48:50.124" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:48:50.124" starttime="20190401 12:48:50.124"></status>
</kw>
<msg timestamp="20190401 12:48:50.125" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:50.125" starttime="20190401 12:48:50.121"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:50.125" starttime="20190401 12:48:50.125"></status>
</kw>
<status status="PASS" endtime="20190401 12:48:50.125" starttime="20190401 12:48:50.125"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:50.126" starttime="20190401 12:48:50.126"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:48:50.126" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: preinstall</msg>
<status status="PASS" endtime="20190401 12:48:50.126" starttime="20190401 12:48:50.126"></status>
</kw>
<msg timestamp="20190401 12:48:50.126" level="INFO">${result} = {u'stdout': u'preinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:48:50.126" starttime="20190401 12:48:49.109"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:48:50.127" level="INFO">${value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:50.127" starttime="20190401 12:48:50.126"></status>
</kw>
<msg timestamp="20190401 12:48:50.127" level="INFO">${current_value} = preinstall</msg>
<status status="PASS" endtime="20190401 12:48:50.127" starttime="20190401 12:48:49.109"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:48:50.127" level="FAIL">preinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:48:50.127" starttime="20190401 12:48:50.127"></status>
</kw>
<status status="FAIL" endtime="20190401 12:48:50.127" starttime="20190401 12:48:49.108"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:48:55.129" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:55.129" starttime="20190401 12:48:55.129"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:55.131" starttime="20190401 12:48:55.130"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:48:55.132" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:48:55.132" starttime="20190401 12:48:55.131"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:55.133" starttime="20190401 12:48:55.132"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:55.133" starttime="20190401 12:48:55.133"></status>
</kw>
<msg timestamp="20190401 12:48:55.134" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:48:55.134" starttime="20190401 12:48:55.131"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:48:55.134" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:55.134" starttime="20190401 12:48:55.134"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:48:55.153" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:48:55.153" starttime="20190401 12:48:55.135"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:48:56.134" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:48:56.134" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:56.134" starttime="20190401 12:48:55.153"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:48:56.135" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:48:56.135" starttime="20190401 12:48:56.134"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:48:56.135" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:48:56.135" starttime="20190401 12:48:56.135"></status>
</kw>
<msg timestamp="20190401 12:48:56.135" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:48:56.135" starttime="20190401 12:48:56.134"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:48:56.137" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:48:56.137" starttime="20190401 12:48:56.136"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:48:56.138" level="INFO">0</msg>
<msg timestamp="20190401 12:48:56.138" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:56.138" starttime="20190401 12:48:56.137"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:48:56.138" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:48:56.138" starttime="20190401 12:48:56.138"></status>
</kw>
<msg timestamp="20190401 12:48:56.138" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:48:56.138" starttime="20190401 12:48:56.135"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:56.139" starttime="20190401 12:48:56.139"></status>
</kw>
<status status="PASS" endtime="20190401 12:48:56.139" starttime="20190401 12:48:56.138"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:48:56.139" starttime="20190401 12:48:56.139"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:48:56.140" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:48:56.140" starttime="20190401 12:48:56.140"></status>
</kw>
<msg timestamp="20190401 12:48:56.140" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:48:56.140" starttime="20190401 12:48:55.130"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:48:56.140" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:48:56.140" starttime="20190401 12:48:56.140"></status>
</kw>
<msg timestamp="20190401 12:48:56.141" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:48:56.141" starttime="20190401 12:48:55.128"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:48:56.141" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:48:56.141" starttime="20190401 12:48:56.141"></status>
</kw>
<status status="FAIL" endtime="20190401 12:48:56.141" starttime="20190401 12:48:55.128"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:49:01.143" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:01.143" starttime="20190401 12:49:01.142"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:01.143" starttime="20190401 12:49:01.143"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:49:01.144" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:49:01.144" starttime="20190401 12:49:01.144"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:01.144" starttime="20190401 12:49:01.144"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:01.145" starttime="20190401 12:49:01.145"></status>
</kw>
<msg timestamp="20190401 12:49:01.145" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:49:01.145" starttime="20190401 12:49:01.144"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:49:01.145" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:01.145" starttime="20190401 12:49:01.145"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:49:01.160" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:01.160" starttime="20190401 12:49:01.146"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:49:02.151" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:49:02.151" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:02.152" starttime="20190401 12:49:01.160"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:49:02.153" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:02.153" starttime="20190401 12:49:02.152"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:49:02.153" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:02.153" starttime="20190401 12:49:02.153"></status>
</kw>
<msg timestamp="20190401 12:49:02.153" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:02.153" starttime="20190401 12:49:02.152"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:49:02.155" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:49:02.155" starttime="20190401 12:49:02.153"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:49:02.156" level="INFO">0</msg>
<msg timestamp="20190401 12:49:02.156" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:02.156" starttime="20190401 12:49:02.155"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:49:02.156" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:49:02.156" starttime="20190401 12:49:02.156"></status>
</kw>
<msg timestamp="20190401 12:49:02.156" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:02.156" starttime="20190401 12:49:02.153"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:02.157" starttime="20190401 12:49:02.157"></status>
</kw>
<status status="PASS" endtime="20190401 12:49:02.157" starttime="20190401 12:49:02.156"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:02.157" starttime="20190401 12:49:02.157"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:49:02.158" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:49:02.158" starttime="20190401 12:49:02.158"></status>
</kw>
<msg timestamp="20190401 12:49:02.158" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:49:02.158" starttime="20190401 12:49:01.143"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:49:02.158" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:02.158" starttime="20190401 12:49:02.158"></status>
</kw>
<msg timestamp="20190401 12:49:02.158" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:02.158" starttime="20190401 12:49:01.142"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:49:02.159" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:49:02.159" starttime="20190401 12:49:02.159"></status>
</kw>
<status status="FAIL" endtime="20190401 12:49:02.159" starttime="20190401 12:49:01.142"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:49:07.160" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:07.161" starttime="20190401 12:49:07.160"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:07.161" starttime="20190401 12:49:07.161"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:49:07.162" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:49:07.162" starttime="20190401 12:49:07.162"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:07.162" starttime="20190401 12:49:07.162"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:07.163" starttime="20190401 12:49:07.162"></status>
</kw>
<msg timestamp="20190401 12:49:07.163" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:49:07.163" starttime="20190401 12:49:07.161"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:49:07.163" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:07.163" starttime="20190401 12:49:07.163"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:49:07.173" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:07.173" starttime="20190401 12:49:07.163"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:49:08.216" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:49:08.216" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:08.216" starttime="20190401 12:49:07.173"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:49:08.217" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:08.217" starttime="20190401 12:49:08.216"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:49:08.217" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:08.217" starttime="20190401 12:49:08.217"></status>
</kw>
<msg timestamp="20190401 12:49:08.217" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:08.217" starttime="20190401 12:49:08.216"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:49:08.220" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:49:08.220" starttime="20190401 12:49:08.218"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:49:08.220" level="INFO">0</msg>
<msg timestamp="20190401 12:49:08.220" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:08.220" starttime="20190401 12:49:08.220"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:49:08.221" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:49:08.221" starttime="20190401 12:49:08.220"></status>
</kw>
<msg timestamp="20190401 12:49:08.221" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:08.221" starttime="20190401 12:49:08.218"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:08.222" starttime="20190401 12:49:08.221"></status>
</kw>
<status status="PASS" endtime="20190401 12:49:08.222" starttime="20190401 12:49:08.221"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:08.222" starttime="20190401 12:49:08.222"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:49:08.222" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:49:08.222" starttime="20190401 12:49:08.222"></status>
</kw>
<msg timestamp="20190401 12:49:08.223" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:49:08.223" starttime="20190401 12:49:07.161"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:49:08.223" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:08.223" starttime="20190401 12:49:08.223"></status>
</kw>
<msg timestamp="20190401 12:49:08.223" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:08.223" starttime="20190401 12:49:07.160"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:49:08.224" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:49:08.224" starttime="20190401 12:49:08.223"></status>
</kw>
<status status="FAIL" endtime="20190401 12:49:08.224" starttime="20190401 12:49:07.159"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:49:13.225" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:13.225" starttime="20190401 12:49:13.225"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:13.226" starttime="20190401 12:49:13.226"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:49:13.227" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:49:13.227" starttime="20190401 12:49:13.226"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:13.227" starttime="20190401 12:49:13.227"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:13.227" starttime="20190401 12:49:13.227"></status>
</kw>
<msg timestamp="20190401 12:49:13.228" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:49:13.228" starttime="20190401 12:49:13.226"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:49:13.228" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:13.228" starttime="20190401 12:49:13.228"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:49:13.238" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:13.238" starttime="20190401 12:49:13.228"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:49:14.318" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:49:14.318" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:14.318" starttime="20190401 12:49:13.238"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:49:14.319" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:14.319" starttime="20190401 12:49:14.319"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:49:14.319" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:14.319" starttime="20190401 12:49:14.319"></status>
</kw>
<msg timestamp="20190401 12:49:14.320" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:14.320" starttime="20190401 12:49:14.318"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:49:14.322" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:49:14.322" starttime="20190401 12:49:14.320"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:49:14.322" level="INFO">0</msg>
<msg timestamp="20190401 12:49:14.322" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:14.322" starttime="20190401 12:49:14.322"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:49:14.323" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:49:14.323" starttime="20190401 12:49:14.323"></status>
</kw>
<msg timestamp="20190401 12:49:14.323" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:14.323" starttime="20190401 12:49:14.320"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:14.324" starttime="20190401 12:49:14.323"></status>
</kw>
<status status="PASS" endtime="20190401 12:49:14.324" starttime="20190401 12:49:14.323"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:14.324" starttime="20190401 12:49:14.324"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:49:14.324" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:49:14.324" starttime="20190401 12:49:14.324"></status>
</kw>
<msg timestamp="20190401 12:49:14.325" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:49:14.325" starttime="20190401 12:49:13.225"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:49:14.325" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:14.325" starttime="20190401 12:49:14.325"></status>
</kw>
<msg timestamp="20190401 12:49:14.325" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:14.325" starttime="20190401 12:49:13.225"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:49:14.326" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:49:14.326" starttime="20190401 12:49:14.325"></status>
</kw>
<status status="FAIL" endtime="20190401 12:49:14.326" starttime="20190401 12:49:13.224"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:49:19.327" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:19.327" starttime="20190401 12:49:19.327"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:19.328" starttime="20190401 12:49:19.328"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:49:19.329" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:49:19.329" starttime="20190401 12:49:19.328"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:19.329" starttime="20190401 12:49:19.329"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:19.329" starttime="20190401 12:49:19.329"></status>
</kw>
<msg timestamp="20190401 12:49:19.330" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:49:19.330" starttime="20190401 12:49:19.328"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:49:19.330" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:19.330" starttime="20190401 12:49:19.330"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:49:19.339" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:19.339" starttime="20190401 12:49:19.330"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:49:20.346" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:49:20.346" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:20.346" starttime="20190401 12:49:19.340"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:49:20.347" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:20.347" starttime="20190401 12:49:20.347"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:49:20.348" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:20.348" starttime="20190401 12:49:20.347"></status>
</kw>
<msg timestamp="20190401 12:49:20.348" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:20.348" starttime="20190401 12:49:20.347"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:49:20.349" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:49:20.349" starttime="20190401 12:49:20.348"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:49:20.350" level="INFO">0</msg>
<msg timestamp="20190401 12:49:20.350" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:20.350" starttime="20190401 12:49:20.350"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:49:20.350" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:49:20.350" starttime="20190401 12:49:20.350"></status>
</kw>
<msg timestamp="20190401 12:49:20.350" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:20.350" starttime="20190401 12:49:20.348"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:20.351" starttime="20190401 12:49:20.351"></status>
</kw>
<status status="PASS" endtime="20190401 12:49:20.351" starttime="20190401 12:49:20.350"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:20.352" starttime="20190401 12:49:20.351"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:49:20.352" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:49:20.352" starttime="20190401 12:49:20.352"></status>
</kw>
<msg timestamp="20190401 12:49:20.352" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:49:20.352" starttime="20190401 12:49:19.327"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:49:20.352" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:20.353" starttime="20190401 12:49:20.352"></status>
</kw>
<msg timestamp="20190401 12:49:20.353" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:20.353" starttime="20190401 12:49:19.326"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:49:20.353" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:49:20.353" starttime="20190401 12:49:20.353"></status>
</kw>
<status status="FAIL" endtime="20190401 12:49:20.353" starttime="20190401 12:49:19.326"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:49:25.355" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:25.355" starttime="20190401 12:49:25.354"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:25.356" starttime="20190401 12:49:25.355"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:49:25.356" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:49:25.356" starttime="20190401 12:49:25.356"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:25.357" starttime="20190401 12:49:25.357"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:25.357" starttime="20190401 12:49:25.357"></status>
</kw>
<msg timestamp="20190401 12:49:25.357" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:49:25.357" starttime="20190401 12:49:25.356"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:49:25.358" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:25.358" starttime="20190401 12:49:25.358"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:49:25.368" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:25.369" starttime="20190401 12:49:25.358"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:49:26.409" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:49:26.409" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:26.409" starttime="20190401 12:49:25.369"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:49:26.410" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:26.410" starttime="20190401 12:49:26.410"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:49:26.410" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:26.410" starttime="20190401 12:49:26.410"></status>
</kw>
<msg timestamp="20190401 12:49:26.410" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:26.410" starttime="20190401 12:49:26.409"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:49:26.414" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:49:26.414" starttime="20190401 12:49:26.411"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:49:26.414" level="INFO">0</msg>
<msg timestamp="20190401 12:49:26.414" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:26.414" starttime="20190401 12:49:26.414"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:49:26.414" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:49:26.414" starttime="20190401 12:49:26.414"></status>
</kw>
<msg timestamp="20190401 12:49:26.415" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:26.415" starttime="20190401 12:49:26.411"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:26.415" starttime="20190401 12:49:26.415"></status>
</kw>
<status status="PASS" endtime="20190401 12:49:26.415" starttime="20190401 12:49:26.415"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:26.416" starttime="20190401 12:49:26.416"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:49:26.417" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:49:26.417" starttime="20190401 12:49:26.416"></status>
</kw>
<msg timestamp="20190401 12:49:26.417" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:49:26.417" starttime="20190401 12:49:25.355"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:49:26.417" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:26.417" starttime="20190401 12:49:26.417"></status>
</kw>
<msg timestamp="20190401 12:49:26.417" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:26.418" starttime="20190401 12:49:25.354"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:49:26.418" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:49:26.418" starttime="20190401 12:49:26.418"></status>
</kw>
<status status="FAIL" endtime="20190401 12:49:26.418" starttime="20190401 12:49:25.354"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:49:31.420" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:31.420" starttime="20190401 12:49:31.419"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:31.420" starttime="20190401 12:49:31.420"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:49:31.421" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:49:31.421" starttime="20190401 12:49:31.421"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:31.422" starttime="20190401 12:49:31.421"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:31.422" starttime="20190401 12:49:31.422"></status>
</kw>
<msg timestamp="20190401 12:49:31.423" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:49:31.423" starttime="20190401 12:49:31.420"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:49:31.423" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:31.423" starttime="20190401 12:49:31.423"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:49:31.441" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:31.442" starttime="20190401 12:49:31.423"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:49:32.457" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:49:32.458" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:32.458" starttime="20190401 12:49:31.442"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:49:32.458" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:32.458" starttime="20190401 12:49:32.458"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:49:32.459" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:32.459" starttime="20190401 12:49:32.459"></status>
</kw>
<msg timestamp="20190401 12:49:32.459" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:32.459" starttime="20190401 12:49:32.458"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:49:32.462" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:49:32.462" starttime="20190401 12:49:32.459"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:49:32.462" level="INFO">0</msg>
<msg timestamp="20190401 12:49:32.462" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:32.462" starttime="20190401 12:49:32.462"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:49:32.463" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:49:32.463" starttime="20190401 12:49:32.462"></status>
</kw>
<msg timestamp="20190401 12:49:32.463" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:32.463" starttime="20190401 12:49:32.459"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:32.464" starttime="20190401 12:49:32.463"></status>
</kw>
<status status="PASS" endtime="20190401 12:49:32.464" starttime="20190401 12:49:32.463"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:32.464" starttime="20190401 12:49:32.464"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:49:32.464" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:49:32.464" starttime="20190401 12:49:32.464"></status>
</kw>
<msg timestamp="20190401 12:49:32.465" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:49:32.465" starttime="20190401 12:49:31.420"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:49:32.465" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:32.465" starttime="20190401 12:49:32.465"></status>
</kw>
<msg timestamp="20190401 12:49:32.465" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:32.465" starttime="20190401 12:49:31.419"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:49:32.466" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:49:32.466" starttime="20190401 12:49:32.465"></status>
</kw>
<status status="FAIL" endtime="20190401 12:49:32.466" starttime="20190401 12:49:31.418"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:49:37.468" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:37.468" starttime="20190401 12:49:37.467"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:37.468" starttime="20190401 12:49:37.468"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:49:37.469" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:49:37.469" starttime="20190401 12:49:37.469"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:37.470" starttime="20190401 12:49:37.470"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:37.470" starttime="20190401 12:49:37.470"></status>
</kw>
<msg timestamp="20190401 12:49:37.471" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:49:37.471" starttime="20190401 12:49:37.469"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:49:37.471" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:37.471" starttime="20190401 12:49:37.471"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:49:37.487" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:37.487" starttime="20190401 12:49:37.471"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:49:38.486" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:49:38.486" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:38.486" starttime="20190401 12:49:37.487"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:49:38.487" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:38.487" starttime="20190401 12:49:38.487"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:49:38.487" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:38.487" starttime="20190401 12:49:38.487"></status>
</kw>
<msg timestamp="20190401 12:49:38.487" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:38.487" starttime="20190401 12:49:38.486"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:49:38.490" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:49:38.490" starttime="20190401 12:49:38.488"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:49:38.490" level="INFO">0</msg>
<msg timestamp="20190401 12:49:38.490" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:38.490" starttime="20190401 12:49:38.490"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:49:38.490" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:49:38.491" starttime="20190401 12:49:38.490"></status>
</kw>
<msg timestamp="20190401 12:49:38.491" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:38.491" starttime="20190401 12:49:38.488"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:38.492" starttime="20190401 12:49:38.491"></status>
</kw>
<status status="PASS" endtime="20190401 12:49:38.492" starttime="20190401 12:49:38.491"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:38.492" starttime="20190401 12:49:38.492"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:49:38.492" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:49:38.492" starttime="20190401 12:49:38.492"></status>
</kw>
<msg timestamp="20190401 12:49:38.492" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:49:38.492" starttime="20190401 12:49:37.468"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:49:38.493" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:38.493" starttime="20190401 12:49:38.493"></status>
</kw>
<msg timestamp="20190401 12:49:38.493" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:38.493" starttime="20190401 12:49:37.467"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:49:38.494" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:49:38.494" starttime="20190401 12:49:38.493"></status>
</kw>
<status status="FAIL" endtime="20190401 12:49:38.494" starttime="20190401 12:49:37.466"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:49:43.495" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:43.495" starttime="20190401 12:49:43.495"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:43.496" starttime="20190401 12:49:43.496"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:49:43.497" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:49:43.497" starttime="20190401 12:49:43.497"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:43.497" starttime="20190401 12:49:43.497"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:43.498" starttime="20190401 12:49:43.497"></status>
</kw>
<msg timestamp="20190401 12:49:43.498" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:49:43.498" starttime="20190401 12:49:43.496"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:49:43.498" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:43.498" starttime="20190401 12:49:43.498"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:49:43.514" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:43.514" starttime="20190401 12:49:43.498"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:49:44.521" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:49:44.521" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:44.521" starttime="20190401 12:49:43.514"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:49:44.522" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:44.522" starttime="20190401 12:49:44.521"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:49:44.522" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:44.522" starttime="20190401 12:49:44.522"></status>
</kw>
<msg timestamp="20190401 12:49:44.523" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:44.523" starttime="20190401 12:49:44.521"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:49:44.525" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:49:44.525" starttime="20190401 12:49:44.523"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:49:44.525" level="INFO">0</msg>
<msg timestamp="20190401 12:49:44.525" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:44.526" starttime="20190401 12:49:44.525"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:49:44.526" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:49:44.526" starttime="20190401 12:49:44.526"></status>
</kw>
<msg timestamp="20190401 12:49:44.526" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:44.526" starttime="20190401 12:49:44.523"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:44.527" starttime="20190401 12:49:44.526"></status>
</kw>
<status status="PASS" endtime="20190401 12:49:44.527" starttime="20190401 12:49:44.526"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:44.527" starttime="20190401 12:49:44.527"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:49:44.527" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:49:44.527" starttime="20190401 12:49:44.527"></status>
</kw>
<msg timestamp="20190401 12:49:44.528" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:49:44.528" starttime="20190401 12:49:43.496"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:49:44.528" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:44.528" starttime="20190401 12:49:44.528"></status>
</kw>
<msg timestamp="20190401 12:49:44.528" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:44.528" starttime="20190401 12:49:43.494"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:49:44.529" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:49:44.529" starttime="20190401 12:49:44.528"></status>
</kw>
<status status="FAIL" endtime="20190401 12:49:44.529" starttime="20190401 12:49:43.494"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:49:49.530" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:49.530" starttime="20190401 12:49:49.530"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:49.531" starttime="20190401 12:49:49.531"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:49:49.532" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:49:49.532" starttime="20190401 12:49:49.532"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:49.532" starttime="20190401 12:49:49.532"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:49.533" starttime="20190401 12:49:49.533"></status>
</kw>
<msg timestamp="20190401 12:49:49.533" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:49:49.533" starttime="20190401 12:49:49.531"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:49:49.533" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:49.533" starttime="20190401 12:49:49.533"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:49:49.547" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:49.548" starttime="20190401 12:49:49.533"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:49:50.527" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:49:50.527" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:50.527" starttime="20190401 12:49:49.548"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:49:50.528" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:50.528" starttime="20190401 12:49:50.528"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:49:50.528" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:50.528" starttime="20190401 12:49:50.528"></status>
</kw>
<msg timestamp="20190401 12:49:50.528" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:50.528" starttime="20190401 12:49:50.527"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:49:50.530" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:49:50.531" starttime="20190401 12:49:50.529"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:49:50.531" level="INFO">0</msg>
<msg timestamp="20190401 12:49:50.531" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:50.531" starttime="20190401 12:49:50.531"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:49:50.531" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:49:50.531" starttime="20190401 12:49:50.531"></status>
</kw>
<msg timestamp="20190401 12:49:50.531" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:50.531" starttime="20190401 12:49:50.528"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:50.532" starttime="20190401 12:49:50.532"></status>
</kw>
<status status="PASS" endtime="20190401 12:49:50.532" starttime="20190401 12:49:50.532"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:50.533" starttime="20190401 12:49:50.532"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:49:50.533" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:49:50.533" starttime="20190401 12:49:50.533"></status>
</kw>
<msg timestamp="20190401 12:49:50.533" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:49:50.533" starttime="20190401 12:49:49.530"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:49:50.533" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:50.533" starttime="20190401 12:49:50.533"></status>
</kw>
<msg timestamp="20190401 12:49:50.534" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:50.534" starttime="20190401 12:49:49.530"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:49:50.534" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:49:50.534" starttime="20190401 12:49:50.534"></status>
</kw>
<status status="FAIL" endtime="20190401 12:49:50.534" starttime="20190401 12:49:49.529"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:49:55.536" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:55.536" starttime="20190401 12:49:55.535"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:55.536" starttime="20190401 12:49:55.536"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:49:55.538" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:49:55.538" starttime="20190401 12:49:55.537"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:55.538" starttime="20190401 12:49:55.538"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:55.538" starttime="20190401 12:49:55.538"></status>
</kw>
<msg timestamp="20190401 12:49:55.539" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:49:55.539" starttime="20190401 12:49:55.536"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:49:55.539" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:55.539" starttime="20190401 12:49:55.539"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:49:55.550" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:49:55.550" starttime="20190401 12:49:55.539"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:49:56.553" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:49:56.553" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:56.553" starttime="20190401 12:49:55.550"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:49:56.554" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:49:56.554" starttime="20190401 12:49:56.554"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:49:56.555" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:56.555" starttime="20190401 12:49:56.554"></status>
</kw>
<msg timestamp="20190401 12:49:56.555" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:49:56.555" starttime="20190401 12:49:56.554"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:49:56.556" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:49:56.556" starttime="20190401 12:49:56.555"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:49:56.557" level="INFO">0</msg>
<msg timestamp="20190401 12:49:56.557" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:56.557" starttime="20190401 12:49:56.557"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:49:56.557" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:49:56.558" starttime="20190401 12:49:56.557"></status>
</kw>
<msg timestamp="20190401 12:49:56.558" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:49:56.558" starttime="20190401 12:49:56.555"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:56.558" starttime="20190401 12:49:56.558"></status>
</kw>
<status status="PASS" endtime="20190401 12:49:56.559" starttime="20190401 12:49:56.558"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:49:56.559" starttime="20190401 12:49:56.559"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:49:56.559" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:49:56.559" starttime="20190401 12:49:56.559"></status>
</kw>
<msg timestamp="20190401 12:49:56.559" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:49:56.559" starttime="20190401 12:49:55.536"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:49:56.560" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:56.560" starttime="20190401 12:49:56.559"></status>
</kw>
<msg timestamp="20190401 12:49:56.560" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:49:56.560" starttime="20190401 12:49:55.535"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:49:56.560" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:49:56.560" starttime="20190401 12:49:56.560"></status>
</kw>
<status status="FAIL" endtime="20190401 12:49:56.561" starttime="20190401 12:49:55.535"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:50:01.562" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:01.562" starttime="20190401 12:50:01.562"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:01.563" starttime="20190401 12:50:01.563"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:50:01.563" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:50:01.564" starttime="20190401 12:50:01.563"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:01.564" starttime="20190401 12:50:01.564"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:01.564" starttime="20190401 12:50:01.564"></status>
</kw>
<msg timestamp="20190401 12:50:01.565" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:50:01.565" starttime="20190401 12:50:01.563"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:50:01.565" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:01.565" starttime="20190401 12:50:01.565"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:50:01.577" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:01.577" starttime="20190401 12:50:01.565"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:50:02.571" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:50:02.571" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:02.571" starttime="20190401 12:50:01.577"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:50:02.572" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:02.572" starttime="20190401 12:50:02.572"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:50:02.573" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:02.573" starttime="20190401 12:50:02.572"></status>
</kw>
<msg timestamp="20190401 12:50:02.573" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:02.573" starttime="20190401 12:50:02.572"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:50:02.575" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:50:02.575" starttime="20190401 12:50:02.573"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:50:02.575" level="INFO">0</msg>
<msg timestamp="20190401 12:50:02.575" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:02.575" starttime="20190401 12:50:02.575"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:50:02.575" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:50:02.576" starttime="20190401 12:50:02.575"></status>
</kw>
<msg timestamp="20190401 12:50:02.576" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:02.576" starttime="20190401 12:50:02.573"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:02.576" starttime="20190401 12:50:02.576"></status>
</kw>
<status status="PASS" endtime="20190401 12:50:02.577" starttime="20190401 12:50:02.576"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:02.577" starttime="20190401 12:50:02.577"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:50:02.577" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:50:02.577" starttime="20190401 12:50:02.577"></status>
</kw>
<msg timestamp="20190401 12:50:02.577" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:50:02.577" starttime="20190401 12:50:01.562"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:50:02.578" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:02.578" starttime="20190401 12:50:02.577"></status>
</kw>
<msg timestamp="20190401 12:50:02.578" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:02.578" starttime="20190401 12:50:01.561"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:50:02.578" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:50:02.578" starttime="20190401 12:50:02.578"></status>
</kw>
<status status="FAIL" endtime="20190401 12:50:02.579" starttime="20190401 12:50:01.561"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:50:07.581" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:07.581" starttime="20190401 12:50:07.580"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:07.582" starttime="20190401 12:50:07.582"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:50:07.583" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:50:07.583" starttime="20190401 12:50:07.582"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:07.584" starttime="20190401 12:50:07.583"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:07.584" starttime="20190401 12:50:07.584"></status>
</kw>
<msg timestamp="20190401 12:50:07.585" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:50:07.585" starttime="20190401 12:50:07.582"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:50:07.585" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:07.585" starttime="20190401 12:50:07.585"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:50:07.604" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:07.604" starttime="20190401 12:50:07.585"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:50:08.590" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:50:08.590" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:08.590" starttime="20190401 12:50:07.605"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:50:08.591" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:08.591" starttime="20190401 12:50:08.591"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:50:08.591" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:08.591" starttime="20190401 12:50:08.591"></status>
</kw>
<msg timestamp="20190401 12:50:08.591" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:08.591" starttime="20190401 12:50:08.590"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:50:08.594" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:50:08.594" starttime="20190401 12:50:08.592"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:50:08.594" level="INFO">0</msg>
<msg timestamp="20190401 12:50:08.594" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:08.594" starttime="20190401 12:50:08.594"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:50:08.595" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:50:08.595" starttime="20190401 12:50:08.595"></status>
</kw>
<msg timestamp="20190401 12:50:08.595" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:08.595" starttime="20190401 12:50:08.592"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:08.596" starttime="20190401 12:50:08.595"></status>
</kw>
<status status="PASS" endtime="20190401 12:50:08.596" starttime="20190401 12:50:08.595"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:08.596" starttime="20190401 12:50:08.596"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:50:08.596" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:50:08.596" starttime="20190401 12:50:08.596"></status>
</kw>
<msg timestamp="20190401 12:50:08.596" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:50:08.597" starttime="20190401 12:50:07.581"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:50:08.597" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:08.597" starttime="20190401 12:50:08.597"></status>
</kw>
<msg timestamp="20190401 12:50:08.597" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:08.597" starttime="20190401 12:50:07.580"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:50:08.598" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:50:08.598" starttime="20190401 12:50:08.597"></status>
</kw>
<status status="FAIL" endtime="20190401 12:50:08.598" starttime="20190401 12:50:07.579"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:50:13.599" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:13.599" starttime="20190401 12:50:13.599"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:13.600" starttime="20190401 12:50:13.600"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:50:13.601" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:50:13.601" starttime="20190401 12:50:13.600"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:13.601" starttime="20190401 12:50:13.601"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:13.601" starttime="20190401 12:50:13.601"></status>
</kw>
<msg timestamp="20190401 12:50:13.602" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:50:13.602" starttime="20190401 12:50:13.600"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:50:13.602" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:13.602" starttime="20190401 12:50:13.602"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:50:13.615" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:13.615" starttime="20190401 12:50:13.602"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:50:14.665" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:50:14.665" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:14.665" starttime="20190401 12:50:13.615"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:50:14.666" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:14.666" starttime="20190401 12:50:14.666"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:50:14.667" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:14.667" starttime="20190401 12:50:14.666"></status>
</kw>
<msg timestamp="20190401 12:50:14.667" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:14.667" starttime="20190401 12:50:14.665"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:50:14.669" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:50:14.669" starttime="20190401 12:50:14.667"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:50:14.670" level="INFO">0</msg>
<msg timestamp="20190401 12:50:14.670" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:14.670" starttime="20190401 12:50:14.669"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:50:14.670" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:50:14.670" starttime="20190401 12:50:14.670"></status>
</kw>
<msg timestamp="20190401 12:50:14.670" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:14.670" starttime="20190401 12:50:14.667"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:14.671" starttime="20190401 12:50:14.671"></status>
</kw>
<status status="PASS" endtime="20190401 12:50:14.671" starttime="20190401 12:50:14.671"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:14.671" starttime="20190401 12:50:14.671"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:50:14.672" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:50:14.672" starttime="20190401 12:50:14.672"></status>
</kw>
<msg timestamp="20190401 12:50:14.672" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:50:14.672" starttime="20190401 12:50:13.599"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:50:14.672" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:14.672" starttime="20190401 12:50:14.672"></status>
</kw>
<msg timestamp="20190401 12:50:14.673" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:14.673" starttime="20190401 12:50:13.598"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:50:14.673" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:50:14.673" starttime="20190401 12:50:14.673"></status>
</kw>
<status status="FAIL" endtime="20190401 12:50:14.673" starttime="20190401 12:50:13.598"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:50:19.675" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:19.675" starttime="20190401 12:50:19.675"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:19.676" starttime="20190401 12:50:19.676"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:50:19.678" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:50:19.678" starttime="20190401 12:50:19.677"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:19.678" starttime="20190401 12:50:19.678"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:19.679" starttime="20190401 12:50:19.679"></status>
</kw>
<msg timestamp="20190401 12:50:19.679" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:50:19.679" starttime="20190401 12:50:19.677"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:50:19.680" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:19.680" starttime="20190401 12:50:19.680"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:50:19.699" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:19.699" starttime="20190401 12:50:19.680"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:50:20.694" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:50:20.694" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:20.694" starttime="20190401 12:50:19.699"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:50:20.695" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:20.695" starttime="20190401 12:50:20.695"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:50:20.695" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:20.695" starttime="20190401 12:50:20.695"></status>
</kw>
<msg timestamp="20190401 12:50:20.696" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:20.696" starttime="20190401 12:50:20.694"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:50:20.697" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:50:20.698" starttime="20190401 12:50:20.696"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:50:20.698" level="INFO">0</msg>
<msg timestamp="20190401 12:50:20.698" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:20.698" starttime="20190401 12:50:20.698"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:50:20.699" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:50:20.699" starttime="20190401 12:50:20.698"></status>
</kw>
<msg timestamp="20190401 12:50:20.699" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:20.699" starttime="20190401 12:50:20.696"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:20.700" starttime="20190401 12:50:20.699"></status>
</kw>
<status status="PASS" endtime="20190401 12:50:20.700" starttime="20190401 12:50:20.699"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:20.700" starttime="20190401 12:50:20.700"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:50:20.700" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:50:20.700" starttime="20190401 12:50:20.700"></status>
</kw>
<msg timestamp="20190401 12:50:20.701" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:50:20.701" starttime="20190401 12:50:19.675"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:50:20.701" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:20.701" starttime="20190401 12:50:20.701"></status>
</kw>
<msg timestamp="20190401 12:50:20.701" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:20.701" starttime="20190401 12:50:19.674"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:50:20.702" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:50:20.702" starttime="20190401 12:50:20.701"></status>
</kw>
<status status="FAIL" endtime="20190401 12:50:20.702" starttime="20190401 12:50:19.674"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:50:25.703" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:25.703" starttime="20190401 12:50:25.703"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:25.704" starttime="20190401 12:50:25.704"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:50:25.705" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:50:25.705" starttime="20190401 12:50:25.704"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:25.705" starttime="20190401 12:50:25.705"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:25.705" starttime="20190401 12:50:25.705"></status>
</kw>
<msg timestamp="20190401 12:50:25.706" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:50:25.706" starttime="20190401 12:50:25.704"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:50:25.706" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:25.706" starttime="20190401 12:50:25.706"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:50:25.716" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:25.716" starttime="20190401 12:50:25.706"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:50:26.747" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:50:26.747" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:26.747" starttime="20190401 12:50:25.716"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:50:26.748" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:26.748" starttime="20190401 12:50:26.747"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:50:26.748" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:26.748" starttime="20190401 12:50:26.748"></status>
</kw>
<msg timestamp="20190401 12:50:26.748" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:26.748" starttime="20190401 12:50:26.747"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:50:26.750" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:50:26.750" starttime="20190401 12:50:26.749"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:50:26.751" level="INFO">0</msg>
<msg timestamp="20190401 12:50:26.751" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:26.751" starttime="20190401 12:50:26.750"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:50:26.751" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:50:26.751" starttime="20190401 12:50:26.751"></status>
</kw>
<msg timestamp="20190401 12:50:26.751" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:26.751" starttime="20190401 12:50:26.748"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:26.752" starttime="20190401 12:50:26.752"></status>
</kw>
<status status="PASS" endtime="20190401 12:50:26.752" starttime="20190401 12:50:26.752"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:26.753" starttime="20190401 12:50:26.753"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:50:26.753" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:50:26.753" starttime="20190401 12:50:26.753"></status>
</kw>
<msg timestamp="20190401 12:50:26.753" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:50:26.753" starttime="20190401 12:50:25.703"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:50:26.754" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:26.754" starttime="20190401 12:50:26.753"></status>
</kw>
<msg timestamp="20190401 12:50:26.754" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:26.754" starttime="20190401 12:50:25.703"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:50:26.754" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:50:26.754" starttime="20190401 12:50:26.754"></status>
</kw>
<status status="FAIL" endtime="20190401 12:50:26.754" starttime="20190401 12:50:25.702"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:50:31.756" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:31.756" starttime="20190401 12:50:31.756"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:31.757" starttime="20190401 12:50:31.756"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:50:31.757" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:50:31.757" starttime="20190401 12:50:31.757"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:31.758" starttime="20190401 12:50:31.757"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:31.758" starttime="20190401 12:50:31.758"></status>
</kw>
<msg timestamp="20190401 12:50:31.758" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:50:31.758" starttime="20190401 12:50:31.757"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:50:31.759" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:31.759" starttime="20190401 12:50:31.758"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:50:31.768" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:31.768" starttime="20190401 12:50:31.759"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:50:32.822" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:50:32.822" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:32.822" starttime="20190401 12:50:31.768"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:50:32.823" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:32.823" starttime="20190401 12:50:32.822"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:50:32.823" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:32.823" starttime="20190401 12:50:32.823"></status>
</kw>
<msg timestamp="20190401 12:50:32.823" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:32.823" starttime="20190401 12:50:32.822"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:50:32.825" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:50:32.825" starttime="20190401 12:50:32.824"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:50:32.825" level="INFO">0</msg>
<msg timestamp="20190401 12:50:32.826" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:32.826" starttime="20190401 12:50:32.825"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:50:32.826" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:50:32.826" starttime="20190401 12:50:32.826"></status>
</kw>
<msg timestamp="20190401 12:50:32.826" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:32.826" starttime="20190401 12:50:32.823"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:32.827" starttime="20190401 12:50:32.827"></status>
</kw>
<status status="PASS" endtime="20190401 12:50:32.827" starttime="20190401 12:50:32.826"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:32.827" starttime="20190401 12:50:32.827"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:50:32.827" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:50:32.827" starttime="20190401 12:50:32.827"></status>
</kw>
<msg timestamp="20190401 12:50:32.828" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:50:32.828" starttime="20190401 12:50:31.756"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:50:32.828" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:32.828" starttime="20190401 12:50:32.828"></status>
</kw>
<msg timestamp="20190401 12:50:32.828" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:32.828" starttime="20190401 12:50:31.755"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:50:32.829" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:50:32.829" starttime="20190401 12:50:32.828"></status>
</kw>
<status status="FAIL" endtime="20190401 12:50:32.829" starttime="20190401 12:50:31.755"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:50:37.830" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:37.830" starttime="20190401 12:50:37.830"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:37.831" starttime="20190401 12:50:37.831"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:50:37.832" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:50:37.832" starttime="20190401 12:50:37.832"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:37.832" starttime="20190401 12:50:37.832"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:37.833" starttime="20190401 12:50:37.833"></status>
</kw>
<msg timestamp="20190401 12:50:37.833" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:50:37.833" starttime="20190401 12:50:37.831"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:50:37.833" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:37.833" starttime="20190401 12:50:37.833"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:50:37.844" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:37.844" starttime="20190401 12:50:37.833"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:50:38.843" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:50:38.843" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:38.843" starttime="20190401 12:50:37.844"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:50:38.844" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:38.844" starttime="20190401 12:50:38.844"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:50:38.844" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:38.845" starttime="20190401 12:50:38.844"></status>
</kw>
<msg timestamp="20190401 12:50:38.845" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:38.845" starttime="20190401 12:50:38.844"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:50:38.847" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:50:38.847" starttime="20190401 12:50:38.845"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:50:38.847" level="INFO">0</msg>
<msg timestamp="20190401 12:50:38.847" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:38.847" starttime="20190401 12:50:38.847"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:50:38.847" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:50:38.847" starttime="20190401 12:50:38.847"></status>
</kw>
<msg timestamp="20190401 12:50:38.848" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:38.848" starttime="20190401 12:50:38.845"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:38.848" starttime="20190401 12:50:38.848"></status>
</kw>
<status status="PASS" endtime="20190401 12:50:38.848" starttime="20190401 12:50:38.848"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:38.849" starttime="20190401 12:50:38.849"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:50:38.849" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:50:38.849" starttime="20190401 12:50:38.849"></status>
</kw>
<msg timestamp="20190401 12:50:38.849" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:50:38.849" starttime="20190401 12:50:37.831"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:50:38.850" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:38.850" starttime="20190401 12:50:38.849"></status>
</kw>
<msg timestamp="20190401 12:50:38.850" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:38.850" starttime="20190401 12:50:37.830"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:50:38.850" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:50:38.850" starttime="20190401 12:50:38.850"></status>
</kw>
<status status="FAIL" endtime="20190401 12:50:38.851" starttime="20190401 12:50:37.829"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:50:43.853" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:43.853" starttime="20190401 12:50:43.852"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:43.854" starttime="20190401 12:50:43.853"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:50:43.855" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:50:43.855" starttime="20190401 12:50:43.854"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:43.855" starttime="20190401 12:50:43.855"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:43.856" starttime="20190401 12:50:43.856"></status>
</kw>
<msg timestamp="20190401 12:50:43.856" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:50:43.856" starttime="20190401 12:50:43.854"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:50:43.857" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:43.857" starttime="20190401 12:50:43.856"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:50:43.866" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:43.866" starttime="20190401 12:50:43.857"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:50:44.920" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:50:44.920" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:44.920" starttime="20190401 12:50:43.866"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:50:44.921" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:44.921" starttime="20190401 12:50:44.921"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:50:44.921" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:44.921" starttime="20190401 12:50:44.921"></status>
</kw>
<msg timestamp="20190401 12:50:44.921" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:44.921" starttime="20190401 12:50:44.920"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:50:44.923" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:50:44.923" starttime="20190401 12:50:44.922"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:50:44.924" level="INFO">0</msg>
<msg timestamp="20190401 12:50:44.924" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:44.924" starttime="20190401 12:50:44.923"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:50:44.924" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:50:44.924" starttime="20190401 12:50:44.924"></status>
</kw>
<msg timestamp="20190401 12:50:44.924" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:44.924" starttime="20190401 12:50:44.921"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:44.925" starttime="20190401 12:50:44.925"></status>
</kw>
<status status="PASS" endtime="20190401 12:50:44.925" starttime="20190401 12:50:44.924"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:44.925" starttime="20190401 12:50:44.925"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:50:44.925" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:50:44.926" starttime="20190401 12:50:44.925"></status>
</kw>
<msg timestamp="20190401 12:50:44.926" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:50:44.926" starttime="20190401 12:50:43.853"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:50:44.926" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:44.926" starttime="20190401 12:50:44.926"></status>
</kw>
<msg timestamp="20190401 12:50:44.926" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:44.926" starttime="20190401 12:50:43.851"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:50:44.927" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:50:44.927" starttime="20190401 12:50:44.926"></status>
</kw>
<status status="FAIL" endtime="20190401 12:50:44.927" starttime="20190401 12:50:43.851"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:50:49.928" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:49.928" starttime="20190401 12:50:49.928"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:49.929" starttime="20190401 12:50:49.929"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:50:49.930" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:50:49.930" starttime="20190401 12:50:49.930"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:49.930" starttime="20190401 12:50:49.930"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:49.931" starttime="20190401 12:50:49.931"></status>
</kw>
<msg timestamp="20190401 12:50:49.931" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:50:49.931" starttime="20190401 12:50:49.930"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:50:49.931" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:49.931" starttime="20190401 12:50:49.931"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:50:49.942" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:49.942" starttime="20190401 12:50:49.931"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:50:50.947" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:50:50.947" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:50.947" starttime="20190401 12:50:49.942"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:50:50.948" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:50.948" starttime="20190401 12:50:50.948"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:50:50.948" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:50.948" starttime="20190401 12:50:50.948"></status>
</kw>
<msg timestamp="20190401 12:50:50.949" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:50.949" starttime="20190401 12:50:50.947"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:50:50.951" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:50:50.951" starttime="20190401 12:50:50.949"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:50:50.951" level="INFO">0</msg>
<msg timestamp="20190401 12:50:50.951" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:50.951" starttime="20190401 12:50:50.951"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:50:50.952" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:50:50.952" starttime="20190401 12:50:50.951"></status>
</kw>
<msg timestamp="20190401 12:50:50.952" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:50.952" starttime="20190401 12:50:50.949"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:50.953" starttime="20190401 12:50:50.952"></status>
</kw>
<status status="PASS" endtime="20190401 12:50:50.953" starttime="20190401 12:50:50.952"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:50.953" starttime="20190401 12:50:50.953"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:50:50.953" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:50:50.953" starttime="20190401 12:50:50.953"></status>
</kw>
<msg timestamp="20190401 12:50:50.953" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:50:50.953" starttime="20190401 12:50:49.928"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:50:50.954" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:50.954" starttime="20190401 12:50:50.954"></status>
</kw>
<msg timestamp="20190401 12:50:50.954" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:50.954" starttime="20190401 12:50:49.928"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:50:50.954" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:50:50.954" starttime="20190401 12:50:50.954"></status>
</kw>
<status status="FAIL" endtime="20190401 12:50:50.955" starttime="20190401 12:50:49.927"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:50:55.956" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:55.956" starttime="20190401 12:50:55.956"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:55.957" starttime="20190401 12:50:55.957"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:50:55.958" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:50:55.958" starttime="20190401 12:50:55.957"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:55.958" starttime="20190401 12:50:55.958"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:55.959" starttime="20190401 12:50:55.958"></status>
</kw>
<msg timestamp="20190401 12:50:55.959" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:50:55.959" starttime="20190401 12:50:55.957"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:50:55.959" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:55.959" starttime="20190401 12:50:55.959"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:50:55.969" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:50:55.969" starttime="20190401 12:50:55.959"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:50:56.992" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:50:56.992" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:56.992" starttime="20190401 12:50:55.969"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:50:56.993" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:50:56.993" starttime="20190401 12:50:56.993"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:50:56.993" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:56.993" starttime="20190401 12:50:56.993"></status>
</kw>
<msg timestamp="20190401 12:50:56.994" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:50:56.994" starttime="20190401 12:50:56.992"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:50:56.995" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:50:56.995" starttime="20190401 12:50:56.994"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:50:56.997" level="INFO">0</msg>
<msg timestamp="20190401 12:50:56.997" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:56.997" starttime="20190401 12:50:56.995"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:50:56.998" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:50:56.998" starttime="20190401 12:50:56.998"></status>
</kw>
<msg timestamp="20190401 12:50:56.998" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:50:56.998" starttime="20190401 12:50:56.994"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:56.999" starttime="20190401 12:50:56.998"></status>
</kw>
<status status="PASS" endtime="20190401 12:50:56.999" starttime="20190401 12:50:56.998"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:50:56.999" starttime="20190401 12:50:56.999"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:50:56.999" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:50:56.999" starttime="20190401 12:50:56.999"></status>
</kw>
<msg timestamp="20190401 12:50:57.000" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:50:57.000" starttime="20190401 12:50:55.956"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:50:57.000" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:57.000" starttime="20190401 12:50:57.000"></status>
</kw>
<msg timestamp="20190401 12:50:57.000" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:50:57.000" starttime="20190401 12:50:55.955"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:50:57.001" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:50:57.001" starttime="20190401 12:50:57.000"></status>
</kw>
<status status="FAIL" endtime="20190401 12:50:57.001" starttime="20190401 12:50:55.955"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:51:02.002" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:02.002" starttime="20190401 12:51:02.002"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:02.003" starttime="20190401 12:51:02.003"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:51:02.004" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:51:02.004" starttime="20190401 12:51:02.003"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:02.004" starttime="20190401 12:51:02.004"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:02.005" starttime="20190401 12:51:02.004"></status>
</kw>
<msg timestamp="20190401 12:51:02.005" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:51:02.005" starttime="20190401 12:51:02.003"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:51:02.005" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:02.005" starttime="20190401 12:51:02.005"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:51:02.018" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:02.018" starttime="20190401 12:51:02.005"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:51:03.028" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:51:03.028" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:03.028" starttime="20190401 12:51:02.018"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:51:03.029" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:03.029" starttime="20190401 12:51:03.029"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:51:03.029" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:03.029" starttime="20190401 12:51:03.029"></status>
</kw>
<msg timestamp="20190401 12:51:03.029" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:03.029" starttime="20190401 12:51:03.028"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:51:03.031" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:51:03.031" starttime="20190401 12:51:03.030"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:51:03.032" level="INFO">0</msg>
<msg timestamp="20190401 12:51:03.032" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:03.032" starttime="20190401 12:51:03.032"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:51:03.032" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:51:03.032" starttime="20190401 12:51:03.032"></status>
</kw>
<msg timestamp="20190401 12:51:03.032" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:03.032" starttime="20190401 12:51:03.029"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:03.033" starttime="20190401 12:51:03.033"></status>
</kw>
<status status="PASS" endtime="20190401 12:51:03.033" starttime="20190401 12:51:03.033"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:03.034" starttime="20190401 12:51:03.033"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:51:03.034" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:51:03.034" starttime="20190401 12:51:03.034"></status>
</kw>
<msg timestamp="20190401 12:51:03.034" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:51:03.034" starttime="20190401 12:51:02.002"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:51:03.034" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:03.034" starttime="20190401 12:51:03.034"></status>
</kw>
<msg timestamp="20190401 12:51:03.035" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:03.035" starttime="20190401 12:51:02.002"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:51:03.035" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:51:03.035" starttime="20190401 12:51:03.035"></status>
</kw>
<status status="FAIL" endtime="20190401 12:51:03.035" starttime="20190401 12:51:02.001"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:51:08.037" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:08.037" starttime="20190401 12:51:08.036"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:08.037" starttime="20190401 12:51:08.037"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:51:08.038" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:51:08.038" starttime="20190401 12:51:08.038"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:08.038" starttime="20190401 12:51:08.038"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:08.039" starttime="20190401 12:51:08.039"></status>
</kw>
<msg timestamp="20190401 12:51:08.039" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:51:08.039" starttime="20190401 12:51:08.037"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:51:08.040" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:08.040" starttime="20190401 12:51:08.039"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:51:08.054" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:08.054" starttime="20190401 12:51:08.040"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:51:09.044" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:51:09.045" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:09.045" starttime="20190401 12:51:08.054"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:51:09.045" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:09.045" starttime="20190401 12:51:09.045"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:51:09.046" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:09.046" starttime="20190401 12:51:09.046"></status>
</kw>
<msg timestamp="20190401 12:51:09.046" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:09.046" starttime="20190401 12:51:09.045"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:51:09.048" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:51:09.048" starttime="20190401 12:51:09.046"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:51:09.048" level="INFO">0</msg>
<msg timestamp="20190401 12:51:09.049" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:09.049" starttime="20190401 12:51:09.048"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:51:09.049" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:51:09.049" starttime="20190401 12:51:09.049"></status>
</kw>
<msg timestamp="20190401 12:51:09.049" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:09.049" starttime="20190401 12:51:09.046"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:09.050" starttime="20190401 12:51:09.050"></status>
</kw>
<status status="PASS" endtime="20190401 12:51:09.050" starttime="20190401 12:51:09.049"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:09.050" starttime="20190401 12:51:09.050"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:51:09.050" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:51:09.050" starttime="20190401 12:51:09.050"></status>
</kw>
<msg timestamp="20190401 12:51:09.051" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:51:09.051" starttime="20190401 12:51:08.037"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:51:09.051" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:09.051" starttime="20190401 12:51:09.051"></status>
</kw>
<msg timestamp="20190401 12:51:09.051" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:09.051" starttime="20190401 12:51:08.036"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:51:09.052" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:51:09.052" starttime="20190401 12:51:09.051"></status>
</kw>
<status status="FAIL" endtime="20190401 12:51:09.052" starttime="20190401 12:51:08.035"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:51:14.053" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:14.053" starttime="20190401 12:51:14.053"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:14.054" starttime="20190401 12:51:14.054"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:51:14.055" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:51:14.055" starttime="20190401 12:51:14.054"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:14.055" starttime="20190401 12:51:14.055"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:14.055" starttime="20190401 12:51:14.055"></status>
</kw>
<msg timestamp="20190401 12:51:14.056" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:51:14.056" starttime="20190401 12:51:14.054"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:51:14.056" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:14.056" starttime="20190401 12:51:14.056"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:51:14.058" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:14.058" starttime="20190401 12:51:14.056"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:51:15.070" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:51:15.070" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:15.070" starttime="20190401 12:51:14.058"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:51:15.071" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:15.071" starttime="20190401 12:51:15.071"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:51:15.072" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:15.072" starttime="20190401 12:51:15.071"></status>
</kw>
<msg timestamp="20190401 12:51:15.072" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:15.072" starttime="20190401 12:51:15.071"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:51:15.074" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:51:15.074" starttime="20190401 12:51:15.072"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:51:15.075" level="INFO">0</msg>
<msg timestamp="20190401 12:51:15.075" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:15.075" starttime="20190401 12:51:15.075"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:51:15.075" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:51:15.075" starttime="20190401 12:51:15.075"></status>
</kw>
<msg timestamp="20190401 12:51:15.075" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:15.075" starttime="20190401 12:51:15.072"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:15.076" starttime="20190401 12:51:15.076"></status>
</kw>
<status status="PASS" endtime="20190401 12:51:15.076" starttime="20190401 12:51:15.075"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:15.076" starttime="20190401 12:51:15.076"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:51:15.077" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:51:15.077" starttime="20190401 12:51:15.076"></status>
</kw>
<msg timestamp="20190401 12:51:15.077" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:51:15.077" starttime="20190401 12:51:14.053"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:51:15.077" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:15.077" starttime="20190401 12:51:15.077"></status>
</kw>
<msg timestamp="20190401 12:51:15.077" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:15.077" starttime="20190401 12:51:14.053"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:51:15.078" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:51:15.078" starttime="20190401 12:51:15.078"></status>
</kw>
<status status="FAIL" endtime="20190401 12:51:15.078" starttime="20190401 12:51:14.052"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:51:20.079" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:20.079" starttime="20190401 12:51:20.079"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:20.080" starttime="20190401 12:51:20.080"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:51:20.081" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:51:20.081" starttime="20190401 12:51:20.080"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:20.081" starttime="20190401 12:51:20.081"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:20.082" starttime="20190401 12:51:20.081"></status>
</kw>
<msg timestamp="20190401 12:51:20.082" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:51:20.082" starttime="20190401 12:51:20.080"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:51:20.082" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:20.082" starttime="20190401 12:51:20.082"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:51:20.096" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:20.097" starttime="20190401 12:51:20.082"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:51:21.170" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:51:21.170" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:21.170" starttime="20190401 12:51:20.097"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:51:21.171" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:21.171" starttime="20190401 12:51:21.171"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:51:21.172" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:21.172" starttime="20190401 12:51:21.171"></status>
</kw>
<msg timestamp="20190401 12:51:21.172" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:21.172" starttime="20190401 12:51:21.170"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:51:21.174" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:51:21.174" starttime="20190401 12:51:21.172"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:51:21.175" level="INFO">0</msg>
<msg timestamp="20190401 12:51:21.175" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:21.175" starttime="20190401 12:51:21.175"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:51:21.175" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:51:21.175" starttime="20190401 12:51:21.175"></status>
</kw>
<msg timestamp="20190401 12:51:21.175" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:21.175" starttime="20190401 12:51:21.172"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:21.176" starttime="20190401 12:51:21.176"></status>
</kw>
<status status="PASS" endtime="20190401 12:51:21.176" starttime="20190401 12:51:21.176"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:21.177" starttime="20190401 12:51:21.176"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:51:21.177" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:51:21.177" starttime="20190401 12:51:21.177"></status>
</kw>
<msg timestamp="20190401 12:51:21.177" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:51:21.177" starttime="20190401 12:51:20.080"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:51:21.177" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:21.177" starttime="20190401 12:51:21.177"></status>
</kw>
<msg timestamp="20190401 12:51:21.178" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:21.178" starttime="20190401 12:51:20.079"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:51:21.178" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:51:21.178" starttime="20190401 12:51:21.178"></status>
</kw>
<status status="FAIL" endtime="20190401 12:51:21.178" starttime="20190401 12:51:20.078"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:51:26.180" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:26.180" starttime="20190401 12:51:26.179"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:26.180" starttime="20190401 12:51:26.180"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:51:26.181" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:51:26.181" starttime="20190401 12:51:26.181"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:26.181" starttime="20190401 12:51:26.181"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:26.182" starttime="20190401 12:51:26.182"></status>
</kw>
<msg timestamp="20190401 12:51:26.182" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:51:26.182" starttime="20190401 12:51:26.180"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:51:26.182" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:26.182" starttime="20190401 12:51:26.182"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:51:26.192" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:26.192" starttime="20190401 12:51:26.183"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:51:27.288" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:51:27.288" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:27.288" starttime="20190401 12:51:26.192"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:51:27.289" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:27.289" starttime="20190401 12:51:27.288"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:51:27.289" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:27.289" starttime="20190401 12:51:27.289"></status>
</kw>
<msg timestamp="20190401 12:51:27.289" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:27.289" starttime="20190401 12:51:27.288"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:51:27.291" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:51:27.292" starttime="20190401 12:51:27.290"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:51:27.292" level="INFO">0</msg>
<msg timestamp="20190401 12:51:27.292" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:27.292" starttime="20190401 12:51:27.292"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:51:27.292" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:51:27.292" starttime="20190401 12:51:27.292"></status>
</kw>
<msg timestamp="20190401 12:51:27.293" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:27.293" starttime="20190401 12:51:27.289"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:27.293" starttime="20190401 12:51:27.293"></status>
</kw>
<status status="PASS" endtime="20190401 12:51:27.293" starttime="20190401 12:51:27.293"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:27.294" starttime="20190401 12:51:27.293"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:51:27.294" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:51:27.294" starttime="20190401 12:51:27.294"></status>
</kw>
<msg timestamp="20190401 12:51:27.294" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:51:27.294" starttime="20190401 12:51:26.180"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:51:27.294" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:27.294" starttime="20190401 12:51:27.294"></status>
</kw>
<msg timestamp="20190401 12:51:27.295" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:27.295" starttime="20190401 12:51:26.179"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:51:27.295" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:51:27.295" starttime="20190401 12:51:27.295"></status>
</kw>
<status status="FAIL" endtime="20190401 12:51:27.295" starttime="20190401 12:51:26.179"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:51:32.297" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:32.297" starttime="20190401 12:51:32.296"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:32.297" starttime="20190401 12:51:32.297"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:51:32.298" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:51:32.298" starttime="20190401 12:51:32.298"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:32.298" starttime="20190401 12:51:32.298"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:32.299" starttime="20190401 12:51:32.299"></status>
</kw>
<msg timestamp="20190401 12:51:32.299" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:51:32.299" starttime="20190401 12:51:32.297"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:51:32.299" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:32.299" starttime="20190401 12:51:32.299"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:51:32.312" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:32.312" starttime="20190401 12:51:32.299"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:51:33.332" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:51:33.332" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:33.333" starttime="20190401 12:51:32.312"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:51:33.333" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:33.333" starttime="20190401 12:51:33.333"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:51:33.334" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:33.334" starttime="20190401 12:51:33.333"></status>
</kw>
<msg timestamp="20190401 12:51:33.334" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:33.334" starttime="20190401 12:51:33.333"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:51:33.336" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:51:33.336" starttime="20190401 12:51:33.334"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:51:33.336" level="INFO">0</msg>
<msg timestamp="20190401 12:51:33.336" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:33.336" starttime="20190401 12:51:33.336"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:51:33.337" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:51:33.337" starttime="20190401 12:51:33.336"></status>
</kw>
<msg timestamp="20190401 12:51:33.337" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:33.337" starttime="20190401 12:51:33.334"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:33.338" starttime="20190401 12:51:33.337"></status>
</kw>
<status status="PASS" endtime="20190401 12:51:33.338" starttime="20190401 12:51:33.337"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:33.338" starttime="20190401 12:51:33.338"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:51:33.338" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:51:33.338" starttime="20190401 12:51:33.338"></status>
</kw>
<msg timestamp="20190401 12:51:33.339" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:51:33.339" starttime="20190401 12:51:32.297"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:51:33.339" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:33.339" starttime="20190401 12:51:33.339"></status>
</kw>
<msg timestamp="20190401 12:51:33.339" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:33.339" starttime="20190401 12:51:32.296"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:51:33.340" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:51:33.340" starttime="20190401 12:51:33.339"></status>
</kw>
<status status="FAIL" endtime="20190401 12:51:33.340" starttime="20190401 12:51:32.296"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:51:38.341" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:38.341" starttime="20190401 12:51:38.341"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:38.342" starttime="20190401 12:51:38.342"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:51:38.343" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:51:38.343" starttime="20190401 12:51:38.342"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:38.343" starttime="20190401 12:51:38.343"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:38.343" starttime="20190401 12:51:38.343"></status>
</kw>
<msg timestamp="20190401 12:51:38.344" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:51:38.344" starttime="20190401 12:51:38.342"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:51:38.344" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:38.344" starttime="20190401 12:51:38.344"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:51:38.354" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:38.354" starttime="20190401 12:51:38.344"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:51:39.351" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:51:39.351" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:39.352" starttime="20190401 12:51:38.354"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:51:39.352" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:39.352" starttime="20190401 12:51:39.352"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:51:39.353" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:39.353" starttime="20190401 12:51:39.352"></status>
</kw>
<msg timestamp="20190401 12:51:39.353" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:39.353" starttime="20190401 12:51:39.352"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:51:39.355" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:51:39.355" starttime="20190401 12:51:39.353"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:51:39.356" level="INFO">0</msg>
<msg timestamp="20190401 12:51:39.356" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:39.356" starttime="20190401 12:51:39.355"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:51:39.356" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:51:39.357" starttime="20190401 12:51:39.356"></status>
</kw>
<msg timestamp="20190401 12:51:39.357" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:39.357" starttime="20190401 12:51:39.353"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:39.358" starttime="20190401 12:51:39.358"></status>
</kw>
<status status="PASS" endtime="20190401 12:51:39.358" starttime="20190401 12:51:39.357"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:39.358" starttime="20190401 12:51:39.358"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:51:39.359" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:51:39.359" starttime="20190401 12:51:39.359"></status>
</kw>
<msg timestamp="20190401 12:51:39.359" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:51:39.359" starttime="20190401 12:51:38.341"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:51:39.360" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:39.360" starttime="20190401 12:51:39.359"></status>
</kw>
<msg timestamp="20190401 12:51:39.360" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:39.360" starttime="20190401 12:51:38.341"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:51:39.361" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:51:39.361" starttime="20190401 12:51:39.361"></status>
</kw>
<status status="FAIL" endtime="20190401 12:51:39.361" starttime="20190401 12:51:38.340"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:51:44.363" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:44.363" starttime="20190401 12:51:44.363"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:44.365" starttime="20190401 12:51:44.364"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:51:44.366" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:51:44.366" starttime="20190401 12:51:44.365"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:44.367" starttime="20190401 12:51:44.366"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:44.367" starttime="20190401 12:51:44.367"></status>
</kw>
<msg timestamp="20190401 12:51:44.368" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:51:44.368" starttime="20190401 12:51:44.365"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:51:44.368" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:44.368" starttime="20190401 12:51:44.368"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:51:44.389" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:44.389" starttime="20190401 12:51:44.368"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:51:45.378" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:51:45.378" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:45.378" starttime="20190401 12:51:44.390"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:51:45.379" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:45.379" starttime="20190401 12:51:45.379"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:51:45.379" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:45.379" starttime="20190401 12:51:45.379"></status>
</kw>
<msg timestamp="20190401 12:51:45.379" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:45.379" starttime="20190401 12:51:45.378"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:51:45.382" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:51:45.382" starttime="20190401 12:51:45.380"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:51:45.382" level="INFO">0</msg>
<msg timestamp="20190401 12:51:45.382" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:45.382" starttime="20190401 12:51:45.382"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:51:45.383" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:51:45.383" starttime="20190401 12:51:45.382"></status>
</kw>
<msg timestamp="20190401 12:51:45.383" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:45.383" starttime="20190401 12:51:45.379"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:45.384" starttime="20190401 12:51:45.384"></status>
</kw>
<status status="PASS" endtime="20190401 12:51:45.384" starttime="20190401 12:51:45.383"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:45.385" starttime="20190401 12:51:45.385"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:51:45.385" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:51:45.385" starttime="20190401 12:51:45.385"></status>
</kw>
<msg timestamp="20190401 12:51:45.385" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:51:45.385" starttime="20190401 12:51:44.364"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:51:45.386" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:45.386" starttime="20190401 12:51:45.385"></status>
</kw>
<msg timestamp="20190401 12:51:45.386" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:45.386" starttime="20190401 12:51:44.362"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:51:45.386" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:51:45.386" starttime="20190401 12:51:45.386"></status>
</kw>
<status status="FAIL" endtime="20190401 12:51:45.387" starttime="20190401 12:51:44.362"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:51:50.388" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:50.388" starttime="20190401 12:51:50.388"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:50.389" starttime="20190401 12:51:50.389"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:51:50.390" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:51:50.390" starttime="20190401 12:51:50.389"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:50.390" starttime="20190401 12:51:50.390"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:50.390" starttime="20190401 12:51:50.390"></status>
</kw>
<msg timestamp="20190401 12:51:50.391" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:51:50.391" starttime="20190401 12:51:50.389"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:51:50.391" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:50.391" starttime="20190401 12:51:50.391"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:51:50.393" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:50.393" starttime="20190401 12:51:50.391"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:51:51.391" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:51:51.392" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:51.392" starttime="20190401 12:51:50.393"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:51:51.392" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:51.393" starttime="20190401 12:51:51.392"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:51:51.393" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:51.393" starttime="20190401 12:51:51.393"></status>
</kw>
<msg timestamp="20190401 12:51:51.393" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:51.393" starttime="20190401 12:51:51.392"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:51:51.396" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:51:51.396" starttime="20190401 12:51:51.393"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:51:51.396" level="INFO">0</msg>
<msg timestamp="20190401 12:51:51.396" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:51.396" starttime="20190401 12:51:51.396"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:51:51.397" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:51:51.397" starttime="20190401 12:51:51.397"></status>
</kw>
<msg timestamp="20190401 12:51:51.397" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:51.397" starttime="20190401 12:51:51.393"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:51.398" starttime="20190401 12:51:51.397"></status>
</kw>
<status status="PASS" endtime="20190401 12:51:51.398" starttime="20190401 12:51:51.397"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:51.398" starttime="20190401 12:51:51.398"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:51:51.398" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:51:51.398" starttime="20190401 12:51:51.398"></status>
</kw>
<msg timestamp="20190401 12:51:51.398" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:51:51.399" starttime="20190401 12:51:50.388"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:51:51.399" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:51.399" starttime="20190401 12:51:51.399"></status>
</kw>
<msg timestamp="20190401 12:51:51.399" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:51.399" starttime="20190401 12:51:50.387"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:51:51.399" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:51:51.400" starttime="20190401 12:51:51.399"></status>
</kw>
<status status="FAIL" endtime="20190401 12:51:51.400" starttime="20190401 12:51:50.387"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:51:56.401" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:56.401" starttime="20190401 12:51:56.401"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:56.402" starttime="20190401 12:51:56.402"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:51:56.403" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:51:56.403" starttime="20190401 12:51:56.402"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:56.403" starttime="20190401 12:51:56.403"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:56.403" starttime="20190401 12:51:56.403"></status>
</kw>
<msg timestamp="20190401 12:51:56.404" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:51:56.404" starttime="20190401 12:51:56.402"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:51:56.404" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:56.404" starttime="20190401 12:51:56.404"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:51:56.412" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:51:56.413" starttime="20190401 12:51:56.404"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:51:57.500" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:51:57.500" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:57.500" starttime="20190401 12:51:56.413"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:51:57.501" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:51:57.501" starttime="20190401 12:51:57.501"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:51:57.501" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:57.501" starttime="20190401 12:51:57.501"></status>
</kw>
<msg timestamp="20190401 12:51:57.501" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:51:57.501" starttime="20190401 12:51:57.500"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:51:57.504" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:51:57.504" starttime="20190401 12:51:57.502"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:51:57.505" level="INFO">0</msg>
<msg timestamp="20190401 12:51:57.505" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:57.505" starttime="20190401 12:51:57.504"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:51:57.505" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:51:57.505" starttime="20190401 12:51:57.505"></status>
</kw>
<msg timestamp="20190401 12:51:57.505" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:51:57.505" starttime="20190401 12:51:57.502"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:57.506" starttime="20190401 12:51:57.506"></status>
</kw>
<status status="PASS" endtime="20190401 12:51:57.506" starttime="20190401 12:51:57.505"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:51:57.506" starttime="20190401 12:51:57.506"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:51:57.507" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:51:57.507" starttime="20190401 12:51:57.506"></status>
</kw>
<msg timestamp="20190401 12:51:57.507" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:51:57.507" starttime="20190401 12:51:56.401"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:51:57.507" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:57.507" starttime="20190401 12:51:57.507"></status>
</kw>
<msg timestamp="20190401 12:51:57.507" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:51:57.507" starttime="20190401 12:51:56.400"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:51:57.508" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:51:57.508" starttime="20190401 12:51:57.508"></status>
</kw>
<status status="FAIL" endtime="20190401 12:51:57.508" starttime="20190401 12:51:56.400"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:52:02.509" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:02.509" starttime="20190401 12:52:02.509"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:02.510" starttime="20190401 12:52:02.510"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:52:02.511" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:52:02.511" starttime="20190401 12:52:02.511"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:02.512" starttime="20190401 12:52:02.511"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:02.512" starttime="20190401 12:52:02.512"></status>
</kw>
<msg timestamp="20190401 12:52:02.512" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:52:02.512" starttime="20190401 12:52:02.511"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:52:02.512" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:02.513" starttime="20190401 12:52:02.512"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:52:02.523" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:02.523" starttime="20190401 12:52:02.513"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:52:03.525" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:52:03.525" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:03.525" starttime="20190401 12:52:02.523"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:52:03.526" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:03.526" starttime="20190401 12:52:03.526"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:52:03.526" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:52:03.526" starttime="20190401 12:52:03.526"></status>
</kw>
<msg timestamp="20190401 12:52:03.527" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:52:03.527" starttime="20190401 12:52:03.525"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:52:03.528" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:52:03.529" starttime="20190401 12:52:03.527"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:52:03.529" level="INFO">0</msg>
<msg timestamp="20190401 12:52:03.529" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:03.529" starttime="20190401 12:52:03.529"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:52:03.530" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:52:03.530" starttime="20190401 12:52:03.529"></status>
</kw>
<msg timestamp="20190401 12:52:03.530" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:03.530" starttime="20190401 12:52:03.527"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:03.531" starttime="20190401 12:52:03.530"></status>
</kw>
<status status="PASS" endtime="20190401 12:52:03.531" starttime="20190401 12:52:03.530"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:03.531" starttime="20190401 12:52:03.531"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:52:03.531" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:52:03.531" starttime="20190401 12:52:03.531"></status>
</kw>
<msg timestamp="20190401 12:52:03.531" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:52:03.531" starttime="20190401 12:52:02.510"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:52:03.532" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:52:03.532" starttime="20190401 12:52:03.531"></status>
</kw>
<msg timestamp="20190401 12:52:03.532" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:52:03.532" starttime="20190401 12:52:02.509"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:52:03.532" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:52:03.532" starttime="20190401 12:52:03.532"></status>
</kw>
<status status="FAIL" endtime="20190401 12:52:03.533" starttime="20190401 12:52:02.508"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:52:08.534" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:08.534" starttime="20190401 12:52:08.534"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:08.535" starttime="20190401 12:52:08.535"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:52:08.536" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:52:08.536" starttime="20190401 12:52:08.535"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:08.536" starttime="20190401 12:52:08.536"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:08.536" starttime="20190401 12:52:08.536"></status>
</kw>
<msg timestamp="20190401 12:52:08.537" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:52:08.537" starttime="20190401 12:52:08.535"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:52:08.537" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:08.537" starttime="20190401 12:52:08.537"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:52:08.547" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:08.547" starttime="20190401 12:52:08.537"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:52:09.608" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:52:09.608" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:09.608" starttime="20190401 12:52:08.547"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:52:09.609" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:09.609" starttime="20190401 12:52:09.609"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:52:09.609" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:52:09.609" starttime="20190401 12:52:09.609"></status>
</kw>
<msg timestamp="20190401 12:52:09.609" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:52:09.609" starttime="20190401 12:52:09.608"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:52:09.611" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:52:09.611" starttime="20190401 12:52:09.610"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:52:09.611" level="INFO">0</msg>
<msg timestamp="20190401 12:52:09.612" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:09.612" starttime="20190401 12:52:09.611"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:52:09.612" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:52:09.612" starttime="20190401 12:52:09.612"></status>
</kw>
<msg timestamp="20190401 12:52:09.612" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:09.612" starttime="20190401 12:52:09.609"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:09.613" starttime="20190401 12:52:09.613"></status>
</kw>
<status status="PASS" endtime="20190401 12:52:09.613" starttime="20190401 12:52:09.612"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:09.613" starttime="20190401 12:52:09.613"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:52:09.613" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:52:09.614" starttime="20190401 12:52:09.613"></status>
</kw>
<msg timestamp="20190401 12:52:09.614" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:52:09.614" starttime="20190401 12:52:08.534"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:52:09.614" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:52:09.614" starttime="20190401 12:52:09.614"></status>
</kw>
<msg timestamp="20190401 12:52:09.614" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:52:09.614" starttime="20190401 12:52:08.533"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:52:09.615" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:52:09.615" starttime="20190401 12:52:09.614"></status>
</kw>
<status status="FAIL" endtime="20190401 12:52:09.615" starttime="20190401 12:52:08.533"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:52:14.616" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:14.616" starttime="20190401 12:52:14.616"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:14.617" starttime="20190401 12:52:14.617"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:52:14.618" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:52:14.618" starttime="20190401 12:52:14.617"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:14.618" starttime="20190401 12:52:14.618"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:14.619" starttime="20190401 12:52:14.618"></status>
</kw>
<msg timestamp="20190401 12:52:14.619" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:52:14.619" starttime="20190401 12:52:14.617"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:52:14.619" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:14.619" starttime="20190401 12:52:14.619"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:52:14.627" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:14.627" starttime="20190401 12:52:14.619"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:52:15.630" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:52:15.630" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:15.630" starttime="20190401 12:52:14.628"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:52:15.631" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:15.631" starttime="20190401 12:52:15.631"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:52:15.631" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:52:15.631" starttime="20190401 12:52:15.631"></status>
</kw>
<msg timestamp="20190401 12:52:15.631" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:52:15.631" starttime="20190401 12:52:15.630"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:52:15.634" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:52:15.634" starttime="20190401 12:52:15.632"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:52:15.634" level="INFO">0</msg>
<msg timestamp="20190401 12:52:15.634" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:15.634" starttime="20190401 12:52:15.634"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:52:15.635" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:52:15.635" starttime="20190401 12:52:15.634"></status>
</kw>
<msg timestamp="20190401 12:52:15.635" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:15.635" starttime="20190401 12:52:15.632"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:15.636" starttime="20190401 12:52:15.635"></status>
</kw>
<status status="PASS" endtime="20190401 12:52:15.636" starttime="20190401 12:52:15.635"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:15.636" starttime="20190401 12:52:15.636"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:52:15.636" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:52:15.636" starttime="20190401 12:52:15.636"></status>
</kw>
<msg timestamp="20190401 12:52:15.636" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:52:15.636" starttime="20190401 12:52:14.616"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:52:15.637" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:52:15.637" starttime="20190401 12:52:15.637"></status>
</kw>
<msg timestamp="20190401 12:52:15.637" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:52:15.637" starttime="20190401 12:52:14.616"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:52:15.637" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:52:15.637" starttime="20190401 12:52:15.637"></status>
</kw>
<status status="FAIL" endtime="20190401 12:52:15.638" starttime="20190401 12:52:14.615"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:52:20.639" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:20.639" starttime="20190401 12:52:20.639"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:20.640" starttime="20190401 12:52:20.640"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:52:20.640" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:52:20.640" starttime="20190401 12:52:20.640"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:20.641" starttime="20190401 12:52:20.641"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:20.641" starttime="20190401 12:52:20.641"></status>
</kw>
<msg timestamp="20190401 12:52:20.641" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:52:20.641" starttime="20190401 12:52:20.640"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:52:20.642" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:20.642" starttime="20190401 12:52:20.642"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:52:20.653" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:20.653" starttime="20190401 12:52:20.642"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:52:21.654" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:52:21.654" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:21.654" starttime="20190401 12:52:20.653"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:52:21.655" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:21.655" starttime="20190401 12:52:21.654"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:52:21.655" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:52:21.655" starttime="20190401 12:52:21.655"></status>
</kw>
<msg timestamp="20190401 12:52:21.655" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:52:21.655" starttime="20190401 12:52:21.654"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:52:21.657" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:52:21.657" starttime="20190401 12:52:21.656"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:52:21.657" level="INFO">0</msg>
<msg timestamp="20190401 12:52:21.658" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:21.658" starttime="20190401 12:52:21.657"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:52:21.658" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:52:21.658" starttime="20190401 12:52:21.658"></status>
</kw>
<msg timestamp="20190401 12:52:21.658" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:21.658" starttime="20190401 12:52:21.655"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:21.659" starttime="20190401 12:52:21.659"></status>
</kw>
<status status="PASS" endtime="20190401 12:52:21.659" starttime="20190401 12:52:21.658"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:21.659" starttime="20190401 12:52:21.659"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:52:21.660" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:52:21.660" starttime="20190401 12:52:21.659"></status>
</kw>
<msg timestamp="20190401 12:52:21.660" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:52:21.660" starttime="20190401 12:52:20.639"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:52:21.660" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:52:21.660" starttime="20190401 12:52:21.660"></status>
</kw>
<msg timestamp="20190401 12:52:21.660" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:52:21.660" starttime="20190401 12:52:20.638"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:52:21.661" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:52:21.661" starttime="20190401 12:52:21.660"></status>
</kw>
<status status="FAIL" endtime="20190401 12:52:21.661" starttime="20190401 12:52:20.638"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:52:26.662" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:26.662" starttime="20190401 12:52:26.662"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:26.663" starttime="20190401 12:52:26.663"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:52:26.664" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:52:26.664" starttime="20190401 12:52:26.663"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:26.664" starttime="20190401 12:52:26.664"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:26.665" starttime="20190401 12:52:26.664"></status>
</kw>
<msg timestamp="20190401 12:52:26.665" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:52:26.665" starttime="20190401 12:52:26.663"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:52:26.665" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:26.665" starttime="20190401 12:52:26.665"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:52:26.676" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:26.676" starttime="20190401 12:52:26.665"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:52:27.728" level="INFO">installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:52:27.728" level="INFO">${output} = installing
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:27.728" starttime="20190401 12:52:26.677"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:52:27.729" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:27.729" starttime="20190401 12:52:27.729"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:52:27.730" level="INFO">${clean_out} = installing
</msg>
<status status="PASS" endtime="20190401 12:52:27.730" starttime="20190401 12:52:27.730"></status>
</kw>
<msg timestamp="20190401 12:52:27.730" level="INFO">${output} = installing
</msg>
<status status="PASS" endtime="20190401 12:52:27.730" starttime="20190401 12:52:27.729"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:52:27.732" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:52:27.732" starttime="20190401 12:52:27.730"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:52:27.732" level="INFO">0</msg>
<msg timestamp="20190401 12:52:27.732" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:27.732" starttime="20190401 12:52:27.732"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:52:27.733" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:52:27.733" starttime="20190401 12:52:27.732"></status>
</kw>
<msg timestamp="20190401 12:52:27.733" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:27.733" starttime="20190401 12:52:27.730"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:27.734" starttime="20190401 12:52:27.733"></status>
</kw>
<status status="PASS" endtime="20190401 12:52:27.734" starttime="20190401 12:52:27.733"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:27.734" starttime="20190401 12:52:27.734"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:52:27.734" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: installing</msg>
<status status="PASS" endtime="20190401 12:52:27.734" starttime="20190401 12:52:27.734"></status>
</kw>
<msg timestamp="20190401 12:52:27.734" level="INFO">${result} = {u'stdout': u'installing', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:52:27.734" starttime="20190401 12:52:26.662"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:52:27.735" level="INFO">${value} = installing</msg>
<status status="PASS" endtime="20190401 12:52:27.735" starttime="20190401 12:52:27.735"></status>
</kw>
<msg timestamp="20190401 12:52:27.735" level="INFO">${current_value} = installing</msg>
<status status="PASS" endtime="20190401 12:52:27.735" starttime="20190401 12:52:26.662"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:52:27.735" level="FAIL">installing != completed</msg>
<status status="FAIL" endtime="20190401 12:52:27.735" starttime="20190401 12:52:27.735"></status>
</kw>
<status status="FAIL" endtime="20190401 12:52:27.736" starttime="20190401 12:52:26.661"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:52:32.737" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:32.737" starttime="20190401 12:52:32.737"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:32.738" starttime="20190401 12:52:32.738"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:52:32.739" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:52:32.739" starttime="20190401 12:52:32.738"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:32.739" starttime="20190401 12:52:32.739"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:32.739" starttime="20190401 12:52:32.739"></status>
</kw>
<msg timestamp="20190401 12:52:32.740" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:52:32.740" starttime="20190401 12:52:32.738"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:52:32.740" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:32.740" starttime="20190401 12:52:32.740"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:52:32.753" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:32.753" starttime="20190401 12:52:32.740"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:52:33.749" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:52:33.749" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:33.749" starttime="20190401 12:52:32.753"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:52:33.750" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:33.750" starttime="20190401 12:52:33.749"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:52:33.750" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:52:33.750" starttime="20190401 12:52:33.750"></status>
</kw>
<msg timestamp="20190401 12:52:33.750" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:52:33.750" starttime="20190401 12:52:33.749"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:52:33.753" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:52:33.753" starttime="20190401 12:52:33.751"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:52:33.754" level="INFO">0</msg>
<msg timestamp="20190401 12:52:33.754" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:33.754" starttime="20190401 12:52:33.753"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:52:33.754" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:52:33.754" starttime="20190401 12:52:33.754"></status>
</kw>
<msg timestamp="20190401 12:52:33.754" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:33.754" starttime="20190401 12:52:33.750"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:33.755" starttime="20190401 12:52:33.755"></status>
</kw>
<status status="PASS" endtime="20190401 12:52:33.755" starttime="20190401 12:52:33.755"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:33.755" starttime="20190401 12:52:33.755"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:52:33.756" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:52:33.756" starttime="20190401 12:52:33.756"></status>
</kw>
<msg timestamp="20190401 12:52:33.756" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:52:33.756" starttime="20190401 12:52:32.737"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:52:33.756" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:52:33.756" starttime="20190401 12:52:33.756"></status>
</kw>
<msg timestamp="20190401 12:52:33.757" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:52:33.757" starttime="20190401 12:52:32.736"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:52:33.757" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:52:33.757" starttime="20190401 12:52:33.757"></status>
</kw>
<status status="FAIL" endtime="20190401 12:52:33.757" starttime="20190401 12:52:32.736"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:52:38.759" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:38.759" starttime="20190401 12:52:38.758"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:38.759" starttime="20190401 12:52:38.759"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:52:38.760" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:52:38.760" starttime="20190401 12:52:38.760"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:38.760" starttime="20190401 12:52:38.760"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:38.761" starttime="20190401 12:52:38.760"></status>
</kw>
<msg timestamp="20190401 12:52:38.761" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:52:38.761" starttime="20190401 12:52:38.759"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:52:38.761" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:38.761" starttime="20190401 12:52:38.761"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:52:38.772" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:38.772" starttime="20190401 12:52:38.761"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:52:39.796" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:52:39.796" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:39.796" starttime="20190401 12:52:38.772"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:52:39.797" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:39.797" starttime="20190401 12:52:39.797"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:52:39.798" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:52:39.798" starttime="20190401 12:52:39.797"></status>
</kw>
<msg timestamp="20190401 12:52:39.798" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:52:39.798" starttime="20190401 12:52:39.797"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:52:39.800" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:52:39.800" starttime="20190401 12:52:39.798"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:52:39.800" level="INFO">0</msg>
<msg timestamp="20190401 12:52:39.800" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:39.800" starttime="20190401 12:52:39.800"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:52:39.801" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:52:39.801" starttime="20190401 12:52:39.801"></status>
</kw>
<msg timestamp="20190401 12:52:39.801" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:39.801" starttime="20190401 12:52:39.798"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:39.802" starttime="20190401 12:52:39.802"></status>
</kw>
<status status="PASS" endtime="20190401 12:52:39.802" starttime="20190401 12:52:39.801"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:39.802" starttime="20190401 12:52:39.802"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:52:39.802" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:52:39.803" starttime="20190401 12:52:39.802"></status>
</kw>
<msg timestamp="20190401 12:52:39.803" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:52:39.803" starttime="20190401 12:52:38.759"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:52:39.803" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:52:39.803" starttime="20190401 12:52:39.803"></status>
</kw>
<msg timestamp="20190401 12:52:39.803" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:52:39.803" starttime="20190401 12:52:38.758"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:52:39.804" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:52:39.804" starttime="20190401 12:52:39.803"></status>
</kw>
<status status="FAIL" endtime="20190401 12:52:39.804" starttime="20190401 12:52:38.757"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:52:44.805" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:44.805" starttime="20190401 12:52:44.805"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:44.806" starttime="20190401 12:52:44.806"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:52:44.807" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:52:44.807" starttime="20190401 12:52:44.806"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:44.807" starttime="20190401 12:52:44.807"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:44.807" starttime="20190401 12:52:44.807"></status>
</kw>
<msg timestamp="20190401 12:52:44.808" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:52:44.808" starttime="20190401 12:52:44.806"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:52:44.808" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:44.808" starttime="20190401 12:52:44.808"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:52:44.823" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:44.823" starttime="20190401 12:52:44.808"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:52:45.811" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:52:45.811" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:45.811" starttime="20190401 12:52:44.823"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:52:45.812" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:45.812" starttime="20190401 12:52:45.812"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:52:45.812" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:52:45.812" starttime="20190401 12:52:45.812"></status>
</kw>
<msg timestamp="20190401 12:52:45.813" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:52:45.813" starttime="20190401 12:52:45.811"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:52:45.815" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:52:45.815" starttime="20190401 12:52:45.813"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:52:45.816" level="INFO">0</msg>
<msg timestamp="20190401 12:52:45.816" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:45.816" starttime="20190401 12:52:45.815"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:52:45.816" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:52:45.816" starttime="20190401 12:52:45.816"></status>
</kw>
<msg timestamp="20190401 12:52:45.817" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:45.817" starttime="20190401 12:52:45.813"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:45.817" starttime="20190401 12:52:45.817"></status>
</kw>
<status status="PASS" endtime="20190401 12:52:45.817" starttime="20190401 12:52:45.817"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:45.818" starttime="20190401 12:52:45.818"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:52:45.818" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:52:45.818" starttime="20190401 12:52:45.818"></status>
</kw>
<msg timestamp="20190401 12:52:45.818" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:52:45.818" starttime="20190401 12:52:44.805"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:52:45.819" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:52:45.819" starttime="20190401 12:52:45.818"></status>
</kw>
<msg timestamp="20190401 12:52:45.819" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:52:45.819" starttime="20190401 12:52:44.805"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:52:45.819" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:52:45.820" starttime="20190401 12:52:45.819"></status>
</kw>
<status status="FAIL" endtime="20190401 12:52:45.820" starttime="20190401 12:52:44.804"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:52:50.821" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:50.821" starttime="20190401 12:52:50.821"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:50.822" starttime="20190401 12:52:50.822"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:52:50.823" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:52:50.823" starttime="20190401 12:52:50.822"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:50.823" starttime="20190401 12:52:50.823"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:50.823" starttime="20190401 12:52:50.823"></status>
</kw>
<msg timestamp="20190401 12:52:50.823" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:52:50.824" starttime="20190401 12:52:50.822"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:52:50.824" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:50.824" starttime="20190401 12:52:50.824"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:52:50.838" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:50.838" starttime="20190401 12:52:50.824"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:52:51.823" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:52:51.823" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:51.823" starttime="20190401 12:52:50.839"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:52:51.824" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:51.824" starttime="20190401 12:52:51.824"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:52:51.824" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:52:51.825" starttime="20190401 12:52:51.824"></status>
</kw>
<msg timestamp="20190401 12:52:51.825" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:52:51.825" starttime="20190401 12:52:51.824"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:52:51.829" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:52:51.830" starttime="20190401 12:52:51.825"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:52:51.830" level="INFO">0</msg>
<msg timestamp="20190401 12:52:51.830" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:51.830" starttime="20190401 12:52:51.830"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:52:51.830" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:52:51.830" starttime="20190401 12:52:51.830"></status>
</kw>
<msg timestamp="20190401 12:52:51.831" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:51.831" starttime="20190401 12:52:51.825"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:51.831" starttime="20190401 12:52:51.831"></status>
</kw>
<status status="PASS" endtime="20190401 12:52:51.831" starttime="20190401 12:52:51.831"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:51.832" starttime="20190401 12:52:51.832"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:52:51.832" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:52:51.832" starttime="20190401 12:52:51.832"></status>
</kw>
<msg timestamp="20190401 12:52:51.832" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:52:51.832" starttime="20190401 12:52:50.821"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:52:51.833" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:52:51.833" starttime="20190401 12:52:51.832"></status>
</kw>
<msg timestamp="20190401 12:52:51.833" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:52:51.833" starttime="20190401 12:52:50.820"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:52:51.833" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:52:51.834" starttime="20190401 12:52:51.833"></status>
</kw>
<status status="FAIL" endtime="20190401 12:52:51.834" starttime="20190401 12:52:50.820"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:52:56.835" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:56.835" starttime="20190401 12:52:56.835"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:56.836" starttime="20190401 12:52:56.836"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:52:56.837" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:52:56.837" starttime="20190401 12:52:56.836"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:56.837" starttime="20190401 12:52:56.837"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:56.838" starttime="20190401 12:52:56.837"></status>
</kw>
<msg timestamp="20190401 12:52:56.838" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:52:56.838" starttime="20190401 12:52:56.836"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:52:56.838" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:56.838" starttime="20190401 12:52:56.838"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:52:56.849" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:52:56.849" starttime="20190401 12:52:56.838"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:52:57.880" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:52:57.881" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:57.881" starttime="20190401 12:52:56.849"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:52:57.881" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:52:57.881" starttime="20190401 12:52:57.881"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:52:57.882" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:52:57.882" starttime="20190401 12:52:57.882"></status>
</kw>
<msg timestamp="20190401 12:52:57.882" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:52:57.882" starttime="20190401 12:52:57.881"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:52:57.883" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:52:57.883" starttime="20190401 12:52:57.882"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:52:57.884" level="INFO">0</msg>
<msg timestamp="20190401 12:52:57.884" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:57.884" starttime="20190401 12:52:57.883"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:52:57.884" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:52:57.885" starttime="20190401 12:52:57.884"></status>
</kw>
<msg timestamp="20190401 12:52:57.885" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:52:57.885" starttime="20190401 12:52:57.882"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:57.885" starttime="20190401 12:52:57.885"></status>
</kw>
<status status="PASS" endtime="20190401 12:52:57.885" starttime="20190401 12:52:57.885"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:52:57.886" starttime="20190401 12:52:57.886"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:52:57.886" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:52:57.886" starttime="20190401 12:52:57.886"></status>
</kw>
<msg timestamp="20190401 12:52:57.886" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:52:57.886" starttime="20190401 12:52:56.835"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:52:57.887" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:52:57.887" starttime="20190401 12:52:57.886"></status>
</kw>
<msg timestamp="20190401 12:52:57.887" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:52:57.887" starttime="20190401 12:52:56.834"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:52:57.887" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:52:57.887" starttime="20190401 12:52:57.887"></status>
</kw>
<status status="FAIL" endtime="20190401 12:52:57.887" starttime="20190401 12:52:56.834"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:53:02.889" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:02.889" starttime="20190401 12:53:02.889"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:02.890" starttime="20190401 12:53:02.890"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:53:02.891" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:53:02.891" starttime="20190401 12:53:02.890"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:02.891" starttime="20190401 12:53:02.891"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:02.891" starttime="20190401 12:53:02.891"></status>
</kw>
<msg timestamp="20190401 12:53:02.892" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:53:02.892" starttime="20190401 12:53:02.890"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:53:02.892" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:02.892" starttime="20190401 12:53:02.892"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:53:02.903" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:02.903" starttime="20190401 12:53:02.892"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:53:03.920" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:53:03.920" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:03.921" starttime="20190401 12:53:02.903"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:53:03.921" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:03.921" starttime="20190401 12:53:03.921"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:53:03.922" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:03.922" starttime="20190401 12:53:03.921"></status>
</kw>
<msg timestamp="20190401 12:53:03.922" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:03.922" starttime="20190401 12:53:03.921"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:53:03.924" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:53:03.924" starttime="20190401 12:53:03.922"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:53:03.924" level="INFO">0</msg>
<msg timestamp="20190401 12:53:03.924" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:03.924" starttime="20190401 12:53:03.924"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:53:03.925" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:53:03.925" starttime="20190401 12:53:03.924"></status>
</kw>
<msg timestamp="20190401 12:53:03.925" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:03.925" starttime="20190401 12:53:03.922"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:03.926" starttime="20190401 12:53:03.925"></status>
</kw>
<status status="PASS" endtime="20190401 12:53:03.926" starttime="20190401 12:53:03.925"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:03.926" starttime="20190401 12:53:03.926"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:53:03.926" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:53:03.926" starttime="20190401 12:53:03.926"></status>
</kw>
<msg timestamp="20190401 12:53:03.926" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:53:03.926" starttime="20190401 12:53:02.889"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:53:03.927" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:03.927" starttime="20190401 12:53:03.927"></status>
</kw>
<msg timestamp="20190401 12:53:03.927" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:03.927" starttime="20190401 12:53:02.888"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:53:03.927" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:53:03.928" starttime="20190401 12:53:03.927"></status>
</kw>
<status status="FAIL" endtime="20190401 12:53:03.928" starttime="20190401 12:53:02.888"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:53:08.929" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:08.929" starttime="20190401 12:53:08.929"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:08.930" starttime="20190401 12:53:08.930"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:53:08.931" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:53:08.931" starttime="20190401 12:53:08.930"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:08.931" starttime="20190401 12:53:08.931"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:08.932" starttime="20190401 12:53:08.931"></status>
</kw>
<msg timestamp="20190401 12:53:08.932" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:53:08.932" starttime="20190401 12:53:08.930"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:53:08.932" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:08.932" starttime="20190401 12:53:08.932"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:53:08.941" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:08.941" starttime="20190401 12:53:08.932"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:53:09.933" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:53:09.934" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:09.934" starttime="20190401 12:53:08.941"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:53:09.934" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:09.934" starttime="20190401 12:53:09.934"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:53:09.935" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:09.935" starttime="20190401 12:53:09.934"></status>
</kw>
<msg timestamp="20190401 12:53:09.935" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:09.935" starttime="20190401 12:53:09.934"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:53:09.937" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:53:09.937" starttime="20190401 12:53:09.935"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:53:09.937" level="INFO">0</msg>
<msg timestamp="20190401 12:53:09.937" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:09.937" starttime="20190401 12:53:09.937"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:53:09.938" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:53:09.938" starttime="20190401 12:53:09.937"></status>
</kw>
<msg timestamp="20190401 12:53:09.938" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:09.938" starttime="20190401 12:53:09.935"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:09.939" starttime="20190401 12:53:09.938"></status>
</kw>
<status status="PASS" endtime="20190401 12:53:09.939" starttime="20190401 12:53:09.938"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:09.939" starttime="20190401 12:53:09.939"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:53:09.939" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:53:09.939" starttime="20190401 12:53:09.939"></status>
</kw>
<msg timestamp="20190401 12:53:09.939" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:53:09.939" starttime="20190401 12:53:08.929"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:53:09.940" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:09.940" starttime="20190401 12:53:09.940"></status>
</kw>
<msg timestamp="20190401 12:53:09.940" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:09.940" starttime="20190401 12:53:08.928"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:53:09.940" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:53:09.940" starttime="20190401 12:53:09.940"></status>
</kw>
<status status="FAIL" endtime="20190401 12:53:09.941" starttime="20190401 12:53:08.928"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:53:14.943" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:14.943" starttime="20190401 12:53:14.942"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:14.944" starttime="20190401 12:53:14.944"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:53:14.946" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:53:14.946" starttime="20190401 12:53:14.945"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:14.946" starttime="20190401 12:53:14.946"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:14.947" starttime="20190401 12:53:14.946"></status>
</kw>
<msg timestamp="20190401 12:53:14.947" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:53:14.947" starttime="20190401 12:53:14.944"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:53:14.948" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:14.948" starttime="20190401 12:53:14.947"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:53:14.966" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:14.966" starttime="20190401 12:53:14.948"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:53:15.946" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:53:15.946" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:15.946" starttime="20190401 12:53:14.966"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:53:15.947" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:15.947" starttime="20190401 12:53:15.947"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:53:15.947" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:15.948" starttime="20190401 12:53:15.947"></status>
</kw>
<msg timestamp="20190401 12:53:15.948" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:15.948" starttime="20190401 12:53:15.947"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:53:15.949" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:53:15.949" starttime="20190401 12:53:15.948"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:53:15.950" level="INFO">0</msg>
<msg timestamp="20190401 12:53:15.950" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:15.950" starttime="20190401 12:53:15.949"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:53:15.950" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:53:15.950" starttime="20190401 12:53:15.950"></status>
</kw>
<msg timestamp="20190401 12:53:15.950" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:15.950" starttime="20190401 12:53:15.948"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:15.951" starttime="20190401 12:53:15.951"></status>
</kw>
<status status="PASS" endtime="20190401 12:53:15.951" starttime="20190401 12:53:15.950"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:15.951" starttime="20190401 12:53:15.951"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:53:15.952" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:53:15.952" starttime="20190401 12:53:15.951"></status>
</kw>
<msg timestamp="20190401 12:53:15.952" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:53:15.952" starttime="20190401 12:53:14.943"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:53:15.952" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:15.952" starttime="20190401 12:53:15.952"></status>
</kw>
<msg timestamp="20190401 12:53:15.952" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:15.952" starttime="20190401 12:53:14.942"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:53:15.953" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:53:15.953" starttime="20190401 12:53:15.953"></status>
</kw>
<status status="FAIL" endtime="20190401 12:53:15.953" starttime="20190401 12:53:14.941"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:53:20.955" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:20.955" starttime="20190401 12:53:20.954"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:20.956" starttime="20190401 12:53:20.955"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:53:20.956" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:53:20.956" starttime="20190401 12:53:20.956"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:20.957" starttime="20190401 12:53:20.957"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:20.957" starttime="20190401 12:53:20.957"></status>
</kw>
<msg timestamp="20190401 12:53:20.958" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:53:20.958" starttime="20190401 12:53:20.956"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:53:20.958" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:20.958" starttime="20190401 12:53:20.958"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:53:20.971" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:20.971" starttime="20190401 12:53:20.958"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:53:21.950" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:53:21.950" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:21.950" starttime="20190401 12:53:20.971"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:53:21.950" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:21.951" starttime="20190401 12:53:21.950"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:53:21.951" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:21.951" starttime="20190401 12:53:21.951"></status>
</kw>
<msg timestamp="20190401 12:53:21.951" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:21.951" starttime="20190401 12:53:21.950"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:53:21.954" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:53:21.954" starttime="20190401 12:53:21.951"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:53:21.954" level="INFO">0</msg>
<msg timestamp="20190401 12:53:21.954" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:21.954" starttime="20190401 12:53:21.954"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:53:21.954" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:53:21.954" starttime="20190401 12:53:21.954"></status>
</kw>
<msg timestamp="20190401 12:53:21.955" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:21.955" starttime="20190401 12:53:21.951"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:21.955" starttime="20190401 12:53:21.955"></status>
</kw>
<status status="PASS" endtime="20190401 12:53:21.955" starttime="20190401 12:53:21.955"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:21.956" starttime="20190401 12:53:21.955"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:53:21.956" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:53:21.956" starttime="20190401 12:53:21.956"></status>
</kw>
<msg timestamp="20190401 12:53:21.956" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:53:21.956" starttime="20190401 12:53:20.955"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:53:21.956" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:21.957" starttime="20190401 12:53:21.956"></status>
</kw>
<msg timestamp="20190401 12:53:21.957" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:21.957" starttime="20190401 12:53:20.954"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:53:21.957" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:53:21.957" starttime="20190401 12:53:21.957"></status>
</kw>
<status status="FAIL" endtime="20190401 12:53:21.957" starttime="20190401 12:53:20.953"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:53:26.959" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:26.959" starttime="20190401 12:53:26.958"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:26.960" starttime="20190401 12:53:26.959"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:53:26.960" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:53:26.960" starttime="20190401 12:53:26.960"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:26.961" starttime="20190401 12:53:26.960"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:26.961" starttime="20190401 12:53:26.961"></status>
</kw>
<msg timestamp="20190401 12:53:26.961" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:53:26.961" starttime="20190401 12:53:26.960"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:53:26.962" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:26.962" starttime="20190401 12:53:26.961"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:53:26.975" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:26.975" starttime="20190401 12:53:26.962"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:53:28.013" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:53:28.013" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:28.014" starttime="20190401 12:53:26.975"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:53:28.014" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:28.014" starttime="20190401 12:53:28.014"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:53:28.015" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:28.015" starttime="20190401 12:53:28.014"></status>
</kw>
<msg timestamp="20190401 12:53:28.015" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:28.015" starttime="20190401 12:53:28.014"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:53:28.017" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:53:28.018" starttime="20190401 12:53:28.015"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:53:28.018" level="INFO">0</msg>
<msg timestamp="20190401 12:53:28.018" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:28.018" starttime="20190401 12:53:28.018"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:53:28.018" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:53:28.018" starttime="20190401 12:53:28.018"></status>
</kw>
<msg timestamp="20190401 12:53:28.018" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:28.018" starttime="20190401 12:53:28.015"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:28.019" starttime="20190401 12:53:28.019"></status>
</kw>
<status status="PASS" endtime="20190401 12:53:28.019" starttime="20190401 12:53:28.019"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:28.020" starttime="20190401 12:53:28.019"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:53:28.020" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:53:28.020" starttime="20190401 12:53:28.020"></status>
</kw>
<msg timestamp="20190401 12:53:28.020" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:53:28.020" starttime="20190401 12:53:26.959"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:53:28.020" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:28.020" starttime="20190401 12:53:28.020"></status>
</kw>
<msg timestamp="20190401 12:53:28.021" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:28.021" starttime="20190401 12:53:26.958"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:53:28.021" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:53:28.021" starttime="20190401 12:53:28.021"></status>
</kw>
<status status="FAIL" endtime="20190401 12:53:28.021" starttime="20190401 12:53:26.958"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:53:33.023" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:33.023" starttime="20190401 12:53:33.022"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:33.023" starttime="20190401 12:53:33.023"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:53:33.024" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:53:33.024" starttime="20190401 12:53:33.024"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:33.024" starttime="20190401 12:53:33.024"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:33.025" starttime="20190401 12:53:33.025"></status>
</kw>
<msg timestamp="20190401 12:53:33.025" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:53:33.025" starttime="20190401 12:53:33.024"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:53:33.025" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:33.025" starttime="20190401 12:53:33.025"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:53:33.034" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:33.034" starttime="20190401 12:53:33.026"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:53:34.083" level="INFO">postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:53:34.084" level="INFO">${output} = postinstall
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:34.084" starttime="20190401 12:53:33.035"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:53:34.085" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:34.085" starttime="20190401 12:53:34.084"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:53:34.085" level="INFO">${clean_out} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:34.085" starttime="20190401 12:53:34.085"></status>
</kw>
<msg timestamp="20190401 12:53:34.085" level="INFO">${output} = postinstall
</msg>
<status status="PASS" endtime="20190401 12:53:34.085" starttime="20190401 12:53:34.084"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:53:34.088" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:53:34.088" starttime="20190401 12:53:34.086"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:53:34.088" level="INFO">0</msg>
<msg timestamp="20190401 12:53:34.088" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:34.088" starttime="20190401 12:53:34.088"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:53:34.088" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:53:34.088" starttime="20190401 12:53:34.088"></status>
</kw>
<msg timestamp="20190401 12:53:34.088" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:34.088" starttime="20190401 12:53:34.085"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:34.089" starttime="20190401 12:53:34.089"></status>
</kw>
<status status="PASS" endtime="20190401 12:53:34.089" starttime="20190401 12:53:34.089"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:34.090" starttime="20190401 12:53:34.089"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:53:34.090" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: postinstall</msg>
<status status="PASS" endtime="20190401 12:53:34.090" starttime="20190401 12:53:34.090"></status>
</kw>
<msg timestamp="20190401 12:53:34.090" level="INFO">${result} = {u'stdout': u'postinstall', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:53:34.090" starttime="20190401 12:53:33.023"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:53:34.090" level="INFO">${value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:34.090" starttime="20190401 12:53:34.090"></status>
</kw>
<msg timestamp="20190401 12:53:34.091" level="INFO">${current_value} = postinstall</msg>
<status status="PASS" endtime="20190401 12:53:34.091" starttime="20190401 12:53:33.022"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:53:34.091" level="FAIL">postinstall != completed</msg>
<status status="FAIL" endtime="20190401 12:53:34.091" starttime="20190401 12:53:34.091"></status>
</kw>
<status status="FAIL" endtime="20190401 12:53:34.091" starttime="20190401 12:53:33.022"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:53:39.093" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:39.093" starttime="20190401 12:53:39.093"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:39.095" starttime="20190401 12:53:39.094"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:53:39.096" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:53:39.096" starttime="20190401 12:53:39.095"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:39.097" starttime="20190401 12:53:39.096"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:39.097" starttime="20190401 12:53:39.097"></status>
</kw>
<msg timestamp="20190401 12:53:39.097" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:53:39.098" starttime="20190401 12:53:39.095"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:53:39.098" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:39.098" starttime="20190401 12:53:39.098"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:53:39.118" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:39.118" starttime="20190401 12:53:39.098"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:53:40.117" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:53:40.117" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:40.117" starttime="20190401 12:53:39.119"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:53:40.118" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:40.118" starttime="20190401 12:53:40.118"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:53:40.118" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:53:40.118" starttime="20190401 12:53:40.118"></status>
</kw>
<msg timestamp="20190401 12:53:40.119" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:53:40.119" starttime="20190401 12:53:40.118"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:53:40.120" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:53:40.120" starttime="20190401 12:53:40.119"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:53:40.121" level="INFO">0</msg>
<msg timestamp="20190401 12:53:40.121" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:40.121" starttime="20190401 12:53:40.120"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:53:40.121" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:53:40.121" starttime="20190401 12:53:40.121"></status>
</kw>
<msg timestamp="20190401 12:53:40.122" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:40.122" starttime="20190401 12:53:40.119"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:40.122" starttime="20190401 12:53:40.122"></status>
</kw>
<status status="PASS" endtime="20190401 12:53:40.122" starttime="20190401 12:53:40.122"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:40.123" starttime="20190401 12:53:40.122"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:53:40.123" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:53:40.123" starttime="20190401 12:53:40.123"></status>
</kw>
<msg timestamp="20190401 12:53:40.123" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:53:40.123" starttime="20190401 12:53:39.094"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:53:40.123" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:53:40.123" starttime="20190401 12:53:40.123"></status>
</kw>
<msg timestamp="20190401 12:53:40.124" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:53:40.124" starttime="20190401 12:53:39.092"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:53:40.124" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:53:40.124" starttime="20190401 12:53:40.124"></status>
</kw>
<status status="FAIL" endtime="20190401 12:53:40.124" starttime="20190401 12:53:39.092"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:53:45.126" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:45.126" starttime="20190401 12:53:45.125"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:45.126" starttime="20190401 12:53:45.126"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:53:45.127" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:53:45.127" starttime="20190401 12:53:45.127"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:45.128" starttime="20190401 12:53:45.127"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:45.128" starttime="20190401 12:53:45.128"></status>
</kw>
<msg timestamp="20190401 12:53:45.128" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:53:45.128" starttime="20190401 12:53:45.127"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:53:45.129" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:45.129" starttime="20190401 12:53:45.128"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:53:45.130" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:45.130" starttime="20190401 12:53:45.129"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:53:46.122" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:53:46.122" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:46.122" starttime="20190401 12:53:45.131"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:53:46.123" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:46.123" starttime="20190401 12:53:46.123"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:53:46.124" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:53:46.124" starttime="20190401 12:53:46.123"></status>
</kw>
<msg timestamp="20190401 12:53:46.124" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:53:46.124" starttime="20190401 12:53:46.123"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:53:46.125" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:53:46.126" starttime="20190401 12:53:46.124"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:53:46.126" level="INFO">0</msg>
<msg timestamp="20190401 12:53:46.126" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:46.126" starttime="20190401 12:53:46.126"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:53:46.126" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:53:46.126" starttime="20190401 12:53:46.126"></status>
</kw>
<msg timestamp="20190401 12:53:46.127" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:46.127" starttime="20190401 12:53:46.124"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:46.128" starttime="20190401 12:53:46.127"></status>
</kw>
<status status="PASS" endtime="20190401 12:53:46.128" starttime="20190401 12:53:46.127"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:46.128" starttime="20190401 12:53:46.128"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:53:46.128" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:53:46.128" starttime="20190401 12:53:46.128"></status>
</kw>
<msg timestamp="20190401 12:53:46.128" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:53:46.128" starttime="20190401 12:53:45.126"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:53:46.129" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:53:46.129" starttime="20190401 12:53:46.129"></status>
</kw>
<msg timestamp="20190401 12:53:46.129" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:53:46.129" starttime="20190401 12:53:45.125"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:53:46.129" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:53:46.130" starttime="20190401 12:53:46.129"></status>
</kw>
<status status="FAIL" endtime="20190401 12:53:46.130" starttime="20190401 12:53:45.125"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:53:51.131" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:51.131" starttime="20190401 12:53:51.131"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:51.132" starttime="20190401 12:53:51.132"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:53:51.132" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:53:51.133" starttime="20190401 12:53:51.132"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:51.133" starttime="20190401 12:53:51.133"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:51.133" starttime="20190401 12:53:51.133"></status>
</kw>
<msg timestamp="20190401 12:53:51.133" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:53:51.133" starttime="20190401 12:53:51.132"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:53:51.134" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:51.134" starttime="20190401 12:53:51.134"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:53:51.145" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:51.145" starttime="20190401 12:53:51.134"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:53:52.140" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:53:52.140" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:52.140" starttime="20190401 12:53:51.145"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:53:52.141" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:52.141" starttime="20190401 12:53:52.141"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:53:52.142" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:53:52.142" starttime="20190401 12:53:52.141"></status>
</kw>
<msg timestamp="20190401 12:53:52.142" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:53:52.142" starttime="20190401 12:53:52.141"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:53:52.144" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:53:52.144" starttime="20190401 12:53:52.142"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:53:52.144" level="INFO">0</msg>
<msg timestamp="20190401 12:53:52.144" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:52.144" starttime="20190401 12:53:52.144"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:53:52.145" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:53:52.145" starttime="20190401 12:53:52.144"></status>
</kw>
<msg timestamp="20190401 12:53:52.145" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:52.145" starttime="20190401 12:53:52.142"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:52.145" starttime="20190401 12:53:52.145"></status>
</kw>
<status status="PASS" endtime="20190401 12:53:52.146" starttime="20190401 12:53:52.145"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:52.146" starttime="20190401 12:53:52.146"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:53:52.146" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:53:52.146" starttime="20190401 12:53:52.146"></status>
</kw>
<msg timestamp="20190401 12:53:52.146" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:53:52.146" starttime="20190401 12:53:51.131"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:53:52.147" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:53:52.147" starttime="20190401 12:53:52.146"></status>
</kw>
<msg timestamp="20190401 12:53:52.147" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:53:52.147" starttime="20190401 12:53:51.130"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:53:52.148" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:53:52.148" starttime="20190401 12:53:52.148"></status>
</kw>
<status status="FAIL" endtime="20190401 12:53:52.148" starttime="20190401 12:53:51.130"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:53:57.149" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:57.150" starttime="20190401 12:53:57.149"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:57.150" starttime="20190401 12:53:57.150"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:53:57.151" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:53:57.151" starttime="20190401 12:53:57.151"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:57.151" starttime="20190401 12:53:57.151"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:57.152" starttime="20190401 12:53:57.151"></status>
</kw>
<msg timestamp="20190401 12:53:57.152" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:53:57.152" starttime="20190401 12:53:57.150"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:53:57.152" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:57.152" starttime="20190401 12:53:57.152"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:53:57.163" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:53:57.163" starttime="20190401 12:53:57.152"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:53:58.198" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:53:58.198" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:58.198" starttime="20190401 12:53:57.163"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:53:58.199" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:53:58.199" starttime="20190401 12:53:58.199"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:53:58.199" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:53:58.199" starttime="20190401 12:53:58.199"></status>
</kw>
<msg timestamp="20190401 12:53:58.200" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:53:58.200" starttime="20190401 12:53:58.199"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:53:58.201" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:53:58.201" starttime="20190401 12:53:58.200"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:53:58.202" level="INFO">0</msg>
<msg timestamp="20190401 12:53:58.202" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:58.202" starttime="20190401 12:53:58.201"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:53:58.202" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:53:58.202" starttime="20190401 12:53:58.202"></status>
</kw>
<msg timestamp="20190401 12:53:58.203" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:53:58.203" starttime="20190401 12:53:58.200"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:58.203" starttime="20190401 12:53:58.203"></status>
</kw>
<status status="PASS" endtime="20190401 12:53:58.203" starttime="20190401 12:53:58.203"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:53:58.204" starttime="20190401 12:53:58.204"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:53:58.204" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:53:58.204" starttime="20190401 12:53:58.204"></status>
</kw>
<msg timestamp="20190401 12:53:58.204" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:53:58.204" starttime="20190401 12:53:57.150"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:53:58.205" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:53:58.205" starttime="20190401 12:53:58.204"></status>
</kw>
<msg timestamp="20190401 12:53:58.205" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:53:58.205" starttime="20190401 12:53:57.149"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:53:58.205" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:53:58.205" starttime="20190401 12:53:58.205"></status>
</kw>
<status status="FAIL" endtime="20190401 12:53:58.205" starttime="20190401 12:53:57.148"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:54:03.208" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:03.208" starttime="20190401 12:54:03.207"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:03.209" starttime="20190401 12:54:03.209"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:54:03.211" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:54:03.211" starttime="20190401 12:54:03.210"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:03.211" starttime="20190401 12:54:03.211"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:03.212" starttime="20190401 12:54:03.211"></status>
</kw>
<msg timestamp="20190401 12:54:03.212" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:54:03.212" starttime="20190401 12:54:03.209"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:54:03.213" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:03.213" starttime="20190401 12:54:03.212"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:54:03.231" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:03.231" starttime="20190401 12:54:03.213"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:54:04.224" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:54:04.225" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:04.225" starttime="20190401 12:54:03.231"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:54:04.225" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:04.226" starttime="20190401 12:54:04.225"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:54:04.226" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:04.226" starttime="20190401 12:54:04.226"></status>
</kw>
<msg timestamp="20190401 12:54:04.226" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:04.226" starttime="20190401 12:54:04.225"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:54:04.228" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:54:04.228" starttime="20190401 12:54:04.226"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:54:04.228" level="INFO">0</msg>
<msg timestamp="20190401 12:54:04.228" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:04.229" starttime="20190401 12:54:04.228"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:54:04.229" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:54:04.229" starttime="20190401 12:54:04.229"></status>
</kw>
<msg timestamp="20190401 12:54:04.229" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:04.229" starttime="20190401 12:54:04.226"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:04.230" starttime="20190401 12:54:04.229"></status>
</kw>
<status status="PASS" endtime="20190401 12:54:04.230" starttime="20190401 12:54:04.229"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:04.230" starttime="20190401 12:54:04.230"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:54:04.230" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:54:04.230" starttime="20190401 12:54:04.230"></status>
</kw>
<msg timestamp="20190401 12:54:04.231" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:54:04.231" starttime="20190401 12:54:03.208"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:54:04.231" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:04.231" starttime="20190401 12:54:04.231"></status>
</kw>
<msg timestamp="20190401 12:54:04.231" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:04.231" starttime="20190401 12:54:03.207"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:54:04.232" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:54:04.232" starttime="20190401 12:54:04.231"></status>
</kw>
<status status="FAIL" endtime="20190401 12:54:04.232" starttime="20190401 12:54:03.206"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:54:09.233" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:09.233" starttime="20190401 12:54:09.233"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:09.234" starttime="20190401 12:54:09.234"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:54:09.235" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:54:09.235" starttime="20190401 12:54:09.235"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:09.235" starttime="20190401 12:54:09.235"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:09.236" starttime="20190401 12:54:09.235"></status>
</kw>
<msg timestamp="20190401 12:54:09.236" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:54:09.236" starttime="20190401 12:54:09.234"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:54:09.236" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:09.236" starttime="20190401 12:54:09.236"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:54:09.246" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:09.246" starttime="20190401 12:54:09.236"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:54:10.244" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:54:10.244" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:10.244" starttime="20190401 12:54:09.246"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:54:10.245" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:10.245" starttime="20190401 12:54:10.244"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:54:10.245" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:10.245" starttime="20190401 12:54:10.245"></status>
</kw>
<msg timestamp="20190401 12:54:10.245" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:10.245" starttime="20190401 12:54:10.244"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:54:10.247" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:54:10.247" starttime="20190401 12:54:10.246"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:54:10.248" level="INFO">0</msg>
<msg timestamp="20190401 12:54:10.248" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:10.248" starttime="20190401 12:54:10.247"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:54:10.248" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:54:10.248" starttime="20190401 12:54:10.248"></status>
</kw>
<msg timestamp="20190401 12:54:10.248" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:10.248" starttime="20190401 12:54:10.245"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:10.249" starttime="20190401 12:54:10.249"></status>
</kw>
<status status="PASS" endtime="20190401 12:54:10.249" starttime="20190401 12:54:10.248"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:10.249" starttime="20190401 12:54:10.249"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:54:10.250" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:54:10.250" starttime="20190401 12:54:10.250"></status>
</kw>
<msg timestamp="20190401 12:54:10.250" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:54:10.250" starttime="20190401 12:54:09.234"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:54:10.250" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:10.250" starttime="20190401 12:54:10.250"></status>
</kw>
<msg timestamp="20190401 12:54:10.251" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:10.251" starttime="20190401 12:54:09.233"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:54:10.251" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:54:10.251" starttime="20190401 12:54:10.251"></status>
</kw>
<status status="FAIL" endtime="20190401 12:54:10.251" starttime="20190401 12:54:09.232"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:54:15.253" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:15.253" starttime="20190401 12:54:15.252"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:15.254" starttime="20190401 12:54:15.253"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:54:15.254" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:54:15.254" starttime="20190401 12:54:15.254"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:15.255" starttime="20190401 12:54:15.254"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:15.255" starttime="20190401 12:54:15.255"></status>
</kw>
<msg timestamp="20190401 12:54:15.255" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:54:15.255" starttime="20190401 12:54:15.254"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:54:15.256" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:15.256" starttime="20190401 12:54:15.255"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:54:15.265" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:15.265" starttime="20190401 12:54:15.256"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:54:16.261" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:54:16.261" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:16.261" starttime="20190401 12:54:15.265"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:54:16.262" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:16.262" starttime="20190401 12:54:16.261"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:54:16.262" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:16.262" starttime="20190401 12:54:16.262"></status>
</kw>
<msg timestamp="20190401 12:54:16.262" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:16.262" starttime="20190401 12:54:16.261"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:54:16.264" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:54:16.264" starttime="20190401 12:54:16.263"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:54:16.265" level="INFO">0</msg>
<msg timestamp="20190401 12:54:16.265" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:16.265" starttime="20190401 12:54:16.264"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:54:16.265" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:54:16.265" starttime="20190401 12:54:16.265"></status>
</kw>
<msg timestamp="20190401 12:54:16.265" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:16.265" starttime="20190401 12:54:16.262"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:16.266" starttime="20190401 12:54:16.266"></status>
</kw>
<status status="PASS" endtime="20190401 12:54:16.266" starttime="20190401 12:54:16.265"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:16.267" starttime="20190401 12:54:16.266"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:54:16.267" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:54:16.267" starttime="20190401 12:54:16.267"></status>
</kw>
<msg timestamp="20190401 12:54:16.267" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:54:16.267" starttime="20190401 12:54:15.253"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:54:16.267" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:16.267" starttime="20190401 12:54:16.267"></status>
</kw>
<msg timestamp="20190401 12:54:16.268" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:16.268" starttime="20190401 12:54:15.252"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:54:16.268" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:54:16.268" starttime="20190401 12:54:16.268"></status>
</kw>
<status status="FAIL" endtime="20190401 12:54:16.268" starttime="20190401 12:54:15.252"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:54:21.270" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:21.270" starttime="20190401 12:54:21.269"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:21.270" starttime="20190401 12:54:21.270"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:54:21.271" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:54:21.271" starttime="20190401 12:54:21.271"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:21.272" starttime="20190401 12:54:21.271"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:21.272" starttime="20190401 12:54:21.272"></status>
</kw>
<msg timestamp="20190401 12:54:21.272" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:54:21.272" starttime="20190401 12:54:21.271"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:54:21.273" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:21.273" starttime="20190401 12:54:21.272"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:54:21.284" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:21.284" starttime="20190401 12:54:21.273"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:54:22.273" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:54:22.273" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:22.273" starttime="20190401 12:54:21.284"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:54:22.274" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:22.274" starttime="20190401 12:54:22.274"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:54:22.274" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:22.274" starttime="20190401 12:54:22.274"></status>
</kw>
<msg timestamp="20190401 12:54:22.274" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:22.275" starttime="20190401 12:54:22.273"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:54:22.276" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:54:22.276" starttime="20190401 12:54:22.275"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:54:22.277" level="INFO">0</msg>
<msg timestamp="20190401 12:54:22.277" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:22.277" starttime="20190401 12:54:22.276"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:54:22.277" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:54:22.277" starttime="20190401 12:54:22.277"></status>
</kw>
<msg timestamp="20190401 12:54:22.277" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:22.277" starttime="20190401 12:54:22.275"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:22.278" starttime="20190401 12:54:22.278"></status>
</kw>
<status status="PASS" endtime="20190401 12:54:22.278" starttime="20190401 12:54:22.277"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:22.278" starttime="20190401 12:54:22.278"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:54:22.279" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:54:22.279" starttime="20190401 12:54:22.279"></status>
</kw>
<msg timestamp="20190401 12:54:22.279" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:54:22.279" starttime="20190401 12:54:21.270"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:54:22.279" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:22.279" starttime="20190401 12:54:22.279"></status>
</kw>
<msg timestamp="20190401 12:54:22.280" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:22.280" starttime="20190401 12:54:21.269"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:54:22.280" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:54:22.280" starttime="20190401 12:54:22.280"></status>
</kw>
<status status="FAIL" endtime="20190401 12:54:22.280" starttime="20190401 12:54:21.269"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:54:27.282" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:27.282" starttime="20190401 12:54:27.281"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:27.282" starttime="20190401 12:54:27.282"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:54:27.283" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:54:27.283" starttime="20190401 12:54:27.283"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:27.284" starttime="20190401 12:54:27.283"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:27.284" starttime="20190401 12:54:27.284"></status>
</kw>
<msg timestamp="20190401 12:54:27.284" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:54:27.285" starttime="20190401 12:54:27.282"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:54:27.285" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:27.285" starttime="20190401 12:54:27.285"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:54:27.287" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:27.287" starttime="20190401 12:54:27.285"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:54:28.373" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:54:28.373" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:28.373" starttime="20190401 12:54:27.287"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:54:28.374" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:28.374" starttime="20190401 12:54:28.374"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:54:28.374" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:28.374" starttime="20190401 12:54:28.374"></status>
</kw>
<msg timestamp="20190401 12:54:28.374" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:28.374" starttime="20190401 12:54:28.373"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:54:28.377" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:54:28.377" starttime="20190401 12:54:28.375"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:54:28.377" level="INFO">0</msg>
<msg timestamp="20190401 12:54:28.378" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:28.378" starttime="20190401 12:54:28.377"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:54:28.378" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:54:28.378" starttime="20190401 12:54:28.378"></status>
</kw>
<msg timestamp="20190401 12:54:28.378" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:28.378" starttime="20190401 12:54:28.374"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:28.379" starttime="20190401 12:54:28.379"></status>
</kw>
<status status="PASS" endtime="20190401 12:54:28.379" starttime="20190401 12:54:28.378"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:28.379" starttime="20190401 12:54:28.379"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:54:28.380" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:54:28.380" starttime="20190401 12:54:28.380"></status>
</kw>
<msg timestamp="20190401 12:54:28.380" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:54:28.380" starttime="20190401 12:54:27.282"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:54:28.380" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:28.380" starttime="20190401 12:54:28.380"></status>
</kw>
<msg timestamp="20190401 12:54:28.380" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:28.381" starttime="20190401 12:54:27.281"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:54:28.381" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:54:28.381" starttime="20190401 12:54:28.381"></status>
</kw>
<status status="FAIL" endtime="20190401 12:54:28.381" starttime="20190401 12:54:27.280"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:54:33.383" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:33.383" starttime="20190401 12:54:33.382"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:33.383" starttime="20190401 12:54:33.383"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:54:33.384" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:54:33.384" starttime="20190401 12:54:33.384"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:33.384" starttime="20190401 12:54:33.384"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:33.385" starttime="20190401 12:54:33.384"></status>
</kw>
<msg timestamp="20190401 12:54:33.385" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:54:33.385" starttime="20190401 12:54:33.383"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:54:33.385" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:33.385" starttime="20190401 12:54:33.385"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:54:33.395" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:33.395" starttime="20190401 12:54:33.385"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:54:34.496" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:54:34.496" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:34.496" starttime="20190401 12:54:33.396"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:54:34.497" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:34.497" starttime="20190401 12:54:34.497"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:54:34.498" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:34.498" starttime="20190401 12:54:34.498"></status>
</kw>
<msg timestamp="20190401 12:54:34.498" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:34.498" starttime="20190401 12:54:34.497"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:54:34.500" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:54:34.500" starttime="20190401 12:54:34.499"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:54:34.501" level="INFO">0</msg>
<msg timestamp="20190401 12:54:34.501" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:34.501" starttime="20190401 12:54:34.501"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:54:34.501" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:54:34.502" starttime="20190401 12:54:34.501"></status>
</kw>
<msg timestamp="20190401 12:54:34.502" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:34.502" starttime="20190401 12:54:34.498"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:34.503" starttime="20190401 12:54:34.502"></status>
</kw>
<status status="PASS" endtime="20190401 12:54:34.503" starttime="20190401 12:54:34.502"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:34.503" starttime="20190401 12:54:34.503"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:54:34.504" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:54:34.504" starttime="20190401 12:54:34.503"></status>
</kw>
<msg timestamp="20190401 12:54:34.504" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:54:34.504" starttime="20190401 12:54:33.383"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:54:34.504" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:34.504" starttime="20190401 12:54:34.504"></status>
</kw>
<msg timestamp="20190401 12:54:34.505" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:34.505" starttime="20190401 12:54:33.382"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:54:34.505" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:54:34.505" starttime="20190401 12:54:34.505"></status>
</kw>
<status status="FAIL" endtime="20190401 12:54:34.505" starttime="20190401 12:54:33.381"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:54:39.507" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:39.507" starttime="20190401 12:54:39.506"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:39.508" starttime="20190401 12:54:39.507"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:54:39.508" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:54:39.508" starttime="20190401 12:54:39.508"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:39.509" starttime="20190401 12:54:39.509"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:39.509" starttime="20190401 12:54:39.509"></status>
</kw>
<msg timestamp="20190401 12:54:39.509" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:54:39.509" starttime="20190401 12:54:39.508"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:54:39.510" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:39.510" starttime="20190401 12:54:39.509"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:54:39.520" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:39.520" starttime="20190401 12:54:39.510"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:54:40.536" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:54:40.536" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:40.537" starttime="20190401 12:54:39.520"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:54:40.538" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:40.538" starttime="20190401 12:54:40.537"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:54:40.538" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:40.538" starttime="20190401 12:54:40.538"></status>
</kw>
<msg timestamp="20190401 12:54:40.538" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:40.538" starttime="20190401 12:54:40.537"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:54:40.540" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:54:40.540" starttime="20190401 12:54:40.538"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:54:40.540" level="INFO">0</msg>
<msg timestamp="20190401 12:54:40.540" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:40.541" starttime="20190401 12:54:40.540"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:54:40.541" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:54:40.541" starttime="20190401 12:54:40.541"></status>
</kw>
<msg timestamp="20190401 12:54:40.541" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:40.541" starttime="20190401 12:54:40.538"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:40.542" starttime="20190401 12:54:40.541"></status>
</kw>
<status status="PASS" endtime="20190401 12:54:40.542" starttime="20190401 12:54:40.541"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:40.542" starttime="20190401 12:54:40.542"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:54:40.542" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:54:40.542" starttime="20190401 12:54:40.542"></status>
</kw>
<msg timestamp="20190401 12:54:40.543" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:54:40.543" starttime="20190401 12:54:39.507"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:54:40.543" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:40.543" starttime="20190401 12:54:40.543"></status>
</kw>
<msg timestamp="20190401 12:54:40.543" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:40.543" starttime="20190401 12:54:39.506"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:54:40.544" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:54:40.544" starttime="20190401 12:54:40.543"></status>
</kw>
<status status="FAIL" endtime="20190401 12:54:40.544" starttime="20190401 12:54:39.506"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:54:45.545" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:45.545" starttime="20190401 12:54:45.545"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:45.546" starttime="20190401 12:54:45.546"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:54:45.547" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:54:45.547" starttime="20190401 12:54:45.546"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:45.547" starttime="20190401 12:54:45.547"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:45.547" starttime="20190401 12:54:45.547"></status>
</kw>
<msg timestamp="20190401 12:54:45.548" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:54:45.548" starttime="20190401 12:54:45.546"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:54:45.548" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:45.548" starttime="20190401 12:54:45.548"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:54:45.559" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:45.559" starttime="20190401 12:54:45.548"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:54:46.547" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:54:46.548" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:46.548" starttime="20190401 12:54:45.559"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:54:46.548" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:46.548" starttime="20190401 12:54:46.548"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:54:46.549" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:46.549" starttime="20190401 12:54:46.548"></status>
</kw>
<msg timestamp="20190401 12:54:46.549" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:46.549" starttime="20190401 12:54:46.548"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:54:46.551" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:54:46.551" starttime="20190401 12:54:46.549"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:54:46.551" level="INFO">0</msg>
<msg timestamp="20190401 12:54:46.551" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:46.551" starttime="20190401 12:54:46.551"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:54:46.552" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:54:46.552" starttime="20190401 12:54:46.551"></status>
</kw>
<msg timestamp="20190401 12:54:46.552" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:46.552" starttime="20190401 12:54:46.549"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:46.553" starttime="20190401 12:54:46.552"></status>
</kw>
<status status="PASS" endtime="20190401 12:54:46.553" starttime="20190401 12:54:46.552"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:46.553" starttime="20190401 12:54:46.553"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:54:46.553" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:54:46.553" starttime="20190401 12:54:46.553"></status>
</kw>
<msg timestamp="20190401 12:54:46.554" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:54:46.554" starttime="20190401 12:54:45.545"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:54:46.554" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:46.554" starttime="20190401 12:54:46.554"></status>
</kw>
<msg timestamp="20190401 12:54:46.554" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:46.554" starttime="20190401 12:54:45.545"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:54:46.555" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:54:46.555" starttime="20190401 12:54:46.554"></status>
</kw>
<status status="FAIL" endtime="20190401 12:54:46.555" starttime="20190401 12:54:45.544"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:54:51.556" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:51.556" starttime="20190401 12:54:51.556"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:51.557" starttime="20190401 12:54:51.557"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:54:51.558" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:54:51.558" starttime="20190401 12:54:51.557"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:51.558" starttime="20190401 12:54:51.558"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:51.558" starttime="20190401 12:54:51.558"></status>
</kw>
<msg timestamp="20190401 12:54:51.559" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:54:51.559" starttime="20190401 12:54:51.557"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:54:51.559" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:51.559" starttime="20190401 12:54:51.559"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:54:51.570" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:51.570" starttime="20190401 12:54:51.559"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:54:52.618" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:54:52.618" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:52.618" starttime="20190401 12:54:51.570"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:54:52.619" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:52.619" starttime="20190401 12:54:52.619"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:54:52.619" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:52.619" starttime="20190401 12:54:52.619"></status>
</kw>
<msg timestamp="20190401 12:54:52.620" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:52.620" starttime="20190401 12:54:52.618"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:54:52.621" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:54:52.621" starttime="20190401 12:54:52.620"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:54:52.621" level="INFO">0</msg>
<msg timestamp="20190401 12:54:52.621" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:52.621" starttime="20190401 12:54:52.621"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:54:52.622" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:54:52.622" starttime="20190401 12:54:52.622"></status>
</kw>
<msg timestamp="20190401 12:54:52.622" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:52.622" starttime="20190401 12:54:52.620"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:52.623" starttime="20190401 12:54:52.622"></status>
</kw>
<status status="PASS" endtime="20190401 12:54:52.623" starttime="20190401 12:54:52.622"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:52.623" starttime="20190401 12:54:52.623"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:54:52.623" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:54:52.624" starttime="20190401 12:54:52.623"></status>
</kw>
<msg timestamp="20190401 12:54:52.624" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:54:52.624" starttime="20190401 12:54:51.556"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:54:52.624" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:52.624" starttime="20190401 12:54:52.624"></status>
</kw>
<msg timestamp="20190401 12:54:52.624" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:52.624" starttime="20190401 12:54:51.556"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:54:52.625" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:54:52.625" starttime="20190401 12:54:52.624"></status>
</kw>
<status status="FAIL" endtime="20190401 12:54:52.625" starttime="20190401 12:54:51.555"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:54:57.626" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:57.626" starttime="20190401 12:54:57.626"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:57.627" starttime="20190401 12:54:57.627"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:54:57.628" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:54:57.628" starttime="20190401 12:54:57.627"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:57.628" starttime="20190401 12:54:57.628"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:57.629" starttime="20190401 12:54:57.628"></status>
</kw>
<msg timestamp="20190401 12:54:57.629" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:54:57.629" starttime="20190401 12:54:57.627"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:54:57.629" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:57.629" starttime="20190401 12:54:57.629"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:54:57.639" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:54:57.639" starttime="20190401 12:54:57.629"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:54:58.650" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:54:58.650" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:58.650" starttime="20190401 12:54:57.639"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:54:58.651" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:54:58.651" starttime="20190401 12:54:58.651"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:54:58.651" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:58.652" starttime="20190401 12:54:58.651"></status>
</kw>
<msg timestamp="20190401 12:54:58.652" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:54:58.652" starttime="20190401 12:54:58.650"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:54:58.653" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:54:58.653" starttime="20190401 12:54:58.652"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:54:58.654" level="INFO">0</msg>
<msg timestamp="20190401 12:54:58.654" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:58.654" starttime="20190401 12:54:58.653"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:54:58.654" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:54:58.654" starttime="20190401 12:54:58.654"></status>
</kw>
<msg timestamp="20190401 12:54:58.655" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:54:58.655" starttime="20190401 12:54:58.652"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:58.655" starttime="20190401 12:54:58.655"></status>
</kw>
<status status="PASS" endtime="20190401 12:54:58.655" starttime="20190401 12:54:58.655"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:54:58.656" starttime="20190401 12:54:58.655"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:54:58.656" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:54:58.656" starttime="20190401 12:54:58.656"></status>
</kw>
<msg timestamp="20190401 12:54:58.656" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:54:58.656" starttime="20190401 12:54:57.626"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:54:58.656" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:58.656" starttime="20190401 12:54:58.656"></status>
</kw>
<msg timestamp="20190401 12:54:58.657" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:54:58.657" starttime="20190401 12:54:57.626"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:54:58.657" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:54:58.657" starttime="20190401 12:54:58.657"></status>
</kw>
<status status="FAIL" endtime="20190401 12:54:58.658" starttime="20190401 12:54:57.625"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:55:03.660" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:03.660" starttime="20190401 12:55:03.659"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:03.661" starttime="20190401 12:55:03.660"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:03.662" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:03.662" starttime="20190401 12:55:03.661"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:03.663" starttime="20190401 12:55:03.662"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:03.663" starttime="20190401 12:55:03.663"></status>
</kw>
<msg timestamp="20190401 12:55:03.664" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:03.664" starttime="20190401 12:55:03.661"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:03.664" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:03.664" starttime="20190401 12:55:03.664"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:03.667" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:03.667" starttime="20190401 12:55:03.665"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:04.686" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:04.686" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:04.686" starttime="20190401 12:55:03.667"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:04.687" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:04.687" starttime="20190401 12:55:04.687"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:04.687" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:55:04.687" starttime="20190401 12:55:04.687"></status>
</kw>
<msg timestamp="20190401 12:55:04.687" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:55:04.687" starttime="20190401 12:55:04.686"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:04.689" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:04.689" starttime="20190401 12:55:04.688"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:04.690" level="INFO">0</msg>
<msg timestamp="20190401 12:55:04.690" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:04.690" starttime="20190401 12:55:04.689"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:04.690" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:04.690" starttime="20190401 12:55:04.690"></status>
</kw>
<msg timestamp="20190401 12:55:04.690" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:04.690" starttime="20190401 12:55:04.687"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:04.691" starttime="20190401 12:55:04.691"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:04.691" starttime="20190401 12:55:04.691"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:04.691" starttime="20190401 12:55:04.691"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:04.692" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:55:04.692" starttime="20190401 12:55:04.692"></status>
</kw>
<msg timestamp="20190401 12:55:04.692" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:04.692" starttime="20190401 12:55:03.660"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:55:04.692" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:55:04.692" starttime="20190401 12:55:04.692"></status>
</kw>
<msg timestamp="20190401 12:55:04.692" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:55:04.693" starttime="20190401 12:55:03.659"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:55:04.693" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:55:04.693" starttime="20190401 12:55:04.693"></status>
</kw>
<status status="FAIL" endtime="20190401 12:55:04.693" starttime="20190401 12:55:03.658"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:55:09.695" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:09.695" starttime="20190401 12:55:09.694"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:09.696" starttime="20190401 12:55:09.695"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:09.696" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:09.696" starttime="20190401 12:55:09.696"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:09.697" starttime="20190401 12:55:09.696"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:09.697" starttime="20190401 12:55:09.697"></status>
</kw>
<msg timestamp="20190401 12:55:09.697" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:09.697" starttime="20190401 12:55:09.696"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:09.698" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:09.698" starttime="20190401 12:55:09.697"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:09.708" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:09.708" starttime="20190401 12:55:09.698"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:10.858" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:10.858" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:10.858" starttime="20190401 12:55:09.709"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:10.859" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:10.859" starttime="20190401 12:55:10.858"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:10.859" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:55:10.859" starttime="20190401 12:55:10.859"></status>
</kw>
<msg timestamp="20190401 12:55:10.859" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:55:10.859" starttime="20190401 12:55:10.858"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:10.861" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:10.861" starttime="20190401 12:55:10.859"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:10.861" level="INFO">0</msg>
<msg timestamp="20190401 12:55:10.861" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:10.861" starttime="20190401 12:55:10.861"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:10.862" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:10.862" starttime="20190401 12:55:10.861"></status>
</kw>
<msg timestamp="20190401 12:55:10.862" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:10.862" starttime="20190401 12:55:10.859"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:10.863" starttime="20190401 12:55:10.862"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:10.863" starttime="20190401 12:55:10.862"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:10.863" starttime="20190401 12:55:10.863"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:10.863" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:55:10.863" starttime="20190401 12:55:10.863"></status>
</kw>
<msg timestamp="20190401 12:55:10.863" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:10.863" starttime="20190401 12:55:09.695"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:55:10.864" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:55:10.864" starttime="20190401 12:55:10.864"></status>
</kw>
<msg timestamp="20190401 12:55:10.864" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:55:10.864" starttime="20190401 12:55:09.694"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:55:10.864" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:55:10.864" starttime="20190401 12:55:10.864"></status>
</kw>
<status status="FAIL" endtime="20190401 12:55:10.865" starttime="20190401 12:55:09.693"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:55:15.866" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:15.866" starttime="20190401 12:55:15.866"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:15.868" starttime="20190401 12:55:15.868"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:15.868" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:15.869" starttime="20190401 12:55:15.868"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:15.869" starttime="20190401 12:55:15.869"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:15.869" starttime="20190401 12:55:15.869"></status>
</kw>
<msg timestamp="20190401 12:55:15.870" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:15.870" starttime="20190401 12:55:15.868"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:15.870" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:15.870" starttime="20190401 12:55:15.870"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:15.879" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:15.879" starttime="20190401 12:55:15.870"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:16.871" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:16.871" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:16.871" starttime="20190401 12:55:15.880"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:16.872" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:16.872" starttime="20190401 12:55:16.872"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:16.873" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:55:16.873" starttime="20190401 12:55:16.872"></status>
</kw>
<msg timestamp="20190401 12:55:16.873" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:55:16.873" starttime="20190401 12:55:16.872"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:16.875" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:16.875" starttime="20190401 12:55:16.873"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:16.875" level="INFO">0</msg>
<msg timestamp="20190401 12:55:16.875" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:16.875" starttime="20190401 12:55:16.875"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:16.876" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:16.876" starttime="20190401 12:55:16.876"></status>
</kw>
<msg timestamp="20190401 12:55:16.876" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:16.876" starttime="20190401 12:55:16.873"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:16.877" starttime="20190401 12:55:16.876"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:16.877" starttime="20190401 12:55:16.876"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:16.877" starttime="20190401 12:55:16.877"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:16.877" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:55:16.877" starttime="20190401 12:55:16.877"></status>
</kw>
<msg timestamp="20190401 12:55:16.877" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:16.877" starttime="20190401 12:55:15.867"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:55:16.878" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:55:16.878" starttime="20190401 12:55:16.878"></status>
</kw>
<msg timestamp="20190401 12:55:16.878" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:55:16.878" starttime="20190401 12:55:15.866"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:55:16.878" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:55:16.879" starttime="20190401 12:55:16.878"></status>
</kw>
<status status="FAIL" endtime="20190401 12:55:16.879" starttime="20190401 12:55:15.865"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:55:21.880" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:21.880" starttime="20190401 12:55:21.880"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:21.881" starttime="20190401 12:55:21.881"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:21.882" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:21.882" starttime="20190401 12:55:21.881"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:21.882" starttime="20190401 12:55:21.882"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:21.883" starttime="20190401 12:55:21.882"></status>
</kw>
<msg timestamp="20190401 12:55:21.883" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:21.883" starttime="20190401 12:55:21.881"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:21.883" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:21.883" starttime="20190401 12:55:21.883"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:21.893" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:21.893" starttime="20190401 12:55:21.883"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:22.919" level="INFO">booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:22.919" level="INFO">${output} = booting
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:22.919" starttime="20190401 12:55:21.893"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:22.920" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:22.920" starttime="20190401 12:55:22.920"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:22.920" level="INFO">${clean_out} = booting
</msg>
<status status="PASS" endtime="20190401 12:55:22.920" starttime="20190401 12:55:22.920"></status>
</kw>
<msg timestamp="20190401 12:55:22.920" level="INFO">${output} = booting
</msg>
<status status="PASS" endtime="20190401 12:55:22.920" starttime="20190401 12:55:22.919"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:22.922" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:22.923" starttime="20190401 12:55:22.921"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:22.923" level="INFO">0</msg>
<msg timestamp="20190401 12:55:22.923" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:22.923" starttime="20190401 12:55:22.923"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:22.923" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:22.923" starttime="20190401 12:55:22.923"></status>
</kw>
<msg timestamp="20190401 12:55:22.924" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:22.924" starttime="20190401 12:55:22.921"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:22.924" starttime="20190401 12:55:22.924"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:22.924" starttime="20190401 12:55:22.924"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:22.925" starttime="20190401 12:55:22.924"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:22.925" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: booting</msg>
<status status="PASS" endtime="20190401 12:55:22.925" starttime="20190401 12:55:22.925"></status>
</kw>
<msg timestamp="20190401 12:55:22.925" level="INFO">${result} = {u'stdout': u'booting', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:22.925" starttime="20190401 12:55:21.880"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:55:22.925" level="INFO">${value} = booting</msg>
<status status="PASS" endtime="20190401 12:55:22.925" starttime="20190401 12:55:22.925"></status>
</kw>
<msg timestamp="20190401 12:55:22.926" level="INFO">${current_value} = booting</msg>
<status status="PASS" endtime="20190401 12:55:22.926" starttime="20190401 12:55:21.879"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:55:22.926" level="FAIL">booting != completed</msg>
<status status="FAIL" endtime="20190401 12:55:22.926" starttime="20190401 12:55:22.926"></status>
</kw>
<status status="FAIL" endtime="20190401 12:55:22.926" starttime="20190401 12:55:21.879"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${name}</arg>
<arg>install_state</arg>
<arg>completed</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:55:27.928" level="INFO">${system_cmd} = system host-show controller-1|grep -w install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:27.928" starttime="20190401 12:55:27.927"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:27.928" starttime="20190401 12:55:27.928"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:27.929" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:27.929" starttime="20190401 12:55:27.929"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:27.930" starttime="20190401 12:55:27.930"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:27.930" starttime="20190401 12:55:27.930"></status>
</kw>
<msg timestamp="20190401 12:55:27.930" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:27.930" starttime="20190401 12:55:27.929"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:27.931" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:27.931" starttime="20190401 12:55:27.930"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:27.941" level="INFO">system host-show controller-1|grep -w  install_state|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:27.941" starttime="20190401 12:55:27.931"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:29.081" level="INFO">completed
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:29.081" level="INFO">${output} = completed
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:29.081" starttime="20190401 12:55:27.941"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:29.082" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:29.082" starttime="20190401 12:55:29.082"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:29.082" level="INFO">${clean_out} = completed
</msg>
<status status="PASS" endtime="20190401 12:55:29.083" starttime="20190401 12:55:29.082"></status>
</kw>
<msg timestamp="20190401 12:55:29.083" level="INFO">${output} = completed
</msg>
<status status="PASS" endtime="20190401 12:55:29.083" starttime="20190401 12:55:29.082"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:29.084" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:29.084" starttime="20190401 12:55:29.083"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:29.085" level="INFO">0</msg>
<msg timestamp="20190401 12:55:29.085" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:29.085" starttime="20190401 12:55:29.085"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:29.085" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:29.085" starttime="20190401 12:55:29.085"></status>
</kw>
<msg timestamp="20190401 12:55:29.086" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:29.086" starttime="20190401 12:55:29.083"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.086" starttime="20190401 12:55:29.086"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:29.086" starttime="20190401 12:55:29.086"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.087" starttime="20190401 12:55:29.086"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:29.087" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: completed</msg>
<status status="PASS" endtime="20190401 12:55:29.087" starttime="20190401 12:55:29.087"></status>
</kw>
<msg timestamp="20190401 12:55:29.087" level="INFO">${result} = {u'stdout': u'completed', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:29.087" starttime="20190401 12:55:27.928"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:55:29.087" level="INFO">${value} = completed</msg>
<status status="PASS" endtime="20190401 12:55:29.087" starttime="20190401 12:55:29.087"></status>
</kw>
<msg timestamp="20190401 12:55:29.088" level="INFO">${current_value} = completed</msg>
<status status="PASS" endtime="20190401 12:55:29.088" starttime="20190401 12:55:27.927"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.088" starttime="20190401 12:55:29.088"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:29.088" starttime="20190401 12:55:27.927"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:29.088" starttime="20190401 12:46:33.747"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:29.088" starttime="20190401 12:46:33.746"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:29.088" starttime="20190401 12:46:33.745"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:29.088" starttime="20190401 12:46:29.202"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:29.088" starttime="20190401 12:46:29.202"></status>
</kw>
<kw name="Configure Data Interfaces" library="Utils">
<doc>Configure data interfaces with proper values.</doc>
<arguments>
<arg>${second_controller}</arg>
<arg>${data0if}</arg>
<arg>${data1if}</arg>
<arg>${physnet0}</arg>
<arg>${physnet1}</arg>
<arg>${mtu}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>Run Keywords</arg>
<arg>Provide OAM Network Interface</arg>
<arg>${host}</arg>
<arg>AND</arg>
<arg>Setup Cluster-host Interfaces</arg>
<arg>${host}</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Provide OAM Network Interface</arg>
<arg>${host}</arg>
<arg>AND</arg>
<arg>Setup Cluster-host Interfaces</arg>
<arg>${host}</arg>
</arguments>
<kw name="Provide OAM Network Interface" library="Utils">
<doc>Enables the OAM interface for second controller.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>oam</arg>
</arguments>
<assign>
<var>${net_type}</var>
</assign>
<msg timestamp="20190401 12:55:29.090" level="INFO">${net_type} = oam</msg>
<status status="PASS" endtime="20190401 12:55:29.090" starttime="20190401 12:55:29.090"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>platform</arg>
</arguments>
<assign>
<var>${class}</var>
</assign>
<msg timestamp="20190401 12:55:29.090" level="INFO">${class} = platform</msg>
<status status="PASS" endtime="20190401 12:55:29.090" starttime="20190401 12:55:29.090"></status>
</kw>
<kw name="Get OAM Interface Name" library="Utils">
<doc>Returns the interface name of the OAM network.</doc>
<assign>
<var>${oam_if}</var>
</assign>
<kw name="Get Release Version" library="Utils">
<doc>Returns the version of the release under validation.</doc>
<assign>
<var>${sw_version}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>cat /etc/build.info |</arg>
<arg>grep SW_VERSION | awk '{ split($1, v, "="); print v[2]}'</arg>
</arguments>
<assign>
<var>${cmd_current_version}</var>
</assign>
<msg timestamp="20190401 12:55:29.091" level="INFO">${cmd_current_version} = cat /etc/build.info | grep SW_VERSION | awk '{ split($1, v, "="); print v[2]}'</msg>
<status status="PASS" endtime="20190401 12:55:29.091" starttime="20190401 12:55:29.091"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd_current_version}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.092" starttime="20190401 12:55:29.091"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:29.093" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:29.093" starttime="20190401 12:55:29.092"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.093" starttime="20190401 12:55:29.093"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.093" starttime="20190401 12:55:29.093"></status>
</kw>
<msg timestamp="20190401 12:55:29.094" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:29.094" starttime="20190401 12:55:29.092"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:29.094" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:29.094" starttime="20190401 12:55:29.094"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:29.106" level="INFO">cat /etc/build.info | grep SW_VERSION  | awk '{ split($1, v, "="); print v[2]}'</msg>
<status status="PASS" endtime="20190401 12:55:29.106" starttime="20190401 12:55:29.094"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:29.107" level="INFO">"19.01"
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:29.107" level="INFO">${output} = "19.01"
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:29.107" starttime="20190401 12:55:29.106"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:29.108" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:29.108" starttime="20190401 12:55:29.108"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:29.108" level="INFO">${clean_out} = "19.01"
</msg>
<status status="PASS" endtime="20190401 12:55:29.108" starttime="20190401 12:55:29.108"></status>
</kw>
<msg timestamp="20190401 12:55:29.108" level="INFO">${output} = "19.01"
</msg>
<status status="PASS" endtime="20190401 12:55:29.108" starttime="20190401 12:55:29.107"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:29.109" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:29.110" starttime="20190401 12:55:29.109"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:29.110" level="INFO">0</msg>
<msg timestamp="20190401 12:55:29.110" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:29.111" starttime="20190401 12:55:29.110"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:29.111" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:29.111" starttime="20190401 12:55:29.111"></status>
</kw>
<msg timestamp="20190401 12:55:29.111" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:29.111" starttime="20190401 12:55:29.109"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.112" starttime="20190401 12:55:29.111"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:29.112" starttime="20190401 12:55:29.111"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.112" starttime="20190401 12:55:29.112"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:29.112" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: "19.01"</msg>
<status status="PASS" endtime="20190401 12:55:29.112" starttime="20190401 12:55:29.112"></status>
</kw>
<msg timestamp="20190401 12:55:29.113" level="INFO">&amp;{result} = { stdout="19.01" | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 12:55:29.113" starttime="20190401 12:55:29.091"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${current_version}</var>
</assign>
<msg timestamp="20190401 12:55:29.113" level="INFO">${current_version} = "19.01"</msg>
<status status="PASS" endtime="20190401 12:55:29.113" starttime="20190401 12:55:29.113"></status>
</kw>
<msg timestamp="20190401 12:55:29.113" level="INFO">${sw_version} = 19.01</msg>
<status status="PASS" endtime="20190401 12:55:29.113" starttime="20190401 12:55:29.091"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>cat /opt/platform/config/${sw_version}/cgcs_config</arg>
<arg>grep EXTERNAL_OAM_INTERFACE_NAME</arg>
<arg>awk '{ split($1, v, "="); print v[2]}'</arg>
</arguments>
<assign>
<var>${command}</var>
</assign>
<msg timestamp="20190401 12:55:29.114" level="INFO">${command} = cat /opt/platform/config/19.01/cgcs_config|grep EXTERNAL_OAM_INTERFACE_NAME|awk '{ split($1, v, "="); print v[2]}'</msg>
<status status="PASS" endtime="20190401 12:55:29.114" starttime="20190401 12:55:29.113"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${command}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.114" starttime="20190401 12:55:29.114"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:29.115" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:29.115" starttime="20190401 12:55:29.115"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.115" starttime="20190401 12:55:29.115"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.116" starttime="20190401 12:55:29.116"></status>
</kw>
<msg timestamp="20190401 12:55:29.116" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:29.116" starttime="20190401 12:55:29.115"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:29.116" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:29.116" starttime="20190401 12:55:29.116"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:29.119" level="INFO">cat /opt/platform/config/19.01/cgcs_co nfig|grep EXTERNAL_OAM_INTERFACE_NAME|awk '{ split($1, v, "="); print v[2]}'</msg>
<status status="PASS" endtime="20190401 12:55:29.119" starttime="20190401 12:55:29.116"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:29.121" level="INFO">eno1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:29.121" level="INFO">${output} = eno1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:29.121" starttime="20190401 12:55:29.119"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:29.122" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:29.122" starttime="20190401 12:55:29.122"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:29.122" level="INFO">${clean_out} = eno1
</msg>
<status status="PASS" endtime="20190401 12:55:29.122" starttime="20190401 12:55:29.122"></status>
</kw>
<msg timestamp="20190401 12:55:29.122" level="INFO">${output} = eno1
</msg>
<status status="PASS" endtime="20190401 12:55:29.122" starttime="20190401 12:55:29.121"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:29.123" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:29.124" starttime="20190401 12:55:29.123"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:29.124" level="INFO">0</msg>
<msg timestamp="20190401 12:55:29.124" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:29.124" starttime="20190401 12:55:29.124"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:29.125" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:29.125" starttime="20190401 12:55:29.125"></status>
</kw>
<msg timestamp="20190401 12:55:29.125" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:29.125" starttime="20190401 12:55:29.123"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.126" starttime="20190401 12:55:29.125"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:29.126" starttime="20190401 12:55:29.125"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.126" starttime="20190401 12:55:29.126"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:29.126" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: eno1</msg>
<status status="PASS" endtime="20190401 12:55:29.126" starttime="20190401 12:55:29.126"></status>
</kw>
<msg timestamp="20190401 12:55:29.127" level="INFO">${result} = {u'stdout': u'eno1', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:29.127" starttime="20190401 12:55:29.114"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${oam_if}</var>
</assign>
<msg timestamp="20190401 12:55:29.127" level="INFO">${oam_if} = eno1</msg>
<status status="PASS" endtime="20190401 12:55:29.127" starttime="20190401 12:55:29.127"></status>
</kw>
<msg timestamp="20190401 12:55:29.127" level="INFO">${oam_if} = eno1</msg>
<status status="PASS" endtime="20190401 12:55:29.127" starttime="20190401 12:55:29.090"></status>
</kw>
<kw name="Modify Host Interface" library="Utils">
<doc>Modify interface attributes according to given options.</doc>
<arguments>
<arg>${net_type}</arg>
<arg>${class}</arg>
<arg>${controller}</arg>
<arg>${oam_if}</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system host-if-modify</arg>
<arg>-n oam0 -c ${class} --networks ${net_type}</arg>
<arg>${host}</arg>
<arg>${interface}</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:55:29.128" level="INFO">${system_cmd} = system host-if-modify -n oam0 -c platform --networks oam controller-1 eno1</msg>
<status status="PASS" endtime="20190401 12:55:29.128" starttime="20190401 12:55:29.128"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.129" starttime="20190401 12:55:29.128"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:29.129" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:29.129" starttime="20190401 12:55:29.129"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.130" starttime="20190401 12:55:29.129"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:29.130" starttime="20190401 12:55:29.130"></status>
</kw>
<msg timestamp="20190401 12:55:29.130" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:29.130" starttime="20190401 12:55:29.129"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:29.130" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:29.131" starttime="20190401 12:55:29.130"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:29.133" level="INFO">system host-if-modify -n oam0 -c platf orm --networks oam controller-1 eno1</msg>
<status status="PASS" endtime="20190401 12:55:29.133" starttime="20190401 12:55:29.131"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:30.799" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | oam0                                 |
| iftype       | ethernet                             |
| ports        | [u'eno1']                            |
| datanetworks | []                                   |
| imac         | a4:bf:01:55:03:ba                    |
| imtu         | 1500                                 |
| ifclass      | platform                             |
| networks     | oam                                  |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 7da2b637-f803-49af-8420-8f06dad65439 |
| ihost_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T18:43:52.629861+00:00     |
| updated_at   | 2019-04-01T18:44:16.725008+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | static                               |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:30.799" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | oam0        ...</msg>
<status status="PASS" endtime="20190401 12:55:30.799" starttime="20190401 12:55:29.133"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:30.800" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:30.800" starttime="20190401 12:55:30.799"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:30.800" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | oam0        ...</msg>
<status status="PASS" endtime="20190401 12:55:30.800" starttime="20190401 12:55:30.800"></status>
</kw>
<msg timestamp="20190401 12:55:30.800" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | oam0        ...</msg>
<status status="PASS" endtime="20190401 12:55:30.800" starttime="20190401 12:55:30.799"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:30.803" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:30.803" starttime="20190401 12:55:30.801"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:30.803" level="INFO">0</msg>
<msg timestamp="20190401 12:55:30.803" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:30.803" starttime="20190401 12:55:30.803"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:30.803" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:30.803" starttime="20190401 12:55:30.803"></status>
</kw>
<msg timestamp="20190401 12:55:30.804" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:30.804" starttime="20190401 12:55:30.800"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:30.804" starttime="20190401 12:55:30.804"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:30.804" starttime="20190401 12:55:30.804"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:30.805" starttime="20190401 12:55:30.805"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:30.805" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | oam0                                 |
| iftype       | ethernet                             |
| ports        | [u'eno1']                            |
| datanetworks | []                                   |
| imac         | a4:bf:01:55:03:ba                    |
| imtu         | 1500                                 |
| ifclass      | platform                             |
| networks     | oam                                  |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 7da2b637-f803-49af-8420-8f06dad65439 |
| ihost_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T18:43:52.629861+00:00     |
| updated_at   | 2019-04-01T18:44:16.725008+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | static                               |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:30.805" starttime="20190401 12:55:30.805"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:30.805" starttime="20190401 12:55:29.128"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:30.805" starttime="20190401 12:55:29.127"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:30.805" starttime="20190401 12:55:29.090"></status>
</kw>
<kw name="Setup Cluster-host Interfaces" library="Utils">
<doc>Setup mgmt network as a cluster-host network interface.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-if-modify ${host} mgmt0 --networks cluster-host</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:30.806" starttime="20190401 12:55:30.806"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:30.807" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:30.807" starttime="20190401 12:55:30.807"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:30.807" starttime="20190401 12:55:30.807"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:30.808" starttime="20190401 12:55:30.808"></status>
</kw>
<msg timestamp="20190401 12:55:30.808" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:30.808" starttime="20190401 12:55:30.806"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:30.808" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:30.808" starttime="20190401 12:55:30.808"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:30.810" level="INFO">system host-if-modify controller-1 mgm t0 --networks cluster-host</msg>
<status status="PASS" endtime="20190401 12:55:30.810" starttime="20190401 12:55:30.808"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:32.517" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | mgmt0                                |
| iftype       | ethernet                             |
| ports        | [u'eno2']                            |
| datanetworks | []                                   |
| imac         | a4:bf:01:55:03:bb                    |
| imtu         | 1500                                 |
| ifclass      | platform                             |
| networks     | mgmt,cluster-host                    |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 93d15eed-3632-405e-9f70-b130bd52b11a |
| ihost_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T18:43:52.721363+00:00     |
| updated_at   | 2019-04-01T18:44:18.365247+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | static                               |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:32.517" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | mgmt0       ...</msg>
<status status="PASS" endtime="20190401 12:55:32.517" starttime="20190401 12:55:30.811"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:32.518" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:32.518" starttime="20190401 12:55:32.518"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:32.518" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | mgmt0       ...</msg>
<status status="PASS" endtime="20190401 12:55:32.518" starttime="20190401 12:55:32.518"></status>
</kw>
<msg timestamp="20190401 12:55:32.518" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | mgmt0       ...</msg>
<status status="PASS" endtime="20190401 12:55:32.518" starttime="20190401 12:55:32.517"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:32.520" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:32.520" starttime="20190401 12:55:32.519"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:32.521" level="INFO">0</msg>
<msg timestamp="20190401 12:55:32.521" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:32.521" starttime="20190401 12:55:32.521"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:32.521" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:32.521" starttime="20190401 12:55:32.521"></status>
</kw>
<msg timestamp="20190401 12:55:32.521" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:32.521" starttime="20190401 12:55:32.519"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:32.522" starttime="20190401 12:55:32.522"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:32.522" starttime="20190401 12:55:32.522"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:32.523" starttime="20190401 12:55:32.522"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:32.523" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | mgmt0                                |
| iftype       | ethernet                             |
| ports        | [u'eno2']                            |
| datanetworks | []                                   |
| imac         | a4:bf:01:55:03:bb                    |
| imtu         | 1500                                 |
| ifclass      | platform                             |
| networks     | mgmt,cluster-host                    |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 93d15eed-3632-405e-9f70-b130bd52b11a |
| ihost_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T18:43:52.721363+00:00     |
| updated_at   | 2019-04-01T18:44:18.365247+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | static                               |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:32.523" starttime="20190401 12:55:32.523"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:32.523" starttime="20190401 12:55:30.806"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:32.523" starttime="20190401 12:55:30.806"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:32.523" starttime="20190401 12:55:29.089"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:32.523" starttime="20190401 12:55:29.089"></status>
</kw>
<kw name="Get Interface Information" library="Utils">
<doc>Returns a dictionary with the values of the spcecified
interface.</doc>
<arguments>
<arg>${host}</arg>
<arg>${data0if}</arg>
</arguments>
<assign>
<var>${iface_info}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-port-list ${host} --nowrap</arg>
<arg>grep ${interface}</arg>
<arg>awk '{ print $2,$4,$8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:55:32.524" level="INFO">${cmd} = system host-port-list controller-1 --nowrap|grep enp24s0f0|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190401 12:55:32.524" starttime="20190401 12:55:32.524"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:32.525" starttime="20190401 12:55:32.525"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:32.526" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:32.526" starttime="20190401 12:55:32.525"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:32.526" starttime="20190401 12:55:32.526"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:32.526" starttime="20190401 12:55:32.526"></status>
</kw>
<msg timestamp="20190401 12:55:32.527" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:32.527" starttime="20190401 12:55:32.525"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:32.527" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:32.527" starttime="20190401 12:55:32.527"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:32.529" level="INFO">system host-port-list controller-1 --n owrap|grep enp24s0f0|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190401 12:55:32.529" starttime="20190401 12:55:32.527"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:33.561" level="INFO">cb113d9b-720a-42a7-956b-18ddf78bdb23 enp24s0f0 0000:18:00.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:33.561" level="INFO">${output} = cb113d9b-720a-42a7-956b-18ddf78bdb23 enp24s0f0 0000:18:00.0
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:33.562" starttime="20190401 12:55:32.529"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:33.562" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:33.562" starttime="20190401 12:55:33.562"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:33.563" level="INFO">${clean_out} = cb113d9b-720a-42a7-956b-18ddf78bdb23 enp24s0f0 0000:18:00.0
</msg>
<status status="PASS" endtime="20190401 12:55:33.563" starttime="20190401 12:55:33.562"></status>
</kw>
<msg timestamp="20190401 12:55:33.563" level="INFO">${output} = cb113d9b-720a-42a7-956b-18ddf78bdb23 enp24s0f0 0000:18:00.0
</msg>
<status status="PASS" endtime="20190401 12:55:33.563" starttime="20190401 12:55:33.562"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:33.565" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:33.565" starttime="20190401 12:55:33.563"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:33.565" level="INFO">0</msg>
<msg timestamp="20190401 12:55:33.565" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:33.565" starttime="20190401 12:55:33.565"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:33.566" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:33.566" starttime="20190401 12:55:33.566"></status>
</kw>
<msg timestamp="20190401 12:55:33.566" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:33.566" starttime="20190401 12:55:33.563"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:33.567" starttime="20190401 12:55:33.566"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:33.567" starttime="20190401 12:55:33.566"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:33.567" starttime="20190401 12:55:33.567"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:33.567" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: cb113d9b-720a-42a7-956b-18ddf78bdb23 enp24s0f0 0000:18:00.0</msg>
<status status="PASS" endtime="20190401 12:55:33.567" starttime="20190401 12:55:33.567"></status>
</kw>
<msg timestamp="20190401 12:55:33.568" level="INFO">${info} = {u'stdout': u'cb113d9b-720a-42a7-956b-18ddf78bdb23 enp24s0f0 0000:18:00.0', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:33.568" starttime="20190401 12:55:32.524"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${info}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 12:55:33.568" level="INFO">${response} = cb113d9b-720a-42a7-956b-18ddf78bdb23 enp24s0f0 0000:18:00.0</msg>
<status status="PASS" endtime="20190401 12:55:33.568" starttime="20190401 12:55:33.568"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 12:55:33.568" level="INFO">@{res_in_list} = [ cb113d9b-720a-42a7-956b-18ddf78bdb23 | enp24s0f0 | 0000:18:00.0 ]</msg>
<status status="PASS" endtime="20190401 12:55:33.569" starttime="20190401 12:55:33.568"></status>
</kw>
<msg timestamp="20190401 12:55:33.569" level="INFO">${info} = [u'cb113d9b-720a-42a7-956b-18ddf78bdb23', u'enp24s0f0', u'0000:18:00.0']</msg>
<status status="PASS" endtime="20190401 12:55:33.569" starttime="20190401 12:55:33.568"></status>
</kw>
<msg timestamp="20190401 12:55:33.569" level="INFO">${iface_info} = [u'cb113d9b-720a-42a7-956b-18ddf78bdb23', u'enp24s0f0', u'0000:18:00.0']</msg>
<status status="PASS" endtime="20190401 12:55:33.569" starttime="20190401 12:55:32.523"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data0portuuid}</var>
</assign>
<msg timestamp="20190401 12:55:33.569" level="INFO">${data0portuuid} = cb113d9b-720a-42a7-956b-18ddf78bdb23</msg>
<status status="PASS" endtime="20190401 12:55:33.569" starttime="20190401 12:55:33.569"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data0portname}</var>
</assign>
<msg timestamp="20190401 12:55:33.569" level="INFO">${data0portname} = enp24s0f0</msg>
<status status="PASS" endtime="20190401 12:55:33.570" starttime="20190401 12:55:33.569"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>2</arg>
</arguments>
<assign>
<var>${data0pciaddr}</var>
</assign>
<msg timestamp="20190401 12:55:33.570" level="INFO">${data0pciaddr} = 0000:18:00.0</msg>
<status status="PASS" endtime="20190401 12:55:33.570" starttime="20190401 12:55:33.570"></status>
</kw>
<kw name="Get Interface Information" library="Utils">
<doc>Returns a dictionary with the values of the spcecified
interface.</doc>
<arguments>
<arg>${host}</arg>
<arg>${data1if}</arg>
</arguments>
<assign>
<var>${iface_info}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-port-list ${host} --nowrap</arg>
<arg>grep ${interface}</arg>
<arg>awk '{ print $2,$4,$8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:55:33.571" level="INFO">${cmd} = system host-port-list controller-1 --nowrap|grep enp24s0f1|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190401 12:55:33.571" starttime="20190401 12:55:33.570"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:33.571" starttime="20190401 12:55:33.571"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:33.572" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:33.572" starttime="20190401 12:55:33.572"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:33.572" starttime="20190401 12:55:33.572"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:33.573" starttime="20190401 12:55:33.573"></status>
</kw>
<msg timestamp="20190401 12:55:33.573" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:33.573" starttime="20190401 12:55:33.572"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:33.573" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:33.573" starttime="20190401 12:55:33.573"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:33.587" level="INFO">system host-port-list controller-1 --n owrap|grep enp24s0f1|awk '{ print $2,$4,$8}'</msg>
<status status="PASS" endtime="20190401 12:55:33.587" starttime="20190401 12:55:33.573"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:34.587" level="INFO">2a50fe25-7321-4b0a-b350-0ea87ab63e91 enp24s0f1 0000:18:00.1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:34.587" level="INFO">${output} = 2a50fe25-7321-4b0a-b350-0ea87ab63e91 enp24s0f1 0000:18:00.1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:34.587" starttime="20190401 12:55:33.587"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:34.588" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:34.588" starttime="20190401 12:55:34.588"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:34.588" level="INFO">${clean_out} = 2a50fe25-7321-4b0a-b350-0ea87ab63e91 enp24s0f1 0000:18:00.1
</msg>
<status status="PASS" endtime="20190401 12:55:34.588" starttime="20190401 12:55:34.588"></status>
</kw>
<msg timestamp="20190401 12:55:34.588" level="INFO">${output} = 2a50fe25-7321-4b0a-b350-0ea87ab63e91 enp24s0f1 0000:18:00.1
</msg>
<status status="PASS" endtime="20190401 12:55:34.588" starttime="20190401 12:55:34.587"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:34.590" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:34.590" starttime="20190401 12:55:34.589"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:34.591" level="INFO">0</msg>
<msg timestamp="20190401 12:55:34.591" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:34.591" starttime="20190401 12:55:34.591"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:34.591" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:34.591" starttime="20190401 12:55:34.591"></status>
</kw>
<msg timestamp="20190401 12:55:34.591" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:34.591" starttime="20190401 12:55:34.588"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:34.592" starttime="20190401 12:55:34.592"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:34.592" starttime="20190401 12:55:34.592"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:34.593" starttime="20190401 12:55:34.592"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:34.593" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 2a50fe25-7321-4b0a-b350-0ea87ab63e91 enp24s0f1 0000:18:00.1</msg>
<status status="PASS" endtime="20190401 12:55:34.593" starttime="20190401 12:55:34.593"></status>
</kw>
<msg timestamp="20190401 12:55:34.593" level="INFO">${info} = {u'stdout': u'2a50fe25-7321-4b0a-b350-0ea87ab63e91 enp24s0f1 0000:18:00.1', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:34.593" starttime="20190401 12:55:33.571"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${info}</arg>
</arguments>
<assign>
<var>${info}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 12:55:34.594" level="INFO">${response} = 2a50fe25-7321-4b0a-b350-0ea87ab63e91 enp24s0f1 0000:18:00.1</msg>
<status status="PASS" endtime="20190401 12:55:34.594" starttime="20190401 12:55:34.594"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 12:55:34.594" level="INFO">@{res_in_list} = [ 2a50fe25-7321-4b0a-b350-0ea87ab63e91 | enp24s0f1 | 0000:18:00.1 ]</msg>
<status status="PASS" endtime="20190401 12:55:34.594" starttime="20190401 12:55:34.594"></status>
</kw>
<msg timestamp="20190401 12:55:34.594" level="INFO">${info} = [u'2a50fe25-7321-4b0a-b350-0ea87ab63e91', u'enp24s0f1', u'0000:18:00.1']</msg>
<status status="PASS" endtime="20190401 12:55:34.594" starttime="20190401 12:55:34.593"></status>
</kw>
<msg timestamp="20190401 12:55:34.594" level="INFO">${iface_info} = [u'2a50fe25-7321-4b0a-b350-0ea87ab63e91', u'enp24s0f1', u'0000:18:00.1']</msg>
<status status="PASS" endtime="20190401 12:55:34.594" starttime="20190401 12:55:33.570"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${data1portuuid}</var>
</assign>
<msg timestamp="20190401 12:55:34.595" level="INFO">${data1portuuid} = 2a50fe25-7321-4b0a-b350-0ea87ab63e91</msg>
<status status="PASS" endtime="20190401 12:55:34.595" starttime="20190401 12:55:34.595"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>1</arg>
</arguments>
<assign>
<var>${data1portname}</var>
</assign>
<msg timestamp="20190401 12:55:34.595" level="INFO">${data1portname} = enp24s0f1</msg>
<status status="PASS" endtime="20190401 12:55:34.595" starttime="20190401 12:55:34.595"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${iface_info}</arg>
<arg>2</arg>
</arguments>
<assign>
<var>${data1pciaddr}</var>
</assign>
<msg timestamp="20190401 12:55:34.595" level="INFO">${data1pciaddr} = 0000:18:00.1</msg>
<status status="PASS" endtime="20190401 12:55:34.596" starttime="20190401 12:55:34.595"></status>
</kw>
<kw name="Get Interface UUID" library="Utils">
<doc>Get Interface id of the specified host and port</doc>
<arguments>
<arg>${host}</arg>
<arg>${data0portname}</arg>
</arguments>
<assign>
<var>${data0ifuuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-if-list -a ${host}</arg>
<arg>grep ${port_name}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:55:34.596" level="INFO">${cmd} = system host-if-list -a controller-1|grep enp24s0f0|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:55:34.596" starttime="20190401 12:55:34.596"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${uuid}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:34.597" starttime="20190401 12:55:34.597"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:34.598" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:34.598" starttime="20190401 12:55:34.597"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:34.598" starttime="20190401 12:55:34.598"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:34.599" starttime="20190401 12:55:34.598"></status>
</kw>
<msg timestamp="20190401 12:55:34.599" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:34.599" starttime="20190401 12:55:34.597"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:34.599" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:34.599" starttime="20190401 12:55:34.599"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:34.601" level="INFO">system host-if-list -a controller-1|gr ep enp24s0f0|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:55:34.601" starttime="20190401 12:55:34.599"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:35.751" level="INFO">098a5a6c-913f-4782-a77f-4ff95bff68a5
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:35.751" level="INFO">${output} = 098a5a6c-913f-4782-a77f-4ff95bff68a5
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:35.751" starttime="20190401 12:55:34.601"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:35.752" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:35.752" starttime="20190401 12:55:35.752"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:35.753" level="INFO">${clean_out} = 098a5a6c-913f-4782-a77f-4ff95bff68a5
</msg>
<status status="PASS" endtime="20190401 12:55:35.753" starttime="20190401 12:55:35.752"></status>
</kw>
<msg timestamp="20190401 12:55:35.753" level="INFO">${output} = 098a5a6c-913f-4782-a77f-4ff95bff68a5
</msg>
<status status="PASS" endtime="20190401 12:55:35.753" starttime="20190401 12:55:35.752"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:35.755" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:35.755" starttime="20190401 12:55:35.753"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:35.755" level="INFO">0</msg>
<msg timestamp="20190401 12:55:35.755" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:35.755" starttime="20190401 12:55:35.755"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:35.756" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:35.756" starttime="20190401 12:55:35.755"></status>
</kw>
<msg timestamp="20190401 12:55:35.756" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:35.756" starttime="20190401 12:55:35.753"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:35.757" starttime="20190401 12:55:35.756"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:35.757" starttime="20190401 12:55:35.756"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:35.757" starttime="20190401 12:55:35.757"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:35.757" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 098a5a6c-913f-4782-a77f-4ff95bff68a5</msg>
<status status="PASS" endtime="20190401 12:55:35.757" starttime="20190401 12:55:35.757"></status>
</kw>
<msg timestamp="20190401 12:55:35.757" level="INFO">${uuid} = {u'stdout': u'098a5a6c-913f-4782-a77f-4ff95bff68a5', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:35.757" starttime="20190401 12:55:34.596"></status>
</kw>
<msg timestamp="20190401 12:55:35.758" level="INFO">${data0ifuuid} = 098a5a6c-913f-4782-a77f-4ff95bff68a5</msg>
<status status="PASS" endtime="20190401 12:55:35.758" starttime="20190401 12:55:34.596"></status>
</kw>
<kw name="Get Interface UUID" library="Utils">
<doc>Get Interface id of the specified host and port</doc>
<arguments>
<arg>${host}</arg>
<arg>${data1portname}</arg>
</arguments>
<assign>
<var>${data1ifuuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-if-list -a ${host}</arg>
<arg>grep ${port_name}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:55:35.758" level="INFO">${cmd} = system host-if-list -a controller-1|grep enp24s0f1|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:55:35.758" starttime="20190401 12:55:35.758"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${uuid}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:35.759" starttime="20190401 12:55:35.759"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:35.760" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:35.760" starttime="20190401 12:55:35.759"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:35.760" starttime="20190401 12:55:35.760"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:35.761" starttime="20190401 12:55:35.760"></status>
</kw>
<msg timestamp="20190401 12:55:35.761" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:35.761" starttime="20190401 12:55:35.759"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:35.761" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:35.761" starttime="20190401 12:55:35.761"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:35.764" level="INFO">system host-if-list -a controller-1|gr ep enp24s0f1|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:55:35.764" starttime="20190401 12:55:35.761"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:36.996" level="INFO">b098e794-0904-4fda-8a1e-46b0f3119e8b
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:36.996" level="INFO">${output} = b098e794-0904-4fda-8a1e-46b0f3119e8b
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:36.996" starttime="20190401 12:55:35.764"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:36.997" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:36.997" starttime="20190401 12:55:36.997"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:36.997" level="INFO">${clean_out} = b098e794-0904-4fda-8a1e-46b0f3119e8b
</msg>
<status status="PASS" endtime="20190401 12:55:36.997" starttime="20190401 12:55:36.997"></status>
</kw>
<msg timestamp="20190401 12:55:36.997" level="INFO">${output} = b098e794-0904-4fda-8a1e-46b0f3119e8b
</msg>
<status status="PASS" endtime="20190401 12:55:36.997" starttime="20190401 12:55:36.996"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:36.999" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:37.000" starttime="20190401 12:55:36.998"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:37.000" level="INFO">0</msg>
<msg timestamp="20190401 12:55:37.000" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:37.000" starttime="20190401 12:55:37.000"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:37.000" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:37.000" starttime="20190401 12:55:37.000"></status>
</kw>
<msg timestamp="20190401 12:55:37.000" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:37.000" starttime="20190401 12:55:36.998"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:37.001" starttime="20190401 12:55:37.001"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:37.001" starttime="20190401 12:55:37.001"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:37.002" starttime="20190401 12:55:37.001"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:37.002" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: b098e794-0904-4fda-8a1e-46b0f3119e8b</msg>
<status status="PASS" endtime="20190401 12:55:37.002" starttime="20190401 12:55:37.002"></status>
</kw>
<msg timestamp="20190401 12:55:37.002" level="INFO">${uuid} = {u'stdout': u'b098e794-0904-4fda-8a1e-46b0f3119e8b', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:37.002" starttime="20190401 12:55:35.759"></status>
</kw>
<msg timestamp="20190401 12:55:37.002" level="INFO">${data1ifuuid} = b098e794-0904-4fda-8a1e-46b0f3119e8b</msg>
<status status="PASS" endtime="20190401 12:55:37.002" starttime="20190401 12:55:35.758"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-0' or '${host}'=='compute-0'</arg>
<arg>Run Keywords</arg>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet0} vlan</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system datanetwork-add ${physnet1} vlan</arg>
<arg>True</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:37.003" starttime="20190401 12:55:37.002"></status>
</kw>
<kw name="Add Interface To Data Network" library="Utils">
<doc>Adds an interface to the specified data network.</doc>
<arguments>
<arg>${mtu}</arg>
<arg>data0</arg>
<arg>${physnet0}</arg>
<arg>${host}</arg>
<arg>${data0ifuuid}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controler-0'</arg>
<arg>-d</arg>
<arg>-p</arg>
</arguments>
<assign>
<var>${option}</var>
</assign>
<msg timestamp="20190401 12:55:37.003" level="INFO">${option} = -p</msg>
<status status="PASS" endtime="20190401 12:55:37.003" starttime="20190401 12:55:37.003"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system host-if-modify</arg>
<arg>-m ${mtu}</arg>
<arg>-n ${if_name}</arg>
<arg>${option} ${datanetwork}</arg>
<arg>-c data</arg>
<arg>${host}</arg>
<arg>${uuid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:55:37.004" level="INFO">${cmd} = system host-if-modify -m 1500 -n data0 -p physnet0 -c data controller-1 098a5a6c-913f-4782-a77f-4ff95bff68a5</msg>
<status status="PASS" endtime="20190401 12:55:37.004" starttime="20190401 12:55:37.004"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:37.005" starttime="20190401 12:55:37.004"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:37.005" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:37.005" starttime="20190401 12:55:37.005"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:37.006" starttime="20190401 12:55:37.005"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:37.006" starttime="20190401 12:55:37.006"></status>
</kw>
<msg timestamp="20190401 12:55:37.006" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:37.006" starttime="20190401 12:55:37.005"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:37.006" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:37.007" starttime="20190401 12:55:37.006"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:37.009" level="INFO">system host-if-modify -m 1500 -n data0  -p physnet0 -c data controller-1 098a5a6c-913f-4782-a77f-4ff95bff68a5</msg>
<status status="PASS" endtime="20190401 12:55:37.009" starttime="20190401 12:55:37.007"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:38.489" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f0']                       |
| datanetworks | [u'physnet0']                        |
| imac         | 3c:fd:fe:be:e0:e4                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 098a5a6c-913f-4782-a77f-4ff95bff68a5 |
| ihost_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T18:43:52.437582+00:00     |
| updated_at   | 2019-04-01T18:44:24.449804+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:38.490" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190401 12:55:38.490" starttime="20190401 12:55:37.009"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:38.491" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:38.491" starttime="20190401 12:55:38.490"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:38.491" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190401 12:55:38.491" starttime="20190401 12:55:38.491"></status>
</kw>
<msg timestamp="20190401 12:55:38.491" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0       ...</msg>
<status status="PASS" endtime="20190401 12:55:38.491" starttime="20190401 12:55:38.490"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:38.493" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:38.494" starttime="20190401 12:55:38.491"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:38.494" level="INFO">0</msg>
<msg timestamp="20190401 12:55:38.494" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:38.494" starttime="20190401 12:55:38.494"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:38.494" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:38.494" starttime="20190401 12:55:38.494"></status>
</kw>
<msg timestamp="20190401 12:55:38.495" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:38.495" starttime="20190401 12:55:38.491"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:38.495" starttime="20190401 12:55:38.495"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:38.495" starttime="20190401 12:55:38.495"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:38.496" starttime="20190401 12:55:38.495"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:38.496" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data0                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f0']                       |
| datanetworks | [u'physnet0']                        |
| imac         | 3c:fd:fe:be:e0:e4                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | 098a5a6c-913f-4782-a77f-4ff95bff68a5 |
| ihost_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T18:43:52.437582+00:00     |
| updated_at   | 2019-04-01T18:44:24.449804+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:38.496" starttime="20190401 12:55:38.496"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:38.496" starttime="20190401 12:55:37.004"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:38.496" starttime="20190401 12:55:37.003"></status>
</kw>
<kw name="Add Interface To Data Network" library="Utils">
<doc>Adds an interface to the specified data network.</doc>
<arguments>
<arg>${mtu}</arg>
<arg>data1</arg>
<arg>${physnet1}</arg>
<arg>${host}</arg>
<arg>${data1ifuuid}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controler-0'</arg>
<arg>-d</arg>
<arg>-p</arg>
</arguments>
<assign>
<var>${option}</var>
</assign>
<msg timestamp="20190401 12:55:38.497" level="INFO">${option} = -p</msg>
<status status="PASS" endtime="20190401 12:55:38.497" starttime="20190401 12:55:38.497"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system host-if-modify</arg>
<arg>-m ${mtu}</arg>
<arg>-n ${if_name}</arg>
<arg>${option} ${datanetwork}</arg>
<arg>-c data</arg>
<arg>${host}</arg>
<arg>${uuid}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:55:38.497" level="INFO">${cmd} = system host-if-modify -m 1500 -n data1 -p physnet1 -c data controller-1 b098e794-0904-4fda-8a1e-46b0f3119e8b</msg>
<status status="PASS" endtime="20190401 12:55:38.497" starttime="20190401 12:55:38.497"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:38.498" starttime="20190401 12:55:38.498"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:38.499" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:38.499" starttime="20190401 12:55:38.498"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:38.499" starttime="20190401 12:55:38.499"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:38.499" starttime="20190401 12:55:38.499"></status>
</kw>
<msg timestamp="20190401 12:55:38.500" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:38.500" starttime="20190401 12:55:38.498"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:38.500" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:38.500" starttime="20190401 12:55:38.500"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:38.502" level="INFO">system host-if-modify -m 1500 -n data1  -p physnet1 -c data controller-1 b098e794-0904-4fda-8a1e-46b0f3119e8b</msg>
<status status="PASS" endtime="20190401 12:55:38.502" starttime="20190401 12:55:38.500"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:40.098" level="INFO">+--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f1']                       |
| datanetworks | [u'physnet1']                        |
| imac         | 3c:fd:fe:be:e0:e5                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | b098e794-0904-4fda-8a1e-46b0f3119e8b |
| ihost_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T18:43:52.539267+00:00     |
| updated_at   | 2019-04-01T18:44:26.040851+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:40.098" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190401 12:55:40.098" starttime="20190401 12:55:38.502"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:40.099" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:40.099" starttime="20190401 12:55:40.099"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:40.099" level="INFO">${clean_out} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190401 12:55:40.099" starttime="20190401 12:55:40.099"></status>
</kw>
<msg timestamp="20190401 12:55:40.100" level="INFO">${output} = +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1       ...</msg>
<status status="PASS" endtime="20190401 12:55:40.100" starttime="20190401 12:55:40.098"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:40.102" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:40.102" starttime="20190401 12:55:40.100"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:40.103" level="INFO">0</msg>
<msg timestamp="20190401 12:55:40.103" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:40.103" starttime="20190401 12:55:40.102"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:40.103" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:40.103" starttime="20190401 12:55:40.103"></status>
</kw>
<msg timestamp="20190401 12:55:40.103" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:40.103" starttime="20190401 12:55:40.100"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:40.104" starttime="20190401 12:55:40.104"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:40.104" starttime="20190401 12:55:40.103"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:40.104" starttime="20190401 12:55:40.104"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:40.105" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------+--------------------------------------+
| Property     | Value                                |
+--------------+--------------------------------------+
| ifname       | data1                                |
| iftype       | ethernet                             |
| ports        | [u'enp24s0f1']                       |
| datanetworks | [u'physnet1']                        |
| imac         | 3c:fd:fe:be:e0:e5                    |
| imtu         | 1500                                 |
| ifclass      | data                                 |
| networks     |                                      |
| aemode       | None                                 |
| schedpolicy  | None                                 |
| txhashpolicy | None                                 |
| uuid         | b098e794-0904-4fda-8a1e-46b0f3119e8b |
| ihost_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| vlan_id      | None                                 |
| uses         | []                                   |
| used_by      | []                                   |
| created_at   | 2019-04-01T18:43:52.539267+00:00     |
| updated_at   | 2019-04-01T18:44:26.040851+00:00     |
| sriov_numvfs | 0                                    |
| ipv4_mode    | disabled                             |
| ipv6_mode    | disabled                             |
| accelerated  | [True]                               |
+--------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:40.105" starttime="20190401 12:55:40.104"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:40.105" starttime="20190401 12:55:38.497"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:40.105" starttime="20190401 12:55:38.496"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:40.105" starttime="20190401 12:55:29.089"></status>
</kw>
<kw name="Enable Containerized Services" library="Utils">
<doc>apply all the node labels for each controller
and compute functions.</doc>
<arguments>
<arg>${second_controller}</arg>
</arguments>
<kw name="Evaluate" library="BuiltIn">
<doc>Evaluates the given expression in Python and returns the results.</doc>
<arguments>
<arg>"controller" in """${host}"""</arg>
</arguments>
<assign>
<var>${is_controller}</var>
</assign>
<msg timestamp="20190401 12:55:40.106" level="INFO">${is_controller} = True</msg>
<status status="PASS" endtime="20190401 12:55:40.106" starttime="20190401 12:55:40.105"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-control-plane=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openstack-control-plane=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:40.107" starttime="20190401 12:55:40.107"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:40.107" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:40.107" starttime="20190401 12:55:40.107"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:40.108" starttime="20190401 12:55:40.108"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:40.108" starttime="20190401 12:55:40.108"></status>
</kw>
<msg timestamp="20190401 12:55:40.108" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:40.108" starttime="20190401 12:55:40.107"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:40.109" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:40.109" starttime="20190401 12:55:40.108"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:40.110" level="INFO">system host-label-assign controller-1  openstack-control-plane=enabled</msg>
<status status="PASS" endtime="20190401 12:55:40.110" starttime="20190401 12:55:40.109"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:41.148" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 9ae84c3f-70e0-4c51-aa14-70363951f94a |
| host_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| label_key   | openstack-control-plane              |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:41.148" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 9ae84c3f-70e0-4c...</msg>
<status status="PASS" endtime="20190401 12:55:41.148" starttime="20190401 12:55:40.110"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:41.149" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:41.149" starttime="20190401 12:55:41.149"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:41.149" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 9ae84c3f-70e0-4c...</msg>
<status status="PASS" endtime="20190401 12:55:41.149" starttime="20190401 12:55:41.149"></status>
</kw>
<msg timestamp="20190401 12:55:41.149" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 9ae84c3f-70e0-4c...</msg>
<status status="PASS" endtime="20190401 12:55:41.149" starttime="20190401 12:55:41.148"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:41.151" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:41.151" starttime="20190401 12:55:41.150"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:41.152" level="INFO">0</msg>
<msg timestamp="20190401 12:55:41.152" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:41.152" starttime="20190401 12:55:41.151"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:41.152" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:41.152" starttime="20190401 12:55:41.152"></status>
</kw>
<msg timestamp="20190401 12:55:41.152" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:41.152" starttime="20190401 12:55:41.149"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:41.153" starttime="20190401 12:55:41.153"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:41.153" starttime="20190401 12:55:41.152"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:41.153" starttime="20190401 12:55:41.153"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:41.154" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 9ae84c3f-70e0-4c51-aa14-70363951f94a |
| host_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| label_key   | openstack-control-plane              |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:41.154" starttime="20190401 12:55:41.153"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:41.154" starttime="20190401 12:55:40.106"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:41.154" starttime="20190401 12:55:40.106"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}'=='Simplex' or '${CONFIGURATION_TYPE}'=='Duplex' or ${is_controller}==False</arg>
<arg>Run Keywords</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
<arg>AND</arg>
<arg>Run Command</arg>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openstack-compute-node=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:41.156" starttime="20190401 12:55:41.156"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:41.156" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:41.157" starttime="20190401 12:55:41.156"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:41.157" starttime="20190401 12:55:41.157"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:41.157" starttime="20190401 12:55:41.157"></status>
</kw>
<msg timestamp="20190401 12:55:41.157" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:41.157" starttime="20190401 12:55:41.156"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:41.158" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:41.158" starttime="20190401 12:55:41.157"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:41.169" level="INFO">system host-label-assign controller-1  openstack-compute-node=enabled</msg>
<status status="PASS" endtime="20190401 12:55:41.170" starttime="20190401 12:55:41.158"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:42.206" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | da0dcb26-a1f8-4b72-b96d-4a162326471f |
| host_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| label_key   | openstack-compute-node               |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:42.206" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | da0dcb26-a1f8-4b...</msg>
<status status="PASS" endtime="20190401 12:55:42.206" starttime="20190401 12:55:41.170"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:42.207" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:42.207" starttime="20190401 12:55:42.207"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:42.207" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | da0dcb26-a1f8-4b...</msg>
<status status="PASS" endtime="20190401 12:55:42.207" starttime="20190401 12:55:42.207"></status>
</kw>
<msg timestamp="20190401 12:55:42.207" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | da0dcb26-a1f8-4b...</msg>
<status status="PASS" endtime="20190401 12:55:42.207" starttime="20190401 12:55:42.206"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:42.209" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:42.210" starttime="20190401 12:55:42.208"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:42.210" level="INFO">0</msg>
<msg timestamp="20190401 12:55:42.210" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:42.210" starttime="20190401 12:55:42.210"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:42.210" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:42.210" starttime="20190401 12:55:42.210"></status>
</kw>
<msg timestamp="20190401 12:55:42.211" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:42.211" starttime="20190401 12:55:42.208"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:42.211" starttime="20190401 12:55:42.211"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:42.211" starttime="20190401 12:55:42.211"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:42.212" starttime="20190401 12:55:42.211"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:42.212" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | da0dcb26-a1f8-4b72-b96d-4a162326471f |
| host_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| label_key   | openstack-compute-node               |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:42.212" starttime="20190401 12:55:42.212"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:42.212" starttime="20190401 12:55:41.155"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} openvswitch=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:42.213" starttime="20190401 12:55:42.213"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:42.214" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:42.214" starttime="20190401 12:55:42.213"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:42.214" starttime="20190401 12:55:42.214"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:42.215" starttime="20190401 12:55:42.214"></status>
</kw>
<msg timestamp="20190401 12:55:42.215" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:42.215" starttime="20190401 12:55:42.213"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:42.215" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:42.215" starttime="20190401 12:55:42.215"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:42.217" level="INFO">system host-label-assign controller-1  openvswitch=enabled</msg>
<status status="PASS" endtime="20190401 12:55:42.217" starttime="20190401 12:55:42.215"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:43.389" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 105e123e-9db2-42c0-a821-0bb4fc85651d |
| host_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| label_key   | openvswitch                          |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:43.389" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 105e123e-9db2-42...</msg>
<status status="PASS" endtime="20190401 12:55:43.389" starttime="20190401 12:55:42.217"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:43.390" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:43.390" starttime="20190401 12:55:43.390"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:43.391" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 105e123e-9db2-42...</msg>
<status status="PASS" endtime="20190401 12:55:43.391" starttime="20190401 12:55:43.390"></status>
</kw>
<msg timestamp="20190401 12:55:43.391" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 105e123e-9db2-42...</msg>
<status status="PASS" endtime="20190401 12:55:43.391" starttime="20190401 12:55:43.390"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:43.392" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:43.392" starttime="20190401 12:55:43.391"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:43.393" level="INFO">0</msg>
<msg timestamp="20190401 12:55:43.393" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:43.393" starttime="20190401 12:55:43.393"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:43.393" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:43.393" starttime="20190401 12:55:43.393"></status>
</kw>
<msg timestamp="20190401 12:55:43.393" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:43.393" starttime="20190401 12:55:43.391"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:43.394" starttime="20190401 12:55:43.394"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:43.394" starttime="20190401 12:55:43.394"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:43.395" starttime="20190401 12:55:43.394"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:43.395" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | 105e123e-9db2-42c0-a821-0bb4fc85651d |
| host_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| label_key   | openvswitch                          |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:43.395" starttime="20190401 12:55:43.395"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:43.395" starttime="20190401 12:55:42.212"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-label-assign ${host} sriov=enabled</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:43.396" starttime="20190401 12:55:43.396"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:43.396" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:43.396" starttime="20190401 12:55:43.396"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:43.397" starttime="20190401 12:55:43.397"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:43.397" starttime="20190401 12:55:43.397"></status>
</kw>
<msg timestamp="20190401 12:55:43.397" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:43.397" starttime="20190401 12:55:43.396"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:43.398" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:43.398" starttime="20190401 12:55:43.398"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:43.406" level="INFO">system host-label-assign controller-1  sriov=enabled</msg>
<status status="PASS" endtime="20190401 12:55:43.406" starttime="20190401 12:55:43.398"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:44.465" level="INFO">+-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | d9b33a70-9d99-48a6-b8cc-f047ac517cee |
| host_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| label_key   | sriov                                |
| label_value | enabled                              |
+-------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:44.465" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | d9b33a70-9d99-48...</msg>
<status status="PASS" endtime="20190401 12:55:44.465" starttime="20190401 12:55:43.406"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:44.466" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:44.466" starttime="20190401 12:55:44.466"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:44.467" level="INFO">${clean_out} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | d9b33a70-9d99-48...</msg>
<status status="PASS" endtime="20190401 12:55:44.467" starttime="20190401 12:55:44.466"></status>
</kw>
<msg timestamp="20190401 12:55:44.467" level="INFO">${output} = +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | d9b33a70-9d99-48...</msg>
<status status="PASS" endtime="20190401 12:55:44.467" starttime="20190401 12:55:44.466"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:44.469" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:44.469" starttime="20190401 12:55:44.467"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:44.469" level="INFO">0</msg>
<msg timestamp="20190401 12:55:44.469" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:44.469" starttime="20190401 12:55:44.469"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:44.470" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:44.470" starttime="20190401 12:55:44.470"></status>
</kw>
<msg timestamp="20190401 12:55:44.470" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:44.470" starttime="20190401 12:55:44.467"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:44.471" starttime="20190401 12:55:44.470"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:44.471" starttime="20190401 12:55:44.470"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:44.471" starttime="20190401 12:55:44.471"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:44.471" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------+
| Property    | Value                                |
+-------------+--------------------------------------+
| uuid        | d9b33a70-9d99-48a6-b8cc-f047ac517cee |
| host_uuid   | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| label_key   | sriov                                |
| label_value | enabled                              |
+-------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:44.471" starttime="20190401 12:55:44.471"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:44.471" starttime="20190401 12:55:43.395"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:44.472" starttime="20190401 12:55:41.154"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:44.472" starttime="20190401 12:55:41.154"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:44.472" starttime="20190401 12:55:40.105"></status>
</kw>
<kw name="Setup Partitions" library="Utils">
<doc>Setup required partition on specified host.</doc>
<arguments>
<arg>${second_controller}</arg>
<arg>${lgv_name}</arg>
<arg>${nova_size}</arg>
<arg>${cgts_part_size}</arg>
</arguments>
<kw name="Get Root Disk Device" library="Utils">
<doc>Get the root disk partition assigned to the specified
node</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<assign>
<var>${root_disk_device}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${host}</arg>
<arg>grep rootfs</arg>
<arg>awk '{print $4}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:55:44.473" level="INFO">${cmd} = system host-show controller-1|grep rootfs|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:55:44.473" starttime="20190401 12:55:44.472"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:44.473" starttime="20190401 12:55:44.473"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:44.474" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:44.474" starttime="20190401 12:55:44.474"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:44.474" starttime="20190401 12:55:44.474"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:44.475" starttime="20190401 12:55:44.475"></status>
</kw>
<msg timestamp="20190401 12:55:44.475" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:44.475" starttime="20190401 12:55:44.474"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:44.475" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:44.475" starttime="20190401 12:55:44.475"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:44.477" level="INFO">system host-show controller-1|grep roo tfs|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:55:44.477" starttime="20190401 12:55:44.475"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:45.511" level="INFO">sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:45.511" level="INFO">${output} = sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:45.511" starttime="20190401 12:55:44.477"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:45.512" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:45.512" starttime="20190401 12:55:45.511"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:45.512" level="INFO">${clean_out} = sda
</msg>
<status status="PASS" endtime="20190401 12:55:45.512" starttime="20190401 12:55:45.512"></status>
</kw>
<msg timestamp="20190401 12:55:45.512" level="INFO">${output} = sda
</msg>
<status status="PASS" endtime="20190401 12:55:45.512" starttime="20190401 12:55:45.511"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:45.514" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:45.514" starttime="20190401 12:55:45.512"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:45.515" level="INFO">0</msg>
<msg timestamp="20190401 12:55:45.515" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:45.515" starttime="20190401 12:55:45.514"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:45.515" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:45.515" starttime="20190401 12:55:45.515"></status>
</kw>
<msg timestamp="20190401 12:55:45.515" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:45.515" starttime="20190401 12:55:45.512"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:45.516" starttime="20190401 12:55:45.516"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:45.516" starttime="20190401 12:55:45.515"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:45.516" starttime="20190401 12:55:45.516"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:45.517" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: sda</msg>
<status status="PASS" endtime="20190401 12:55:45.517" starttime="20190401 12:55:45.516"></status>
</kw>
<msg timestamp="20190401 12:55:45.517" level="INFO">${result} = {u'stdout': u'sda', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:45.517" starttime="20190401 12:55:44.473"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${result.stdout.strip()}</arg>
</arguments>
<assign>
<var>${root_disk}</var>
</assign>
<msg timestamp="20190401 12:55:45.517" level="INFO">${root_disk} = sda</msg>
<status status="PASS" endtime="20190401 12:55:45.517" starttime="20190401 12:55:45.517"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host} --nowrap</arg>
<arg>grep ${root_disk}</arg>
<arg>awk '{print $4}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:55:45.518" level="INFO">${cmd} = system host-disk-list controller-1 --nowrap|grep sda|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:55:45.518" starttime="20190401 12:55:45.517"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${root_disk_device}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:45.518" starttime="20190401 12:55:45.518"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:45.519" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:45.519" starttime="20190401 12:55:45.519"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:45.519" starttime="20190401 12:55:45.519"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:45.520" starttime="20190401 12:55:45.520"></status>
</kw>
<msg timestamp="20190401 12:55:45.520" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:45.520" starttime="20190401 12:55:45.519"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:45.520" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:45.520" starttime="20190401 12:55:45.520"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:45.522" level="INFO">system host-disk-list controller-1 --n owrap|grep sda|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 12:55:45.522" starttime="20190401 12:55:45.520"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:46.563" level="INFO">/dev/sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:46.563" level="INFO">${output} = /dev/sda
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:46.563" starttime="20190401 12:55:45.522"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:46.564" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:46.564" starttime="20190401 12:55:46.563"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:46.564" level="INFO">${clean_out} = /dev/sda
</msg>
<status status="PASS" endtime="20190401 12:55:46.564" starttime="20190401 12:55:46.564"></status>
</kw>
<msg timestamp="20190401 12:55:46.564" level="INFO">${output} = /dev/sda
</msg>
<status status="PASS" endtime="20190401 12:55:46.564" starttime="20190401 12:55:46.563"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:46.566" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:46.566" starttime="20190401 12:55:46.565"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:46.567" level="INFO">0</msg>
<msg timestamp="20190401 12:55:46.567" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:46.567" starttime="20190401 12:55:46.566"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:46.567" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:46.567" starttime="20190401 12:55:46.567"></status>
</kw>
<msg timestamp="20190401 12:55:46.567" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:46.567" starttime="20190401 12:55:46.564"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:46.568" starttime="20190401 12:55:46.568"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:46.568" starttime="20190401 12:55:46.567"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:46.568" starttime="20190401 12:55:46.568"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:46.569" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: /dev/sda</msg>
<status status="PASS" endtime="20190401 12:55:46.569" starttime="20190401 12:55:46.568"></status>
</kw>
<msg timestamp="20190401 12:55:46.569" level="INFO">${root_disk_device} = {u'stdout': u'/dev/sda', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:46.569" starttime="20190401 12:55:45.518"></status>
</kw>
<msg timestamp="20190401 12:55:46.569" level="INFO">${root_disk_device} = /dev/sda</msg>
<status status="PASS" endtime="20190401 12:55:46.569" starttime="20190401 12:55:44.472"></status>
</kw>
<kw name="Get Disk List UID" library="Utils">
<doc>Returns the UID of the disk given the device node and
host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_device}</arg>
</arguments>
<assign>
<var>${root_disk_uuid}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host}</arg>
<arg>grep ${device_node}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:55:46.570" level="INFO">${system_cmd} = system host-disk-list controller-1|grep /dev/sda|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:55:46.570" starttime="20190401 12:55:46.570"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:46.570" starttime="20190401 12:55:46.570"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:46.571" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:46.571" starttime="20190401 12:55:46.571"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:46.572" starttime="20190401 12:55:46.571"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:46.572" starttime="20190401 12:55:46.572"></status>
</kw>
<msg timestamp="20190401 12:55:46.572" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:46.572" starttime="20190401 12:55:46.571"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:46.573" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:46.573" starttime="20190401 12:55:46.572"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:46.582" level="INFO">system host-disk-list controller-1|gre p /dev/sda|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:55:46.582" starttime="20190401 12:55:46.573"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:47.613" level="INFO">93560760-a10d-429d-bf0d-f3471d290015
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:47.613" level="INFO">${output} = 93560760-a10d-429d-bf0d-f3471d290015
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:47.613" starttime="20190401 12:55:46.582"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:47.613" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:47.614" starttime="20190401 12:55:47.613"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:47.614" level="INFO">${clean_out} = 93560760-a10d-429d-bf0d-f3471d290015
</msg>
<status status="PASS" endtime="20190401 12:55:47.614" starttime="20190401 12:55:47.614"></status>
</kw>
<msg timestamp="20190401 12:55:47.614" level="INFO">${output} = 93560760-a10d-429d-bf0d-f3471d290015
</msg>
<status status="PASS" endtime="20190401 12:55:47.614" starttime="20190401 12:55:47.613"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:47.616" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:47.616" starttime="20190401 12:55:47.614"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:47.617" level="INFO">0</msg>
<msg timestamp="20190401 12:55:47.617" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:47.617" starttime="20190401 12:55:47.616"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:47.617" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:47.617" starttime="20190401 12:55:47.617"></status>
</kw>
<msg timestamp="20190401 12:55:47.617" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:47.617" starttime="20190401 12:55:47.614"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:47.618" starttime="20190401 12:55:47.618"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:47.618" starttime="20190401 12:55:47.617"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:47.618" starttime="20190401 12:55:47.618"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:47.619" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 93560760-a10d-429d-bf0d-f3471d290015</msg>
<status status="PASS" endtime="20190401 12:55:47.619" starttime="20190401 12:55:47.618"></status>
</kw>
<msg timestamp="20190401 12:55:47.619" level="INFO">&amp;{result} = { stdout=93560760-a10d-429d-bf0d-f3471d290015 | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 12:55:47.619" starttime="20190401 12:55:46.570"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${uid}</var>
</assign>
<msg timestamp="20190401 12:55:47.619" level="INFO">${uid} = 93560760-a10d-429d-bf0d-f3471d290015</msg>
<status status="PASS" endtime="20190401 12:55:47.619" starttime="20190401 12:55:47.619"></status>
</kw>
<msg timestamp="20190401 12:55:47.619" level="INFO">${root_disk_uuid} = 93560760-a10d-429d-bf0d-f3471d290015</msg>
<status status="PASS" endtime="20190401 12:55:47.619" starttime="20190401 12:55:46.569"></status>
</kw>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controller-0'</arg>
<arg>Ready</arg>
<arg>Creating</arg>
</arguments>
<assign>
<var>${part_status}</var>
</assign>
<msg timestamp="20190401 12:55:47.620" level="INFO">${part_status} = Creating</msg>
<status status="PASS" endtime="20190401 12:55:47.620" starttime="20190401 12:55:47.620"></status>
</kw>
<kw name="Evaluate" library="BuiltIn">
<doc>Evaluates the given expression in Python and returns the results.</doc>
<arguments>
<arg>"controller" in """${host}"""</arg>
</arguments>
<assign>
<var>${is_controller}</var>
</assign>
<msg timestamp="20190401 12:55:47.620" level="INFO">${is_controller} = True</msg>
<status status="PASS" endtime="20190401 12:55:47.620" starttime="20190401 12:55:47.620"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${nova_size}==True</arg>
<arg>Calcultae Nova Partition Size For Computes</arg>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>ELSE</arg>
<arg>Set Variable</arg>
<arg>${nova_size}</arg>
</arguments>
<assign>
<var>${nova_size}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${nova_size}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:47.621" starttime="20190401 12:55:47.621"></status>
</kw>
<msg timestamp="20190401 12:55:47.621" level="INFO">${nova_size} = 100</msg>
<status status="PASS" endtime="20190401 12:55:47.621" starttime="20190401 12:55:47.620"></status>
</kw>
<kw name="Add Disk Partition" library="Utils">
<doc>Add a partition for specified disk on the specified host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${nova_size}</arg>
<arg>${part_status}</arg>
</arguments>
<assign>
<var>${nova_partition_uuid}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-disk-partition-add ${host} ${uid} ${size} -t lvm_phys_vol</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:47.622" starttime="20190401 12:55:47.622"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:47.623" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:47.623" starttime="20190401 12:55:47.622"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:47.623" starttime="20190401 12:55:47.623"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:47.623" starttime="20190401 12:55:47.623"></status>
</kw>
<msg timestamp="20190401 12:55:47.624" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:47.624" starttime="20190401 12:55:47.622"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:47.624" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:47.624" starttime="20190401 12:55:47.624"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:47.627" level="INFO">system host-disk-partition-add control ler-1 93560760-a10d-429d-bf0d-f3471d290015 100 -t lvm_phys_vol</msg>
<status status="PASS" endtime="20190401 12:55:47.627" starttime="20190401 12:55:47.624"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:48.772" level="INFO">+-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| device_node | /dev/sda5                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 102400                                           |
| uuid        | e0745e54-367d-49dc-8e14-d7fb3e3c700f             |
| ihost_uuid  | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb             |
| idisk_uuid  | 93560760-a10d-429d-bf0d-f3471d290015             |
| ipv_uuid    | None                                             |
| status      | Creating (on unlock)                             |
| created_at  | 2019-04-01T18:44:34.782476+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:48.772" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:48.772" starttime="20190401 12:55:47.627"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:48.773" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:48.773" starttime="20190401 12:55:48.773"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:48.773" level="INFO">${clean_out} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:48.773" starttime="20190401 12:55:48.773"></status>
</kw>
<msg timestamp="20190401 12:55:48.773" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:48.773" starttime="20190401 12:55:48.772"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:48.775" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:48.775" starttime="20190401 12:55:48.774"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:48.776" level="INFO">0</msg>
<msg timestamp="20190401 12:55:48.776" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:48.776" starttime="20190401 12:55:48.776"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:48.776" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:48.776" starttime="20190401 12:55:48.776"></status>
</kw>
<msg timestamp="20190401 12:55:48.776" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:48.776" starttime="20190401 12:55:48.774"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:48.777" starttime="20190401 12:55:48.777"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:48.777" starttime="20190401 12:55:48.777"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:48.777" starttime="20190401 12:55:48.777"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:48.778" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| device_node | /dev/sda5                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 102400                                           |
| uuid        | e0745e54-367d-49dc-8e14-d7fb3e3c700f             |
| ihost_uuid  | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb             |
| idisk_uuid  | 93560760-a10d-429d-bf0d-f3471d290015             |
| ipv_uuid    | None                                             |
| status      | Creating (on unlock)                             |
| created_at  | 2019-04-01T18:44:34.782476+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:48.778" starttime="20190401 12:55:48.778"></status>
</kw>
<msg timestamp="20190401 12:55:48.778" level="INFO">${result} = {u'stdout': u'+-------------+--------------------------------------------------+\r\n| Property    | Value                                            |\r\n+-------------+-------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:48.778" starttime="20190401 12:55:47.621"></status>
</kw>
<kw name="Get Property From Result" library="Utils">
<arguments>
<arg>${result}</arg>
<arg>uuid</arg>
</arguments>
<assign>
<var>${new_uid}</var>
</assign>
<kw name="String To Dict" library="common">
<doc>Convert string table to dictionary</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:55:48.779" level="INFO">${dict} = {'Property': {'status': {'Value': 'Creating (on unlock)'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': 'e0745e54-367...</msg>
<status status="PASS" endtime="20190401 12:55:48.779" starttime="20190401 12:55:48.778"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Property</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:55:48.779" level="INFO">${dict} = {'status': {'Value': 'Creating (on unlock)'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': 'e0745e54-367d-49dc-8e14-d...</msg>
<status status="PASS" endtime="20190401 12:55:48.779" starttime="20190401 12:55:48.779"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:55:48.779" level="INFO">${dict} = {'Value': 'e0745e54-367d-49dc-8e14-d7fb3e3c700f'}</msg>
<status status="PASS" endtime="20190401 12:55:48.779" starttime="20190401 12:55:48.779"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Value</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:55:48.780" level="INFO">${dict} = e0745e54-367d-49dc-8e14-d7fb3e3c700f</msg>
<status status="PASS" endtime="20190401 12:55:48.780" starttime="20190401 12:55:48.779"></status>
</kw>
<msg timestamp="20190401 12:55:48.780" level="INFO">${new_uid} = e0745e54-367d-49dc-8e14-d7fb3e3c700f</msg>
<status status="PASS" endtime="20190401 12:55:48.780" starttime="20190401 12:55:48.778"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>30 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value Of Command</arg>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:48.781" starttime="20190401 12:55:48.781"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:48.782" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:48.782" starttime="20190401 12:55:48.782"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:48.783" starttime="20190401 12:55:48.782"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:48.783" starttime="20190401 12:55:48.783"></status>
</kw>
<msg timestamp="20190401 12:55:48.783" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:48.783" starttime="20190401 12:55:48.782"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:48.784" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:48.784" starttime="20190401 12:55:48.783"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:48.786" level="INFO">system host-disk-partition-show contro ller-1 e0745e54-367d-49dc-8e14-d7fb3e3c700f | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:48.786" starttime="20190401 12:55:48.784"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:49.811" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:49.812" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:49.812" starttime="20190401 12:55:48.786"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:49.812" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:49.813" starttime="20190401 12:55:49.812"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:49.813" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190401 12:55:49.813" starttime="20190401 12:55:49.813"></status>
</kw>
<msg timestamp="20190401 12:55:49.813" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190401 12:55:49.813" starttime="20190401 12:55:49.812"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:49.815" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:49.815" starttime="20190401 12:55:49.813"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:49.816" level="INFO">0</msg>
<msg timestamp="20190401 12:55:49.816" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:49.816" starttime="20190401 12:55:49.815"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:49.816" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:49.816" starttime="20190401 12:55:49.816"></status>
</kw>
<msg timestamp="20190401 12:55:49.817" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:49.817" starttime="20190401 12:55:49.813"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:49.817" starttime="20190401 12:55:49.817"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:49.817" starttime="20190401 12:55:49.817"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:49.818" starttime="20190401 12:55:49.817"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:49.818" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190401 12:55:49.818" starttime="20190401 12:55:49.818"></status>
</kw>
<msg timestamp="20190401 12:55:49.818" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:49.818" starttime="20190401 12:55:48.781"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:55:49.818" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190401 12:55:49.819" starttime="20190401 12:55:49.818"></status>
</kw>
<msg timestamp="20190401 12:55:49.819" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190401 12:55:49.819" starttime="20190401 12:55:48.781"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:49.819" starttime="20190401 12:55:49.819"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:49.819" starttime="20190401 12:55:48.780"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:49.819" starttime="20190401 12:55:48.780"></status>
</kw>
<msg timestamp="20190401 12:55:49.819" level="INFO">${nova_partition_uuid} = e0745e54-367d-49dc-8e14-d7fb3e3c700f</msg>
<status status="PASS" endtime="20190401 12:55:49.819" starttime="20190401 12:55:47.621"></status>
</kw>
<kw name="Add Local Volume Group" library="Utils">
<doc>Adds a local volume group according to given options.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-lvg-add ${host} ${lvg_name}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:49.820" starttime="20190401 12:55:49.820"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:49.821" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:49.821" starttime="20190401 12:55:49.821"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:49.821" starttime="20190401 12:55:49.821"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:49.822" starttime="20190401 12:55:49.822"></status>
</kw>
<msg timestamp="20190401 12:55:49.822" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:49.822" starttime="20190401 12:55:49.821"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:49.822" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:49.822" starttime="20190401 12:55:49.822"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:49.830" level="INFO">system host-lvg-add controller-1 nova- local</msg>
<status status="PASS" endtime="20190401 12:55:49.830" starttime="20190401 12:55:49.822"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:50.874" level="INFO">+-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+-----------------------+-------------------------------------------------------------------+
| lvm_vg_name           | nova-local                                                        |
| vg_state              | adding                                                            |
| uuid                  | 9712070d-4f3e-4345-92e7-dc8d62604307                              |
| ihost_uuid            | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb                              |
| lvm_vg_access         | None                                                              |
| lvm_max_lv            | 0                                                                 |
| lvm_cur_lv            | 0                                                                 |
| lvm_max_pv            | 0                                                                 |
| lvm_cur_pv            | 0                                                                 |
| lvm_vg_size_gib       | 0.0                                                               |
| lvm_vg_avail_size_gib | 0.0                                                               |
| lvm_vg_total_pe       | 0                                                                 |
| lvm_vg_free_pe        | 0                                                                 |
| created_at            | 2019-04-01T18:44:36.892166+00:00                                  |
| updated_at            | None                                                              |
| parameters            | {u'concurrent_disk_operations': 2, u'instance_backing': u'image'} |
+-----------------------+-------------------------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:50.874" level="INFO">${output} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190401 12:55:50.875" starttime="20190401 12:55:49.830"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:50.875" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:50.876" starttime="20190401 12:55:50.875"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:50.876" level="INFO">${clean_out} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190401 12:55:50.876" starttime="20190401 12:55:50.876"></status>
</kw>
<msg timestamp="20190401 12:55:50.876" level="INFO">${output} = +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+---------...</msg>
<status status="PASS" endtime="20190401 12:55:50.876" starttime="20190401 12:55:50.875"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:50.878" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:50.878" starttime="20190401 12:55:50.876"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:50.879" level="INFO">0</msg>
<msg timestamp="20190401 12:55:50.879" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:50.879" starttime="20190401 12:55:50.878"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:50.879" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:50.879" starttime="20190401 12:55:50.879"></status>
</kw>
<msg timestamp="20190401 12:55:50.879" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:50.879" starttime="20190401 12:55:50.876"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:50.880" starttime="20190401 12:55:50.880"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:50.880" starttime="20190401 12:55:50.879"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:50.880" starttime="20190401 12:55:50.880"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:50.881" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-----------------------+-------------------------------------------------------------------+
| Property              | Value                                                             |
+-----------------------+-------------------------------------------------------------------+
| lvm_vg_name           | nova-local                                                        |
| vg_state              | adding                                                            |
| uuid                  | 9712070d-4f3e-4345-92e7-dc8d62604307                              |
| ihost_uuid            | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb                              |
| lvm_vg_access         | None                                                              |
| lvm_max_lv            | 0                                                                 |
| lvm_cur_lv            | 0                                                                 |
| lvm_max_pv            | 0                                                                 |
| lvm_cur_pv            | 0                                                                 |
| lvm_vg_size_gib       | 0.0                                                               |
| lvm_vg_avail_size_gib | 0.0                                                               |
| lvm_vg_total_pe       | 0                                                                 |
| lvm_vg_free_pe        | 0                                                                 |
| created_at            | 2019-04-01T18:44:36.892166+00:00                                  |
| updated_at            | None                                                              |
| parameters            | {u'concurrent_disk_operations': 2, u'instance_backing': u'image'} |
+-----------------------+-------------------------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:50.881" starttime="20190401 12:55:50.880"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:50.881" starttime="20190401 12:55:49.820"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:50.881" starttime="20190401 12:55:49.820"></status>
</kw>
<kw name="Add Physical Volume" library="Utils">
<doc>Adds a physical volume to the specified host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${nova_partition_uuid}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-pv-add ${host} ${lvg name} ${uid}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:50.882" starttime="20190401 12:55:50.882"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:50.883" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:50.883" starttime="20190401 12:55:50.882"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:50.883" starttime="20190401 12:55:50.883"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:50.884" starttime="20190401 12:55:50.883"></status>
</kw>
<msg timestamp="20190401 12:55:50.884" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:50.884" starttime="20190401 12:55:50.882"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:50.884" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:50.884" starttime="20190401 12:55:50.884"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:50.896" level="INFO">system host-pv-add controller-1 nova-l ocal e0745e54-367d-49dc-8e14-d7fb3e3c700f</msg>
<status status="PASS" endtime="20190401 12:55:50.896" starttime="20190401 12:55:50.884"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:52.036" level="INFO">+--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | e1a30e90-95d7-47f0-b5b3-b09c4dd0f83b             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | e0745e54-367d-49dc-8e14-d7fb3e3c700f             |
| disk_or_part_device_node | /dev/sda5                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| lvm_pv_name              | /dev/sda5                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb             |
| created_at               | 2019-04-01T18:44:38.038142+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:52.036" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:55:52.036" starttime="20190401 12:55:50.896"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:52.037" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:52.037" starttime="20190401 12:55:52.037"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:52.037" level="INFO">${clean_out} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:55:52.037" starttime="20190401 12:55:52.037"></status>
</kw>
<msg timestamp="20190401 12:55:52.038" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:55:52.038" starttime="20190401 12:55:52.036"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:52.039" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:52.039" starttime="20190401 12:55:52.038"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:52.040" level="INFO">0</msg>
<msg timestamp="20190401 12:55:52.040" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:52.040" starttime="20190401 12:55:52.040"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:52.040" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:52.040" starttime="20190401 12:55:52.040"></status>
</kw>
<msg timestamp="20190401 12:55:52.041" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:52.041" starttime="20190401 12:55:52.038"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:52.042" starttime="20190401 12:55:52.041"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:52.042" starttime="20190401 12:55:52.041"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:52.042" starttime="20190401 12:55:52.042"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:52.042" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | e1a30e90-95d7-47f0-b5b3-b09c4dd0f83b             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | e0745e54-367d-49dc-8e14-d7fb3e3c700f             |
| disk_or_part_device_node | /dev/sda5                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part5 |
| lvm_pv_name              | /dev/sda5                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb             |
| created_at               | 2019-04-01T18:44:38.038142+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:52.042" starttime="20190401 12:55:52.042"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:52.043" starttime="20190401 12:55:50.881"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:52.043" starttime="20190401 12:55:50.881"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==False</arg>
<arg>Modify LVG Attributes</arg>
<arg>-b image</arg>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:52.043" starttime="20190401 12:55:52.043"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True or ${setup_cgts}==True</arg>
<arg>Add Disk Partition</arg>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>${part_status}</arg>
</arguments>
<assign>
<var>${cgts_partition_uuid}</var>
</assign>
<kw name="Add Disk Partition" library="Utils">
<doc>Add a partition for specified disk on the specified host</doc>
<arguments>
<arg>${host}</arg>
<arg>${root_disk_uuid}</arg>
<arg>${cgts_part_size}</arg>
<arg>${part_status}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-disk-partition-add ${host} ${uid} ${size} -t lvm_phys_vol</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:52.044" starttime="20190401 12:55:52.044"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:52.045" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:52.045" starttime="20190401 12:55:52.045"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:52.045" starttime="20190401 12:55:52.045"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:52.046" starttime="20190401 12:55:52.046"></status>
</kw>
<msg timestamp="20190401 12:55:52.046" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:52.046" starttime="20190401 12:55:52.044"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:52.046" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:52.046" starttime="20190401 12:55:52.046"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:52.060" level="INFO">system host-disk-partition-add control ler-1 93560760-a10d-429d-bf0d-f3471d290015 20 -t lvm_phys_vol</msg>
<status status="PASS" endtime="20190401 12:55:52.060" starttime="20190401 12:55:52.046"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:53.208" level="INFO">+-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| device_node | /dev/sda6                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 20480                                            |
| uuid        | 87d4b027-4abd-4ed6-8e5c-343d80c317ea             |
| ihost_uuid  | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb             |
| idisk_uuid  | 93560760-a10d-429d-bf0d-f3471d290015             |
| ipv_uuid    | None                                             |
| status      | Creating (on unlock)                             |
| created_at  | 2019-04-01T18:44:39.215994+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:53.209" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:53.209" starttime="20190401 12:55:52.060"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:53.209" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:53.209" starttime="20190401 12:55:53.209"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:53.210" level="INFO">${clean_out} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:53.210" starttime="20190401 12:55:53.210"></status>
</kw>
<msg timestamp="20190401 12:55:53.210" level="INFO">${output} = +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+-------------------------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:53.210" starttime="20190401 12:55:53.209"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:53.212" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:53.212" starttime="20190401 12:55:53.210"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:53.212" level="INFO">0</msg>
<msg timestamp="20190401 12:55:53.212" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:53.213" starttime="20190401 12:55:53.212"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:53.213" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:53.213" starttime="20190401 12:55:53.213"></status>
</kw>
<msg timestamp="20190401 12:55:53.213" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:53.213" starttime="20190401 12:55:53.210"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:53.214" starttime="20190401 12:55:53.213"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:53.214" starttime="20190401 12:55:53.213"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:53.214" starttime="20190401 12:55:53.214"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:53.214" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +-------------+--------------------------------------------------+
| Property    | Value                                            |
+-------------+--------------------------------------------------+
| device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| device_node | /dev/sda6                                        |
| type_guid   | ba5eba11-0000-1111-2222-000000000001             |
| type_name   | None                                             |
| start_mib   | None                                             |
| end_mib     | None                                             |
| size_mib    | 20480                                            |
| uuid        | 87d4b027-4abd-4ed6-8e5c-343d80c317ea             |
| ihost_uuid  | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb             |
| idisk_uuid  | 93560760-a10d-429d-bf0d-f3471d290015             |
| ipv_uuid    | None                                             |
| status      | Creating (on unlock)                             |
| created_at  | 2019-04-01T18:44:39.215994+00:00                 |
| updated_at  | None                                             |
+-------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:53.214" starttime="20190401 12:55:53.214"></status>
</kw>
<msg timestamp="20190401 12:55:53.215" level="INFO">${result} = {u'stdout': u'+-------------+--------------------------------------------------+\r\n| Property    | Value                                            |\r\n+-------------+-------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:53.215" starttime="20190401 12:55:52.044"></status>
</kw>
<kw name="Get Property From Result" library="Utils">
<arguments>
<arg>${result}</arg>
<arg>uuid</arg>
</arguments>
<assign>
<var>${new_uid}</var>
</assign>
<kw name="String To Dict" library="common">
<doc>Convert string table to dictionary</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:55:53.215" level="INFO">${dict} = {'Property': {'status': {'Value': 'Creating (on unlock)'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '87d4b027-4ab...</msg>
<status status="PASS" endtime="20190401 12:55:53.216" starttime="20190401 12:55:53.215"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Property</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:55:53.216" level="INFO">${dict} = {'status': {'Value': 'Creating (on unlock)'}, 'device_path': {'Value': '/dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6'}, 'start_mib': {'Value': 'None'}, 'uuid': {'Value': '87d4b027-4abd-4ed6-8e5c-3...</msg>
<status status="PASS" endtime="20190401 12:55:53.216" starttime="20190401 12:55:53.216"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:55:53.216" level="INFO">${dict} = {'Value': '87d4b027-4abd-4ed6-8e5c-343d80c317ea'}</msg>
<status status="PASS" endtime="20190401 12:55:53.216" starttime="20190401 12:55:53.216"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${dict}</arg>
<arg>Value</arg>
</arguments>
<assign>
<var>${dict}</var>
</assign>
<msg timestamp="20190401 12:55:53.217" level="INFO">${dict} = 87d4b027-4abd-4ed6-8e5c-343d80c317ea</msg>
<status status="PASS" endtime="20190401 12:55:53.217" starttime="20190401 12:55:53.216"></status>
</kw>
<msg timestamp="20190401 12:55:53.217" level="INFO">${new_uid} = 87d4b027-4abd-4ed6-8e5c-343d80c317ea</msg>
<status status="PASS" endtime="20190401 12:55:53.217" starttime="20190401 12:55:53.215"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>30 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value Of Command</arg>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Check Property Value Of Command" library="Utils">
<doc>Validates that property is set correctly to the expected
value on the repsonse of command given.</doc>
<arguments>
<arg>system host-disk-partition-show ${host} ${new_uid}</arg>
<arg>status</arg>
<arg>${status}</arg>
</arguments>
<kw name="Get Property Value Of Command" library="Utils">
<doc>Given a command that returns a a table, this command
returns the specific value of the property specified.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd} | grep -w ${property} | awk '{print$4}'</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:53.218" starttime="20190401 12:55:53.218"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:53.219" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:53.219" starttime="20190401 12:55:53.219"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:53.219" starttime="20190401 12:55:53.219"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:53.220" starttime="20190401 12:55:53.219"></status>
</kw>
<msg timestamp="20190401 12:55:53.220" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:53.220" starttime="20190401 12:55:53.218"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:53.220" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:53.220" starttime="20190401 12:55:53.220"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:53.238" level="INFO">system host-disk-partition-show contro ller-1 87d4b027-4abd-4ed6-8e5c-343d80c317ea | grep -w status | awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:53.238" starttime="20190401 12:55:53.220"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:54.235" level="INFO">Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:54.235" level="INFO">${output} = Creating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:54.235" starttime="20190401 12:55:53.238"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:54.236" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:54.236" starttime="20190401 12:55:54.236"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:54.236" level="INFO">${clean_out} = Creating
</msg>
<status status="PASS" endtime="20190401 12:55:54.236" starttime="20190401 12:55:54.236"></status>
</kw>
<msg timestamp="20190401 12:55:54.237" level="INFO">${output} = Creating
</msg>
<status status="PASS" endtime="20190401 12:55:54.237" starttime="20190401 12:55:54.235"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:54.239" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:54.239" starttime="20190401 12:55:54.237"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:54.239" level="INFO">0</msg>
<msg timestamp="20190401 12:55:54.239" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:54.239" starttime="20190401 12:55:54.239"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:54.239" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:54.240" starttime="20190401 12:55:54.239"></status>
</kw>
<msg timestamp="20190401 12:55:54.240" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:54.240" starttime="20190401 12:55:54.237"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:54.241" starttime="20190401 12:55:54.240"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:54.241" starttime="20190401 12:55:54.240"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:54.241" starttime="20190401 12:55:54.241"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:54.241" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: Creating</msg>
<status status="PASS" endtime="20190401 12:55:54.242" starttime="20190401 12:55:54.241"></status>
</kw>
<msg timestamp="20190401 12:55:54.242" level="INFO">${result} = {u'stdout': u'Creating', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:54.242" starttime="20190401 12:55:53.218"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:55:54.242" level="INFO">${value} = Creating</msg>
<status status="PASS" endtime="20190401 12:55:54.242" starttime="20190401 12:55:54.242"></status>
</kw>
<msg timestamp="20190401 12:55:54.242" level="INFO">${current_value} = Creating</msg>
<status status="PASS" endtime="20190401 12:55:54.242" starttime="20190401 12:55:53.217"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:54.243" starttime="20190401 12:55:54.243"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:54.243" starttime="20190401 12:55:53.217"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:54.243" starttime="20190401 12:55:53.217"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:54.243" starttime="20190401 12:55:52.043"></status>
</kw>
<msg timestamp="20190401 12:55:54.243" level="INFO">${cgts_partition_uuid} = 87d4b027-4abd-4ed6-8e5c-343d80c317ea</msg>
<status status="PASS" endtime="20190401 12:55:54.243" starttime="20190401 12:55:52.043"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${is_controller}==True or ${setup_cgts}==True</arg>
<arg>Add Physical Volume</arg>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${cgts_partition_uuid}</arg>
</arguments>
<kw name="Add Physical Volume" library="Utils">
<doc>Adds a physical volume to the specified host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${lgv_name}</arg>
<arg>${cgts_partition_uuid}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-pv-add ${host} ${lvg name} ${uid}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:54.245" starttime="20190401 12:55:54.245"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:54.246" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:54.246" starttime="20190401 12:55:54.245"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:54.246" starttime="20190401 12:55:54.246"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:54.246" starttime="20190401 12:55:54.246"></status>
</kw>
<msg timestamp="20190401 12:55:54.247" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:54.247" starttime="20190401 12:55:54.245"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:54.247" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:54.247" starttime="20190401 12:55:54.247"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:54.249" level="INFO">system host-pv-add controller-1 nova-l ocal 87d4b027-4abd-4ed6-8e5c-343d80c317ea</msg>
<status status="PASS" endtime="20190401 12:55:54.249" starttime="20190401 12:55:54.247"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:55.432" level="INFO">+--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | dcd5a3a0-9289-4257-8a63-e981bc8ce42b             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 87d4b027-4abd-4ed6-8e5c-343d80c317ea             |
| disk_or_part_device_node | /dev/sda6                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| lvm_pv_name              | /dev/sda6                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb             |
| created_at               | 2019-04-01T18:44:41.436648+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:55.432" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:55:55.432" starttime="20190401 12:55:54.249"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:55.433" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:55.433" starttime="20190401 12:55:55.432"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:55.433" level="INFO">${clean_out} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:55:55.433" starttime="20190401 12:55:55.433"></status>
</kw>
<msg timestamp="20190401 12:55:55.433" level="INFO">${output} = +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+----------...</msg>
<status status="PASS" endtime="20190401 12:55:55.433" starttime="20190401 12:55:55.432"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:55.435" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:55.435" starttime="20190401 12:55:55.434"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:55.436" level="INFO">0</msg>
<msg timestamp="20190401 12:55:55.436" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:55.436" starttime="20190401 12:55:55.435"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:55.436" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:55.436" starttime="20190401 12:55:55.436"></status>
</kw>
<msg timestamp="20190401 12:55:55.436" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:55.436" starttime="20190401 12:55:55.433"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:55.437" starttime="20190401 12:55:55.437"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:55.437" starttime="20190401 12:55:55.436"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:55.437" starttime="20190401 12:55:55.437"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:55.438" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +--------------------------+--------------------------------------------------+
| Property                 | Value                                            |
+--------------------------+--------------------------------------------------+
| uuid                     | dcd5a3a0-9289-4257-8a63-e981bc8ce42b             |
| pv_state                 | adding                                           |
| pv_type                  | partition                                        |
| disk_or_part_uuid        | 87d4b027-4abd-4ed6-8e5c-343d80c317ea             |
| disk_or_part_device_node | /dev/sda6                                        |
| disk_or_part_device_path | /dev/disk/by-path/pci-0000:00:17.0-ata-1.0-part6 |
| lvm_pv_name              | /dev/sda6                                        |
| lvm_vg_name              | nova-local                                       |
| lvm_pv_uuid              | None                                             |
| lvm_pv_size_gib          | 0.0                                              |
| lvm_pe_total             | 0                                                |
| lvm_pe_alloced           | 0                                                |
| ihost_uuid               | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb             |
| created_at               | 2019-04-01T18:44:41.436648+00:00                 |
| updated_at               | None                                             |
+--------------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:55.438" starttime="20190401 12:55:55.437"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:55.438" starttime="20190401 12:55:54.244"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:55.438" starttime="20190401 12:55:54.244"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:55.438" starttime="20190401 12:55:54.243"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:55.438" starttime="20190401 12:55:44.472"></status>
</kw>
<kw name="Configure Ceph" library="Utils">
<doc>Enable CEPH partition on the specified node</doc>
<arguments>
<arg>${second_controller}</arg>
<arg>${backend_type}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-0'</arg>
<arg>Run Keywords</arg>
<arg>Add LVM Storage Backend</arg>
<arg>${backend_type}</arg>
<arg>--confirmed</arg>
<arg>AND</arg>
<arg>Check Ceph Status</arg>
<arg>HEALTH_ERR</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:55.439" starttime="20190401 12:55:55.439"></status>
</kw>
<kw name="Add ODS To Tier" library="Utils">
<doc>Enable the ODS on the specified node.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>/dev/sdb</arg>
</arguments>
<assign>
<var>${device}</var>
</assign>
<msg timestamp="20190401 12:55:55.439" level="INFO">${device} = /dev/sdb</msg>
<status status="PASS" endtime="20190401 12:55:55.439" starttime="20190401 12:55:55.439"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>ceph_cluster</arg>
</arguments>
<assign>
<var>${tier_name}</var>
</assign>
<msg timestamp="20190401 12:55:55.440" level="INFO">${tier_name} = ceph_cluster</msg>
<status status="PASS" endtime="20190401 12:55:55.440" starttime="20190401 12:55:55.439"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>${SPACE}</arg>
</arguments>
<assign>
<var>${tier_opt}</var>
</assign>
<msg timestamp="20190401 12:55:55.440" level="INFO">${tier_opt} =  </msg>
<status status="PASS" endtime="20190401 12:55:55.440" starttime="20190401 12:55:55.440"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-disk-list ${host}</arg>
<arg>grep ${device}</arg>
<arg>awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:55:55.440" level="INFO">${cmd} = system host-disk-list controller-1|grep /dev/sdb|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:55:55.441" starttime="20190401 12:55:55.440"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:55.441" starttime="20190401 12:55:55.441"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:55.442" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:55.442" starttime="20190401 12:55:55.442"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:55.442" starttime="20190401 12:55:55.442"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:55.443" starttime="20190401 12:55:55.442"></status>
</kw>
<msg timestamp="20190401 12:55:55.443" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:55.443" starttime="20190401 12:55:55.441"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:55.443" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:55.443" starttime="20190401 12:55:55.443"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:55.445" level="INFO">system host-disk-list controller-1|gre p /dev/sdb|awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:55:55.445" starttime="20190401 12:55:55.443"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:56.467" level="INFO">069c2517-1429-481d-b12a-e1cf9ace49b1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:56.467" level="INFO">${output} = 069c2517-1429-481d-b12a-e1cf9ace49b1
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:56.467" starttime="20190401 12:55:55.446"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:56.468" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:56.468" starttime="20190401 12:55:56.468"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:56.468" level="INFO">${clean_out} = 069c2517-1429-481d-b12a-e1cf9ace49b1
</msg>
<status status="PASS" endtime="20190401 12:55:56.468" starttime="20190401 12:55:56.468"></status>
</kw>
<msg timestamp="20190401 12:55:56.468" level="INFO">${output} = 069c2517-1429-481d-b12a-e1cf9ace49b1
</msg>
<status status="PASS" endtime="20190401 12:55:56.468" starttime="20190401 12:55:56.467"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:56.470" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:56.471" starttime="20190401 12:55:56.469"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:56.471" level="INFO">0</msg>
<msg timestamp="20190401 12:55:56.471" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:56.471" starttime="20190401 12:55:56.471"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:56.471" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:56.471" starttime="20190401 12:55:56.471"></status>
</kw>
<msg timestamp="20190401 12:55:56.472" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:56.472" starttime="20190401 12:55:56.469"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:56.472" starttime="20190401 12:55:56.472"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:56.472" starttime="20190401 12:55:56.472"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:56.473" starttime="20190401 12:55:56.472"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:56.473" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 069c2517-1429-481d-b12a-e1cf9ace49b1</msg>
<status status="PASS" endtime="20190401 12:55:56.473" starttime="20190401 12:55:56.473"></status>
</kw>
<msg timestamp="20190401 12:55:56.473" level="INFO">${result} = {u'stdout': u'069c2517-1429-481d-b12a-e1cf9ace49b1', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:56.473" starttime="20190401 12:55:55.441"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>Get Tier UUID</arg>
<arg>${tier_name}</arg>
</arguments>
<assign>
<var>${tier_uuid}</var>
</assign>
<kw name="Get Tier UUID" library="Utils">
<doc>Returns the TIER uuid</doc>
<arguments>
<arg>${tier_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>storage</arg>
</arguments>
<assign>
<var>${name}</var>
</assign>
<msg timestamp="20190401 12:55:56.474" level="INFO">${name} = storage</msg>
<status status="PASS" endtime="20190401 12:55:56.474" starttime="20190401 12:55:56.474"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>system storage-tier-list</arg>
<arg>${tier_name}</arg>
<arg>|grep ${name}</arg>
<arg>|awk '{print $2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 12:55:56.474" level="INFO">${cmd} = system storage-tier-list ceph_cluster |grep storage |awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:55:56.474" starttime="20190401 12:55:56.474"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${uuid}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:56.476" starttime="20190401 12:55:56.475"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:56.476" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:56.476" starttime="20190401 12:55:56.476"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:56.477" starttime="20190401 12:55:56.476"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:56.477" starttime="20190401 12:55:56.477"></status>
</kw>
<msg timestamp="20190401 12:55:56.477" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:56.477" starttime="20190401 12:55:56.476"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:56.477" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:56.477" starttime="20190401 12:55:56.477"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:56.488" level="INFO">system storage-tier-list ceph_cluster  |grep storage |awk '{print $2}'</msg>
<status status="PASS" endtime="20190401 12:55:56.488" starttime="20190401 12:55:56.478"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:57.572" level="INFO">3c727df7-e614-4c0a-8c2c-d456f04ca631
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:57.573" level="INFO">${output} = 3c727df7-e614-4c0a-8c2c-d456f04ca631
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:57.573" starttime="20190401 12:55:56.488"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:57.573" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:57.573" starttime="20190401 12:55:57.573"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:57.574" level="INFO">${clean_out} = 3c727df7-e614-4c0a-8c2c-d456f04ca631
</msg>
<status status="PASS" endtime="20190401 12:55:57.574" starttime="20190401 12:55:57.573"></status>
</kw>
<msg timestamp="20190401 12:55:57.574" level="INFO">${output} = 3c727df7-e614-4c0a-8c2c-d456f04ca631
</msg>
<status status="PASS" endtime="20190401 12:55:57.574" starttime="20190401 12:55:57.573"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:57.576" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:57.576" starttime="20190401 12:55:57.574"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:57.576" level="INFO">0</msg>
<msg timestamp="20190401 12:55:57.576" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:57.576" starttime="20190401 12:55:57.576"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:57.577" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:57.577" starttime="20190401 12:55:57.577"></status>
</kw>
<msg timestamp="20190401 12:55:57.577" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:57.577" starttime="20190401 12:55:57.574"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:57.578" starttime="20190401 12:55:57.577"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:57.578" starttime="20190401 12:55:57.577"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:57.578" starttime="20190401 12:55:57.578"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:57.578" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: 3c727df7-e614-4c0a-8c2c-d456f04ca631</msg>
<status status="PASS" endtime="20190401 12:55:57.578" starttime="20190401 12:55:57.578"></status>
</kw>
<msg timestamp="20190401 12:55:57.578" level="INFO">${uuid} = {u'stdout': u'3c727df7-e614-4c0a-8c2c-d456f04ca631', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:55:57.578" starttime="20190401 12:55:56.474"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:57.579" starttime="20190401 12:55:56.474"></status>
</kw>
<msg timestamp="20190401 12:55:57.579" level="INFO">${tier_uuid} = 3c727df7-e614-4c0a-8c2c-d456f04ca631</msg>
<status status="PASS" endtime="20190401 12:55:57.579" starttime="20190401 12:55:56.473"></status>
</kw>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${host}'=='controller-1'</arg>
<arg>--tier-uuid ${tier_uuid}</arg>
<arg>${EMPTY}</arg>
</arguments>
<assign>
<var>${tier_opt}</var>
</assign>
<msg timestamp="20190401 12:55:57.579" level="INFO">${tier_opt} = --tier-uuid 3c727df7-e614-4c0a-8c2c-d456f04ca631</msg>
<status status="PASS" endtime="20190401 12:55:57.579" starttime="20190401 12:55:57.579"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-stor-add ${host} ${result.stdout.strip()} ${tier_opt}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:57.580" starttime="20190401 12:55:57.580"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:57.581" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:57.581" starttime="20190401 12:55:57.580"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:57.581" starttime="20190401 12:55:57.581"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:57.581" starttime="20190401 12:55:57.581"></status>
</kw>
<msg timestamp="20190401 12:55:57.582" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:57.582" starttime="20190401 12:55:57.580"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:57.582" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:57.582" starttime="20190401 12:55:57.582"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:57.600" level="INFO">system host-stor-add controller-1 069c 2517-1429-481d-b12a-e1cf9ace49b1 --tier-uuid 3c727df7-e614-4c0a-8c2c-d456f04ca63 1</msg>
<status status="PASS" endtime="20190401 12:55:57.600" starttime="20190401 12:55:57.582"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:59.061" level="INFO">+------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+--------------------------------------------------+
| osdid            | 1                                                |
| function         | osd                                              |
| state            | configuring-on-unlock                            |
| journal_location | 9f58de2d-6081-4c55-a360-31a4346ae55d             |
| journal_size_gib | 1024                                             |
| journal_path     | /dev/disk/by-path/pci-0000:00:17.0-ata-2.0-part2 |
| journal_node     | /dev/sdb2                                        |
| uuid             | 9f58de2d-6081-4c55-a360-31a4346ae55d             |
| ihost_uuid       | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb             |
| idisk_uuid       | 069c2517-1429-481d-b12a-e1cf9ace49b1             |
| tier_uuid        | 3c727df7-e614-4c0a-8c2c-d456f04ca631             |
| tier_name        | storage                                          |
| created_at       | 2019-04-01T18:44:44.702809+00:00                 |
| updated_at       | 2019-04-01T18:44:44.911950+00:00                 |
+------------------+--------------------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:59.061" level="INFO">${output} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:59.061" starttime="20190401 12:55:57.600"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:59.062" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:59.062" starttime="20190401 12:55:59.062"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:59.062" level="INFO">${clean_out} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:59.062" starttime="20190401 12:55:59.062"></status>
</kw>
<msg timestamp="20190401 12:55:59.062" level="INFO">${output} = +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+----------------------------------...</msg>
<status status="PASS" endtime="20190401 12:55:59.062" starttime="20190401 12:55:59.061"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:59.064" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:59.064" starttime="20190401 12:55:59.063"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:59.065" level="INFO">0</msg>
<msg timestamp="20190401 12:55:59.065" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:59.065" starttime="20190401 12:55:59.065"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:59.065" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:59.065" starttime="20190401 12:55:59.065"></status>
</kw>
<msg timestamp="20190401 12:55:59.065" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:59.065" starttime="20190401 12:55:59.062"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.066" starttime="20190401 12:55:59.066"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:59.066" starttime="20190401 12:55:59.065"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.066" starttime="20190401 12:55:59.066"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:59.067" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +------------------+--------------------------------------------------+
| Property         | Value                                            |
+------------------+--------------------------------------------------+
| osdid            | 1                                                |
| function         | osd                                              |
| state            | configuring-on-unlock                            |
| journal_location | 9f58de2d-6081-4c55-a360-31a4346ae55d             |
| journal_size_gib | 1024                                             |
| journal_path     | /dev/disk/by-path/pci-0000:00:17.0-ata-2.0-part2 |
| journal_node     | /dev/sdb2                                        |
| uuid             | 9f58de2d-6081-4c55-a360-31a4346ae55d             |
| ihost_uuid       | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb             |
| idisk_uuid       | 069c2517-1429-481d-b12a-e1cf9ace49b1             |
| tier_uuid        | 3c727df7-e614-4c0a-8c2c-d456f04ca631             |
| tier_name        | storage                                          |
| created_at       | 2019-04-01T18:44:44.702809+00:00                 |
| updated_at       | 2019-04-01T18:44:44.911950+00:00                 |
+------------------+--------------------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:55:59.067" starttime="20190401 12:55:59.066"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:59.067" starttime="20190401 12:55:57.579"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd tree</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.067" starttime="20190401 12:55:59.067"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:59.068" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:59.068" starttime="20190401 12:55:59.068"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.068" starttime="20190401 12:55:59.068"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.069" starttime="20190401 12:55:59.069"></status>
</kw>
<msg timestamp="20190401 12:55:59.069" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:59.069" starttime="20190401 12:55:59.068"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:59.069" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:59.069" starttime="20190401 12:55:59.069"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:59.070" level="INFO">ceph osd tree</msg>
<status status="PASS" endtime="20190401 12:55:59.070" starttime="20190401 12:55:59.069"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:55:59.207" level="INFO">ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3       0         host controller-1                                   
 1       0 osd.1                        down        0          1.00000 
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:55:59.207" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190401 12:55:59.207" starttime="20190401 12:55:59.070"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:55:59.208" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:59.208" starttime="20190401 12:55:59.208"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:55:59.208" level="INFO">${clean_out} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190401 12:55:59.208" starttime="20190401 12:55:59.208"></status>
</kw>
<msg timestamp="20190401 12:55:59.209" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190401 12:55:59.209" starttime="20190401 12:55:59.207"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:55:59.210" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:55:59.211" starttime="20190401 12:55:59.209"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:55:59.211" level="INFO">0</msg>
<msg timestamp="20190401 12:55:59.211" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:59.211" starttime="20190401 12:55:59.211"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:55:59.211" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:55:59.211" starttime="20190401 12:55:59.211"></status>
</kw>
<msg timestamp="20190401 12:55:59.211" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:55:59.211" starttime="20190401 12:55:59.209"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.212" starttime="20190401 12:55:59.212"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:59.212" starttime="20190401 12:55:59.212"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.213" starttime="20190401 12:55:59.212"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:55:59.213" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.43549 root storage-tier                                           
-2 0.43549     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3       0         host controller-1                                   
 1       0 osd.1                        down        0          1.00000</msg>
<status status="PASS" endtime="20190401 12:55:59.213" starttime="20190401 12:55:59.213"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:59.213" starttime="20190401 12:55:59.067"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:59.213" starttime="20190401 12:55:55.439"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}'=='Simplex'</arg>
<arg>Set Ceph Pool Replication</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.214" starttime="20190401 12:55:59.213"></status>
</kw>
<status status="PASS" endtime="20190401 12:55:59.214" starttime="20190401 12:55:55.438"></status>
</kw>
<kw name="Unlock Second Controller" library="Utils">
<doc>Verify second controller is unlocked.</doc>
<arguments>
<arg>${second_controller}</arg>
</arguments>
<kw name="Unlock Controller" library="Utils">
<doc>Unlocks specified controller.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>15 min</arg>
<arg>10 sec</arg>
<arg>Check Property Value</arg>
<arg>${controller_name}</arg>
<arg>availability</arg>
<arg>online</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>availability</arg>
<arg>online</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:55:59.216" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:59.216" starttime="20190401 12:55:59.215"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.216" starttime="20190401 12:55:59.216"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:55:59.217" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:55:59.217" starttime="20190401 12:55:59.217"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.217" starttime="20190401 12:55:59.217"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:55:59.218" starttime="20190401 12:55:59.217"></status>
</kw>
<msg timestamp="20190401 12:55:59.218" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:55:59.218" starttime="20190401 12:55:59.216"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:55:59.218" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:55:59.218" starttime="20190401 12:55:59.218"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:55:59.221" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:55:59.221" starttime="20190401 12:55:59.218"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:56:00.254" level="INFO">online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:56:00.254" level="INFO">${output} = online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:00.254" starttime="20190401 12:55:59.221"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:56:00.254" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:00.255" starttime="20190401 12:56:00.254"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:56:00.255" level="INFO">${clean_out} = online
</msg>
<status status="PASS" endtime="20190401 12:56:00.255" starttime="20190401 12:56:00.255"></status>
</kw>
<msg timestamp="20190401 12:56:00.255" level="INFO">${output} = online
</msg>
<status status="PASS" endtime="20190401 12:56:00.255" starttime="20190401 12:56:00.254"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:56:00.257" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:56:00.257" starttime="20190401 12:56:00.255"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:56:00.258" level="INFO">0</msg>
<msg timestamp="20190401 12:56:00.258" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:00.258" starttime="20190401 12:56:00.257"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:56:00.258" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:56:00.258" starttime="20190401 12:56:00.258"></status>
</kw>
<msg timestamp="20190401 12:56:00.259" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:00.259" starttime="20190401 12:56:00.255"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:00.259" starttime="20190401 12:56:00.259"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:00.259" starttime="20190401 12:56:00.259"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:00.260" starttime="20190401 12:56:00.259"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:56:00.260" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: online</msg>
<status status="PASS" endtime="20190401 12:56:00.260" starttime="20190401 12:56:00.260"></status>
</kw>
<msg timestamp="20190401 12:56:00.260" level="INFO">${result} = {u'stdout': u'online', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:56:00.260" starttime="20190401 12:55:59.216"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:56:00.260" level="INFO">${value} = online</msg>
<status status="PASS" endtime="20190401 12:56:00.261" starttime="20190401 12:56:00.260"></status>
</kw>
<msg timestamp="20190401 12:56:00.261" level="INFO">${current_value} = online</msg>
<status status="PASS" endtime="20190401 12:56:00.261" starttime="20190401 12:55:59.215"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:00.261" starttime="20190401 12:56:00.261"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:00.261" starttime="20190401 12:55:59.215"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:00.261" starttime="20190401 12:55:59.214"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system host-unlock ${controller_name}</arg>
<arg>True</arg>
<arg>60</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:00.262" starttime="20190401 12:56:00.262"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:56:00.263" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:56:00.263" starttime="20190401 12:56:00.262"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:00.263" starttime="20190401 12:56:00.263"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:00.263" starttime="20190401 12:56:00.263"></status>
</kw>
<msg timestamp="20190401 12:56:00.263" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:56:00.264" starttime="20190401 12:56:00.262"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:56:00.264" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:00.264" starttime="20190401 12:56:00.264"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:56:00.269" level="INFO">system host-unlock controller-1</msg>
<status status="PASS" endtime="20190401 12:56:00.269" starttime="20190401 12:56:00.264"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:56:05.200" level="INFO">+---------------------+--------------------------------------+
| Property            | Value                                |
+---------------------+--------------------------------------+
| action              | none                                 |
| administrative      | locked                               |
| availability        | online                               |
| bm_ip               | None                                 |
| bm_type             | None                                 |
| bm_username         | None                                 |
| boot_device         | sda                                  |
| capabilities        | {u'stor_function': u'monitor'}       |
| config_applied      | None                                 |
| config_status       | Config out-of-date                   |
| config_target       | 8d5742f3-3925-4f4d-9813-b708f7010c18 |
| console             | ttyS0,115200                         |
| created_at          | 2019-04-01T18:35:17.435156+00:00     |
| hostname            | controller-1                         |
| id                  | 2                                    |
| install_output      | text                                 |
| install_state       | completed                            |
| install_state_info  | None                                 |
| invprovision        | unprovisioned                        |
| location            | {}                                   |
| mgmt_ip             | 10.10.53.4                           |
| mgmt_mac            | a4:bf:01:55:03:bb                    |
| operational         | disabled                             |
| personality         | controller                           |
| reserved            | False                                |
| rootfs_device       | sda                                  |
| serialid            | None                                 |
| software_load       | 19.01                                |
| subfunction_avail   | online                               |
| subfunction_oper    | disabled                             |
| subfunctions        | controller,worker                    |
| task                | Unlocking                            |
| tboot               | false                                |
| ttys_dcd            | None                                 |
| updated_at          | 2019-04-01T18:44:44.987743+00:00     |
| uptime              | 45                                   |
| uuid                | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| vim_progress_status | None                                 |
+---------------------+--------------------------------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:56:05.200" level="INFO">${output} = +---------------------+--------------------------------------+
| Property            | Value                                |
+---------------------+--------------------------------------+
| action...</msg>
<status status="PASS" endtime="20190401 12:56:05.200" starttime="20190401 12:56:00.269"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:56:05.201" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:05.201" starttime="20190401 12:56:05.201"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:56:05.201" level="INFO">${clean_out} = +---------------------+--------------------------------------+
| Property            | Value                                |
+---------------------+--------------------------------------+
| action...</msg>
<status status="PASS" endtime="20190401 12:56:05.201" starttime="20190401 12:56:05.201"></status>
</kw>
<msg timestamp="20190401 12:56:05.202" level="INFO">${output} = +---------------------+--------------------------------------+
| Property            | Value                                |
+---------------------+--------------------------------------+
| action...</msg>
<status status="PASS" endtime="20190401 12:56:05.202" starttime="20190401 12:56:05.200"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:56:05.203" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:56:05.204" starttime="20190401 12:56:05.202"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:56:05.207" level="INFO">0</msg>
<msg timestamp="20190401 12:56:05.207" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:05.207" starttime="20190401 12:56:05.204"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:56:05.208" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:56:05.208" starttime="20190401 12:56:05.208"></status>
</kw>
<msg timestamp="20190401 12:56:05.208" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:05.208" starttime="20190401 12:56:05.202"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:05.209" starttime="20190401 12:56:05.209"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:05.209" starttime="20190401 12:56:05.208"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:05.209" starttime="20190401 12:56:05.209"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:56:05.210" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +---------------------+--------------------------------------+
| Property            | Value                                |
+---------------------+--------------------------------------+
| action              | none                                 |
| administrative      | locked                               |
| availability        | online                               |
| bm_ip               | None                                 |
| bm_type             | None                                 |
| bm_username         | None                                 |
| boot_device         | sda                                  |
| capabilities        | {u'stor_function': u'monitor'}       |
| config_applied      | None                                 |
| config_status       | Config out-of-date                   |
| config_target       | 8d5742f3-3925-4f4d-9813-b708f7010c18 |
| console             | ttyS0,115200                         |
| created_at          | 2019-04-01T18:35:17.435156+00:00     |
| hostname            | controller-1                         |
| id                  | 2                                    |
| install_output      | text                                 |
| install_state       | completed                            |
| install_state_info  | None                                 |
| invprovision        | unprovisioned                        |
| location            | {}                                   |
| mgmt_ip             | 10.10.53.4                           |
| mgmt_mac            | a4:bf:01:55:03:bb                    |
| operational         | disabled                             |
| personality         | controller                           |
| reserved            | False                                |
| rootfs_device       | sda                                  |
| serialid            | None                                 |
| software_load       | 19.01                                |
| subfunction_avail   | online                               |
| subfunction_oper    | disabled                             |
| subfunctions        | controller,worker                    |
| task                | Unlocking                            |
| tboot               | false                                |
| ttys_dcd            | None                                 |
| updated_at          | 2019-04-01T18:44:44.987743+00:00     |
| uptime              | 45                                   |
| uuid                | aaad1a33-a9ec-4fe1-a94b-3ac08b23f9cb |
| vim_progress_status | None                                 |
+---------------------+--------------------------------------+</msg>
<status status="PASS" endtime="20190401 12:56:05.210" starttime="20190401 12:56:05.209"></status>
</kw>
<msg timestamp="20190401 12:56:05.210" level="INFO">${result} = {u'stdout': u"+---------------------+--------------------------------------+\r\n| Property            | Value                                |\r\n+---------------------+-------------------------------...</msg>
<status status="PASS" endtime="20190401 12:56:05.210" starttime="20190401 12:56:00.261"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:05.210" starttime="20190401 12:55:59.214"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>40 min</arg>
<arg>30 sec</arg>
<arg>Check Controller Is Unlocked</arg>
<arg>${controller}</arg>
</arguments>
<kw name="Check Controller Is Unlocked" library="Utils">
<doc>Validates that controller is successfully unlocked.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:05.212" starttime="20190401 12:56:05.211"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:56:05.212" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:56:05.212" starttime="20190401 12:56:05.212"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:05.213" starttime="20190401 12:56:05.212"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:05.213" starttime="20190401 12:56:05.213"></status>
</kw>
<msg timestamp="20190401 12:56:05.213" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:56:05.213" starttime="20190401 12:56:05.212"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:56:05.213" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:05.213" starttime="20190401 12:56:05.213"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:56:05.218" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 12:56:05.218" starttime="20190401 12:56:05.214"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:56:05.638" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:56:05.638" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:05.638" starttime="20190401 12:56:05.218"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:56:05.639" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:05.639" starttime="20190401 12:56:05.639"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:56:05.639" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 12:56:05.639" starttime="20190401 12:56:05.639"></status>
</kw>
<msg timestamp="20190401 12:56:05.639" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 12:56:05.639" starttime="20190401 12:56:05.638"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:56:05.641" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:56:05.642" starttime="20190401 12:56:05.640"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:56:05.642" level="INFO">0</msg>
<msg timestamp="20190401 12:56:05.642" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:05.642" starttime="20190401 12:56:05.642"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:56:05.642" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:56:05.642" starttime="20190401 12:56:05.642"></status>
</kw>
<msg timestamp="20190401 12:56:05.643" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:05.643" starttime="20190401 12:56:05.639"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:05.643" starttime="20190401 12:56:05.643"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:05.643" starttime="20190401 12:56:05.643"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:05.644" starttime="20190401 12:56:05.643"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:56:05.644" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 12:56:05.644" starttime="20190401 12:56:05.644"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:05.644" starttime="20190401 12:56:05.211"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:05.644" starttime="20190401 12:56:05.211"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller_name}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:56:05.645" level="INFO">${system_cmd} = system host-show controller-1|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:56:05.645" starttime="20190401 12:56:05.645"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:05.646" starttime="20190401 12:56:05.646"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:56:05.647" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:56:05.647" starttime="20190401 12:56:05.646"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:05.647" starttime="20190401 12:56:05.647"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:05.647" starttime="20190401 12:56:05.647"></status>
</kw>
<msg timestamp="20190401 12:56:05.648" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:56:05.648" starttime="20190401 12:56:05.646"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:56:05.648" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:05.648" starttime="20190401 12:56:05.648"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:56:05.650" level="INFO">system host-show controller-1|grep -w  administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:56:05.650" starttime="20190401 12:56:05.648"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:56:06.674" level="INFO">unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:56:06.674" level="INFO">${output} = unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:06.674" starttime="20190401 12:56:05.650"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:56:06.675" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:06.675" starttime="20190401 12:56:06.675"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:56:06.675" level="INFO">${clean_out} = unlocked
</msg>
<status status="PASS" endtime="20190401 12:56:06.675" starttime="20190401 12:56:06.675"></status>
</kw>
<msg timestamp="20190401 12:56:06.675" level="INFO">${output} = unlocked
</msg>
<status status="PASS" endtime="20190401 12:56:06.676" starttime="20190401 12:56:06.674"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:56:06.677" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:56:06.678" starttime="20190401 12:56:06.676"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:56:06.678" level="INFO">0</msg>
<msg timestamp="20190401 12:56:06.678" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:06.678" starttime="20190401 12:56:06.678"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:56:06.678" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:56:06.678" starttime="20190401 12:56:06.678"></status>
</kw>
<msg timestamp="20190401 12:56:06.678" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:06.678" starttime="20190401 12:56:06.676"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:06.679" starttime="20190401 12:56:06.679"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:06.679" starttime="20190401 12:56:06.679"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:06.679" starttime="20190401 12:56:06.679"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:56:06.680" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: unlocked</msg>
<status status="PASS" endtime="20190401 12:56:06.680" starttime="20190401 12:56:06.680"></status>
</kw>
<msg timestamp="20190401 12:56:06.680" level="INFO">${result} = {u'stdout': u'unlocked', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:56:06.680" starttime="20190401 12:56:05.645"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:56:06.680" level="INFO">${value} = unlocked</msg>
<status status="PASS" endtime="20190401 12:56:06.680" starttime="20190401 12:56:06.680"></status>
</kw>
<msg timestamp="20190401 12:56:06.681" level="INFO">${current_value} = unlocked</msg>
<status status="PASS" endtime="20190401 12:56:06.681" starttime="20190401 12:56:05.645"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:06.681" starttime="20190401 12:56:06.681"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:06.681" starttime="20190401 12:56:05.644"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:06.681" starttime="20190401 12:56:05.210"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:06.681" starttime="20190401 12:56:05.210"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>50 min</arg>
<arg>20 sec</arg>
<arg>Check Property Value</arg>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:56:06.682" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:56:06.682" starttime="20190401 12:56:06.682"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:06.683" starttime="20190401 12:56:06.683"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:56:06.684" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:56:06.684" starttime="20190401 12:56:06.683"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:06.684" starttime="20190401 12:56:06.684"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:06.684" starttime="20190401 12:56:06.684"></status>
</kw>
<msg timestamp="20190401 12:56:06.685" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:56:06.685" starttime="20190401 12:56:06.683"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:56:06.685" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:06.685" starttime="20190401 12:56:06.685"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:56:06.687" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:56:06.687" starttime="20190401 12:56:06.685"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:56:07.677" level="INFO">online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:56:07.677" level="INFO">${output} = online
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:07.677" starttime="20190401 12:56:06.687"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:56:07.678" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:07.678" starttime="20190401 12:56:07.678"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:56:07.678" level="INFO">${clean_out} = online
</msg>
<status status="PASS" endtime="20190401 12:56:07.678" starttime="20190401 12:56:07.678"></status>
</kw>
<msg timestamp="20190401 12:56:07.678" level="INFO">${output} = online
</msg>
<status status="PASS" endtime="20190401 12:56:07.679" starttime="20190401 12:56:07.677"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:56:07.680" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:56:07.680" starttime="20190401 12:56:07.679"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:56:07.681" level="INFO">0</msg>
<msg timestamp="20190401 12:56:07.681" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:07.681" starttime="20190401 12:56:07.680"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:56:07.681" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:56:07.681" starttime="20190401 12:56:07.681"></status>
</kw>
<msg timestamp="20190401 12:56:07.681" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:07.681" starttime="20190401 12:56:07.679"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:07.682" starttime="20190401 12:56:07.682"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:07.682" starttime="20190401 12:56:07.681"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:07.682" starttime="20190401 12:56:07.682"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:56:07.683" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: online</msg>
<status status="PASS" endtime="20190401 12:56:07.683" starttime="20190401 12:56:07.682"></status>
</kw>
<msg timestamp="20190401 12:56:07.683" level="INFO">${result} = {u'stdout': u'online', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:56:07.683" starttime="20190401 12:56:06.683"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:56:07.683" level="INFO">${value} = online</msg>
<status status="PASS" endtime="20190401 12:56:07.683" starttime="20190401 12:56:07.683"></status>
</kw>
<msg timestamp="20190401 12:56:07.683" level="INFO">${current_value} = online</msg>
<status status="PASS" endtime="20190401 12:56:07.683" starttime="20190401 12:56:06.682"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:56:07.684" level="FAIL">online != available</msg>
<status status="FAIL" endtime="20190401 12:56:07.684" starttime="20190401 12:56:07.684"></status>
</kw>
<status status="FAIL" endtime="20190401 12:56:07.684" starttime="20190401 12:56:06.682"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:56:27.686" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:56:27.686" starttime="20190401 12:56:27.685"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:27.687" starttime="20190401 12:56:27.686"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:56:27.688" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:56:27.688" starttime="20190401 12:56:27.687"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:27.688" starttime="20190401 12:56:27.688"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:27.688" starttime="20190401 12:56:27.688"></status>
</kw>
<msg timestamp="20190401 12:56:27.688" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:56:27.688" starttime="20190401 12:56:27.687"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:56:27.689" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:27.689" starttime="20190401 12:56:27.689"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:56:27.698" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:56:27.698" starttime="20190401 12:56:27.689"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:56:28.794" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:56:28.794" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:28.794" starttime="20190401 12:56:27.698"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:56:28.795" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:28.795" starttime="20190401 12:56:28.795"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:56:28.795" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:56:28.795" starttime="20190401 12:56:28.795"></status>
</kw>
<msg timestamp="20190401 12:56:28.795" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:56:28.795" starttime="20190401 12:56:28.794"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:56:28.797" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:56:28.797" starttime="20190401 12:56:28.796"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:56:28.798" level="INFO">0</msg>
<msg timestamp="20190401 12:56:28.798" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:28.798" starttime="20190401 12:56:28.797"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:56:28.798" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:56:28.798" starttime="20190401 12:56:28.798"></status>
</kw>
<msg timestamp="20190401 12:56:28.798" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:28.798" starttime="20190401 12:56:28.795"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:28.799" starttime="20190401 12:56:28.799"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:28.799" starttime="20190401 12:56:28.798"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:28.799" starttime="20190401 12:56:28.799"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:56:28.800" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:56:28.800" starttime="20190401 12:56:28.799"></status>
</kw>
<msg timestamp="20190401 12:56:28.800" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:56:28.800" starttime="20190401 12:56:27.686"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:56:28.800" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:56:28.800" starttime="20190401 12:56:28.800"></status>
</kw>
<msg timestamp="20190401 12:56:28.800" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:56:28.800" starttime="20190401 12:56:27.685"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:56:28.801" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:56:28.801" starttime="20190401 12:56:28.801"></status>
</kw>
<status status="FAIL" endtime="20190401 12:56:28.801" starttime="20190401 12:56:27.684"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:56:48.802" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:56:48.802" starttime="20190401 12:56:48.802"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:48.803" starttime="20190401 12:56:48.803"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:56:48.804" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:56:48.804" starttime="20190401 12:56:48.803"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:48.804" starttime="20190401 12:56:48.804"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:48.805" starttime="20190401 12:56:48.804"></status>
</kw>
<msg timestamp="20190401 12:56:48.805" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:56:48.805" starttime="20190401 12:56:48.803"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:56:48.805" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:48.805" starttime="20190401 12:56:48.805"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:56:48.815" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:56:48.815" starttime="20190401 12:56:48.805"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:56:49.810" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:56:49.810" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:49.810" starttime="20190401 12:56:48.815"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:56:49.811" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:56:49.811" starttime="20190401 12:56:49.810"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:56:49.811" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:56:49.811" starttime="20190401 12:56:49.811"></status>
</kw>
<msg timestamp="20190401 12:56:49.811" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:56:49.811" starttime="20190401 12:56:49.810"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:56:49.813" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:56:49.813" starttime="20190401 12:56:49.812"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:56:49.813" level="INFO">0</msg>
<msg timestamp="20190401 12:56:49.814" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:49.814" starttime="20190401 12:56:49.813"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:56:49.814" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:56:49.814" starttime="20190401 12:56:49.814"></status>
</kw>
<msg timestamp="20190401 12:56:49.814" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:56:49.814" starttime="20190401 12:56:49.811"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:49.815" starttime="20190401 12:56:49.815"></status>
</kw>
<status status="PASS" endtime="20190401 12:56:49.815" starttime="20190401 12:56:49.814"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:56:49.815" starttime="20190401 12:56:49.815"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:56:49.815" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:56:49.816" starttime="20190401 12:56:49.815"></status>
</kw>
<msg timestamp="20190401 12:56:49.816" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:56:49.816" starttime="20190401 12:56:48.803"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:56:49.816" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:56:49.816" starttime="20190401 12:56:49.816"></status>
</kw>
<msg timestamp="20190401 12:56:49.816" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:56:49.816" starttime="20190401 12:56:48.802"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:56:49.817" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:56:49.817" starttime="20190401 12:56:49.816"></status>
</kw>
<status status="FAIL" endtime="20190401 12:56:49.817" starttime="20190401 12:56:48.801"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:57:09.818" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:57:09.818" starttime="20190401 12:57:09.818"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:09.819" starttime="20190401 12:57:09.819"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:57:09.820" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:57:09.820" starttime="20190401 12:57:09.819"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:09.820" starttime="20190401 12:57:09.820"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:09.820" starttime="20190401 12:57:09.820"></status>
</kw>
<msg timestamp="20190401 12:57:09.821" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:57:09.821" starttime="20190401 12:57:09.819"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:57:09.821" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:57:09.821" starttime="20190401 12:57:09.821"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:57:09.835" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:57:09.835" starttime="20190401 12:57:09.821"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:57:10.828" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:57:10.828" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:57:10.828" starttime="20190401 12:57:09.836"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:57:10.829" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:57:10.829" starttime="20190401 12:57:10.828"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:57:10.829" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:57:10.829" starttime="20190401 12:57:10.829"></status>
</kw>
<msg timestamp="20190401 12:57:10.829" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:57:10.829" starttime="20190401 12:57:10.828"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:57:10.831" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:57:10.831" starttime="20190401 12:57:10.830"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:57:10.832" level="INFO">0</msg>
<msg timestamp="20190401 12:57:10.832" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:57:10.832" starttime="20190401 12:57:10.832"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:57:10.832" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:57:10.833" starttime="20190401 12:57:10.832"></status>
</kw>
<msg timestamp="20190401 12:57:10.833" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:57:10.833" starttime="20190401 12:57:10.829"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:10.833" starttime="20190401 12:57:10.833"></status>
</kw>
<status status="PASS" endtime="20190401 12:57:10.833" starttime="20190401 12:57:10.833"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:10.834" starttime="20190401 12:57:10.834"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:57:10.834" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:57:10.834" starttime="20190401 12:57:10.834"></status>
</kw>
<msg timestamp="20190401 12:57:10.834" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:57:10.834" starttime="20190401 12:57:09.818"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:57:10.835" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:57:10.835" starttime="20190401 12:57:10.834"></status>
</kw>
<msg timestamp="20190401 12:57:10.835" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:57:10.835" starttime="20190401 12:57:09.818"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:57:10.835" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:57:10.835" starttime="20190401 12:57:10.835"></status>
</kw>
<status status="FAIL" endtime="20190401 12:57:10.835" starttime="20190401 12:57:09.817"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:57:30.837" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:57:30.837" starttime="20190401 12:57:30.837"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:30.838" starttime="20190401 12:57:30.838"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:57:30.839" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:57:30.839" starttime="20190401 12:57:30.839"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:30.840" starttime="20190401 12:57:30.839"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:30.840" starttime="20190401 12:57:30.840"></status>
</kw>
<msg timestamp="20190401 12:57:30.840" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:57:30.840" starttime="20190401 12:57:30.838"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:57:30.841" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:57:30.841" starttime="20190401 12:57:30.841"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:57:30.852" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:57:30.852" starttime="20190401 12:57:30.841"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:57:31.845" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:57:31.845" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:57:31.845" starttime="20190401 12:57:30.852"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:57:31.846" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:57:31.846" starttime="20190401 12:57:31.845"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:57:31.846" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:57:31.846" starttime="20190401 12:57:31.846"></status>
</kw>
<msg timestamp="20190401 12:57:31.846" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:57:31.846" starttime="20190401 12:57:31.845"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:57:31.848" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:57:31.848" starttime="20190401 12:57:31.846"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:57:31.849" level="INFO">0</msg>
<msg timestamp="20190401 12:57:31.849" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:57:31.849" starttime="20190401 12:57:31.849"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:57:31.849" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:57:31.849" starttime="20190401 12:57:31.849"></status>
</kw>
<msg timestamp="20190401 12:57:31.849" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:57:31.849" starttime="20190401 12:57:31.846"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:31.850" starttime="20190401 12:57:31.850"></status>
</kw>
<status status="PASS" endtime="20190401 12:57:31.850" starttime="20190401 12:57:31.850"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:31.851" starttime="20190401 12:57:31.851"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:57:31.851" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:57:31.851" starttime="20190401 12:57:31.851"></status>
</kw>
<msg timestamp="20190401 12:57:31.851" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:57:31.851" starttime="20190401 12:57:30.837"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:57:31.852" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:57:31.852" starttime="20190401 12:57:31.851"></status>
</kw>
<msg timestamp="20190401 12:57:31.852" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:57:31.852" starttime="20190401 12:57:30.836"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:57:31.852" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:57:31.852" starttime="20190401 12:57:31.852"></status>
</kw>
<status status="FAIL" endtime="20190401 12:57:31.852" starttime="20190401 12:57:30.836"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:57:51.854" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:57:51.854" starttime="20190401 12:57:51.854"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:51.855" starttime="20190401 12:57:51.854"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:57:51.855" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:57:51.855" starttime="20190401 12:57:51.855"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:51.856" starttime="20190401 12:57:51.855"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:51.856" starttime="20190401 12:57:51.856"></status>
</kw>
<msg timestamp="20190401 12:57:51.856" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:57:51.856" starttime="20190401 12:57:51.855"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:57:51.856" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:57:51.857" starttime="20190401 12:57:51.856"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:57:51.866" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:57:51.867" starttime="20190401 12:57:51.857"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:57:52.860" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:57:52.861" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:57:52.861" starttime="20190401 12:57:51.867"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:57:52.861" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:57:52.861" starttime="20190401 12:57:52.861"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:57:52.862" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:57:52.862" starttime="20190401 12:57:52.862"></status>
</kw>
<msg timestamp="20190401 12:57:52.862" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:57:52.862" starttime="20190401 12:57:52.861"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:57:52.864" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:57:52.864" starttime="20190401 12:57:52.862"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:57:52.865" level="INFO">0</msg>
<msg timestamp="20190401 12:57:52.865" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:57:52.865" starttime="20190401 12:57:52.864"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:57:52.865" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:57:52.865" starttime="20190401 12:57:52.865"></status>
</kw>
<msg timestamp="20190401 12:57:52.865" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:57:52.865" starttime="20190401 12:57:52.862"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:52.866" starttime="20190401 12:57:52.866"></status>
</kw>
<status status="PASS" endtime="20190401 12:57:52.866" starttime="20190401 12:57:52.865"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:57:52.866" starttime="20190401 12:57:52.866"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:57:52.867" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:57:52.867" starttime="20190401 12:57:52.866"></status>
</kw>
<msg timestamp="20190401 12:57:52.867" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:57:52.867" starttime="20190401 12:57:51.854"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:57:52.867" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:57:52.867" starttime="20190401 12:57:52.867"></status>
</kw>
<msg timestamp="20190401 12:57:52.868" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:57:52.868" starttime="20190401 12:57:51.853"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:57:52.868" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:57:52.868" starttime="20190401 12:57:52.868"></status>
</kw>
<status status="FAIL" endtime="20190401 12:57:52.868" starttime="20190401 12:57:51.853"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:58:12.870" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:58:12.870" starttime="20190401 12:58:12.869"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:12.870" starttime="20190401 12:58:12.870"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:58:12.871" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:58:12.871" starttime="20190401 12:58:12.871"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:12.871" starttime="20190401 12:58:12.871"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:12.872" starttime="20190401 12:58:12.872"></status>
</kw>
<msg timestamp="20190401 12:58:12.872" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:58:12.872" starttime="20190401 12:58:12.870"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:58:12.872" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:58:12.872" starttime="20190401 12:58:12.872"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:58:12.883" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:58:12.883" starttime="20190401 12:58:12.872"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:58:13.932" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:58:13.932" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:58:13.932" starttime="20190401 12:58:12.883"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:58:13.933" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:58:13.933" starttime="20190401 12:58:13.932"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:58:13.933" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:58:13.933" starttime="20190401 12:58:13.933"></status>
</kw>
<msg timestamp="20190401 12:58:13.933" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:58:13.933" starttime="20190401 12:58:13.932"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:58:13.935" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:58:13.935" starttime="20190401 12:58:13.934"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:58:13.936" level="INFO">0</msg>
<msg timestamp="20190401 12:58:13.936" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:58:13.936" starttime="20190401 12:58:13.935"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:58:13.936" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:58:13.936" starttime="20190401 12:58:13.936"></status>
</kw>
<msg timestamp="20190401 12:58:13.936" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:58:13.936" starttime="20190401 12:58:13.933"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:13.937" starttime="20190401 12:58:13.937"></status>
</kw>
<status status="PASS" endtime="20190401 12:58:13.937" starttime="20190401 12:58:13.936"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:13.937" starttime="20190401 12:58:13.937"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:58:13.938" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:58:13.938" starttime="20190401 12:58:13.937"></status>
</kw>
<msg timestamp="20190401 12:58:13.938" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:58:13.938" starttime="20190401 12:58:12.870"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:58:13.938" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:58:13.938" starttime="20190401 12:58:13.938"></status>
</kw>
<msg timestamp="20190401 12:58:13.938" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:58:13.938" starttime="20190401 12:58:12.869"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:58:13.939" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:58:13.939" starttime="20190401 12:58:13.939"></status>
</kw>
<status status="FAIL" endtime="20190401 12:58:13.939" starttime="20190401 12:58:12.869"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:58:33.941" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:58:33.941" starttime="20190401 12:58:33.941"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:33.942" starttime="20190401 12:58:33.942"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:58:33.943" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:58:33.943" starttime="20190401 12:58:33.942"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:33.943" starttime="20190401 12:58:33.943"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:33.943" starttime="20190401 12:58:33.943"></status>
</kw>
<msg timestamp="20190401 12:58:33.943" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:58:33.943" starttime="20190401 12:58:33.942"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:58:33.944" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:58:33.944" starttime="20190401 12:58:33.944"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:58:33.959" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:58:33.959" starttime="20190401 12:58:33.944"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:58:34.962" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:58:34.962" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:58:34.962" starttime="20190401 12:58:33.959"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:58:34.963" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:58:34.963" starttime="20190401 12:58:34.963"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:58:34.963" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:58:34.964" starttime="20190401 12:58:34.963"></status>
</kw>
<msg timestamp="20190401 12:58:34.964" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:58:34.964" starttime="20190401 12:58:34.963"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:58:34.966" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:58:34.966" starttime="20190401 12:58:34.964"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:58:34.966" level="INFO">0</msg>
<msg timestamp="20190401 12:58:34.966" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:58:34.966" starttime="20190401 12:58:34.966"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:58:34.967" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:58:34.967" starttime="20190401 12:58:34.967"></status>
</kw>
<msg timestamp="20190401 12:58:34.967" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:58:34.967" starttime="20190401 12:58:34.964"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:34.968" starttime="20190401 12:58:34.967"></status>
</kw>
<status status="PASS" endtime="20190401 12:58:34.968" starttime="20190401 12:58:34.967"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:34.968" starttime="20190401 12:58:34.968"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:58:34.968" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:58:34.968" starttime="20190401 12:58:34.968"></status>
</kw>
<msg timestamp="20190401 12:58:34.968" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:58:34.969" starttime="20190401 12:58:33.941"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:58:34.969" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:58:34.969" starttime="20190401 12:58:34.969"></status>
</kw>
<msg timestamp="20190401 12:58:34.969" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:58:34.969" starttime="20190401 12:58:33.940"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:58:34.970" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:58:34.970" starttime="20190401 12:58:34.969"></status>
</kw>
<status status="FAIL" endtime="20190401 12:58:34.970" starttime="20190401 12:58:33.939"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:58:54.971" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:58:54.971" starttime="20190401 12:58:54.971"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:54.972" starttime="20190401 12:58:54.972"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:58:54.973" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:58:54.973" starttime="20190401 12:58:54.972"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:54.973" starttime="20190401 12:58:54.973"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:54.973" starttime="20190401 12:58:54.973"></status>
</kw>
<msg timestamp="20190401 12:58:54.974" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:58:54.974" starttime="20190401 12:58:54.972"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:58:54.974" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:58:54.974" starttime="20190401 12:58:54.974"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:58:54.984" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:58:54.984" starttime="20190401 12:58:54.974"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:58:55.993" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:58:55.993" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:58:55.993" starttime="20190401 12:58:54.984"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:58:55.994" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:58:55.994" starttime="20190401 12:58:55.994"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:58:55.994" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:58:55.994" starttime="20190401 12:58:55.994"></status>
</kw>
<msg timestamp="20190401 12:58:55.995" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:58:55.995" starttime="20190401 12:58:55.993"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:58:55.997" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:58:55.997" starttime="20190401 12:58:55.995"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:58:55.997" level="INFO">0</msg>
<msg timestamp="20190401 12:58:55.998" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:58:55.998" starttime="20190401 12:58:55.997"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:58:55.998" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:58:55.998" starttime="20190401 12:58:55.998"></status>
</kw>
<msg timestamp="20190401 12:58:55.998" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:58:55.998" starttime="20190401 12:58:55.995"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:55.999" starttime="20190401 12:58:55.999"></status>
</kw>
<status status="PASS" endtime="20190401 12:58:55.999" starttime="20190401 12:58:55.998"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:58:55.999" starttime="20190401 12:58:55.999"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:58:56.000" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:58:56.000" starttime="20190401 12:58:55.999"></status>
</kw>
<msg timestamp="20190401 12:58:56.000" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:58:56.000" starttime="20190401 12:58:54.972"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:58:56.000" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:58:56.000" starttime="20190401 12:58:56.000"></status>
</kw>
<msg timestamp="20190401 12:58:56.000" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:58:56.001" starttime="20190401 12:58:54.970"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:58:56.001" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:58:56.001" starttime="20190401 12:58:56.001"></status>
</kw>
<status status="FAIL" endtime="20190401 12:58:56.001" starttime="20190401 12:58:54.970"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:59:16.003" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:59:16.003" starttime="20190401 12:59:16.003"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:16.005" starttime="20190401 12:59:16.004"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:59:16.006" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:59:16.006" starttime="20190401 12:59:16.005"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:16.007" starttime="20190401 12:59:16.006"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:16.007" starttime="20190401 12:59:16.007"></status>
</kw>
<msg timestamp="20190401 12:59:16.007" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:59:16.008" starttime="20190401 12:59:16.005"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:59:16.008" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:59:16.008" starttime="20190401 12:59:16.008"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:59:16.027" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:59:16.027" starttime="20190401 12:59:16.008"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:59:17.024" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:59:17.025" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:59:17.025" starttime="20190401 12:59:16.027"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:59:17.025" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:59:17.025" starttime="20190401 12:59:17.025"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:59:17.026" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:59:17.026" starttime="20190401 12:59:17.026"></status>
</kw>
<msg timestamp="20190401 12:59:17.026" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:59:17.026" starttime="20190401 12:59:17.025"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:59:17.028" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:59:17.028" starttime="20190401 12:59:17.026"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:59:17.028" level="INFO">0</msg>
<msg timestamp="20190401 12:59:17.028" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:59:17.028" starttime="20190401 12:59:17.028"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:59:17.029" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:59:17.029" starttime="20190401 12:59:17.029"></status>
</kw>
<msg timestamp="20190401 12:59:17.029" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:59:17.029" starttime="20190401 12:59:17.026"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:17.030" starttime="20190401 12:59:17.029"></status>
</kw>
<status status="PASS" endtime="20190401 12:59:17.030" starttime="20190401 12:59:17.029"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:17.030" starttime="20190401 12:59:17.030"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:59:17.030" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:59:17.030" starttime="20190401 12:59:17.030"></status>
</kw>
<msg timestamp="20190401 12:59:17.031" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:59:17.031" starttime="20190401 12:59:16.003"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:59:17.031" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:59:17.031" starttime="20190401 12:59:17.031"></status>
</kw>
<msg timestamp="20190401 12:59:17.031" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:59:17.031" starttime="20190401 12:59:16.002"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:59:17.032" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:59:17.032" starttime="20190401 12:59:17.031"></status>
</kw>
<status status="FAIL" endtime="20190401 12:59:17.032" starttime="20190401 12:59:16.001"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:59:37.033" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:59:37.033" starttime="20190401 12:59:37.033"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:37.034" starttime="20190401 12:59:37.034"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:59:37.035" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:59:37.035" starttime="20190401 12:59:37.034"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:37.035" starttime="20190401 12:59:37.035"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:37.036" starttime="20190401 12:59:37.035"></status>
</kw>
<msg timestamp="20190401 12:59:37.036" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:59:37.036" starttime="20190401 12:59:37.034"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:59:37.036" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:59:37.036" starttime="20190401 12:59:37.036"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:59:37.048" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:59:37.048" starttime="20190401 12:59:37.036"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:59:38.131" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:59:38.131" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:59:38.131" starttime="20190401 12:59:37.048"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:59:38.132" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:59:38.132" starttime="20190401 12:59:38.132"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:59:38.133" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:59:38.133" starttime="20190401 12:59:38.132"></status>
</kw>
<msg timestamp="20190401 12:59:38.133" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:59:38.133" starttime="20190401 12:59:38.132"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:59:38.135" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:59:38.135" starttime="20190401 12:59:38.133"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:59:38.135" level="INFO">0</msg>
<msg timestamp="20190401 12:59:38.135" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:59:38.136" starttime="20190401 12:59:38.135"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:59:38.136" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:59:38.136" starttime="20190401 12:59:38.136"></status>
</kw>
<msg timestamp="20190401 12:59:38.136" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:59:38.136" starttime="20190401 12:59:38.133"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:38.137" starttime="20190401 12:59:38.136"></status>
</kw>
<status status="PASS" endtime="20190401 12:59:38.137" starttime="20190401 12:59:38.136"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:38.137" starttime="20190401 12:59:38.137"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:59:38.137" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:59:38.137" starttime="20190401 12:59:38.137"></status>
</kw>
<msg timestamp="20190401 12:59:38.138" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:59:38.138" starttime="20190401 12:59:37.033"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:59:38.138" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:59:38.138" starttime="20190401 12:59:38.138"></status>
</kw>
<msg timestamp="20190401 12:59:38.138" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:59:38.138" starttime="20190401 12:59:37.033"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:59:38.139" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:59:38.139" starttime="20190401 12:59:38.138"></status>
</kw>
<status status="FAIL" endtime="20190401 12:59:38.139" starttime="20190401 12:59:37.032"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 12:59:58.140" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:59:58.140" starttime="20190401 12:59:58.140"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:58.141" starttime="20190401 12:59:58.141"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 12:59:58.142" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 12:59:58.142" starttime="20190401 12:59:58.141"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:58.142" starttime="20190401 12:59:58.142"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:58.143" starttime="20190401 12:59:58.142"></status>
</kw>
<msg timestamp="20190401 12:59:58.143" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 12:59:58.143" starttime="20190401 12:59:58.141"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 12:59:58.143" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:59:58.143" starttime="20190401 12:59:58.143"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 12:59:58.153" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 12:59:58.153" starttime="20190401 12:59:58.143"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 12:59:59.145" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 12:59:59.145" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:59:59.145" starttime="20190401 12:59:58.153"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 12:59:59.146" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 12:59:59.146" starttime="20190401 12:59:59.146"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 12:59:59.146" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 12:59:59.146" starttime="20190401 12:59:59.146"></status>
</kw>
<msg timestamp="20190401 12:59:59.146" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 12:59:59.146" starttime="20190401 12:59:59.145"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 12:59:59.148" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 12:59:59.148" starttime="20190401 12:59:59.147"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 12:59:59.149" level="INFO">0</msg>
<msg timestamp="20190401 12:59:59.149" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:59:59.149" starttime="20190401 12:59:59.149"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 12:59:59.149" level="INFO">0</msg>
<status status="PASS" endtime="20190401 12:59:59.149" starttime="20190401 12:59:59.149"></status>
</kw>
<msg timestamp="20190401 12:59:59.149" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 12:59:59.149" starttime="20190401 12:59:59.146"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:59.150" starttime="20190401 12:59:59.150"></status>
</kw>
<status status="PASS" endtime="20190401 12:59:59.150" starttime="20190401 12:59:59.150"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 12:59:59.151" starttime="20190401 12:59:59.150"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 12:59:59.151" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 12:59:59.151" starttime="20190401 12:59:59.151"></status>
</kw>
<msg timestamp="20190401 12:59:59.151" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 12:59:59.151" starttime="20190401 12:59:58.140"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 12:59:59.151" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 12:59:59.151" starttime="20190401 12:59:59.151"></status>
</kw>
<msg timestamp="20190401 12:59:59.152" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 12:59:59.152" starttime="20190401 12:59:58.140"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 12:59:59.152" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 12:59:59.152" starttime="20190401 12:59:59.152"></status>
</kw>
<status status="FAIL" endtime="20190401 12:59:59.152" starttime="20190401 12:59:58.139"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:00:19.154" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:00:19.154" starttime="20190401 13:00:19.154"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:00:19.156" starttime="20190401 13:00:19.155"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:00:19.157" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:00:19.157" starttime="20190401 13:00:19.156"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:00:19.157" starttime="20190401 13:00:19.157"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:00:19.158" starttime="20190401 13:00:19.158"></status>
</kw>
<msg timestamp="20190401 13:00:19.158" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:00:19.158" starttime="20190401 13:00:19.156"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:00:19.159" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:00:19.159" starttime="20190401 13:00:19.159"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:00:19.178" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:00:19.179" starttime="20190401 13:00:19.159"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:00:20.178" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:00:20.178" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:00:20.178" starttime="20190401 13:00:19.179"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:00:20.179" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:00:20.179" starttime="20190401 13:00:20.179"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:00:20.179" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 13:00:20.179" starttime="20190401 13:00:20.179"></status>
</kw>
<msg timestamp="20190401 13:00:20.180" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 13:00:20.180" starttime="20190401 13:00:20.178"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:00:20.182" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:00:20.182" starttime="20190401 13:00:20.180"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:00:20.182" level="INFO">0</msg>
<msg timestamp="20190401 13:00:20.182" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:00:20.182" starttime="20190401 13:00:20.182"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:00:20.183" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:00:20.183" starttime="20190401 13:00:20.183"></status>
</kw>
<msg timestamp="20190401 13:00:20.183" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:00:20.183" starttime="20190401 13:00:20.180"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:00:20.184" starttime="20190401 13:00:20.183"></status>
</kw>
<status status="PASS" endtime="20190401 13:00:20.184" starttime="20190401 13:00:20.183"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:00:20.184" starttime="20190401 13:00:20.184"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:00:20.184" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 13:00:20.184" starttime="20190401 13:00:20.184"></status>
</kw>
<msg timestamp="20190401 13:00:20.185" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:00:20.185" starttime="20190401 13:00:19.155"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:00:20.185" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 13:00:20.185" starttime="20190401 13:00:20.185"></status>
</kw>
<msg timestamp="20190401 13:00:20.185" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 13:00:20.185" starttime="20190401 13:00:19.153"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:00:20.186" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 13:00:20.186" starttime="20190401 13:00:20.185"></status>
</kw>
<status status="FAIL" endtime="20190401 13:00:20.186" starttime="20190401 13:00:19.153"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:00:40.188" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:00:40.188" starttime="20190401 13:00:40.187"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:00:40.189" starttime="20190401 13:00:40.189"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:00:40.190" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:00:40.190" starttime="20190401 13:00:40.190"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:00:40.191" starttime="20190401 13:00:40.191"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:00:40.191" starttime="20190401 13:00:40.191"></status>
</kw>
<msg timestamp="20190401 13:00:40.192" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:00:40.192" starttime="20190401 13:00:40.189"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:00:40.192" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:00:40.192" starttime="20190401 13:00:40.192"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:00:40.212" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:00:40.212" starttime="20190401 13:00:40.193"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:00:41.211" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:00:41.211" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:00:41.211" starttime="20190401 13:00:40.212"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:00:41.212" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:00:41.212" starttime="20190401 13:00:41.212"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:00:41.213" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 13:00:41.213" starttime="20190401 13:00:41.213"></status>
</kw>
<msg timestamp="20190401 13:00:41.213" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 13:00:41.213" starttime="20190401 13:00:41.212"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:00:41.215" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:00:41.215" starttime="20190401 13:00:41.213"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:00:41.215" level="INFO">0</msg>
<msg timestamp="20190401 13:00:41.216" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:00:41.216" starttime="20190401 13:00:41.215"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:00:41.216" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:00:41.216" starttime="20190401 13:00:41.216"></status>
</kw>
<msg timestamp="20190401 13:00:41.216" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:00:41.216" starttime="20190401 13:00:41.213"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:00:41.217" starttime="20190401 13:00:41.217"></status>
</kw>
<status status="PASS" endtime="20190401 13:00:41.217" starttime="20190401 13:00:41.216"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:00:41.217" starttime="20190401 13:00:41.217"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:00:41.218" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 13:00:41.218" starttime="20190401 13:00:41.218"></status>
</kw>
<msg timestamp="20190401 13:00:41.218" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:00:41.218" starttime="20190401 13:00:40.188"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:00:41.218" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 13:00:41.218" starttime="20190401 13:00:41.218"></status>
</kw>
<msg timestamp="20190401 13:00:41.219" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 13:00:41.219" starttime="20190401 13:00:40.187"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:00:41.219" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 13:00:41.219" starttime="20190401 13:00:41.219"></status>
</kw>
<status status="FAIL" endtime="20190401 13:00:41.219" starttime="20190401 13:00:40.186"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:01:01.221" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:01:01.221" starttime="20190401 13:01:01.220"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:01.221" starttime="20190401 13:01:01.221"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:01:01.222" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:01:01.222" starttime="20190401 13:01:01.222"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:01.222" starttime="20190401 13:01:01.222"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:01.223" starttime="20190401 13:01:01.223"></status>
</kw>
<msg timestamp="20190401 13:01:01.223" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:01:01.223" starttime="20190401 13:01:01.221"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:01:01.223" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:01:01.223" starttime="20190401 13:01:01.223"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:01:01.233" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:01:01.234" starttime="20190401 13:01:01.223"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:01:02.225" level="INFO">offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:01:02.225" level="INFO">${output} = offline
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:01:02.225" starttime="20190401 13:01:01.234"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:01:02.226" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:01:02.226" starttime="20190401 13:01:02.226"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:01:02.227" level="INFO">${clean_out} = offline
</msg>
<status status="PASS" endtime="20190401 13:01:02.227" starttime="20190401 13:01:02.226"></status>
</kw>
<msg timestamp="20190401 13:01:02.227" level="INFO">${output} = offline
</msg>
<status status="PASS" endtime="20190401 13:01:02.227" starttime="20190401 13:01:02.226"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:01:02.229" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:01:02.229" starttime="20190401 13:01:02.227"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:01:02.229" level="INFO">0</msg>
<msg timestamp="20190401 13:01:02.229" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:01:02.229" starttime="20190401 13:01:02.229"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:01:02.230" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:01:02.230" starttime="20190401 13:01:02.230"></status>
</kw>
<msg timestamp="20190401 13:01:02.230" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:01:02.230" starttime="20190401 13:01:02.227"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:02.231" starttime="20190401 13:01:02.230"></status>
</kw>
<status status="PASS" endtime="20190401 13:01:02.231" starttime="20190401 13:01:02.230"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:02.231" starttime="20190401 13:01:02.231"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:01:02.231" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: offline</msg>
<status status="PASS" endtime="20190401 13:01:02.231" starttime="20190401 13:01:02.231"></status>
</kw>
<msg timestamp="20190401 13:01:02.231" level="INFO">${result} = {u'stdout': u'offline', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:01:02.232" starttime="20190401 13:01:01.221"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:01:02.232" level="INFO">${value} = offline</msg>
<status status="PASS" endtime="20190401 13:01:02.232" starttime="20190401 13:01:02.232"></status>
</kw>
<msg timestamp="20190401 13:01:02.232" level="INFO">${current_value} = offline</msg>
<status status="PASS" endtime="20190401 13:01:02.232" starttime="20190401 13:01:01.220"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:01:02.232" level="FAIL">offline != available</msg>
<status status="FAIL" endtime="20190401 13:01:02.233" starttime="20190401 13:01:02.232"></status>
</kw>
<status status="FAIL" endtime="20190401 13:01:02.233" starttime="20190401 13:01:01.220"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:01:22.234" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:01:22.234" starttime="20190401 13:01:22.234"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:22.235" starttime="20190401 13:01:22.235"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:01:22.236" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:01:22.236" starttime="20190401 13:01:22.235"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:22.236" starttime="20190401 13:01:22.236"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:22.236" starttime="20190401 13:01:22.236"></status>
</kw>
<msg timestamp="20190401 13:01:22.236" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:01:22.237" starttime="20190401 13:01:22.235"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:01:22.237" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:01:22.237" starttime="20190401 13:01:22.237"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:01:22.245" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:01:22.245" starttime="20190401 13:01:22.237"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:01:23.273" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:01:23.273" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:01:23.273" starttime="20190401 13:01:22.245"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:01:23.274" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:01:23.274" starttime="20190401 13:01:23.274"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:01:23.275" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:01:23.275" starttime="20190401 13:01:23.274"></status>
</kw>
<msg timestamp="20190401 13:01:23.275" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:01:23.275" starttime="20190401 13:01:23.274"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:01:23.276" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:01:23.276" starttime="20190401 13:01:23.275"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:01:23.277" level="INFO">0</msg>
<msg timestamp="20190401 13:01:23.277" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:01:23.277" starttime="20190401 13:01:23.277"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:01:23.278" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:01:23.278" starttime="20190401 13:01:23.277"></status>
</kw>
<msg timestamp="20190401 13:01:23.278" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:01:23.278" starttime="20190401 13:01:23.275"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:23.279" starttime="20190401 13:01:23.278"></status>
</kw>
<status status="PASS" endtime="20190401 13:01:23.279" starttime="20190401 13:01:23.278"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:23.279" starttime="20190401 13:01:23.279"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:01:23.279" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:01:23.279" starttime="20190401 13:01:23.279"></status>
</kw>
<msg timestamp="20190401 13:01:23.280" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:01:23.280" starttime="20190401 13:01:22.234"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:01:23.280" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:01:23.280" starttime="20190401 13:01:23.280"></status>
</kw>
<msg timestamp="20190401 13:01:23.280" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:01:23.280" starttime="20190401 13:01:22.233"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:01:23.281" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:01:23.281" starttime="20190401 13:01:23.280"></status>
</kw>
<status status="FAIL" endtime="20190401 13:01:23.281" starttime="20190401 13:01:22.233"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:01:43.282" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:01:43.282" starttime="20190401 13:01:43.282"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:43.283" starttime="20190401 13:01:43.283"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:01:43.284" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:01:43.284" starttime="20190401 13:01:43.283"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:43.284" starttime="20190401 13:01:43.284"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:43.285" starttime="20190401 13:01:43.284"></status>
</kw>
<msg timestamp="20190401 13:01:43.285" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:01:43.285" starttime="20190401 13:01:43.283"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:01:43.285" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:01:43.285" starttime="20190401 13:01:43.285"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:01:43.295" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:01:43.295" starttime="20190401 13:01:43.285"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:01:44.302" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:01:44.302" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:01:44.302" starttime="20190401 13:01:43.296"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:01:44.303" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:01:44.303" starttime="20190401 13:01:44.303"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:01:44.303" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:01:44.303" starttime="20190401 13:01:44.303"></status>
</kw>
<msg timestamp="20190401 13:01:44.303" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:01:44.303" starttime="20190401 13:01:44.302"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:01:44.305" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:01:44.305" starttime="20190401 13:01:44.304"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:01:44.306" level="INFO">0</msg>
<msg timestamp="20190401 13:01:44.306" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:01:44.306" starttime="20190401 13:01:44.306"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:01:44.306" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:01:44.306" starttime="20190401 13:01:44.306"></status>
</kw>
<msg timestamp="20190401 13:01:44.306" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:01:44.306" starttime="20190401 13:01:44.303"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:44.307" starttime="20190401 13:01:44.307"></status>
</kw>
<status status="PASS" endtime="20190401 13:01:44.307" starttime="20190401 13:01:44.306"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:01:44.307" starttime="20190401 13:01:44.307"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:01:44.308" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:01:44.308" starttime="20190401 13:01:44.308"></status>
</kw>
<msg timestamp="20190401 13:01:44.308" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:01:44.308" starttime="20190401 13:01:43.282"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:01:44.308" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:01:44.308" starttime="20190401 13:01:44.308"></status>
</kw>
<msg timestamp="20190401 13:01:44.308" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:01:44.309" starttime="20190401 13:01:43.282"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:01:44.309" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:01:44.309" starttime="20190401 13:01:44.309"></status>
</kw>
<status status="FAIL" endtime="20190401 13:01:44.309" starttime="20190401 13:01:43.281"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:02:04.311" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:02:04.311" starttime="20190401 13:02:04.311"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:04.312" starttime="20190401 13:02:04.311"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:02:04.312" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:02:04.312" starttime="20190401 13:02:04.312"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:04.313" starttime="20190401 13:02:04.312"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:04.313" starttime="20190401 13:02:04.313"></status>
</kw>
<msg timestamp="20190401 13:02:04.313" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:02:04.313" starttime="20190401 13:02:04.312"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:02:04.314" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:02:04.314" starttime="20190401 13:02:04.313"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:02:04.324" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:02:04.325" starttime="20190401 13:02:04.314"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:02:05.374" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:02:05.375" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:02:05.375" starttime="20190401 13:02:04.325"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:02:05.375" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:02:05.375" starttime="20190401 13:02:05.375"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:02:05.376" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:02:05.376" starttime="20190401 13:02:05.376"></status>
</kw>
<msg timestamp="20190401 13:02:05.376" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:02:05.376" starttime="20190401 13:02:05.375"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:02:05.378" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:02:05.378" starttime="20190401 13:02:05.376"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:02:05.378" level="INFO">0</msg>
<msg timestamp="20190401 13:02:05.378" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:02:05.378" starttime="20190401 13:02:05.378"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:02:05.379" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:02:05.379" starttime="20190401 13:02:05.379"></status>
</kw>
<msg timestamp="20190401 13:02:05.379" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:02:05.379" starttime="20190401 13:02:05.376"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:05.380" starttime="20190401 13:02:05.380"></status>
</kw>
<status status="PASS" endtime="20190401 13:02:05.380" starttime="20190401 13:02:05.379"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:05.381" starttime="20190401 13:02:05.380"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:02:05.381" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:02:05.381" starttime="20190401 13:02:05.381"></status>
</kw>
<msg timestamp="20190401 13:02:05.381" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:02:05.381" starttime="20190401 13:02:04.311"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:02:05.381" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:02:05.382" starttime="20190401 13:02:05.381"></status>
</kw>
<msg timestamp="20190401 13:02:05.382" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:02:05.382" starttime="20190401 13:02:04.310"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:02:05.382" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:02:05.382" starttime="20190401 13:02:05.382"></status>
</kw>
<status status="FAIL" endtime="20190401 13:02:05.382" starttime="20190401 13:02:04.310"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:02:25.384" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:02:25.384" starttime="20190401 13:02:25.384"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:25.385" starttime="20190401 13:02:25.384"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:02:25.385" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:02:25.385" starttime="20190401 13:02:25.385"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:25.386" starttime="20190401 13:02:25.386"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:25.386" starttime="20190401 13:02:25.386"></status>
</kw>
<msg timestamp="20190401 13:02:25.386" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:02:25.386" starttime="20190401 13:02:25.385"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:02:25.387" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:02:25.387" starttime="20190401 13:02:25.386"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:02:25.397" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:02:25.397" starttime="20190401 13:02:25.387"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:02:26.412" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:02:26.412" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:02:26.412" starttime="20190401 13:02:25.397"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:02:26.413" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:02:26.413" starttime="20190401 13:02:26.413"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:02:26.414" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:02:26.414" starttime="20190401 13:02:26.413"></status>
</kw>
<msg timestamp="20190401 13:02:26.414" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:02:26.414" starttime="20190401 13:02:26.413"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:02:26.415" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:02:26.415" starttime="20190401 13:02:26.414"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:02:26.416" level="INFO">0</msg>
<msg timestamp="20190401 13:02:26.416" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:02:26.416" starttime="20190401 13:02:26.415"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:02:26.416" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:02:26.416" starttime="20190401 13:02:26.416"></status>
</kw>
<msg timestamp="20190401 13:02:26.416" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:02:26.416" starttime="20190401 13:02:26.414"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:26.417" starttime="20190401 13:02:26.417"></status>
</kw>
<status status="PASS" endtime="20190401 13:02:26.417" starttime="20190401 13:02:26.416"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:26.417" starttime="20190401 13:02:26.417"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:02:26.418" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:02:26.418" starttime="20190401 13:02:26.417"></status>
</kw>
<msg timestamp="20190401 13:02:26.418" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:02:26.418" starttime="20190401 13:02:25.384"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:02:26.418" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:02:26.418" starttime="20190401 13:02:26.418"></status>
</kw>
<msg timestamp="20190401 13:02:26.418" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:02:26.418" starttime="20190401 13:02:25.383"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:02:26.419" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:02:26.419" starttime="20190401 13:02:26.419"></status>
</kw>
<status status="FAIL" endtime="20190401 13:02:26.419" starttime="20190401 13:02:25.383"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:02:46.420" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:02:46.420" starttime="20190401 13:02:46.420"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:46.421" starttime="20190401 13:02:46.421"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:02:46.422" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:02:46.422" starttime="20190401 13:02:46.422"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:46.422" starttime="20190401 13:02:46.422"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:46.423" starttime="20190401 13:02:46.423"></status>
</kw>
<msg timestamp="20190401 13:02:46.423" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:02:46.423" starttime="20190401 13:02:46.422"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:02:46.423" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:02:46.423" starttime="20190401 13:02:46.423"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:02:46.434" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:02:46.434" starttime="20190401 13:02:46.423"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:02:47.413" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:02:47.413" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:02:47.413" starttime="20190401 13:02:46.434"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:02:47.414" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:02:47.414" starttime="20190401 13:02:47.414"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:02:47.415" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:02:47.415" starttime="20190401 13:02:47.414"></status>
</kw>
<msg timestamp="20190401 13:02:47.415" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:02:47.415" starttime="20190401 13:02:47.414"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:02:47.416" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:02:47.416" starttime="20190401 13:02:47.415"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:02:47.417" level="INFO">0</msg>
<msg timestamp="20190401 13:02:47.417" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:02:47.417" starttime="20190401 13:02:47.416"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:02:47.417" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:02:47.417" starttime="20190401 13:02:47.417"></status>
</kw>
<msg timestamp="20190401 13:02:47.417" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:02:47.418" starttime="20190401 13:02:47.415"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:47.418" starttime="20190401 13:02:47.418"></status>
</kw>
<status status="PASS" endtime="20190401 13:02:47.418" starttime="20190401 13:02:47.418"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:02:47.419" starttime="20190401 13:02:47.418"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:02:47.419" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:02:47.419" starttime="20190401 13:02:47.419"></status>
</kw>
<msg timestamp="20190401 13:02:47.419" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:02:47.419" starttime="20190401 13:02:46.421"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:02:47.419" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:02:47.420" starttime="20190401 13:02:47.419"></status>
</kw>
<msg timestamp="20190401 13:02:47.420" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:02:47.420" starttime="20190401 13:02:46.420"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:02:47.420" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:02:47.420" starttime="20190401 13:02:47.420"></status>
</kw>
<status status="FAIL" endtime="20190401 13:02:47.420" starttime="20190401 13:02:46.419"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:03:07.422" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:03:07.422" starttime="20190401 13:03:07.421"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:07.422" starttime="20190401 13:03:07.422"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:03:07.424" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:03:07.424" starttime="20190401 13:03:07.423"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:07.424" starttime="20190401 13:03:07.424"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:07.424" starttime="20190401 13:03:07.424"></status>
</kw>
<msg timestamp="20190401 13:03:07.425" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:03:07.425" starttime="20190401 13:03:07.423"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:03:07.425" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:03:07.425" starttime="20190401 13:03:07.425"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:03:07.435" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:03:07.435" starttime="20190401 13:03:07.425"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:03:08.438" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:03:08.438" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:03:08.438" starttime="20190401 13:03:07.435"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:03:08.439" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:03:08.439" starttime="20190401 13:03:08.438"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:03:08.439" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:03:08.439" starttime="20190401 13:03:08.439"></status>
</kw>
<msg timestamp="20190401 13:03:08.439" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:03:08.439" starttime="20190401 13:03:08.438"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:03:08.441" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:03:08.441" starttime="20190401 13:03:08.439"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:03:08.442" level="INFO">0</msg>
<msg timestamp="20190401 13:03:08.442" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:03:08.442" starttime="20190401 13:03:08.441"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:03:08.442" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:03:08.442" starttime="20190401 13:03:08.442"></status>
</kw>
<msg timestamp="20190401 13:03:08.442" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:03:08.442" starttime="20190401 13:03:08.439"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:08.443" starttime="20190401 13:03:08.443"></status>
</kw>
<status status="PASS" endtime="20190401 13:03:08.443" starttime="20190401 13:03:08.442"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:08.443" starttime="20190401 13:03:08.443"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:03:08.444" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:03:08.444" starttime="20190401 13:03:08.443"></status>
</kw>
<msg timestamp="20190401 13:03:08.444" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:03:08.444" starttime="20190401 13:03:07.422"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:03:08.444" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:03:08.444" starttime="20190401 13:03:08.444"></status>
</kw>
<msg timestamp="20190401 13:03:08.444" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:03:08.444" starttime="20190401 13:03:07.421"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:03:08.445" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:03:08.445" starttime="20190401 13:03:08.445"></status>
</kw>
<status status="FAIL" endtime="20190401 13:03:08.445" starttime="20190401 13:03:07.421"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:03:28.446" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:03:28.446" starttime="20190401 13:03:28.446"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:28.447" starttime="20190401 13:03:28.447"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:03:28.448" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:03:28.448" starttime="20190401 13:03:28.448"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:28.448" starttime="20190401 13:03:28.448"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:28.449" starttime="20190401 13:03:28.449"></status>
</kw>
<msg timestamp="20190401 13:03:28.449" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:03:28.449" starttime="20190401 13:03:28.447"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:03:28.449" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:03:28.449" starttime="20190401 13:03:28.449"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:03:28.461" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:03:28.461" starttime="20190401 13:03:28.449"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:03:29.535" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:03:29.535" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:03:29.535" starttime="20190401 13:03:28.462"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:03:29.536" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:03:29.536" starttime="20190401 13:03:29.535"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:03:29.536" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:03:29.536" starttime="20190401 13:03:29.536"></status>
</kw>
<msg timestamp="20190401 13:03:29.536" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:03:29.536" starttime="20190401 13:03:29.535"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:03:29.539" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:03:29.539" starttime="20190401 13:03:29.537"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:03:29.539" level="INFO">0</msg>
<msg timestamp="20190401 13:03:29.539" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:03:29.539" starttime="20190401 13:03:29.539"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:03:29.540" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:03:29.540" starttime="20190401 13:03:29.539"></status>
</kw>
<msg timestamp="20190401 13:03:29.540" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:03:29.540" starttime="20190401 13:03:29.536"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:29.540" starttime="20190401 13:03:29.540"></status>
</kw>
<status status="PASS" endtime="20190401 13:03:29.541" starttime="20190401 13:03:29.540"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:29.541" starttime="20190401 13:03:29.541"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:03:29.541" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:03:29.541" starttime="20190401 13:03:29.541"></status>
</kw>
<msg timestamp="20190401 13:03:29.541" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:03:29.541" starttime="20190401 13:03:28.447"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:03:29.542" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:03:29.542" starttime="20190401 13:03:29.541"></status>
</kw>
<msg timestamp="20190401 13:03:29.542" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:03:29.542" starttime="20190401 13:03:28.446"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:03:29.542" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:03:29.542" starttime="20190401 13:03:29.542"></status>
</kw>
<status status="FAIL" endtime="20190401 13:03:29.543" starttime="20190401 13:03:28.445"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:03:49.544" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:03:49.544" starttime="20190401 13:03:49.544"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:49.545" starttime="20190401 13:03:49.544"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:03:49.545" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:03:49.545" starttime="20190401 13:03:49.545"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:49.546" starttime="20190401 13:03:49.546"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:49.546" starttime="20190401 13:03:49.546"></status>
</kw>
<msg timestamp="20190401 13:03:49.547" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:03:49.547" starttime="20190401 13:03:49.545"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:03:49.547" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:03:49.547" starttime="20190401 13:03:49.547"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:03:49.561" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:03:49.561" starttime="20190401 13:03:49.547"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:03:50.555" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:03:50.555" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:03:50.555" starttime="20190401 13:03:49.561"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:03:50.556" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:03:50.556" starttime="20190401 13:03:50.556"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:03:50.556" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:03:50.556" starttime="20190401 13:03:50.556"></status>
</kw>
<msg timestamp="20190401 13:03:50.557" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:03:50.557" starttime="20190401 13:03:50.556"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:03:50.559" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:03:50.559" starttime="20190401 13:03:50.557"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:03:50.559" level="INFO">0</msg>
<msg timestamp="20190401 13:03:50.559" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:03:50.559" starttime="20190401 13:03:50.559"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:03:50.560" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:03:50.560" starttime="20190401 13:03:50.559"></status>
</kw>
<msg timestamp="20190401 13:03:50.560" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:03:50.560" starttime="20190401 13:03:50.557"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:50.561" starttime="20190401 13:03:50.560"></status>
</kw>
<status status="PASS" endtime="20190401 13:03:50.561" starttime="20190401 13:03:50.560"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:03:50.561" starttime="20190401 13:03:50.561"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:03:50.561" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:03:50.561" starttime="20190401 13:03:50.561"></status>
</kw>
<msg timestamp="20190401 13:03:50.561" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:03:50.561" starttime="20190401 13:03:49.544"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:03:50.562" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:03:50.562" starttime="20190401 13:03:50.562"></status>
</kw>
<msg timestamp="20190401 13:03:50.562" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:03:50.562" starttime="20190401 13:03:49.543"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:03:50.562" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:03:50.563" starttime="20190401 13:03:50.562"></status>
</kw>
<status status="FAIL" endtime="20190401 13:03:50.563" starttime="20190401 13:03:49.543"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:04:10.564" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:04:10.564" starttime="20190401 13:04:10.564"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:10.565" starttime="20190401 13:04:10.565"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:04:10.566" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:04:10.566" starttime="20190401 13:04:10.565"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:10.566" starttime="20190401 13:04:10.566"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:10.566" starttime="20190401 13:04:10.566"></status>
</kw>
<msg timestamp="20190401 13:04:10.566" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:04:10.567" starttime="20190401 13:04:10.565"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:04:10.567" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:04:10.567" starttime="20190401 13:04:10.567"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:04:10.580" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:04:10.581" starttime="20190401 13:04:10.567"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:04:11.608" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:04:11.608" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:04:11.608" starttime="20190401 13:04:10.581"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:04:11.609" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:04:11.609" starttime="20190401 13:04:11.609"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:04:11.609" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:04:11.609" starttime="20190401 13:04:11.609"></status>
</kw>
<msg timestamp="20190401 13:04:11.609" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:04:11.609" starttime="20190401 13:04:11.608"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:04:11.612" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:04:11.612" starttime="20190401 13:04:11.610"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:04:11.612" level="INFO">0</msg>
<msg timestamp="20190401 13:04:11.612" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:04:11.612" starttime="20190401 13:04:11.612"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:04:11.613" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:04:11.613" starttime="20190401 13:04:11.613"></status>
</kw>
<msg timestamp="20190401 13:04:11.613" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:04:11.613" starttime="20190401 13:04:11.610"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:11.614" starttime="20190401 13:04:11.613"></status>
</kw>
<status status="PASS" endtime="20190401 13:04:11.614" starttime="20190401 13:04:11.613"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:11.614" starttime="20190401 13:04:11.614"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:04:11.614" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:04:11.614" starttime="20190401 13:04:11.614"></status>
</kw>
<msg timestamp="20190401 13:04:11.614" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:04:11.615" starttime="20190401 13:04:10.564"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:04:11.615" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:04:11.615" starttime="20190401 13:04:11.615"></status>
</kw>
<msg timestamp="20190401 13:04:11.615" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:04:11.615" starttime="20190401 13:04:10.563"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:04:11.616" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:04:11.616" starttime="20190401 13:04:11.615"></status>
</kw>
<status status="FAIL" endtime="20190401 13:04:11.616" starttime="20190401 13:04:10.563"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:04:31.618" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:04:31.618" starttime="20190401 13:04:31.617"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:31.619" starttime="20190401 13:04:31.619"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:04:31.620" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:04:31.620" starttime="20190401 13:04:31.620"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:31.621" starttime="20190401 13:04:31.621"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:31.622" starttime="20190401 13:04:31.621"></status>
</kw>
<msg timestamp="20190401 13:04:31.622" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:04:31.622" starttime="20190401 13:04:31.619"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:04:31.622" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:04:31.623" starttime="20190401 13:04:31.622"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:04:31.641" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:04:31.641" starttime="20190401 13:04:31.623"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:04:32.627" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:04:32.627" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:04:32.627" starttime="20190401 13:04:31.641"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:04:32.628" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:04:32.628" starttime="20190401 13:04:32.628"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:04:32.628" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:04:32.628" starttime="20190401 13:04:32.628"></status>
</kw>
<msg timestamp="20190401 13:04:32.629" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:04:32.629" starttime="20190401 13:04:32.627"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:04:32.631" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:04:32.631" starttime="20190401 13:04:32.629"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:04:32.631" level="INFO">0</msg>
<msg timestamp="20190401 13:04:32.631" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:04:32.631" starttime="20190401 13:04:32.631"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:04:32.631" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:04:32.632" starttime="20190401 13:04:32.631"></status>
</kw>
<msg timestamp="20190401 13:04:32.632" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:04:32.632" starttime="20190401 13:04:32.629"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:32.632" starttime="20190401 13:04:32.632"></status>
</kw>
<status status="PASS" endtime="20190401 13:04:32.632" starttime="20190401 13:04:32.632"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:32.633" starttime="20190401 13:04:32.633"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:04:32.633" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:04:32.633" starttime="20190401 13:04:32.633"></status>
</kw>
<msg timestamp="20190401 13:04:32.633" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:04:32.633" starttime="20190401 13:04:31.618"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:04:32.634" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:04:32.634" starttime="20190401 13:04:32.633"></status>
</kw>
<msg timestamp="20190401 13:04:32.634" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:04:32.634" starttime="20190401 13:04:31.617"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:04:32.634" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:04:32.634" starttime="20190401 13:04:32.634"></status>
</kw>
<status status="FAIL" endtime="20190401 13:04:32.634" starttime="20190401 13:04:31.616"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:04:52.636" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:04:52.636" starttime="20190401 13:04:52.636"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:52.637" starttime="20190401 13:04:52.636"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:04:52.637" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:04:52.637" starttime="20190401 13:04:52.637"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:52.638" starttime="20190401 13:04:52.637"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:52.638" starttime="20190401 13:04:52.638"></status>
</kw>
<msg timestamp="20190401 13:04:52.638" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:04:52.638" starttime="20190401 13:04:52.637"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:04:52.639" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:04:52.639" starttime="20190401 13:04:52.638"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:04:52.649" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:04:52.649" starttime="20190401 13:04:52.639"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:04:53.671" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:04:53.671" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:04:53.671" starttime="20190401 13:04:52.649"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:04:53.672" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:04:53.672" starttime="20190401 13:04:53.672"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:04:53.672" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:04:53.672" starttime="20190401 13:04:53.672"></status>
</kw>
<msg timestamp="20190401 13:04:53.672" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:04:53.672" starttime="20190401 13:04:53.671"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:04:53.675" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:04:53.675" starttime="20190401 13:04:53.673"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:04:53.675" level="INFO">0</msg>
<msg timestamp="20190401 13:04:53.675" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:04:53.675" starttime="20190401 13:04:53.675"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:04:53.675" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:04:53.675" starttime="20190401 13:04:53.675"></status>
</kw>
<msg timestamp="20190401 13:04:53.676" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:04:53.676" starttime="20190401 13:04:53.673"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:53.676" starttime="20190401 13:04:53.676"></status>
</kw>
<status status="PASS" endtime="20190401 13:04:53.676" starttime="20190401 13:04:53.676"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:04:53.677" starttime="20190401 13:04:53.676"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:04:53.677" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:04:53.677" starttime="20190401 13:04:53.677"></status>
</kw>
<msg timestamp="20190401 13:04:53.677" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:04:53.677" starttime="20190401 13:04:52.636"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:04:53.677" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:04:53.678" starttime="20190401 13:04:53.677"></status>
</kw>
<msg timestamp="20190401 13:04:53.678" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:04:53.678" starttime="20190401 13:04:52.635"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:04:53.678" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:04:53.678" starttime="20190401 13:04:53.678"></status>
</kw>
<status status="FAIL" endtime="20190401 13:04:53.678" starttime="20190401 13:04:52.635"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:05:13.680" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:05:13.680" starttime="20190401 13:05:13.680"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:13.681" starttime="20190401 13:05:13.680"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:05:13.681" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:05:13.681" starttime="20190401 13:05:13.681"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:13.682" starttime="20190401 13:05:13.681"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:13.682" starttime="20190401 13:05:13.682"></status>
</kw>
<msg timestamp="20190401 13:05:13.682" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:05:13.682" starttime="20190401 13:05:13.681"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:05:13.682" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:13.683" starttime="20190401 13:05:13.682"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:05:13.693" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:05:13.693" starttime="20190401 13:05:13.683"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:05:14.709" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:05:14.709" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:14.709" starttime="20190401 13:05:13.693"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:05:14.710" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:14.710" starttime="20190401 13:05:14.710"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:05:14.710" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:05:14.710" starttime="20190401 13:05:14.710"></status>
</kw>
<msg timestamp="20190401 13:05:14.710" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:05:14.710" starttime="20190401 13:05:14.709"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:05:14.712" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:05:14.712" starttime="20190401 13:05:14.711"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:05:14.713" level="INFO">0</msg>
<msg timestamp="20190401 13:05:14.713" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:14.713" starttime="20190401 13:05:14.713"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:05:14.713" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:05:14.713" starttime="20190401 13:05:14.713"></status>
</kw>
<msg timestamp="20190401 13:05:14.713" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:14.713" starttime="20190401 13:05:14.711"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:14.714" starttime="20190401 13:05:14.714"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:14.714" starttime="20190401 13:05:14.714"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:14.715" starttime="20190401 13:05:14.715"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:05:14.715" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:05:14.715" starttime="20190401 13:05:14.715"></status>
</kw>
<msg timestamp="20190401 13:05:14.715" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:05:14.715" starttime="20190401 13:05:13.680"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:05:14.716" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:05:14.716" starttime="20190401 13:05:14.715"></status>
</kw>
<msg timestamp="20190401 13:05:14.716" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:05:14.716" starttime="20190401 13:05:13.679"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:05:14.716" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:05:14.716" starttime="20190401 13:05:14.716"></status>
</kw>
<status status="FAIL" endtime="20190401 13:05:14.716" starttime="20190401 13:05:13.679"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:05:34.718" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:05:34.718" starttime="20190401 13:05:34.718"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:34.719" starttime="20190401 13:05:34.718"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:05:34.719" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:05:34.719" starttime="20190401 13:05:34.719"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:34.720" starttime="20190401 13:05:34.720"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:34.720" starttime="20190401 13:05:34.720"></status>
</kw>
<msg timestamp="20190401 13:05:34.720" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:05:34.720" starttime="20190401 13:05:34.719"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:05:34.721" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:34.721" starttime="20190401 13:05:34.720"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:05:34.731" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:05:34.731" starttime="20190401 13:05:34.721"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:05:35.729" level="INFO">intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:05:35.729" level="INFO">${output} = intest
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:35.729" starttime="20190401 13:05:34.731"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:05:35.730" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:35.730" starttime="20190401 13:05:35.729"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:05:35.730" level="INFO">${clean_out} = intest
</msg>
<status status="PASS" endtime="20190401 13:05:35.730" starttime="20190401 13:05:35.730"></status>
</kw>
<msg timestamp="20190401 13:05:35.730" level="INFO">${output} = intest
</msg>
<status status="PASS" endtime="20190401 13:05:35.730" starttime="20190401 13:05:35.729"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:05:35.732" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:05:35.732" starttime="20190401 13:05:35.730"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:05:35.732" level="INFO">0</msg>
<msg timestamp="20190401 13:05:35.732" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:35.732" starttime="20190401 13:05:35.732"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:05:35.733" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:05:35.733" starttime="20190401 13:05:35.733"></status>
</kw>
<msg timestamp="20190401 13:05:35.733" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:35.733" starttime="20190401 13:05:35.730"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:35.734" starttime="20190401 13:05:35.733"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:35.734" starttime="20190401 13:05:35.733"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:35.734" starttime="20190401 13:05:35.734"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:05:35.734" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: intest</msg>
<status status="PASS" endtime="20190401 13:05:35.734" starttime="20190401 13:05:35.734"></status>
</kw>
<msg timestamp="20190401 13:05:35.735" level="INFO">${result} = {u'stdout': u'intest', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:05:35.735" starttime="20190401 13:05:34.718"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:05:35.735" level="INFO">${value} = intest</msg>
<status status="PASS" endtime="20190401 13:05:35.735" starttime="20190401 13:05:35.735"></status>
</kw>
<msg timestamp="20190401 13:05:35.735" level="INFO">${current_value} = intest</msg>
<status status="PASS" endtime="20190401 13:05:35.735" starttime="20190401 13:05:34.717"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:05:35.736" level="FAIL">intest != available</msg>
<status status="FAIL" endtime="20190401 13:05:35.736" starttime="20190401 13:05:35.735"></status>
</kw>
<status status="FAIL" endtime="20190401 13:05:35.736" starttime="20190401 13:05:34.717"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${controller}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:05:55.737" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:05:55.737" starttime="20190401 13:05:55.737"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:55.738" starttime="20190401 13:05:55.738"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:05:55.739" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:05:55.739" starttime="20190401 13:05:55.738"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:55.739" starttime="20190401 13:05:55.739"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:55.740" starttime="20190401 13:05:55.739"></status>
</kw>
<msg timestamp="20190401 13:05:55.740" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:05:55.740" starttime="20190401 13:05:55.738"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:05:55.740" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:55.740" starttime="20190401 13:05:55.740"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:05:55.742" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:05:55.742" starttime="20190401 13:05:55.740"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:05:56.795" level="INFO">available
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:05:56.795" level="INFO">${output} = available
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:56.795" starttime="20190401 13:05:55.742"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:05:56.796" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:56.796" starttime="20190401 13:05:56.796"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:05:56.797" level="INFO">${clean_out} = available
</msg>
<status status="PASS" endtime="20190401 13:05:56.797" starttime="20190401 13:05:56.796"></status>
</kw>
<msg timestamp="20190401 13:05:56.797" level="INFO">${output} = available
</msg>
<status status="PASS" endtime="20190401 13:05:56.797" starttime="20190401 13:05:56.795"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:05:56.798" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:05:56.799" starttime="20190401 13:05:56.797"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:05:56.799" level="INFO">0</msg>
<msg timestamp="20190401 13:05:56.799" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:56.799" starttime="20190401 13:05:56.799"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:05:56.800" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:05:56.800" starttime="20190401 13:05:56.799"></status>
</kw>
<msg timestamp="20190401 13:05:56.800" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:56.800" starttime="20190401 13:05:56.797"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:56.801" starttime="20190401 13:05:56.801"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:56.801" starttime="20190401 13:05:56.800"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:56.802" starttime="20190401 13:05:56.801"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:05:56.802" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: available</msg>
<status status="PASS" endtime="20190401 13:05:56.802" starttime="20190401 13:05:56.802"></status>
</kw>
<msg timestamp="20190401 13:05:56.802" level="INFO">${result} = {u'stdout': u'available', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:05:56.803" starttime="20190401 13:05:55.738"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:05:56.803" level="INFO">${value} = available</msg>
<status status="PASS" endtime="20190401 13:05:56.803" starttime="20190401 13:05:56.803"></status>
</kw>
<msg timestamp="20190401 13:05:56.803" level="INFO">${current_value} = available</msg>
<status status="PASS" endtime="20190401 13:05:56.803" starttime="20190401 13:05:55.737"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:56.804" starttime="20190401 13:05:56.804"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:56.804" starttime="20190401 13:05:55.736"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:56.804" starttime="20190401 12:56:06.681"></status>
</kw>
<kw name="Generate Secondary Controller Connection" library="Utils">
<doc>Establish a SSH connection with the secondary controller
to have it alive.</doc>
<arguments>
<arg>${controller}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${controller}'=='controller-0'</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
<arg>${CONFIG.general.IP_UNIT_1_ADDRESS}</arg>
</arguments>
<assign>
<var>${controller_ip}</var>
</assign>
<msg timestamp="20190401 13:05:56.805" level="INFO">${controller_ip} = 192.168.200.77</msg>
<status status="PASS" endtime="20190401 13:05:56.805" starttime="20190401 13:05:56.805"></status>
</kw>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${controller_ip}</arg>
</arguments>
<assign>
<var>${secondary_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190401 13:05:56.807" level="INFO">${controller_connection} = 2</msg>
<status status="PASS" endtime="20190401 13:05:56.807" starttime="20190401 13:05:56.806"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190401 13:05:56.808" level="INFO">Length is 10</msg>
<msg timestamp="20190401 13:05:56.808" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190401 13:05:56.808" starttime="20190401 13:05:56.808"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190401 13:05:56.809" level="INFO">Logging into '192.168.200.77 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190401 13:05:57.949" level="INFO">Read output: /etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-1:~$</msg>
<status status="PASS" endtime="20190401 13:05:57.949" starttime="20190401 13:05:56.809"></status>
</kw>
<msg timestamp="20190401 13:05:57.949" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 13:05:57.949" starttime="20190401 13:05:56.808"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:57.949" starttime="20190401 13:05:56.807"></status>
</kw>
<msg timestamp="20190401 13:05:57.950" level="INFO">${secondary_controller_connection} = 2</msg>
<status status="PASS" endtime="20190401 13:05:57.950" starttime="20190401 13:05:56.805"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:05:57.950" level="INFO">${secondary_controller_connection} = 2</msg>
<status status="PASS" endtime="20190401 13:05:57.950" starttime="20190401 13:05:57.950"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:05:57.950" level="INFO">2</msg>
<status status="PASS" endtime="20190401 13:05:57.951" starttime="20190401 13:05:57.950"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${secondary_controller_connection} is not None</arg>
<arg>Switch Controller Connection</arg>
<arg>${master_controller_connection}</arg>
<arg>${secondary_controller_connection}</arg>
</arguments>
<kw name="Switch Controller Connection" library="Utils">
<doc>Enable a SSH connection to the new active controller and
source proper variables.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
<arg>${secondary_controller_connection}</arg>
</arguments>
<kw name="Switch Connection" library="SSHLibrary">
<doc>Switches the active connection by index or alias.</doc>
<arguments>
<arg>${new_idx}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:57.951" starttime="20190401 13:05:57.951"></status>
</kw>
<kw name="Get Connection" library="SSHLibrary">
<doc>Returns information about the connection.</doc>
<arguments>
<arg>${new_idx}</arg>
</arguments>
<msg timestamp="20190401 13:05:57.952" level="INFO">index=1
path_separator=/
prompt=$
width=80
newline=

height=24
encoding=UTF-8
alias=None
host=192.168.200.76 prompt=$
timeout=1 minute
term_type=vt100
port=22</msg>
<status status="PASS" endtime="20190401 13:05:57.952" starttime="20190401 13:05:57.952"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>whoami</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:57.953" starttime="20190401 13:05:57.952"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:05:57.953" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:05:57.953" starttime="20190401 13:05:57.953"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:57.954" starttime="20190401 13:05:57.953"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:57.954" starttime="20190401 13:05:57.954"></status>
</kw>
<msg timestamp="20190401 13:05:57.954" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:05:57.954" starttime="20190401 13:05:57.953"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:05:57.955" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:57.955" starttime="20190401 13:05:57.954"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:05:57.956" level="INFO">whoami</msg>
<status status="PASS" endtime="20190401 13:05:57.956" starttime="20190401 13:05:57.955"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:05:58.053" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:05:58.053" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:58.053" starttime="20190401 13:05:57.956"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:05:58.054" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:58.054" starttime="20190401 13:05:58.054"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:05:58.054" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190401 13:05:58.054" starttime="20190401 13:05:58.054"></status>
</kw>
<msg timestamp="20190401 13:05:58.054" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190401 13:05:58.054" starttime="20190401 13:05:58.053"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:05:58.055" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:05:58.055" starttime="20190401 13:05:58.055"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:05:58.056" level="INFO">0</msg>
<msg timestamp="20190401 13:05:58.056" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:58.056" starttime="20190401 13:05:58.056"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:05:58.057" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:05:58.057" starttime="20190401 13:05:58.056"></status>
</kw>
<msg timestamp="20190401 13:05:58.057" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:58.057" starttime="20190401 13:05:58.055"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:58.058" starttime="20190401 13:05:58.057"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:58.058" starttime="20190401 13:05:58.057"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:58.058" starttime="20190401 13:05:58.058"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:05:58.058" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190401 13:05:58.058" starttime="20190401 13:05:58.058"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:58.058" starttime="20190401 13:05:57.952"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Set Env Vars From Openrc</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:58.060" starttime="20190401 13:05:58.059"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:05:58.060" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:05:58.060" starttime="20190401 13:05:58.060"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:58.061" starttime="20190401 13:05:58.060"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:58.061" starttime="20190401 13:05:58.061"></status>
</kw>
<msg timestamp="20190401 13:05:58.061" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:05:58.061" starttime="20190401 13:05:58.060"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:05:58.061" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:58.061" starttime="20190401 13:05:58.061"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:05:58.062" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 13:05:58.062" starttime="20190401 13:05:58.062"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:05:58.462" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:05:58.462" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:58.462" starttime="20190401 13:05:58.063"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:05:58.463" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:58.463" starttime="20190401 13:05:58.463"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:05:58.463" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 13:05:58.463" starttime="20190401 13:05:58.463"></status>
</kw>
<msg timestamp="20190401 13:05:58.464" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:05:58.464" starttime="20190401 13:05:58.462"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:05:58.465" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:05:58.465" starttime="20190401 13:05:58.464"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:05:58.466" level="INFO">0</msg>
<msg timestamp="20190401 13:05:58.466" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:58.466" starttime="20190401 13:05:58.465"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:05:58.466" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:05:58.466" starttime="20190401 13:05:58.466"></status>
</kw>
<msg timestamp="20190401 13:05:58.466" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:58.466" starttime="20190401 13:05:58.464"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:58.467" starttime="20190401 13:05:58.467"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:58.467" starttime="20190401 13:05:58.467"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:58.467" starttime="20190401 13:05:58.467"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:05:58.468" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 13:05:58.468" starttime="20190401 13:05:58.468"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:58.468" starttime="20190401 13:05:58.059"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:58.468" starttime="20190401 13:05:58.059"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:58.468" starttime="20190401 13:05:58.058"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
<arg>${old_idx}</arg>
</arguments>
<msg timestamp="20190401 13:05:58.468" level="INFO">${secondary_controller_connection} = 2</msg>
<status status="PASS" endtime="20190401 13:05:58.468" starttime="20190401 13:05:58.468"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
<arg>${new_idx}</arg>
</arguments>
<msg timestamp="20190401 13:05:58.469" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:05:58.469" starttime="20190401 13:05:58.469"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:58.469" starttime="20190401 13:05:57.951"></status>
</kw>
<msg timestamp="20190401 13:05:58.469" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 13:05:58.469" starttime="20190401 13:05:57.951"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:58.469" starttime="20190401 13:05:56.804"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:58.469" starttime="20190401 12:55:59.214"></status>
</kw>
<kw name="Check Host Readiness" library="Utils">
<doc>Verify that host is unlocked, enabled and available.</doc>
<arguments>
<arg>${second_controller}</arg>
</arguments>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>40 min</arg>
<arg>5 sec</arg>
<arg>Check Property Value</arg>
<arg>${host}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>administrative</arg>
<arg>unlocked</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:05:58.471" level="INFO">${system_cmd} = system host-show controller-1|grep -w administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:05:58.471" starttime="20190401 13:05:58.471"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:58.472" starttime="20190401 13:05:58.471"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:05:58.472" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:05:58.472" starttime="20190401 13:05:58.472"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:58.473" starttime="20190401 13:05:58.472"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:58.473" starttime="20190401 13:05:58.473"></status>
</kw>
<msg timestamp="20190401 13:05:58.473" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:05:58.473" starttime="20190401 13:05:58.472"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:05:58.473" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:58.473" starttime="20190401 13:05:58.473"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:05:58.484" level="INFO">system host-show controller-1|grep -w  administrative|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:05:58.484" starttime="20190401 13:05:58.474"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:05:59.550" level="INFO">unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:05:59.550" level="INFO">${output} = unlocked
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:59.550" starttime="20190401 13:05:58.484"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:05:59.551" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:59.551" starttime="20190401 13:05:59.551"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:05:59.551" level="INFO">${clean_out} = unlocked
</msg>
<status status="PASS" endtime="20190401 13:05:59.551" starttime="20190401 13:05:59.551"></status>
</kw>
<msg timestamp="20190401 13:05:59.551" level="INFO">${output} = unlocked
</msg>
<status status="PASS" endtime="20190401 13:05:59.551" starttime="20190401 13:05:59.550"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:05:59.553" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:05:59.553" starttime="20190401 13:05:59.552"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:05:59.554" level="INFO">0</msg>
<msg timestamp="20190401 13:05:59.554" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:59.554" starttime="20190401 13:05:59.554"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:05:59.554" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:05:59.554" starttime="20190401 13:05:59.554"></status>
</kw>
<msg timestamp="20190401 13:05:59.554" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:05:59.554" starttime="20190401 13:05:59.552"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:59.555" starttime="20190401 13:05:59.555"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:59.555" starttime="20190401 13:05:59.555"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:59.556" starttime="20190401 13:05:59.555"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:05:59.556" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: unlocked</msg>
<status status="PASS" endtime="20190401 13:05:59.556" starttime="20190401 13:05:59.556"></status>
</kw>
<msg timestamp="20190401 13:05:59.556" level="INFO">${result} = {u'stdout': u'unlocked', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:05:59.556" starttime="20190401 13:05:58.471"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:05:59.556" level="INFO">${value} = unlocked</msg>
<status status="PASS" endtime="20190401 13:05:59.557" starttime="20190401 13:05:59.556"></status>
</kw>
<msg timestamp="20190401 13:05:59.557" level="INFO">${current_value} = unlocked</msg>
<status status="PASS" endtime="20190401 13:05:59.557" starttime="20190401 13:05:58.470"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:59.557" starttime="20190401 13:05:59.557"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:59.557" starttime="20190401 13:05:58.470"></status>
</kw>
<status status="PASS" endtime="20190401 13:05:59.557" starttime="20190401 13:05:58.470"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>20 min</arg>
<arg>5 sec</arg>
<arg>Check Property Value</arg>
<arg>${host}</arg>
<arg>operational</arg>
<arg>enabled</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>operational</arg>
<arg>enabled</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:05:59.559" level="INFO">${system_cmd} = system host-show controller-1|grep -w operational|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:05:59.559" starttime="20190401 13:05:59.559"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:59.560" starttime="20190401 13:05:59.559"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:05:59.560" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:05:59.561" starttime="20190401 13:05:59.560"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:59.561" starttime="20190401 13:05:59.561"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:05:59.561" starttime="20190401 13:05:59.561"></status>
</kw>
<msg timestamp="20190401 13:05:59.561" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:05:59.561" starttime="20190401 13:05:59.560"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:05:59.562" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:05:59.562" starttime="20190401 13:05:59.562"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:05:59.573" level="INFO">system host-show controller-1|grep -w  operational|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:05:59.573" starttime="20190401 13:05:59.562"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:00.642" level="INFO">enabled
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:00.642" level="INFO">${output} = enabled
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:00.642" starttime="20190401 13:05:59.573"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:00.643" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:00.643" starttime="20190401 13:06:00.643"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:00.643" level="INFO">${clean_out} = enabled
</msg>
<status status="PASS" endtime="20190401 13:06:00.643" starttime="20190401 13:06:00.643"></status>
</kw>
<msg timestamp="20190401 13:06:00.643" level="INFO">${output} = enabled
</msg>
<status status="PASS" endtime="20190401 13:06:00.643" starttime="20190401 13:06:00.642"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:00.645" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:00.645" starttime="20190401 13:06:00.644"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:00.645" level="INFO">0</msg>
<msg timestamp="20190401 13:06:00.645" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:00.645" starttime="20190401 13:06:00.645"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:00.646" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:00.646" starttime="20190401 13:06:00.645"></status>
</kw>
<msg timestamp="20190401 13:06:00.646" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:00.646" starttime="20190401 13:06:00.644"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:00.647" starttime="20190401 13:06:00.647"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:00.647" starttime="20190401 13:06:00.646"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:00.648" starttime="20190401 13:06:00.648"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:00.648" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: enabled</msg>
<status status="PASS" endtime="20190401 13:06:00.648" starttime="20190401 13:06:00.648"></status>
</kw>
<msg timestamp="20190401 13:06:00.648" level="INFO">${result} = {u'stdout': u'enabled', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:00.648" starttime="20190401 13:05:59.559"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:00.649" level="INFO">${value} = enabled</msg>
<status status="PASS" endtime="20190401 13:06:00.649" starttime="20190401 13:06:00.648"></status>
</kw>
<msg timestamp="20190401 13:06:00.649" level="INFO">${current_value} = enabled</msg>
<status status="PASS" endtime="20190401 13:06:00.649" starttime="20190401 13:05:59.558"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:00.649" starttime="20190401 13:06:00.649"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:00.649" starttime="20190401 13:05:59.558"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:00.649" starttime="20190401 13:05:59.557"></status>
</kw>
<kw name="Run Keyword And Ignore Error" library="BuiltIn">
<doc>Runs the given keyword with the given arguments and ignores possible error.</doc>
<arguments>
<arg>Check If Host Is In Degraded Mode</arg>
<arg>${host}</arg>
<arg>${wait_time}</arg>
</arguments>
<kw name="Check If Host Is In Degraded Mode" library="Utils">
<doc>Verify if host fall in a degraded mode during a period
of specified time.</doc>
<arguments>
<arg>${host}</arg>
<arg>${wait_time}</arg>
</arguments>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>${timeout} min</arg>
<arg>10 sec</arg>
<arg>Check Property Value</arg>
<arg>${host}</arg>
<arg>availability</arg>
<arg>degraded</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>degraded</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:06:00.651" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:00.651" starttime="20190401 13:06:00.651"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:00.652" starttime="20190401 13:06:00.652"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:06:00.653" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:06:00.653" starttime="20190401 13:06:00.652"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:00.653" starttime="20190401 13:06:00.653"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:00.653" starttime="20190401 13:06:00.653"></status>
</kw>
<msg timestamp="20190401 13:06:00.653" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:06:00.654" starttime="20190401 13:06:00.652"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:06:00.654" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:00.654" starttime="20190401 13:06:00.654"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:06:00.663" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:00.663" starttime="20190401 13:06:00.654"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:01.728" level="INFO">available
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:01.728" level="INFO">${output} = available
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:01.728" starttime="20190401 13:06:00.663"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:01.729" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:01.729" starttime="20190401 13:06:01.728"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:01.729" level="INFO">${clean_out} = available
</msg>
<status status="PASS" endtime="20190401 13:06:01.729" starttime="20190401 13:06:01.729"></status>
</kw>
<msg timestamp="20190401 13:06:01.729" level="INFO">${output} = available
</msg>
<status status="PASS" endtime="20190401 13:06:01.729" starttime="20190401 13:06:01.728"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:01.731" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:01.731" starttime="20190401 13:06:01.730"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:01.731" level="INFO">0</msg>
<msg timestamp="20190401 13:06:01.732" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:01.732" starttime="20190401 13:06:01.731"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:01.732" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:01.732" starttime="20190401 13:06:01.732"></status>
</kw>
<msg timestamp="20190401 13:06:01.732" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:01.732" starttime="20190401 13:06:01.729"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:01.733" starttime="20190401 13:06:01.733"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:01.733" starttime="20190401 13:06:01.733"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:01.734" starttime="20190401 13:06:01.733"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:01.734" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: available</msg>
<status status="PASS" endtime="20190401 13:06:01.734" starttime="20190401 13:06:01.734"></status>
</kw>
<msg timestamp="20190401 13:06:01.734" level="INFO">${result} = {u'stdout': u'available', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:01.734" starttime="20190401 13:06:00.651"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:01.734" level="INFO">${value} = available</msg>
<status status="PASS" endtime="20190401 13:06:01.734" starttime="20190401 13:06:01.734"></status>
</kw>
<msg timestamp="20190401 13:06:01.735" level="INFO">${current_value} = available</msg>
<status status="PASS" endtime="20190401 13:06:01.735" starttime="20190401 13:06:00.651"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:06:01.735" level="FAIL">available != degraded</msg>
<status status="FAIL" endtime="20190401 13:06:01.735" starttime="20190401 13:06:01.735"></status>
</kw>
<status status="FAIL" endtime="20190401 13:06:01.735" starttime="20190401 13:06:00.650"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>degraded</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:06:11.737" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:11.737" starttime="20190401 13:06:11.737"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:11.738" starttime="20190401 13:06:11.738"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:06:11.740" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:06:11.740" starttime="20190401 13:06:11.739"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:11.740" starttime="20190401 13:06:11.740"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:11.741" starttime="20190401 13:06:11.740"></status>
</kw>
<msg timestamp="20190401 13:06:11.741" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:06:11.741" starttime="20190401 13:06:11.739"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:06:11.742" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:11.742" starttime="20190401 13:06:11.741"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:06:11.744" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:11.745" starttime="20190401 13:06:11.742"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:12.834" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:12.835" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:12.835" starttime="20190401 13:06:11.745"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:12.835" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:12.835" starttime="20190401 13:06:12.835"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:12.836" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:12.836" starttime="20190401 13:06:12.836"></status>
</kw>
<msg timestamp="20190401 13:06:12.836" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:12.836" starttime="20190401 13:06:12.835"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:12.838" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:12.838" starttime="20190401 13:06:12.836"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:12.839" level="INFO">0</msg>
<msg timestamp="20190401 13:06:12.839" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:12.839" starttime="20190401 13:06:12.838"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:12.839" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:12.839" starttime="20190401 13:06:12.839"></status>
</kw>
<msg timestamp="20190401 13:06:12.839" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:12.839" starttime="20190401 13:06:12.836"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:12.840" starttime="20190401 13:06:12.840"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:12.840" starttime="20190401 13:06:12.839"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:12.841" starttime="20190401 13:06:12.840"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:12.841" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:06:12.841" starttime="20190401 13:06:12.841"></status>
</kw>
<msg timestamp="20190401 13:06:12.841" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:12.841" starttime="20190401 13:06:11.737"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:12.841" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:12.841" starttime="20190401 13:06:12.841"></status>
</kw>
<msg timestamp="20190401 13:06:12.842" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:12.842" starttime="20190401 13:06:11.736"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:12.842" starttime="20190401 13:06:12.842"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:12.842" starttime="20190401 13:06:11.736"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:12.842" starttime="20190401 13:06:00.650"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:12.842" starttime="20190401 13:06:00.650"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:12.842" starttime="20190401 13:06:00.649"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>60 min</arg>
<arg>5 sec</arg>
<arg>Check Property Value</arg>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:06:12.843" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:12.843" starttime="20190401 13:06:12.843"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:12.844" starttime="20190401 13:06:12.844"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:06:12.845" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:06:12.845" starttime="20190401 13:06:12.844"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:12.845" starttime="20190401 13:06:12.845"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:12.846" starttime="20190401 13:06:12.845"></status>
</kw>
<msg timestamp="20190401 13:06:12.846" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:06:12.846" starttime="20190401 13:06:12.844"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:06:12.846" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:12.846" starttime="20190401 13:06:12.846"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:06:12.848" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:12.848" starttime="20190401 13:06:12.846"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:13.990" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:13.990" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:13.990" starttime="20190401 13:06:12.848"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:13.991" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:13.991" starttime="20190401 13:06:13.990"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:13.991" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:13.991" starttime="20190401 13:06:13.991"></status>
</kw>
<msg timestamp="20190401 13:06:13.991" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:13.991" starttime="20190401 13:06:13.990"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:13.993" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:13.993" starttime="20190401 13:06:13.991"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:13.994" level="INFO">0</msg>
<msg timestamp="20190401 13:06:13.994" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:13.994" starttime="20190401 13:06:13.993"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:13.994" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:13.994" starttime="20190401 13:06:13.994"></status>
</kw>
<msg timestamp="20190401 13:06:13.994" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:13.994" starttime="20190401 13:06:13.991"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:13.995" starttime="20190401 13:06:13.995"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:13.995" starttime="20190401 13:06:13.994"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:13.995" starttime="20190401 13:06:13.995"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:13.996" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:06:13.996" starttime="20190401 13:06:13.995"></status>
</kw>
<msg timestamp="20190401 13:06:13.996" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:13.996" starttime="20190401 13:06:12.844"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:13.996" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:13.996" starttime="20190401 13:06:13.996"></status>
</kw>
<msg timestamp="20190401 13:06:13.996" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:13.996" starttime="20190401 13:06:12.843"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:06:13.997" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:06:13.997" starttime="20190401 13:06:13.996"></status>
</kw>
<status status="FAIL" endtime="20190401 13:06:13.997" starttime="20190401 13:06:12.843"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:06:18.999" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:18.999" starttime="20190401 13:06:18.998"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:18.999" starttime="20190401 13:06:18.999"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:06:19.000" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:06:19.000" starttime="20190401 13:06:19.000"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:19.001" starttime="20190401 13:06:19.000"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:19.001" starttime="20190401 13:06:19.001"></status>
</kw>
<msg timestamp="20190401 13:06:19.001" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:06:19.001" starttime="20190401 13:06:19.000"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:06:19.002" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:19.002" starttime="20190401 13:06:19.001"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:06:19.011" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:19.011" starttime="20190401 13:06:19.002"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:20.115" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:20.115" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:20.115" starttime="20190401 13:06:19.011"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:20.116" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:20.116" starttime="20190401 13:06:20.116"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:20.116" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:20.116" starttime="20190401 13:06:20.116"></status>
</kw>
<msg timestamp="20190401 13:06:20.116" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:20.116" starttime="20190401 13:06:20.115"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:20.118" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:20.118" starttime="20190401 13:06:20.117"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:20.119" level="INFO">0</msg>
<msg timestamp="20190401 13:06:20.119" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:20.119" starttime="20190401 13:06:20.119"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:20.119" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:20.119" starttime="20190401 13:06:20.119"></status>
</kw>
<msg timestamp="20190401 13:06:20.120" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:20.120" starttime="20190401 13:06:20.116"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:20.120" starttime="20190401 13:06:20.120"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:20.120" starttime="20190401 13:06:20.120"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:20.121" starttime="20190401 13:06:20.120"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:20.121" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:06:20.121" starttime="20190401 13:06:20.121"></status>
</kw>
<msg timestamp="20190401 13:06:20.121" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:20.121" starttime="20190401 13:06:18.999"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:20.122" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:20.122" starttime="20190401 13:06:20.121"></status>
</kw>
<msg timestamp="20190401 13:06:20.122" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:20.122" starttime="20190401 13:06:18.998"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:06:20.122" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:06:20.122" starttime="20190401 13:06:20.122"></status>
</kw>
<status status="FAIL" endtime="20190401 13:06:20.122" starttime="20190401 13:06:18.997"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:06:25.124" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:25.124" starttime="20190401 13:06:25.124"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:25.125" starttime="20190401 13:06:25.125"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:06:25.126" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:06:25.126" starttime="20190401 13:06:25.125"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:25.126" starttime="20190401 13:06:25.126"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:25.126" starttime="20190401 13:06:25.126"></status>
</kw>
<msg timestamp="20190401 13:06:25.127" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:06:25.127" starttime="20190401 13:06:25.125"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:06:25.127" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:25.127" starttime="20190401 13:06:25.127"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:06:25.137" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:25.137" starttime="20190401 13:06:25.127"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:26.193" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:26.193" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:26.193" starttime="20190401 13:06:25.137"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:26.194" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:26.194" starttime="20190401 13:06:26.194"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:26.194" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:26.194" starttime="20190401 13:06:26.194"></status>
</kw>
<msg timestamp="20190401 13:06:26.194" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:26.194" starttime="20190401 13:06:26.193"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:26.197" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:26.197" starttime="20190401 13:06:26.195"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:26.197" level="INFO">0</msg>
<msg timestamp="20190401 13:06:26.197" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:26.197" starttime="20190401 13:06:26.197"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:26.198" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:26.198" starttime="20190401 13:06:26.197"></status>
</kw>
<msg timestamp="20190401 13:06:26.198" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:26.198" starttime="20190401 13:06:26.195"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:26.199" starttime="20190401 13:06:26.198"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:26.199" starttime="20190401 13:06:26.198"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:26.199" starttime="20190401 13:06:26.199"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:26.199" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:06:26.199" starttime="20190401 13:06:26.199"></status>
</kw>
<msg timestamp="20190401 13:06:26.199" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:26.199" starttime="20190401 13:06:25.124"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:26.200" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:26.200" starttime="20190401 13:06:26.200"></status>
</kw>
<msg timestamp="20190401 13:06:26.200" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:26.200" starttime="20190401 13:06:25.123"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:06:26.200" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:06:26.201" starttime="20190401 13:06:26.200"></status>
</kw>
<status status="FAIL" endtime="20190401 13:06:26.201" starttime="20190401 13:06:25.123"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:06:31.202" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:31.202" starttime="20190401 13:06:31.202"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:31.203" starttime="20190401 13:06:31.203"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:06:31.204" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:06:31.204" starttime="20190401 13:06:31.203"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:31.204" starttime="20190401 13:06:31.204"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:31.205" starttime="20190401 13:06:31.204"></status>
</kw>
<msg timestamp="20190401 13:06:31.205" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:06:31.205" starttime="20190401 13:06:31.203"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:06:31.205" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:31.205" starttime="20190401 13:06:31.205"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:06:31.215" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:31.215" starttime="20190401 13:06:31.205"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:32.437" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:32.438" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:32.438" starttime="20190401 13:06:31.215"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:32.438" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:32.438" starttime="20190401 13:06:32.438"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:32.439" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:32.439" starttime="20190401 13:06:32.439"></status>
</kw>
<msg timestamp="20190401 13:06:32.439" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:32.439" starttime="20190401 13:06:32.438"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:32.441" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:32.441" starttime="20190401 13:06:32.439"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:32.442" level="INFO">0</msg>
<msg timestamp="20190401 13:06:32.442" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:32.442" starttime="20190401 13:06:32.441"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:32.442" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:32.442" starttime="20190401 13:06:32.442"></status>
</kw>
<msg timestamp="20190401 13:06:32.442" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:32.442" starttime="20190401 13:06:32.439"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:32.443" starttime="20190401 13:06:32.443"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:32.443" starttime="20190401 13:06:32.442"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:32.443" starttime="20190401 13:06:32.443"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:32.444" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:06:32.444" starttime="20190401 13:06:32.443"></status>
</kw>
<msg timestamp="20190401 13:06:32.444" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:32.444" starttime="20190401 13:06:31.202"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:32.444" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:32.444" starttime="20190401 13:06:32.444"></status>
</kw>
<msg timestamp="20190401 13:06:32.444" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:32.444" starttime="20190401 13:06:31.201"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:06:32.445" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:06:32.445" starttime="20190401 13:06:32.444"></status>
</kw>
<status status="FAIL" endtime="20190401 13:06:32.445" starttime="20190401 13:06:31.201"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:06:37.446" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:37.446" starttime="20190401 13:06:37.446"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:37.447" starttime="20190401 13:06:37.447"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:06:37.448" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:06:37.448" starttime="20190401 13:06:37.448"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:37.449" starttime="20190401 13:06:37.448"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:37.449" starttime="20190401 13:06:37.449"></status>
</kw>
<msg timestamp="20190401 13:06:37.449" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:06:37.449" starttime="20190401 13:06:37.447"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:06:37.449" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:37.449" starttime="20190401 13:06:37.449"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:06:37.460" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:37.460" starttime="20190401 13:06:37.450"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:38.582" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:38.583" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:38.583" starttime="20190401 13:06:37.460"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:38.583" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:38.583" starttime="20190401 13:06:38.583"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:38.584" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:38.584" starttime="20190401 13:06:38.584"></status>
</kw>
<msg timestamp="20190401 13:06:38.584" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:38.584" starttime="20190401 13:06:38.583"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:38.586" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:38.586" starttime="20190401 13:06:38.584"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:38.586" level="INFO">0</msg>
<msg timestamp="20190401 13:06:38.586" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:38.586" starttime="20190401 13:06:38.586"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:38.587" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:38.587" starttime="20190401 13:06:38.587"></status>
</kw>
<msg timestamp="20190401 13:06:38.587" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:38.587" starttime="20190401 13:06:38.584"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:38.588" starttime="20190401 13:06:38.587"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:38.588" starttime="20190401 13:06:38.587"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:38.588" starttime="20190401 13:06:38.588"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:38.588" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:06:38.588" starttime="20190401 13:06:38.588"></status>
</kw>
<msg timestamp="20190401 13:06:38.589" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:38.589" starttime="20190401 13:06:37.447"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:38.589" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:38.589" starttime="20190401 13:06:38.589"></status>
</kw>
<msg timestamp="20190401 13:06:38.589" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:38.589" starttime="20190401 13:06:37.446"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:06:38.590" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:06:38.590" starttime="20190401 13:06:38.589"></status>
</kw>
<status status="FAIL" endtime="20190401 13:06:38.590" starttime="20190401 13:06:37.445"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:06:43.591" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:43.591" starttime="20190401 13:06:43.591"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:43.592" starttime="20190401 13:06:43.592"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:06:43.593" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:06:43.593" starttime="20190401 13:06:43.592"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:43.593" starttime="20190401 13:06:43.593"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:43.594" starttime="20190401 13:06:43.593"></status>
</kw>
<msg timestamp="20190401 13:06:43.594" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:06:43.594" starttime="20190401 13:06:43.592"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:06:43.594" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:43.594" starttime="20190401 13:06:43.594"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:06:43.604" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:43.604" starttime="20190401 13:06:43.594"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:44.733" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:44.733" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:44.733" starttime="20190401 13:06:43.604"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:44.734" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:44.734" starttime="20190401 13:06:44.734"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:44.734" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:44.734" starttime="20190401 13:06:44.734"></status>
</kw>
<msg timestamp="20190401 13:06:44.735" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:44.735" starttime="20190401 13:06:44.733"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:44.736" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:44.736" starttime="20190401 13:06:44.735"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:44.737" level="INFO">0</msg>
<msg timestamp="20190401 13:06:44.737" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:44.737" starttime="20190401 13:06:44.736"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:44.737" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:44.737" starttime="20190401 13:06:44.737"></status>
</kw>
<msg timestamp="20190401 13:06:44.737" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:44.737" starttime="20190401 13:06:44.735"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:44.738" starttime="20190401 13:06:44.738"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:44.738" starttime="20190401 13:06:44.737"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:44.738" starttime="20190401 13:06:44.738"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:44.739" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:06:44.739" starttime="20190401 13:06:44.739"></status>
</kw>
<msg timestamp="20190401 13:06:44.739" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:44.739" starttime="20190401 13:06:43.591"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:44.739" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:44.739" starttime="20190401 13:06:44.739"></status>
</kw>
<msg timestamp="20190401 13:06:44.739" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:44.740" starttime="20190401 13:06:43.591"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:06:44.740" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:06:44.740" starttime="20190401 13:06:44.740"></status>
</kw>
<status status="FAIL" endtime="20190401 13:06:44.740" starttime="20190401 13:06:43.590"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:06:49.742" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:49.742" starttime="20190401 13:06:49.741"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:49.742" starttime="20190401 13:06:49.742"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:06:49.743" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:06:49.743" starttime="20190401 13:06:49.743"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:49.743" starttime="20190401 13:06:49.743"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:49.744" starttime="20190401 13:06:49.744"></status>
</kw>
<msg timestamp="20190401 13:06:49.744" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:06:49.744" starttime="20190401 13:06:49.742"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:06:49.745" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:49.745" starttime="20190401 13:06:49.745"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:06:49.755" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:49.755" starttime="20190401 13:06:49.745"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:50.811" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:50.811" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:50.811" starttime="20190401 13:06:49.755"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:50.812" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:50.812" starttime="20190401 13:06:50.812"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:50.812" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:50.812" starttime="20190401 13:06:50.812"></status>
</kw>
<msg timestamp="20190401 13:06:50.812" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:50.812" starttime="20190401 13:06:50.811"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:50.814" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:50.814" starttime="20190401 13:06:50.813"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:50.815" level="INFO">0</msg>
<msg timestamp="20190401 13:06:50.815" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:50.815" starttime="20190401 13:06:50.814"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:50.815" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:50.815" starttime="20190401 13:06:50.815"></status>
</kw>
<msg timestamp="20190401 13:06:50.815" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:50.815" starttime="20190401 13:06:50.813"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:50.816" starttime="20190401 13:06:50.816"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:50.816" starttime="20190401 13:06:50.815"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:50.816" starttime="20190401 13:06:50.816"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:50.817" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:06:50.817" starttime="20190401 13:06:50.816"></status>
</kw>
<msg timestamp="20190401 13:06:50.817" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:50.817" starttime="20190401 13:06:49.742"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:50.817" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:50.817" starttime="20190401 13:06:50.817"></status>
</kw>
<msg timestamp="20190401 13:06:50.817" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:50.817" starttime="20190401 13:06:49.741"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:06:50.818" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:06:50.818" starttime="20190401 13:06:50.818"></status>
</kw>
<status status="FAIL" endtime="20190401 13:06:50.818" starttime="20190401 13:06:49.740"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:06:55.819" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:55.819" starttime="20190401 13:06:55.819"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:55.820" starttime="20190401 13:06:55.820"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:06:55.821" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:06:55.821" starttime="20190401 13:06:55.820"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:55.821" starttime="20190401 13:06:55.821"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:55.822" starttime="20190401 13:06:55.821"></status>
</kw>
<msg timestamp="20190401 13:06:55.822" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:06:55.822" starttime="20190401 13:06:55.820"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:06:55.822" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:55.822" starttime="20190401 13:06:55.822"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:06:55.832" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:06:55.832" starttime="20190401 13:06:55.822"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:06:56.900" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:06:56.900" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:56.900" starttime="20190401 13:06:55.833"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:06:56.901" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:06:56.901" starttime="20190401 13:06:56.901"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:06:56.901" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:56.901" starttime="20190401 13:06:56.901"></status>
</kw>
<msg timestamp="20190401 13:06:56.902" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:06:56.902" starttime="20190401 13:06:56.900"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:06:56.903" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:06:56.903" starttime="20190401 13:06:56.902"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:06:56.904" level="INFO">0</msg>
<msg timestamp="20190401 13:06:56.904" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:56.904" starttime="20190401 13:06:56.903"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:06:56.904" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:06:56.904" starttime="20190401 13:06:56.904"></status>
</kw>
<msg timestamp="20190401 13:06:56.904" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:06:56.904" starttime="20190401 13:06:56.902"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:56.905" starttime="20190401 13:06:56.905"></status>
</kw>
<status status="PASS" endtime="20190401 13:06:56.905" starttime="20190401 13:06:56.904"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:06:56.905" starttime="20190401 13:06:56.905"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:06:56.906" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:06:56.906" starttime="20190401 13:06:56.905"></status>
</kw>
<msg timestamp="20190401 13:06:56.906" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:06:56.906" starttime="20190401 13:06:55.820"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:06:56.906" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:56.906" starttime="20190401 13:06:56.906"></status>
</kw>
<msg timestamp="20190401 13:06:56.906" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:06:56.906" starttime="20190401 13:06:55.819"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:06:56.907" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:06:56.907" starttime="20190401 13:06:56.907"></status>
</kw>
<status status="FAIL" endtime="20190401 13:06:56.907" starttime="20190401 13:06:55.818"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:07:01.908" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:01.908" starttime="20190401 13:07:01.908"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:01.909" starttime="20190401 13:07:01.909"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:07:01.910" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:07:01.910" starttime="20190401 13:07:01.910"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:01.910" starttime="20190401 13:07:01.910"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:01.911" starttime="20190401 13:07:01.910"></status>
</kw>
<msg timestamp="20190401 13:07:01.911" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:07:01.911" starttime="20190401 13:07:01.909"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:07:01.911" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:01.911" starttime="20190401 13:07:01.911"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:07:01.925" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:01.925" starttime="20190401 13:07:01.911"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:07:03.075" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:07:03.075" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:03.075" starttime="20190401 13:07:01.925"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:07:03.076" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:03.076" starttime="20190401 13:07:03.075"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:07:03.076" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:03.076" starttime="20190401 13:07:03.076"></status>
</kw>
<msg timestamp="20190401 13:07:03.076" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:03.076" starttime="20190401 13:07:03.075"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:07:03.079" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:07:03.079" starttime="20190401 13:07:03.077"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:07:03.079" level="INFO">0</msg>
<msg timestamp="20190401 13:07:03.079" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:03.079" starttime="20190401 13:07:03.079"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:07:03.079" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:07:03.079" starttime="20190401 13:07:03.079"></status>
</kw>
<msg timestamp="20190401 13:07:03.080" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:03.080" starttime="20190401 13:07:03.077"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:03.080" starttime="20190401 13:07:03.080"></status>
</kw>
<status status="PASS" endtime="20190401 13:07:03.080" starttime="20190401 13:07:03.080"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:03.081" starttime="20190401 13:07:03.081"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:07:03.081" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:07:03.081" starttime="20190401 13:07:03.081"></status>
</kw>
<msg timestamp="20190401 13:07:03.081" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:07:03.081" starttime="20190401 13:07:01.909"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:07:03.082" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:03.082" starttime="20190401 13:07:03.081"></status>
</kw>
<msg timestamp="20190401 13:07:03.082" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:03.082" starttime="20190401 13:07:01.908"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:07:03.082" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:07:03.082" starttime="20190401 13:07:03.082"></status>
</kw>
<status status="FAIL" endtime="20190401 13:07:03.082" starttime="20190401 13:07:01.907"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:07:08.084" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:08.084" starttime="20190401 13:07:08.083"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:08.085" starttime="20190401 13:07:08.084"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:07:08.085" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:07:08.085" starttime="20190401 13:07:08.085"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:08.086" starttime="20190401 13:07:08.085"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:08.086" starttime="20190401 13:07:08.086"></status>
</kw>
<msg timestamp="20190401 13:07:08.086" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:07:08.086" starttime="20190401 13:07:08.085"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:07:08.087" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:08.087" starttime="20190401 13:07:08.086"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:07:08.095" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:08.095" starttime="20190401 13:07:08.087"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:07:09.174" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:07:09.174" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:09.174" starttime="20190401 13:07:08.095"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:07:09.175" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:09.175" starttime="20190401 13:07:09.175"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:07:09.175" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:09.175" starttime="20190401 13:07:09.175"></status>
</kw>
<msg timestamp="20190401 13:07:09.176" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:09.176" starttime="20190401 13:07:09.174"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:07:09.177" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:07:09.178" starttime="20190401 13:07:09.176"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:07:09.178" level="INFO">0</msg>
<msg timestamp="20190401 13:07:09.178" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:09.178" starttime="20190401 13:07:09.178"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:07:09.178" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:07:09.178" starttime="20190401 13:07:09.178"></status>
</kw>
<msg timestamp="20190401 13:07:09.178" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:09.179" starttime="20190401 13:07:09.176"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:09.179" starttime="20190401 13:07:09.179"></status>
</kw>
<status status="PASS" endtime="20190401 13:07:09.179" starttime="20190401 13:07:09.179"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:09.180" starttime="20190401 13:07:09.179"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:07:09.180" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:07:09.180" starttime="20190401 13:07:09.180"></status>
</kw>
<msg timestamp="20190401 13:07:09.180" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:07:09.180" starttime="20190401 13:07:08.084"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:07:09.180" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:09.180" starttime="20190401 13:07:09.180"></status>
</kw>
<msg timestamp="20190401 13:07:09.181" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:09.181" starttime="20190401 13:07:08.083"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:07:09.181" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:07:09.181" starttime="20190401 13:07:09.181"></status>
</kw>
<status status="FAIL" endtime="20190401 13:07:09.181" starttime="20190401 13:07:08.083"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:07:14.183" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:14.183" starttime="20190401 13:07:14.182"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:14.183" starttime="20190401 13:07:14.183"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:07:14.184" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:07:14.184" starttime="20190401 13:07:14.184"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:14.185" starttime="20190401 13:07:14.184"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:14.185" starttime="20190401 13:07:14.185"></status>
</kw>
<msg timestamp="20190401 13:07:14.185" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:07:14.185" starttime="20190401 13:07:14.184"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:07:14.186" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:14.186" starttime="20190401 13:07:14.185"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:07:14.194" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:14.194" starttime="20190401 13:07:14.186"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:07:15.268" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:07:15.268" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:15.268" starttime="20190401 13:07:14.194"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:07:15.269" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:15.269" starttime="20190401 13:07:15.268"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:07:15.269" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:15.269" starttime="20190401 13:07:15.269"></status>
</kw>
<msg timestamp="20190401 13:07:15.269" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:15.269" starttime="20190401 13:07:15.268"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:07:15.271" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:07:15.271" starttime="20190401 13:07:15.269"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:07:15.271" level="INFO">0</msg>
<msg timestamp="20190401 13:07:15.271" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:15.271" starttime="20190401 13:07:15.271"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:07:15.272" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:07:15.272" starttime="20190401 13:07:15.272"></status>
</kw>
<msg timestamp="20190401 13:07:15.272" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:15.272" starttime="20190401 13:07:15.269"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:15.273" starttime="20190401 13:07:15.273"></status>
</kw>
<status status="PASS" endtime="20190401 13:07:15.273" starttime="20190401 13:07:15.272"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:15.274" starttime="20190401 13:07:15.274"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:07:15.274" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:07:15.274" starttime="20190401 13:07:15.274"></status>
</kw>
<msg timestamp="20190401 13:07:15.274" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:07:15.274" starttime="20190401 13:07:14.183"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:07:15.275" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:15.275" starttime="20190401 13:07:15.274"></status>
</kw>
<msg timestamp="20190401 13:07:15.275" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:15.275" starttime="20190401 13:07:14.182"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:07:15.275" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:07:15.275" starttime="20190401 13:07:15.275"></status>
</kw>
<status status="FAIL" endtime="20190401 13:07:15.275" starttime="20190401 13:07:14.182"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:07:20.277" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:20.277" starttime="20190401 13:07:20.277"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:20.278" starttime="20190401 13:07:20.277"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:07:20.278" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:07:20.278" starttime="20190401 13:07:20.278"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:20.279" starttime="20190401 13:07:20.278"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:20.279" starttime="20190401 13:07:20.279"></status>
</kw>
<msg timestamp="20190401 13:07:20.279" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:07:20.279" starttime="20190401 13:07:20.278"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:07:20.280" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:20.280" starttime="20190401 13:07:20.279"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:07:20.289" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:20.289" starttime="20190401 13:07:20.280"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:07:21.345" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:07:21.345" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:21.345" starttime="20190401 13:07:20.290"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:07:21.346" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:21.346" starttime="20190401 13:07:21.345"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:07:21.346" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:21.346" starttime="20190401 13:07:21.346"></status>
</kw>
<msg timestamp="20190401 13:07:21.346" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:21.346" starttime="20190401 13:07:21.345"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:07:21.348" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:07:21.348" starttime="20190401 13:07:21.346"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:07:21.349" level="INFO">0</msg>
<msg timestamp="20190401 13:07:21.349" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:21.349" starttime="20190401 13:07:21.349"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:07:21.349" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:07:21.349" starttime="20190401 13:07:21.349"></status>
</kw>
<msg timestamp="20190401 13:07:21.349" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:21.349" starttime="20190401 13:07:21.346"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:21.350" starttime="20190401 13:07:21.350"></status>
</kw>
<status status="PASS" endtime="20190401 13:07:21.350" starttime="20190401 13:07:21.349"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:21.350" starttime="20190401 13:07:21.350"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:07:21.351" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:07:21.351" starttime="20190401 13:07:21.351"></status>
</kw>
<msg timestamp="20190401 13:07:21.351" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:07:21.351" starttime="20190401 13:07:20.277"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:07:21.352" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:21.352" starttime="20190401 13:07:21.351"></status>
</kw>
<msg timestamp="20190401 13:07:21.352" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:21.352" starttime="20190401 13:07:20.276"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:07:21.352" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:07:21.352" starttime="20190401 13:07:21.352"></status>
</kw>
<status status="FAIL" endtime="20190401 13:07:21.352" starttime="20190401 13:07:20.276"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:07:26.354" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:26.354" starttime="20190401 13:07:26.354"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:26.355" starttime="20190401 13:07:26.354"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:07:26.355" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:07:26.355" starttime="20190401 13:07:26.355"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:26.356" starttime="20190401 13:07:26.355"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:26.356" starttime="20190401 13:07:26.356"></status>
</kw>
<msg timestamp="20190401 13:07:26.356" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:07:26.356" starttime="20190401 13:07:26.355"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:07:26.357" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:26.357" starttime="20190401 13:07:26.356"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:07:26.366" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:26.366" starttime="20190401 13:07:26.357"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:07:27.473" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:07:27.473" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:27.473" starttime="20190401 13:07:26.366"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:07:27.474" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:27.474" starttime="20190401 13:07:27.473"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:07:27.474" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:27.474" starttime="20190401 13:07:27.474"></status>
</kw>
<msg timestamp="20190401 13:07:27.474" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:27.474" starttime="20190401 13:07:27.473"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:07:27.476" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:07:27.476" starttime="20190401 13:07:27.474"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:07:27.477" level="INFO">0</msg>
<msg timestamp="20190401 13:07:27.477" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:27.477" starttime="20190401 13:07:27.477"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:07:27.477" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:07:27.477" starttime="20190401 13:07:27.477"></status>
</kw>
<msg timestamp="20190401 13:07:27.477" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:27.477" starttime="20190401 13:07:27.474"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:27.478" starttime="20190401 13:07:27.478"></status>
</kw>
<status status="PASS" endtime="20190401 13:07:27.478" starttime="20190401 13:07:27.478"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:27.478" starttime="20190401 13:07:27.478"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:07:27.479" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:07:27.479" starttime="20190401 13:07:27.479"></status>
</kw>
<msg timestamp="20190401 13:07:27.479" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:07:27.479" starttime="20190401 13:07:26.354"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:07:27.479" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:27.479" starttime="20190401 13:07:27.479"></status>
</kw>
<msg timestamp="20190401 13:07:27.480" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:27.480" starttime="20190401 13:07:26.353"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:07:27.480" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:07:27.480" starttime="20190401 13:07:27.480"></status>
</kw>
<status status="FAIL" endtime="20190401 13:07:27.480" starttime="20190401 13:07:26.353"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:07:32.482" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:32.482" starttime="20190401 13:07:32.482"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:32.483" starttime="20190401 13:07:32.482"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:07:32.483" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:07:32.483" starttime="20190401 13:07:32.483"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:32.484" starttime="20190401 13:07:32.484"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:32.484" starttime="20190401 13:07:32.484"></status>
</kw>
<msg timestamp="20190401 13:07:32.484" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:07:32.484" starttime="20190401 13:07:32.483"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:07:32.485" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:32.485" starttime="20190401 13:07:32.484"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:07:32.498" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:32.498" starttime="20190401 13:07:32.485"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:07:33.565" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:07:33.565" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:33.565" starttime="20190401 13:07:32.498"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:07:33.566" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:33.566" starttime="20190401 13:07:33.566"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:07:33.566" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:33.566" starttime="20190401 13:07:33.566"></status>
</kw>
<msg timestamp="20190401 13:07:33.566" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:33.567" starttime="20190401 13:07:33.565"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:07:33.569" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:07:33.569" starttime="20190401 13:07:33.567"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:07:33.569" level="INFO">0</msg>
<msg timestamp="20190401 13:07:33.569" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:33.569" starttime="20190401 13:07:33.569"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:07:33.570" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:07:33.570" starttime="20190401 13:07:33.570"></status>
</kw>
<msg timestamp="20190401 13:07:33.570" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:33.570" starttime="20190401 13:07:33.567"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:33.571" starttime="20190401 13:07:33.570"></status>
</kw>
<status status="PASS" endtime="20190401 13:07:33.571" starttime="20190401 13:07:33.570"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:33.571" starttime="20190401 13:07:33.571"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:07:33.571" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:07:33.571" starttime="20190401 13:07:33.571"></status>
</kw>
<msg timestamp="20190401 13:07:33.571" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:07:33.571" starttime="20190401 13:07:32.482"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:07:33.572" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:33.572" starttime="20190401 13:07:33.572"></status>
</kw>
<msg timestamp="20190401 13:07:33.572" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:33.572" starttime="20190401 13:07:32.481"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:07:33.572" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:07:33.573" starttime="20190401 13:07:33.572"></status>
</kw>
<status status="FAIL" endtime="20190401 13:07:33.573" starttime="20190401 13:07:32.480"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:07:38.574" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:38.574" starttime="20190401 13:07:38.574"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:38.575" starttime="20190401 13:07:38.575"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:07:38.576" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:07:38.576" starttime="20190401 13:07:38.575"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:38.576" starttime="20190401 13:07:38.576"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:38.577" starttime="20190401 13:07:38.576"></status>
</kw>
<msg timestamp="20190401 13:07:38.577" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:07:38.577" starttime="20190401 13:07:38.575"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:07:38.577" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:38.577" starttime="20190401 13:07:38.577"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:07:38.590" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:38.591" starttime="20190401 13:07:38.577"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:07:39.643" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:07:39.644" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:39.644" starttime="20190401 13:07:38.591"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:07:39.645" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:39.645" starttime="20190401 13:07:39.644"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:07:39.645" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:39.645" starttime="20190401 13:07:39.645"></status>
</kw>
<msg timestamp="20190401 13:07:39.645" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:39.645" starttime="20190401 13:07:39.644"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:07:39.647" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:07:39.647" starttime="20190401 13:07:39.645"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:07:39.647" level="INFO">0</msg>
<msg timestamp="20190401 13:07:39.648" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:39.648" starttime="20190401 13:07:39.647"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:07:39.648" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:07:39.648" starttime="20190401 13:07:39.648"></status>
</kw>
<msg timestamp="20190401 13:07:39.648" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:39.648" starttime="20190401 13:07:39.645"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:39.649" starttime="20190401 13:07:39.648"></status>
</kw>
<status status="PASS" endtime="20190401 13:07:39.649" starttime="20190401 13:07:39.648"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:39.649" starttime="20190401 13:07:39.649"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:07:39.649" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:07:39.649" starttime="20190401 13:07:39.649"></status>
</kw>
<msg timestamp="20190401 13:07:39.650" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:07:39.650" starttime="20190401 13:07:38.574"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:07:39.650" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:39.650" starttime="20190401 13:07:39.650"></status>
</kw>
<msg timestamp="20190401 13:07:39.650" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:39.650" starttime="20190401 13:07:38.573"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:07:39.651" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:07:39.651" starttime="20190401 13:07:39.650"></status>
</kw>
<status status="FAIL" endtime="20190401 13:07:39.651" starttime="20190401 13:07:38.573"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:07:44.652" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:44.652" starttime="20190401 13:07:44.652"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:44.653" starttime="20190401 13:07:44.653"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:07:44.654" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:07:44.654" starttime="20190401 13:07:44.654"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:44.654" starttime="20190401 13:07:44.654"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:44.655" starttime="20190401 13:07:44.654"></status>
</kw>
<msg timestamp="20190401 13:07:44.655" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:07:44.655" starttime="20190401 13:07:44.653"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:07:44.655" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:44.655" starttime="20190401 13:07:44.655"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:07:44.666" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:44.666" starttime="20190401 13:07:44.655"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:07:45.751" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:07:45.751" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:45.751" starttime="20190401 13:07:44.666"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:07:45.752" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:45.752" starttime="20190401 13:07:45.752"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:07:45.752" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:45.752" starttime="20190401 13:07:45.752"></status>
</kw>
<msg timestamp="20190401 13:07:45.752" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:45.752" starttime="20190401 13:07:45.751"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:07:45.754" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:07:45.754" starttime="20190401 13:07:45.753"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:07:45.754" level="INFO">0</msg>
<msg timestamp="20190401 13:07:45.755" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:45.755" starttime="20190401 13:07:45.754"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:07:45.755" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:07:45.755" starttime="20190401 13:07:45.755"></status>
</kw>
<msg timestamp="20190401 13:07:45.755" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:45.755" starttime="20190401 13:07:45.752"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:45.756" starttime="20190401 13:07:45.756"></status>
</kw>
<status status="PASS" endtime="20190401 13:07:45.756" starttime="20190401 13:07:45.755"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:45.756" starttime="20190401 13:07:45.756"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:07:45.756" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:07:45.757" starttime="20190401 13:07:45.756"></status>
</kw>
<msg timestamp="20190401 13:07:45.757" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:07:45.757" starttime="20190401 13:07:44.652"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:07:45.757" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:45.757" starttime="20190401 13:07:45.757"></status>
</kw>
<msg timestamp="20190401 13:07:45.757" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:45.757" starttime="20190401 13:07:44.652"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:07:45.758" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:07:45.758" starttime="20190401 13:07:45.757"></status>
</kw>
<status status="FAIL" endtime="20190401 13:07:45.758" starttime="20190401 13:07:44.651"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:07:50.759" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:50.759" starttime="20190401 13:07:50.759"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:50.760" starttime="20190401 13:07:50.760"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:07:50.761" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:07:50.761" starttime="20190401 13:07:50.760"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:50.761" starttime="20190401 13:07:50.761"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:50.762" starttime="20190401 13:07:50.761"></status>
</kw>
<msg timestamp="20190401 13:07:50.762" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:07:50.762" starttime="20190401 13:07:50.760"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:07:50.762" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:50.762" starttime="20190401 13:07:50.762"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:07:50.775" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:50.775" starttime="20190401 13:07:50.762"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:07:51.878" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:07:51.879" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:51.879" starttime="20190401 13:07:50.775"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:07:51.879" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:51.879" starttime="20190401 13:07:51.879"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:07:51.880" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:51.880" starttime="20190401 13:07:51.880"></status>
</kw>
<msg timestamp="20190401 13:07:51.880" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:51.880" starttime="20190401 13:07:51.879"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:07:51.882" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:07:51.882" starttime="20190401 13:07:51.880"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:07:51.883" level="INFO">0</msg>
<msg timestamp="20190401 13:07:51.883" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:51.883" starttime="20190401 13:07:51.883"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:07:51.883" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:07:51.883" starttime="20190401 13:07:51.883"></status>
</kw>
<msg timestamp="20190401 13:07:51.883" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:51.883" starttime="20190401 13:07:51.880"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:51.884" starttime="20190401 13:07:51.884"></status>
</kw>
<status status="PASS" endtime="20190401 13:07:51.884" starttime="20190401 13:07:51.883"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:51.884" starttime="20190401 13:07:51.884"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:07:51.885" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:07:51.885" starttime="20190401 13:07:51.885"></status>
</kw>
<msg timestamp="20190401 13:07:51.885" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:07:51.885" starttime="20190401 13:07:50.759"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:07:51.885" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:51.885" starttime="20190401 13:07:51.885"></status>
</kw>
<msg timestamp="20190401 13:07:51.885" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:51.885" starttime="20190401 13:07:50.759"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:07:51.886" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:07:51.886" starttime="20190401 13:07:51.886"></status>
</kw>
<status status="FAIL" endtime="20190401 13:07:51.886" starttime="20190401 13:07:50.758"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:07:56.887" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:56.888" starttime="20190401 13:07:56.887"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:56.888" starttime="20190401 13:07:56.888"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:07:56.889" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:07:56.889" starttime="20190401 13:07:56.889"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:56.889" starttime="20190401 13:07:56.889"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:56.890" starttime="20190401 13:07:56.889"></status>
</kw>
<msg timestamp="20190401 13:07:56.890" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:07:56.890" starttime="20190401 13:07:56.888"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:07:56.890" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:56.891" starttime="20190401 13:07:56.890"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:07:56.900" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:07:56.901" starttime="20190401 13:07:56.891"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:07:57.991" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:07:57.991" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:57.991" starttime="20190401 13:07:56.901"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:07:57.992" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:07:57.992" starttime="20190401 13:07:57.991"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:07:57.992" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:57.992" starttime="20190401 13:07:57.992"></status>
</kw>
<msg timestamp="20190401 13:07:57.992" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:07:57.992" starttime="20190401 13:07:57.991"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:07:57.994" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:07:57.994" starttime="20190401 13:07:57.993"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:07:57.994" level="INFO">0</msg>
<msg timestamp="20190401 13:07:57.994" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:57.994" starttime="20190401 13:07:57.994"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:07:57.995" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:07:57.995" starttime="20190401 13:07:57.995"></status>
</kw>
<msg timestamp="20190401 13:07:57.995" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:07:57.995" starttime="20190401 13:07:57.992"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:57.996" starttime="20190401 13:07:57.995"></status>
</kw>
<status status="PASS" endtime="20190401 13:07:57.996" starttime="20190401 13:07:57.995"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:07:57.996" starttime="20190401 13:07:57.996"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:07:57.996" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:07:57.996" starttime="20190401 13:07:57.996"></status>
</kw>
<msg timestamp="20190401 13:07:57.997" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:07:57.997" starttime="20190401 13:07:56.888"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:07:57.997" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:57.997" starttime="20190401 13:07:57.997"></status>
</kw>
<msg timestamp="20190401 13:07:57.997" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:07:57.997" starttime="20190401 13:07:56.887"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:07:57.998" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:07:57.998" starttime="20190401 13:07:57.997"></status>
</kw>
<status status="FAIL" endtime="20190401 13:07:57.998" starttime="20190401 13:07:56.886"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:08:02.999" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:02.999" starttime="20190401 13:08:02.999"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:03.000" starttime="20190401 13:08:03.000"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:08:03.001" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:08:03.001" starttime="20190401 13:08:03.000"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:03.001" starttime="20190401 13:08:03.001"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:03.001" starttime="20190401 13:08:03.001"></status>
</kw>
<msg timestamp="20190401 13:08:03.002" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:08:03.002" starttime="20190401 13:08:03.000"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:08:03.002" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:03.002" starttime="20190401 13:08:03.002"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:08:03.012" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:03.012" starttime="20190401 13:08:03.002"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:08:04.068" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:08:04.068" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:04.068" starttime="20190401 13:08:03.012"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:08:04.069" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:04.069" starttime="20190401 13:08:04.069"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:08:04.070" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:04.070" starttime="20190401 13:08:04.069"></status>
</kw>
<msg timestamp="20190401 13:08:04.070" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:04.070" starttime="20190401 13:08:04.069"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:08:04.072" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:08:04.072" starttime="20190401 13:08:04.070"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:08:04.072" level="INFO">0</msg>
<msg timestamp="20190401 13:08:04.073" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:04.073" starttime="20190401 13:08:04.072"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:08:04.073" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:08:04.073" starttime="20190401 13:08:04.073"></status>
</kw>
<msg timestamp="20190401 13:08:04.073" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:04.073" starttime="20190401 13:08:04.070"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:04.074" starttime="20190401 13:08:04.073"></status>
</kw>
<status status="PASS" endtime="20190401 13:08:04.074" starttime="20190401 13:08:04.073"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:04.074" starttime="20190401 13:08:04.074"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:08:04.074" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:08:04.074" starttime="20190401 13:08:04.074"></status>
</kw>
<msg timestamp="20190401 13:08:04.075" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:08:04.075" starttime="20190401 13:08:02.999"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:08:04.075" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:04.075" starttime="20190401 13:08:04.075"></status>
</kw>
<msg timestamp="20190401 13:08:04.075" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:04.075" starttime="20190401 13:08:02.999"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:08:04.076" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:08:04.076" starttime="20190401 13:08:04.075"></status>
</kw>
<status status="FAIL" endtime="20190401 13:08:04.076" starttime="20190401 13:08:02.998"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:08:09.077" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:09.077" starttime="20190401 13:08:09.077"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:09.078" starttime="20190401 13:08:09.078"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:08:09.079" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:08:09.079" starttime="20190401 13:08:09.078"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:09.079" starttime="20190401 13:08:09.079"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:09.079" starttime="20190401 13:08:09.079"></status>
</kw>
<msg timestamp="20190401 13:08:09.080" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:08:09.080" starttime="20190401 13:08:09.078"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:08:09.080" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:09.080" starttime="20190401 13:08:09.080"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:08:09.091" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:09.091" starttime="20190401 13:08:09.080"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:08:10.160" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:08:10.160" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:10.160" starttime="20190401 13:08:09.091"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:08:10.161" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:10.161" starttime="20190401 13:08:10.160"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:08:10.161" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:10.161" starttime="20190401 13:08:10.161"></status>
</kw>
<msg timestamp="20190401 13:08:10.161" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:10.161" starttime="20190401 13:08:10.160"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:08:10.163" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:08:10.163" starttime="20190401 13:08:10.162"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:08:10.164" level="INFO">0</msg>
<msg timestamp="20190401 13:08:10.164" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:10.164" starttime="20190401 13:08:10.163"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:08:10.164" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:08:10.164" starttime="20190401 13:08:10.164"></status>
</kw>
<msg timestamp="20190401 13:08:10.164" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:10.164" starttime="20190401 13:08:10.162"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:10.165" starttime="20190401 13:08:10.165"></status>
</kw>
<status status="PASS" endtime="20190401 13:08:10.165" starttime="20190401 13:08:10.164"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:10.165" starttime="20190401 13:08:10.165"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:08:10.166" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:08:10.166" starttime="20190401 13:08:10.166"></status>
</kw>
<msg timestamp="20190401 13:08:10.166" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:08:10.166" starttime="20190401 13:08:09.077"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:08:10.166" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:10.166" starttime="20190401 13:08:10.166"></status>
</kw>
<msg timestamp="20190401 13:08:10.166" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:10.166" starttime="20190401 13:08:09.077"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:08:10.167" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:08:10.167" starttime="20190401 13:08:10.167"></status>
</kw>
<status status="FAIL" endtime="20190401 13:08:10.167" starttime="20190401 13:08:09.076"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:08:15.169" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:15.169" starttime="20190401 13:08:15.168"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:15.169" starttime="20190401 13:08:15.169"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:08:15.170" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:08:15.170" starttime="20190401 13:08:15.170"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:15.170" starttime="20190401 13:08:15.170"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:15.171" starttime="20190401 13:08:15.170"></status>
</kw>
<msg timestamp="20190401 13:08:15.171" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:08:15.171" starttime="20190401 13:08:15.169"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:08:15.171" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:15.171" starttime="20190401 13:08:15.171"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:08:15.182" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:15.182" starttime="20190401 13:08:15.171"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:08:16.227" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:08:16.228" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:16.228" starttime="20190401 13:08:15.182"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:08:16.228" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:16.228" starttime="20190401 13:08:16.228"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:08:16.229" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:16.229" starttime="20190401 13:08:16.229"></status>
</kw>
<msg timestamp="20190401 13:08:16.229" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:16.229" starttime="20190401 13:08:16.228"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:08:16.231" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:08:16.231" starttime="20190401 13:08:16.229"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:08:16.231" level="INFO">0</msg>
<msg timestamp="20190401 13:08:16.231" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:16.231" starttime="20190401 13:08:16.231"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:08:16.232" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:08:16.232" starttime="20190401 13:08:16.232"></status>
</kw>
<msg timestamp="20190401 13:08:16.232" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:16.232" starttime="20190401 13:08:16.229"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:16.233" starttime="20190401 13:08:16.232"></status>
</kw>
<status status="PASS" endtime="20190401 13:08:16.233" starttime="20190401 13:08:16.232"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:16.233" starttime="20190401 13:08:16.233"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:08:16.233" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:08:16.233" starttime="20190401 13:08:16.233"></status>
</kw>
<msg timestamp="20190401 13:08:16.234" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:08:16.234" starttime="20190401 13:08:15.169"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:08:16.234" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:16.234" starttime="20190401 13:08:16.234"></status>
</kw>
<msg timestamp="20190401 13:08:16.234" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:16.234" starttime="20190401 13:08:15.168"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:08:16.235" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:08:16.235" starttime="20190401 13:08:16.234"></status>
</kw>
<status status="FAIL" endtime="20190401 13:08:16.235" starttime="20190401 13:08:15.167"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:08:21.236" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:21.236" starttime="20190401 13:08:21.236"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:21.237" starttime="20190401 13:08:21.237"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:08:21.238" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:08:21.238" starttime="20190401 13:08:21.237"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:21.238" starttime="20190401 13:08:21.238"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:21.238" starttime="20190401 13:08:21.238"></status>
</kw>
<msg timestamp="20190401 13:08:21.239" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:08:21.239" starttime="20190401 13:08:21.237"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:08:21.239" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:21.239" starttime="20190401 13:08:21.239"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:08:21.249" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:21.249" starttime="20190401 13:08:21.239"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:08:22.337" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:08:22.337" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:22.337" starttime="20190401 13:08:21.249"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:08:22.338" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:22.338" starttime="20190401 13:08:22.337"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:08:22.338" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:22.338" starttime="20190401 13:08:22.338"></status>
</kw>
<msg timestamp="20190401 13:08:22.338" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:22.338" starttime="20190401 13:08:22.337"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:08:22.340" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:08:22.340" starttime="20190401 13:08:22.339"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:08:22.340" level="INFO">0</msg>
<msg timestamp="20190401 13:08:22.341" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:22.341" starttime="20190401 13:08:22.340"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:08:22.341" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:08:22.341" starttime="20190401 13:08:22.341"></status>
</kw>
<msg timestamp="20190401 13:08:22.341" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:22.341" starttime="20190401 13:08:22.338"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:22.342" starttime="20190401 13:08:22.342"></status>
</kw>
<status status="PASS" endtime="20190401 13:08:22.342" starttime="20190401 13:08:22.341"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:22.342" starttime="20190401 13:08:22.342"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:08:22.343" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:08:22.343" starttime="20190401 13:08:22.343"></status>
</kw>
<msg timestamp="20190401 13:08:22.343" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:08:22.343" starttime="20190401 13:08:21.236"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:08:22.343" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:22.343" starttime="20190401 13:08:22.343"></status>
</kw>
<msg timestamp="20190401 13:08:22.343" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:22.344" starttime="20190401 13:08:21.236"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:08:22.344" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:08:22.344" starttime="20190401 13:08:22.344"></status>
</kw>
<status status="FAIL" endtime="20190401 13:08:22.344" starttime="20190401 13:08:21.235"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:08:27.346" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:27.346" starttime="20190401 13:08:27.345"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:27.346" starttime="20190401 13:08:27.346"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:08:27.347" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:08:27.347" starttime="20190401 13:08:27.347"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:27.347" starttime="20190401 13:08:27.347"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:27.348" starttime="20190401 13:08:27.347"></status>
</kw>
<msg timestamp="20190401 13:08:27.348" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:08:27.348" starttime="20190401 13:08:27.346"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:08:27.348" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:27.348" starttime="20190401 13:08:27.348"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:08:27.359" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:27.359" starttime="20190401 13:08:27.349"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:08:28.430" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:08:28.430" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:28.430" starttime="20190401 13:08:27.359"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:08:28.431" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:28.431" starttime="20190401 13:08:28.430"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:08:28.431" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:28.431" starttime="20190401 13:08:28.431"></status>
</kw>
<msg timestamp="20190401 13:08:28.431" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:28.431" starttime="20190401 13:08:28.430"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:08:28.434" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:08:28.434" starttime="20190401 13:08:28.431"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:08:28.434" level="INFO">0</msg>
<msg timestamp="20190401 13:08:28.434" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:28.434" starttime="20190401 13:08:28.434"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:08:28.434" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:08:28.434" starttime="20190401 13:08:28.434"></status>
</kw>
<msg timestamp="20190401 13:08:28.434" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:28.435" starttime="20190401 13:08:28.431"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:28.435" starttime="20190401 13:08:28.435"></status>
</kw>
<status status="PASS" endtime="20190401 13:08:28.435" starttime="20190401 13:08:28.435"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:28.436" starttime="20190401 13:08:28.435"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:08:28.436" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:08:28.436" starttime="20190401 13:08:28.436"></status>
</kw>
<msg timestamp="20190401 13:08:28.436" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:08:28.436" starttime="20190401 13:08:27.346"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:08:28.436" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:28.436" starttime="20190401 13:08:28.436"></status>
</kw>
<msg timestamp="20190401 13:08:28.437" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:28.437" starttime="20190401 13:08:27.345"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:08:28.437" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:08:28.437" starttime="20190401 13:08:28.437"></status>
</kw>
<status status="FAIL" endtime="20190401 13:08:28.437" starttime="20190401 13:08:27.344"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:08:33.439" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:33.439" starttime="20190401 13:08:33.439"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:33.440" starttime="20190401 13:08:33.439"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:08:33.440" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:08:33.440" starttime="20190401 13:08:33.440"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:33.441" starttime="20190401 13:08:33.440"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:33.441" starttime="20190401 13:08:33.441"></status>
</kw>
<msg timestamp="20190401 13:08:33.441" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:08:33.441" starttime="20190401 13:08:33.440"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:08:33.442" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:33.442" starttime="20190401 13:08:33.442"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:08:33.453" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:33.453" starttime="20190401 13:08:33.442"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:08:34.490" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:08:34.490" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:34.490" starttime="20190401 13:08:33.453"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:08:34.491" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:34.491" starttime="20190401 13:08:34.491"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:08:34.492" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:34.492" starttime="20190401 13:08:34.491"></status>
</kw>
<msg timestamp="20190401 13:08:34.492" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:34.492" starttime="20190401 13:08:34.491"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:08:34.494" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:08:34.494" starttime="20190401 13:08:34.492"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:08:34.494" level="INFO">0</msg>
<msg timestamp="20190401 13:08:34.494" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:34.494" starttime="20190401 13:08:34.494"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:08:34.495" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:08:34.495" starttime="20190401 13:08:34.495"></status>
</kw>
<msg timestamp="20190401 13:08:34.495" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:34.495" starttime="20190401 13:08:34.492"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:34.496" starttime="20190401 13:08:34.495"></status>
</kw>
<status status="PASS" endtime="20190401 13:08:34.496" starttime="20190401 13:08:34.495"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:34.496" starttime="20190401 13:08:34.496"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:08:34.496" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:08:34.496" starttime="20190401 13:08:34.496"></status>
</kw>
<msg timestamp="20190401 13:08:34.497" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:08:34.497" starttime="20190401 13:08:33.439"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:08:34.497" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:34.497" starttime="20190401 13:08:34.497"></status>
</kw>
<msg timestamp="20190401 13:08:34.497" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:34.497" starttime="20190401 13:08:33.438"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:08:34.498" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:08:34.498" starttime="20190401 13:08:34.497"></status>
</kw>
<status status="FAIL" endtime="20190401 13:08:34.498" starttime="20190401 13:08:33.438"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:08:39.500" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:39.500" starttime="20190401 13:08:39.499"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:39.501" starttime="20190401 13:08:39.500"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:08:39.501" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:08:39.501" starttime="20190401 13:08:39.501"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:39.502" starttime="20190401 13:08:39.501"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:39.502" starttime="20190401 13:08:39.502"></status>
</kw>
<msg timestamp="20190401 13:08:39.502" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:08:39.502" starttime="20190401 13:08:39.501"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:08:39.503" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:39.503" starttime="20190401 13:08:39.502"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:08:39.511" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:39.511" starttime="20190401 13:08:39.503"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:08:40.574" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:08:40.574" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:40.574" starttime="20190401 13:08:39.511"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:08:40.574" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:40.575" starttime="20190401 13:08:40.574"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:08:40.575" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:40.575" starttime="20190401 13:08:40.575"></status>
</kw>
<msg timestamp="20190401 13:08:40.575" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:40.575" starttime="20190401 13:08:40.574"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:08:40.577" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:08:40.577" starttime="20190401 13:08:40.575"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:08:40.578" level="INFO">0</msg>
<msg timestamp="20190401 13:08:40.578" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:40.578" starttime="20190401 13:08:40.577"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:08:40.578" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:08:40.578" starttime="20190401 13:08:40.578"></status>
</kw>
<msg timestamp="20190401 13:08:40.578" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:40.578" starttime="20190401 13:08:40.575"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:40.579" starttime="20190401 13:08:40.579"></status>
</kw>
<status status="PASS" endtime="20190401 13:08:40.579" starttime="20190401 13:08:40.578"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:40.579" starttime="20190401 13:08:40.579"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:08:40.580" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:08:40.580" starttime="20190401 13:08:40.579"></status>
</kw>
<msg timestamp="20190401 13:08:40.580" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:08:40.580" starttime="20190401 13:08:39.500"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:08:40.580" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:40.580" starttime="20190401 13:08:40.580"></status>
</kw>
<msg timestamp="20190401 13:08:40.580" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:40.580" starttime="20190401 13:08:39.499"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:08:40.581" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:08:40.581" starttime="20190401 13:08:40.581"></status>
</kw>
<status status="FAIL" endtime="20190401 13:08:40.581" starttime="20190401 13:08:39.498"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:08:45.582" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:45.583" starttime="20190401 13:08:45.582"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:45.583" starttime="20190401 13:08:45.583"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:08:45.584" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:08:45.584" starttime="20190401 13:08:45.584"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:45.585" starttime="20190401 13:08:45.584"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:45.585" starttime="20190401 13:08:45.585"></status>
</kw>
<msg timestamp="20190401 13:08:45.585" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:08:45.585" starttime="20190401 13:08:45.584"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:08:45.586" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:45.586" starttime="20190401 13:08:45.585"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:08:45.594" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:45.594" starttime="20190401 13:08:45.586"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:08:46.716" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:08:46.716" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:46.716" starttime="20190401 13:08:45.595"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:08:46.717" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:46.717" starttime="20190401 13:08:46.716"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:08:46.717" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:46.717" starttime="20190401 13:08:46.717"></status>
</kw>
<msg timestamp="20190401 13:08:46.717" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:46.717" starttime="20190401 13:08:46.716"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:08:46.719" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:08:46.719" starttime="20190401 13:08:46.718"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:08:46.719" level="INFO">0</msg>
<msg timestamp="20190401 13:08:46.720" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:46.720" starttime="20190401 13:08:46.719"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:08:46.720" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:08:46.720" starttime="20190401 13:08:46.720"></status>
</kw>
<msg timestamp="20190401 13:08:46.720" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:46.720" starttime="20190401 13:08:46.717"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:46.721" starttime="20190401 13:08:46.721"></status>
</kw>
<status status="PASS" endtime="20190401 13:08:46.721" starttime="20190401 13:08:46.720"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:46.721" starttime="20190401 13:08:46.721"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:08:46.721" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:08:46.722" starttime="20190401 13:08:46.721"></status>
</kw>
<msg timestamp="20190401 13:08:46.722" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:08:46.722" starttime="20190401 13:08:45.583"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:08:46.722" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:46.722" starttime="20190401 13:08:46.722"></status>
</kw>
<msg timestamp="20190401 13:08:46.722" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:46.722" starttime="20190401 13:08:45.582"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:08:46.723" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:08:46.723" starttime="20190401 13:08:46.722"></status>
</kw>
<status status="FAIL" endtime="20190401 13:08:46.723" starttime="20190401 13:08:45.581"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:08:51.724" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:51.724" starttime="20190401 13:08:51.724"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:51.725" starttime="20190401 13:08:51.725"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:08:51.726" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:08:51.726" starttime="20190401 13:08:51.726"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:51.726" starttime="20190401 13:08:51.726"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:51.727" starttime="20190401 13:08:51.726"></status>
</kw>
<msg timestamp="20190401 13:08:51.727" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:08:51.727" starttime="20190401 13:08:51.725"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:08:51.727" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:51.727" starttime="20190401 13:08:51.727"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:08:51.737" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:51.737" starttime="20190401 13:08:51.727"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:08:52.830" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:08:52.830" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:52.830" starttime="20190401 13:08:51.737"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:08:52.831" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:52.831" starttime="20190401 13:08:52.831"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:08:52.832" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:52.832" starttime="20190401 13:08:52.831"></status>
</kw>
<msg timestamp="20190401 13:08:52.832" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:52.832" starttime="20190401 13:08:52.831"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:08:52.834" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:08:52.834" starttime="20190401 13:08:52.832"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:08:52.834" level="INFO">0</msg>
<msg timestamp="20190401 13:08:52.834" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:52.834" starttime="20190401 13:08:52.834"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:08:52.835" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:08:52.835" starttime="20190401 13:08:52.835"></status>
</kw>
<msg timestamp="20190401 13:08:52.835" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:52.835" starttime="20190401 13:08:52.832"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:52.836" starttime="20190401 13:08:52.835"></status>
</kw>
<status status="PASS" endtime="20190401 13:08:52.836" starttime="20190401 13:08:52.835"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:52.836" starttime="20190401 13:08:52.836"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:08:52.836" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:08:52.836" starttime="20190401 13:08:52.836"></status>
</kw>
<msg timestamp="20190401 13:08:52.837" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:08:52.837" starttime="20190401 13:08:51.724"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:08:52.837" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:52.837" starttime="20190401 13:08:52.837"></status>
</kw>
<msg timestamp="20190401 13:08:52.837" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:52.837" starttime="20190401 13:08:51.724"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:08:52.838" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:08:52.838" starttime="20190401 13:08:52.837"></status>
</kw>
<status status="FAIL" endtime="20190401 13:08:52.838" starttime="20190401 13:08:51.723"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:08:57.839" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:57.839" starttime="20190401 13:08:57.839"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:57.840" starttime="20190401 13:08:57.840"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:08:57.841" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:08:57.841" starttime="20190401 13:08:57.840"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:57.841" starttime="20190401 13:08:57.841"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:57.842" starttime="20190401 13:08:57.841"></status>
</kw>
<msg timestamp="20190401 13:08:57.842" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:08:57.842" starttime="20190401 13:08:57.840"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:08:57.842" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:57.842" starttime="20190401 13:08:57.842"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:08:57.852" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:08:57.852" starttime="20190401 13:08:57.842"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:08:58.910" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:08:58.910" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:58.910" starttime="20190401 13:08:57.852"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:08:58.911" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:08:58.911" starttime="20190401 13:08:58.911"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:08:58.911" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:58.911" starttime="20190401 13:08:58.911"></status>
</kw>
<msg timestamp="20190401 13:08:58.911" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:08:58.911" starttime="20190401 13:08:58.910"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:08:58.914" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:08:58.914" starttime="20190401 13:08:58.912"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:08:58.914" level="INFO">0</msg>
<msg timestamp="20190401 13:08:58.914" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:58.914" starttime="20190401 13:08:58.914"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:08:58.914" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:08:58.914" starttime="20190401 13:08:58.914"></status>
</kw>
<msg timestamp="20190401 13:08:58.914" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:08:58.915" starttime="20190401 13:08:58.911"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:58.915" starttime="20190401 13:08:58.915"></status>
</kw>
<status status="PASS" endtime="20190401 13:08:58.915" starttime="20190401 13:08:58.915"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:08:58.916" starttime="20190401 13:08:58.915"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:08:58.916" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:08:58.916" starttime="20190401 13:08:58.916"></status>
</kw>
<msg timestamp="20190401 13:08:58.916" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:08:58.916" starttime="20190401 13:08:57.839"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:08:58.916" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:58.916" starttime="20190401 13:08:58.916"></status>
</kw>
<msg timestamp="20190401 13:08:58.917" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:08:58.917" starttime="20190401 13:08:57.839"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:08:58.917" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:08:58.917" starttime="20190401 13:08:58.917"></status>
</kw>
<status status="FAIL" endtime="20190401 13:08:58.917" starttime="20190401 13:08:57.838"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:09:03.919" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:03.919" starttime="20190401 13:09:03.918"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:03.919" starttime="20190401 13:09:03.919"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:09:03.920" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:09:03.920" starttime="20190401 13:09:03.920"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:03.921" starttime="20190401 13:09:03.920"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:03.921" starttime="20190401 13:09:03.921"></status>
</kw>
<msg timestamp="20190401 13:09:03.921" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:09:03.921" starttime="20190401 13:09:03.920"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:09:03.922" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:03.922" starttime="20190401 13:09:03.922"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:09:03.932" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:03.932" starttime="20190401 13:09:03.922"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:09:05.035" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:09:05.035" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:05.035" starttime="20190401 13:09:03.933"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:09:05.036" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:05.036" starttime="20190401 13:09:05.036"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:09:05.036" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:05.036" starttime="20190401 13:09:05.036"></status>
</kw>
<msg timestamp="20190401 13:09:05.037" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:05.037" starttime="20190401 13:09:05.036"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:09:05.039" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:09:05.039" starttime="20190401 13:09:05.037"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:09:05.039" level="INFO">0</msg>
<msg timestamp="20190401 13:09:05.039" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:05.039" starttime="20190401 13:09:05.039"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:09:05.039" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:09:05.039" starttime="20190401 13:09:05.039"></status>
</kw>
<msg timestamp="20190401 13:09:05.040" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:05.040" starttime="20190401 13:09:05.037"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:05.040" starttime="20190401 13:09:05.040"></status>
</kw>
<status status="PASS" endtime="20190401 13:09:05.040" starttime="20190401 13:09:05.040"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:05.041" starttime="20190401 13:09:05.040"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:09:05.041" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:09:05.041" starttime="20190401 13:09:05.041"></status>
</kw>
<msg timestamp="20190401 13:09:05.041" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:09:05.041" starttime="20190401 13:09:03.919"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:09:05.041" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:05.042" starttime="20190401 13:09:05.041"></status>
</kw>
<msg timestamp="20190401 13:09:05.042" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:05.042" starttime="20190401 13:09:03.918"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:09:05.042" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:09:05.042" starttime="20190401 13:09:05.042"></status>
</kw>
<status status="FAIL" endtime="20190401 13:09:05.042" starttime="20190401 13:09:03.918"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:09:10.044" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:10.044" starttime="20190401 13:09:10.043"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:10.045" starttime="20190401 13:09:10.044"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:09:10.045" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:09:10.045" starttime="20190401 13:09:10.045"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:10.046" starttime="20190401 13:09:10.045"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:10.046" starttime="20190401 13:09:10.046"></status>
</kw>
<msg timestamp="20190401 13:09:10.046" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:09:10.046" starttime="20190401 13:09:10.045"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:09:10.047" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:10.047" starttime="20190401 13:09:10.046"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:09:10.056" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:10.056" starttime="20190401 13:09:10.047"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:09:11.104" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:09:11.104" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:11.104" starttime="20190401 13:09:10.056"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:09:11.105" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:11.105" starttime="20190401 13:09:11.105"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:09:11.105" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:11.105" starttime="20190401 13:09:11.105"></status>
</kw>
<msg timestamp="20190401 13:09:11.105" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:11.105" starttime="20190401 13:09:11.104"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:09:11.107" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:09:11.107" starttime="20190401 13:09:11.106"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:09:11.107" level="INFO">0</msg>
<msg timestamp="20190401 13:09:11.107" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:11.107" starttime="20190401 13:09:11.107"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:09:11.108" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:09:11.108" starttime="20190401 13:09:11.108"></status>
</kw>
<msg timestamp="20190401 13:09:11.108" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:11.108" starttime="20190401 13:09:11.105"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:11.109" starttime="20190401 13:09:11.108"></status>
</kw>
<status status="PASS" endtime="20190401 13:09:11.109" starttime="20190401 13:09:11.108"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:11.109" starttime="20190401 13:09:11.109"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:09:11.109" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:09:11.109" starttime="20190401 13:09:11.109"></status>
</kw>
<msg timestamp="20190401 13:09:11.109" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:09:11.110" starttime="20190401 13:09:10.044"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:09:11.110" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:11.110" starttime="20190401 13:09:11.110"></status>
</kw>
<msg timestamp="20190401 13:09:11.110" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:11.110" starttime="20190401 13:09:10.043"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:09:11.110" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:09:11.111" starttime="20190401 13:09:11.110"></status>
</kw>
<status status="FAIL" endtime="20190401 13:09:11.111" starttime="20190401 13:09:10.043"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:09:16.112" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:16.112" starttime="20190401 13:09:16.112"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:16.113" starttime="20190401 13:09:16.113"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:09:16.114" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:09:16.114" starttime="20190401 13:09:16.113"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:16.114" starttime="20190401 13:09:16.114"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:16.114" starttime="20190401 13:09:16.114"></status>
</kw>
<msg timestamp="20190401 13:09:16.114" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:09:16.115" starttime="20190401 13:09:16.113"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:09:16.115" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:16.115" starttime="20190401 13:09:16.115"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:09:16.125" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:16.125" starttime="20190401 13:09:16.115"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:09:17.181" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:09:17.181" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:17.181" starttime="20190401 13:09:16.125"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:09:17.182" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:17.182" starttime="20190401 13:09:17.182"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:09:17.183" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:17.183" starttime="20190401 13:09:17.182"></status>
</kw>
<msg timestamp="20190401 13:09:17.183" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:17.183" starttime="20190401 13:09:17.181"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:09:17.185" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:09:17.185" starttime="20190401 13:09:17.183"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:09:17.185" level="INFO">0</msg>
<msg timestamp="20190401 13:09:17.185" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:17.185" starttime="20190401 13:09:17.185"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:09:17.185" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:09:17.186" starttime="20190401 13:09:17.185"></status>
</kw>
<msg timestamp="20190401 13:09:17.186" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:17.186" starttime="20190401 13:09:17.183"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:17.186" starttime="20190401 13:09:17.186"></status>
</kw>
<status status="PASS" endtime="20190401 13:09:17.186" starttime="20190401 13:09:17.186"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:17.187" starttime="20190401 13:09:17.187"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:09:17.187" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:09:17.187" starttime="20190401 13:09:17.187"></status>
</kw>
<msg timestamp="20190401 13:09:17.187" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:09:17.187" starttime="20190401 13:09:16.112"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:09:17.188" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:17.188" starttime="20190401 13:09:17.187"></status>
</kw>
<msg timestamp="20190401 13:09:17.188" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:17.188" starttime="20190401 13:09:16.111"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:09:17.188" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:09:17.188" starttime="20190401 13:09:17.188"></status>
</kw>
<status status="FAIL" endtime="20190401 13:09:17.188" starttime="20190401 13:09:16.111"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:09:22.190" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:22.190" starttime="20190401 13:09:22.190"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:22.191" starttime="20190401 13:09:22.190"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:09:22.191" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:09:22.191" starttime="20190401 13:09:22.191"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:22.192" starttime="20190401 13:09:22.192"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:22.192" starttime="20190401 13:09:22.192"></status>
</kw>
<msg timestamp="20190401 13:09:22.192" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:09:22.192" starttime="20190401 13:09:22.191"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:09:22.193" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:22.193" starttime="20190401 13:09:22.193"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:09:22.202" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:22.202" starttime="20190401 13:09:22.193"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:09:23.240" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:09:23.241" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:23.241" starttime="20190401 13:09:22.202"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:09:23.241" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:23.241" starttime="20190401 13:09:23.241"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:09:23.242" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:23.242" starttime="20190401 13:09:23.242"></status>
</kw>
<msg timestamp="20190401 13:09:23.242" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:23.242" starttime="20190401 13:09:23.241"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:09:23.244" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:09:23.244" starttime="20190401 13:09:23.242"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:09:23.245" level="INFO">0</msg>
<msg timestamp="20190401 13:09:23.245" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:23.245" starttime="20190401 13:09:23.244"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:09:23.245" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:09:23.245" starttime="20190401 13:09:23.245"></status>
</kw>
<msg timestamp="20190401 13:09:23.245" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:23.245" starttime="20190401 13:09:23.242"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:23.246" starttime="20190401 13:09:23.246"></status>
</kw>
<status status="PASS" endtime="20190401 13:09:23.246" starttime="20190401 13:09:23.245"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:23.246" starttime="20190401 13:09:23.246"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:09:23.247" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:09:23.247" starttime="20190401 13:09:23.246"></status>
</kw>
<msg timestamp="20190401 13:09:23.247" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:09:23.247" starttime="20190401 13:09:22.190"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:09:23.247" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:23.247" starttime="20190401 13:09:23.247"></status>
</kw>
<msg timestamp="20190401 13:09:23.247" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:23.247" starttime="20190401 13:09:22.189"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:09:23.248" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:09:23.248" starttime="20190401 13:09:23.248"></status>
</kw>
<status status="FAIL" endtime="20190401 13:09:23.248" starttime="20190401 13:09:22.189"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:09:28.249" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:28.249" starttime="20190401 13:09:28.249"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:28.250" starttime="20190401 13:09:28.250"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:09:28.251" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:09:28.251" starttime="20190401 13:09:28.251"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:28.251" starttime="20190401 13:09:28.251"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:28.252" starttime="20190401 13:09:28.251"></status>
</kw>
<msg timestamp="20190401 13:09:28.252" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:09:28.252" starttime="20190401 13:09:28.250"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:09:28.252" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:28.252" starttime="20190401 13:09:28.252"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:09:28.254" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:28.254" starttime="20190401 13:09:28.252"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:09:29.321" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:09:29.321" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:29.321" starttime="20190401 13:09:28.254"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:09:29.322" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:29.322" starttime="20190401 13:09:29.321"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:09:29.322" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:29.322" starttime="20190401 13:09:29.322"></status>
</kw>
<msg timestamp="20190401 13:09:29.322" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:29.322" starttime="20190401 13:09:29.321"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:09:29.324" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:09:29.324" starttime="20190401 13:09:29.323"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:09:29.325" level="INFO">0</msg>
<msg timestamp="20190401 13:09:29.325" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:29.325" starttime="20190401 13:09:29.325"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:09:29.325" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:09:29.325" starttime="20190401 13:09:29.325"></status>
</kw>
<msg timestamp="20190401 13:09:29.325" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:29.325" starttime="20190401 13:09:29.322"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:29.326" starttime="20190401 13:09:29.326"></status>
</kw>
<status status="PASS" endtime="20190401 13:09:29.326" starttime="20190401 13:09:29.326"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:29.327" starttime="20190401 13:09:29.327"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:09:29.327" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:09:29.327" starttime="20190401 13:09:29.327"></status>
</kw>
<msg timestamp="20190401 13:09:29.327" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:09:29.327" starttime="20190401 13:09:28.250"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:09:29.328" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:29.328" starttime="20190401 13:09:29.327"></status>
</kw>
<msg timestamp="20190401 13:09:29.328" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:29.328" starttime="20190401 13:09:28.249"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:09:29.328" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:09:29.328" starttime="20190401 13:09:29.328"></status>
</kw>
<status status="FAIL" endtime="20190401 13:09:29.328" starttime="20190401 13:09:28.248"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:09:34.330" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:34.330" starttime="20190401 13:09:34.330"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:34.331" starttime="20190401 13:09:34.330"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:09:34.331" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:09:34.331" starttime="20190401 13:09:34.331"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:34.332" starttime="20190401 13:09:34.331"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:34.332" starttime="20190401 13:09:34.332"></status>
</kw>
<msg timestamp="20190401 13:09:34.332" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:09:34.332" starttime="20190401 13:09:34.331"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:09:34.333" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:34.333" starttime="20190401 13:09:34.332"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:09:34.346" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:34.346" starttime="20190401 13:09:34.333"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:09:35.391" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:09:35.391" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:35.391" starttime="20190401 13:09:34.347"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:09:35.392" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:35.392" starttime="20190401 13:09:35.392"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:09:35.393" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:35.393" starttime="20190401 13:09:35.392"></status>
</kw>
<msg timestamp="20190401 13:09:35.393" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:35.393" starttime="20190401 13:09:35.392"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:09:35.395" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:09:35.395" starttime="20190401 13:09:35.393"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:09:35.395" level="INFO">0</msg>
<msg timestamp="20190401 13:09:35.396" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:35.396" starttime="20190401 13:09:35.395"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:09:35.396" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:09:35.396" starttime="20190401 13:09:35.396"></status>
</kw>
<msg timestamp="20190401 13:09:35.396" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:35.396" starttime="20190401 13:09:35.393"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:35.397" starttime="20190401 13:09:35.397"></status>
</kw>
<status status="PASS" endtime="20190401 13:09:35.397" starttime="20190401 13:09:35.396"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:35.397" starttime="20190401 13:09:35.397"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:09:35.398" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:09:35.398" starttime="20190401 13:09:35.397"></status>
</kw>
<msg timestamp="20190401 13:09:35.398" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:09:35.398" starttime="20190401 13:09:34.330"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:09:35.398" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:35.398" starttime="20190401 13:09:35.398"></status>
</kw>
<msg timestamp="20190401 13:09:35.398" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:35.398" starttime="20190401 13:09:34.329"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:09:35.399" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:09:35.399" starttime="20190401 13:09:35.398"></status>
</kw>
<status status="FAIL" endtime="20190401 13:09:35.399" starttime="20190401 13:09:34.329"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:09:40.401" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:40.401" starttime="20190401 13:09:40.400"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:40.401" starttime="20190401 13:09:40.401"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:09:40.402" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:09:40.402" starttime="20190401 13:09:40.402"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:40.402" starttime="20190401 13:09:40.402"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:40.403" starttime="20190401 13:09:40.403"></status>
</kw>
<msg timestamp="20190401 13:09:40.403" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:09:40.403" starttime="20190401 13:09:40.401"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:09:40.403" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:40.403" starttime="20190401 13:09:40.403"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:09:40.418" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:40.418" starttime="20190401 13:09:40.404"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:09:41.477" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:09:41.477" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:41.478" starttime="20190401 13:09:40.418"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:09:41.478" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:41.478" starttime="20190401 13:09:41.478"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:09:41.479" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:41.479" starttime="20190401 13:09:41.478"></status>
</kw>
<msg timestamp="20190401 13:09:41.479" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:41.479" starttime="20190401 13:09:41.478"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:09:41.481" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:09:41.481" starttime="20190401 13:09:41.479"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:09:41.481" level="INFO">0</msg>
<msg timestamp="20190401 13:09:41.481" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:41.482" starttime="20190401 13:09:41.481"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:09:41.482" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:09:41.482" starttime="20190401 13:09:41.482"></status>
</kw>
<msg timestamp="20190401 13:09:41.482" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:41.482" starttime="20190401 13:09:41.479"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:41.483" starttime="20190401 13:09:41.483"></status>
</kw>
<status status="PASS" endtime="20190401 13:09:41.483" starttime="20190401 13:09:41.482"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:41.483" starttime="20190401 13:09:41.483"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:09:41.483" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:09:41.484" starttime="20190401 13:09:41.483"></status>
</kw>
<msg timestamp="20190401 13:09:41.484" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:09:41.484" starttime="20190401 13:09:40.401"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:09:41.484" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:41.484" starttime="20190401 13:09:41.484"></status>
</kw>
<msg timestamp="20190401 13:09:41.484" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:41.484" starttime="20190401 13:09:40.400"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:09:41.485" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:09:41.485" starttime="20190401 13:09:41.484"></status>
</kw>
<status status="FAIL" endtime="20190401 13:09:41.485" starttime="20190401 13:09:40.399"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:09:46.487" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:46.487" starttime="20190401 13:09:46.486"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:46.487" starttime="20190401 13:09:46.487"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:09:46.488" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:09:46.488" starttime="20190401 13:09:46.488"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:46.488" starttime="20190401 13:09:46.488"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:46.489" starttime="20190401 13:09:46.488"></status>
</kw>
<msg timestamp="20190401 13:09:46.489" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:09:46.489" starttime="20190401 13:09:46.487"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:09:46.489" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:46.489" starttime="20190401 13:09:46.489"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:09:46.501" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:46.501" starttime="20190401 13:09:46.489"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:09:47.552" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:09:47.552" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:47.552" starttime="20190401 13:09:46.501"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:09:47.553" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:47.553" starttime="20190401 13:09:47.552"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:09:47.553" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:47.553" starttime="20190401 13:09:47.553"></status>
</kw>
<msg timestamp="20190401 13:09:47.553" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:47.553" starttime="20190401 13:09:47.552"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:09:47.555" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:09:47.555" starttime="20190401 13:09:47.553"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:09:47.555" level="INFO">0</msg>
<msg timestamp="20190401 13:09:47.555" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:47.556" starttime="20190401 13:09:47.555"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:09:47.556" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:09:47.556" starttime="20190401 13:09:47.556"></status>
</kw>
<msg timestamp="20190401 13:09:47.556" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:47.556" starttime="20190401 13:09:47.553"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:47.557" starttime="20190401 13:09:47.557"></status>
</kw>
<status status="PASS" endtime="20190401 13:09:47.557" starttime="20190401 13:09:47.556"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:47.557" starttime="20190401 13:09:47.557"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:09:47.557" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:09:47.558" starttime="20190401 13:09:47.557"></status>
</kw>
<msg timestamp="20190401 13:09:47.558" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:09:47.558" starttime="20190401 13:09:46.487"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:09:47.558" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:47.558" starttime="20190401 13:09:47.558"></status>
</kw>
<msg timestamp="20190401 13:09:47.558" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:47.558" starttime="20190401 13:09:46.486"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:09:47.559" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:09:47.559" starttime="20190401 13:09:47.558"></status>
</kw>
<status status="FAIL" endtime="20190401 13:09:47.559" starttime="20190401 13:09:46.485"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:09:52.560" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:52.560" starttime="20190401 13:09:52.560"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:52.561" starttime="20190401 13:09:52.561"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:09:52.562" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:09:52.562" starttime="20190401 13:09:52.562"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:52.562" starttime="20190401 13:09:52.562"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:52.563" starttime="20190401 13:09:52.562"></status>
</kw>
<msg timestamp="20190401 13:09:52.563" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:09:52.563" starttime="20190401 13:09:52.561"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:09:52.563" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:52.563" starttime="20190401 13:09:52.563"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:09:52.572" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:52.572" starttime="20190401 13:09:52.563"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:09:53.649" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:09:53.649" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:53.649" starttime="20190401 13:09:52.572"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:09:53.650" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:53.650" starttime="20190401 13:09:53.650"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:09:53.651" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:53.651" starttime="20190401 13:09:53.650"></status>
</kw>
<msg timestamp="20190401 13:09:53.651" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:53.651" starttime="20190401 13:09:53.650"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:09:53.653" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:09:53.653" starttime="20190401 13:09:53.651"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:09:53.653" level="INFO">0</msg>
<msg timestamp="20190401 13:09:53.653" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:53.653" starttime="20190401 13:09:53.653"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:09:53.653" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:09:53.653" starttime="20190401 13:09:53.653"></status>
</kw>
<msg timestamp="20190401 13:09:53.654" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:53.654" starttime="20190401 13:09:53.651"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:53.654" starttime="20190401 13:09:53.654"></status>
</kw>
<status status="PASS" endtime="20190401 13:09:53.654" starttime="20190401 13:09:53.654"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:53.655" starttime="20190401 13:09:53.654"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:09:53.655" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:09:53.655" starttime="20190401 13:09:53.655"></status>
</kw>
<msg timestamp="20190401 13:09:53.655" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:09:53.655" starttime="20190401 13:09:52.560"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:09:53.655" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:53.656" starttime="20190401 13:09:53.655"></status>
</kw>
<msg timestamp="20190401 13:09:53.656" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:53.656" starttime="20190401 13:09:52.560"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:09:53.656" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:09:53.656" starttime="20190401 13:09:53.656"></status>
</kw>
<status status="FAIL" endtime="20190401 13:09:53.656" starttime="20190401 13:09:52.559"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:09:58.658" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:58.658" starttime="20190401 13:09:58.657"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:58.659" starttime="20190401 13:09:58.658"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:09:58.660" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:09:58.660" starttime="20190401 13:09:58.659"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:58.660" starttime="20190401 13:09:58.660"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:58.661" starttime="20190401 13:09:58.660"></status>
</kw>
<msg timestamp="20190401 13:09:58.661" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:09:58.661" starttime="20190401 13:09:58.659"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:09:58.661" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:58.661" starttime="20190401 13:09:58.661"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:09:58.671" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:09:58.671" starttime="20190401 13:09:58.661"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:09:59.690" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:09:59.690" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:59.690" starttime="20190401 13:09:58.671"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:09:59.691" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:09:59.691" starttime="20190401 13:09:59.691"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:09:59.691" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:59.691" starttime="20190401 13:09:59.691"></status>
</kw>
<msg timestamp="20190401 13:09:59.691" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:09:59.691" starttime="20190401 13:09:59.690"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:09:59.694" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:09:59.694" starttime="20190401 13:09:59.692"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:09:59.694" level="INFO">0</msg>
<msg timestamp="20190401 13:09:59.694" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:59.694" starttime="20190401 13:09:59.694"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:09:59.694" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:09:59.695" starttime="20190401 13:09:59.694"></status>
</kw>
<msg timestamp="20190401 13:09:59.695" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:09:59.695" starttime="20190401 13:09:59.691"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:59.695" starttime="20190401 13:09:59.695"></status>
</kw>
<status status="PASS" endtime="20190401 13:09:59.696" starttime="20190401 13:09:59.695"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:09:59.696" starttime="20190401 13:09:59.696"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:09:59.696" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:09:59.696" starttime="20190401 13:09:59.696"></status>
</kw>
<msg timestamp="20190401 13:09:59.696" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:09:59.696" starttime="20190401 13:09:58.658"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:09:59.697" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:59.697" starttime="20190401 13:09:59.696"></status>
</kw>
<msg timestamp="20190401 13:09:59.697" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:09:59.697" starttime="20190401 13:09:58.657"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:09:59.697" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:09:59.697" starttime="20190401 13:09:59.697"></status>
</kw>
<status status="FAIL" endtime="20190401 13:09:59.698" starttime="20190401 13:09:58.657"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:10:04.699" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:04.699" starttime="20190401 13:10:04.699"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:04.700" starttime="20190401 13:10:04.699"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:10:04.701" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:10:04.701" starttime="20190401 13:10:04.700"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:04.701" starttime="20190401 13:10:04.701"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:04.701" starttime="20190401 13:10:04.701"></status>
</kw>
<msg timestamp="20190401 13:10:04.702" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:10:04.702" starttime="20190401 13:10:04.700"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:10:04.702" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:04.702" starttime="20190401 13:10:04.702"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:10:04.712" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:04.712" starttime="20190401 13:10:04.702"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:10:05.816" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:10:05.816" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:05.816" starttime="20190401 13:10:04.712"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:10:05.817" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:05.817" starttime="20190401 13:10:05.817"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:10:05.817" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:05.817" starttime="20190401 13:10:05.817"></status>
</kw>
<msg timestamp="20190401 13:10:05.817" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:05.817" starttime="20190401 13:10:05.816"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:10:05.820" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:10:05.820" starttime="20190401 13:10:05.818"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:10:05.820" level="INFO">0</msg>
<msg timestamp="20190401 13:10:05.820" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:05.820" starttime="20190401 13:10:05.820"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:10:05.821" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:10:05.821" starttime="20190401 13:10:05.820"></status>
</kw>
<msg timestamp="20190401 13:10:05.821" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:05.821" starttime="20190401 13:10:05.818"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:05.822" starttime="20190401 13:10:05.821"></status>
</kw>
<status status="PASS" endtime="20190401 13:10:05.822" starttime="20190401 13:10:05.821"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:05.822" starttime="20190401 13:10:05.822"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:10:05.822" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:10:05.822" starttime="20190401 13:10:05.822"></status>
</kw>
<msg timestamp="20190401 13:10:05.822" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:10:05.822" starttime="20190401 13:10:04.699"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:10:05.823" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:05.823" starttime="20190401 13:10:05.823"></status>
</kw>
<msg timestamp="20190401 13:10:05.823" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:05.823" starttime="20190401 13:10:04.698"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:10:05.823" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:10:05.823" starttime="20190401 13:10:05.823"></status>
</kw>
<status status="FAIL" endtime="20190401 13:10:05.824" starttime="20190401 13:10:04.698"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:10:10.825" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:10.825" starttime="20190401 13:10:10.825"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:10.826" starttime="20190401 13:10:10.825"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:10:10.826" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:10:10.826" starttime="20190401 13:10:10.826"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:10.827" starttime="20190401 13:10:10.827"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:10.827" starttime="20190401 13:10:10.827"></status>
</kw>
<msg timestamp="20190401 13:10:10.828" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:10:10.828" starttime="20190401 13:10:10.826"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:10:10.828" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:10.828" starttime="20190401 13:10:10.828"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:10:10.839" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:10.839" starttime="20190401 13:10:10.828"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:10:11.943" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:10:11.943" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:11.943" starttime="20190401 13:10:10.839"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:10:11.944" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:11.944" starttime="20190401 13:10:11.943"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:10:11.944" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:11.944" starttime="20190401 13:10:11.944"></status>
</kw>
<msg timestamp="20190401 13:10:11.944" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:11.944" starttime="20190401 13:10:11.943"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:10:11.946" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:10:11.946" starttime="20190401 13:10:11.945"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:10:11.946" level="INFO">0</msg>
<msg timestamp="20190401 13:10:11.946" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:11.946" starttime="20190401 13:10:11.946"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:10:11.947" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:10:11.947" starttime="20190401 13:10:11.947"></status>
</kw>
<msg timestamp="20190401 13:10:11.947" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:11.947" starttime="20190401 13:10:11.944"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:11.948" starttime="20190401 13:10:11.947"></status>
</kw>
<status status="PASS" endtime="20190401 13:10:11.948" starttime="20190401 13:10:11.947"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:11.948" starttime="20190401 13:10:11.948"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:10:11.948" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:10:11.948" starttime="20190401 13:10:11.948"></status>
</kw>
<msg timestamp="20190401 13:10:11.949" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:10:11.949" starttime="20190401 13:10:10.825"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:10:11.949" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:11.949" starttime="20190401 13:10:11.949"></status>
</kw>
<msg timestamp="20190401 13:10:11.949" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:11.949" starttime="20190401 13:10:10.824"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:10:11.950" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:10:11.950" starttime="20190401 13:10:11.949"></status>
</kw>
<status status="FAIL" endtime="20190401 13:10:11.950" starttime="20190401 13:10:10.824"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:10:16.951" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:16.951" starttime="20190401 13:10:16.951"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:16.952" starttime="20190401 13:10:16.952"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:10:16.953" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:10:16.953" starttime="20190401 13:10:16.952"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:16.953" starttime="20190401 13:10:16.953"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:16.953" starttime="20190401 13:10:16.953"></status>
</kw>
<msg timestamp="20190401 13:10:16.954" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:10:16.954" starttime="20190401 13:10:16.952"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:10:16.954" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:16.954" starttime="20190401 13:10:16.954"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:10:16.964" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:16.965" starttime="20190401 13:10:16.954"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:10:18.060" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:10:18.060" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:18.060" starttime="20190401 13:10:16.965"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:10:18.061" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:18.061" starttime="20190401 13:10:18.060"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:10:18.061" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:18.061" starttime="20190401 13:10:18.061"></status>
</kw>
<msg timestamp="20190401 13:10:18.061" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:18.061" starttime="20190401 13:10:18.060"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:10:18.063" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:10:18.063" starttime="20190401 13:10:18.062"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:10:18.063" level="INFO">0</msg>
<msg timestamp="20190401 13:10:18.063" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:18.063" starttime="20190401 13:10:18.063"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:10:18.064" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:10:18.064" starttime="20190401 13:10:18.064"></status>
</kw>
<msg timestamp="20190401 13:10:18.064" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:18.064" starttime="20190401 13:10:18.061"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:18.065" starttime="20190401 13:10:18.065"></status>
</kw>
<status status="PASS" endtime="20190401 13:10:18.065" starttime="20190401 13:10:18.064"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:18.065" starttime="20190401 13:10:18.065"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:10:18.065" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:10:18.066" starttime="20190401 13:10:18.065"></status>
</kw>
<msg timestamp="20190401 13:10:18.066" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:10:18.066" starttime="20190401 13:10:16.951"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:10:18.066" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:18.066" starttime="20190401 13:10:18.066"></status>
</kw>
<msg timestamp="20190401 13:10:18.066" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:18.066" starttime="20190401 13:10:16.950"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:10:18.067" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:10:18.067" starttime="20190401 13:10:18.066"></status>
</kw>
<status status="FAIL" endtime="20190401 13:10:18.067" starttime="20190401 13:10:16.950"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:10:23.068" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:23.068" starttime="20190401 13:10:23.068"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:23.069" starttime="20190401 13:10:23.069"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:10:23.070" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:10:23.070" starttime="20190401 13:10:23.069"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:23.070" starttime="20190401 13:10:23.070"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:23.070" starttime="20190401 13:10:23.070"></status>
</kw>
<msg timestamp="20190401 13:10:23.071" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:10:23.071" starttime="20190401 13:10:23.069"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:10:23.071" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:23.071" starttime="20190401 13:10:23.071"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:10:23.080" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:23.080" starttime="20190401 13:10:23.071"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:10:24.128" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:10:24.128" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:24.129" starttime="20190401 13:10:23.081"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:10:24.130" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:24.130" starttime="20190401 13:10:24.129"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:10:24.130" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:24.130" starttime="20190401 13:10:24.130"></status>
</kw>
<msg timestamp="20190401 13:10:24.130" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:24.130" starttime="20190401 13:10:24.129"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:10:24.132" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:10:24.132" starttime="20190401 13:10:24.130"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:10:24.133" level="INFO">0</msg>
<msg timestamp="20190401 13:10:24.133" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:24.133" starttime="20190401 13:10:24.132"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:10:24.133" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:10:24.133" starttime="20190401 13:10:24.133"></status>
</kw>
<msg timestamp="20190401 13:10:24.133" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:24.133" starttime="20190401 13:10:24.130"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:24.134" starttime="20190401 13:10:24.134"></status>
</kw>
<status status="PASS" endtime="20190401 13:10:24.134" starttime="20190401 13:10:24.133"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:24.134" starttime="20190401 13:10:24.134"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:10:24.135" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:10:24.135" starttime="20190401 13:10:24.134"></status>
</kw>
<msg timestamp="20190401 13:10:24.135" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:10:24.135" starttime="20190401 13:10:23.068"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:10:24.135" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:24.135" starttime="20190401 13:10:24.135"></status>
</kw>
<msg timestamp="20190401 13:10:24.135" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:24.135" starttime="20190401 13:10:23.068"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:10:24.136" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:10:24.136" starttime="20190401 13:10:24.136"></status>
</kw>
<status status="FAIL" endtime="20190401 13:10:24.136" starttime="20190401 13:10:23.067"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:10:29.137" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:29.137" starttime="20190401 13:10:29.137"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:29.138" starttime="20190401 13:10:29.138"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:10:29.139" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:10:29.139" starttime="20190401 13:10:29.138"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:29.139" starttime="20190401 13:10:29.139"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:29.140" starttime="20190401 13:10:29.139"></status>
</kw>
<msg timestamp="20190401 13:10:29.140" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:10:29.140" starttime="20190401 13:10:29.138"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:10:29.140" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:29.140" starttime="20190401 13:10:29.140"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:10:29.150" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:29.150" starttime="20190401 13:10:29.140"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:10:30.264" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:10:30.264" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:30.264" starttime="20190401 13:10:29.150"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:10:30.265" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:30.265" starttime="20190401 13:10:30.265"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:10:30.265" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:30.265" starttime="20190401 13:10:30.265"></status>
</kw>
<msg timestamp="20190401 13:10:30.266" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:30.266" starttime="20190401 13:10:30.264"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:10:30.268" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:10:30.268" starttime="20190401 13:10:30.266"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:10:30.268" level="INFO">0</msg>
<msg timestamp="20190401 13:10:30.268" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:30.268" starttime="20190401 13:10:30.268"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:10:30.269" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:10:30.269" starttime="20190401 13:10:30.268"></status>
</kw>
<msg timestamp="20190401 13:10:30.269" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:30.269" starttime="20190401 13:10:30.266"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:30.270" starttime="20190401 13:10:30.269"></status>
</kw>
<status status="PASS" endtime="20190401 13:10:30.270" starttime="20190401 13:10:30.269"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:30.270" starttime="20190401 13:10:30.270"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:10:30.270" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:10:30.270" starttime="20190401 13:10:30.270"></status>
</kw>
<msg timestamp="20190401 13:10:30.270" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:10:30.270" starttime="20190401 13:10:29.138"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:10:30.271" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:30.271" starttime="20190401 13:10:30.271"></status>
</kw>
<msg timestamp="20190401 13:10:30.271" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:30.271" starttime="20190401 13:10:29.137"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:10:30.271" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:10:30.272" starttime="20190401 13:10:30.271"></status>
</kw>
<status status="FAIL" endtime="20190401 13:10:30.272" starttime="20190401 13:10:29.136"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:10:35.273" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:35.273" starttime="20190401 13:10:35.273"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:35.274" starttime="20190401 13:10:35.274"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:10:35.275" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:10:35.275" starttime="20190401 13:10:35.274"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:35.275" starttime="20190401 13:10:35.275"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:35.275" starttime="20190401 13:10:35.275"></status>
</kw>
<msg timestamp="20190401 13:10:35.276" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:10:35.276" starttime="20190401 13:10:35.274"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:10:35.276" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:35.276" starttime="20190401 13:10:35.276"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:10:35.286" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:35.286" starttime="20190401 13:10:35.276"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:10:36.357" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:10:36.357" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:36.357" starttime="20190401 13:10:35.286"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:10:36.358" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:36.358" starttime="20190401 13:10:36.357"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:10:36.358" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:36.358" starttime="20190401 13:10:36.358"></status>
</kw>
<msg timestamp="20190401 13:10:36.358" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:36.358" starttime="20190401 13:10:36.357"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:10:36.360" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:10:36.360" starttime="20190401 13:10:36.359"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:10:36.361" level="INFO">0</msg>
<msg timestamp="20190401 13:10:36.361" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:36.361" starttime="20190401 13:10:36.360"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:10:36.361" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:10:36.361" starttime="20190401 13:10:36.361"></status>
</kw>
<msg timestamp="20190401 13:10:36.361" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:36.361" starttime="20190401 13:10:36.358"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:36.362" starttime="20190401 13:10:36.362"></status>
</kw>
<status status="PASS" endtime="20190401 13:10:36.363" starttime="20190401 13:10:36.362"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:36.363" starttime="20190401 13:10:36.363"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:10:36.363" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:10:36.363" starttime="20190401 13:10:36.363"></status>
</kw>
<msg timestamp="20190401 13:10:36.363" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:10:36.363" starttime="20190401 13:10:35.273"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:10:36.364" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:36.364" starttime="20190401 13:10:36.363"></status>
</kw>
<msg timestamp="20190401 13:10:36.364" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:36.364" starttime="20190401 13:10:35.272"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:10:36.364" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:10:36.364" starttime="20190401 13:10:36.364"></status>
</kw>
<status status="FAIL" endtime="20190401 13:10:36.364" starttime="20190401 13:10:35.272"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:10:41.366" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:41.366" starttime="20190401 13:10:41.366"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:41.367" starttime="20190401 13:10:41.366"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:10:41.367" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:10:41.367" starttime="20190401 13:10:41.367"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:41.368" starttime="20190401 13:10:41.368"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:41.368" starttime="20190401 13:10:41.368"></status>
</kw>
<msg timestamp="20190401 13:10:41.368" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:10:41.368" starttime="20190401 13:10:41.367"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:10:41.369" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:41.369" starttime="20190401 13:10:41.369"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:10:41.382" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:41.382" starttime="20190401 13:10:41.369"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:10:42.405" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:10:42.405" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:42.405" starttime="20190401 13:10:41.382"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:10:42.406" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:42.406" starttime="20190401 13:10:42.406"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:10:42.406" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:42.407" starttime="20190401 13:10:42.406"></status>
</kw>
<msg timestamp="20190401 13:10:42.407" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:42.407" starttime="20190401 13:10:42.406"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:10:42.409" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:10:42.409" starttime="20190401 13:10:42.407"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:10:42.409" level="INFO">0</msg>
<msg timestamp="20190401 13:10:42.409" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:42.409" starttime="20190401 13:10:42.409"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:10:42.410" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:10:42.410" starttime="20190401 13:10:42.409"></status>
</kw>
<msg timestamp="20190401 13:10:42.410" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:42.410" starttime="20190401 13:10:42.407"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:42.411" starttime="20190401 13:10:42.410"></status>
</kw>
<status status="PASS" endtime="20190401 13:10:42.411" starttime="20190401 13:10:42.410"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:42.411" starttime="20190401 13:10:42.411"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:10:42.411" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:10:42.411" starttime="20190401 13:10:42.411"></status>
</kw>
<msg timestamp="20190401 13:10:42.411" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:10:42.411" starttime="20190401 13:10:41.366"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:10:42.412" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:42.412" starttime="20190401 13:10:42.412"></status>
</kw>
<msg timestamp="20190401 13:10:42.412" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:42.412" starttime="20190401 13:10:41.365"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:10:42.413" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:10:42.413" starttime="20190401 13:10:42.412"></status>
</kw>
<status status="FAIL" endtime="20190401 13:10:42.413" starttime="20190401 13:10:41.365"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:10:47.414" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:47.414" starttime="20190401 13:10:47.414"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:47.415" starttime="20190401 13:10:47.415"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:10:47.416" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:10:47.416" starttime="20190401 13:10:47.415"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:47.416" starttime="20190401 13:10:47.416"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:47.416" starttime="20190401 13:10:47.416"></status>
</kw>
<msg timestamp="20190401 13:10:47.417" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:10:47.417" starttime="20190401 13:10:47.415"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:10:47.417" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:47.417" starttime="20190401 13:10:47.417"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:10:47.427" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:47.427" starttime="20190401 13:10:47.417"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:10:48.513" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:10:48.513" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:48.513" starttime="20190401 13:10:47.427"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:10:48.514" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:48.514" starttime="20190401 13:10:48.514"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:10:48.515" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:48.515" starttime="20190401 13:10:48.514"></status>
</kw>
<msg timestamp="20190401 13:10:48.515" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:48.515" starttime="20190401 13:10:48.514"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:10:48.516" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:10:48.516" starttime="20190401 13:10:48.515"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:10:48.517" level="INFO">0</msg>
<msg timestamp="20190401 13:10:48.517" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:48.517" starttime="20190401 13:10:48.517"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:10:48.517" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:10:48.517" starttime="20190401 13:10:48.517"></status>
</kw>
<msg timestamp="20190401 13:10:48.517" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:48.517" starttime="20190401 13:10:48.515"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:48.518" starttime="20190401 13:10:48.518"></status>
</kw>
<status status="PASS" endtime="20190401 13:10:48.518" starttime="20190401 13:10:48.518"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:48.519" starttime="20190401 13:10:48.518"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:10:48.519" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:10:48.519" starttime="20190401 13:10:48.519"></status>
</kw>
<msg timestamp="20190401 13:10:48.519" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:10:48.519" starttime="20190401 13:10:47.414"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:10:48.519" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:48.519" starttime="20190401 13:10:48.519"></status>
</kw>
<msg timestamp="20190401 13:10:48.520" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:48.520" starttime="20190401 13:10:47.414"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:10:48.520" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:10:48.520" starttime="20190401 13:10:48.520"></status>
</kw>
<status status="FAIL" endtime="20190401 13:10:48.520" starttime="20190401 13:10:47.413"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:10:53.522" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:53.522" starttime="20190401 13:10:53.522"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:53.523" starttime="20190401 13:10:53.522"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:10:53.523" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:10:53.523" starttime="20190401 13:10:53.523"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:53.524" starttime="20190401 13:10:53.524"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:53.524" starttime="20190401 13:10:53.524"></status>
</kw>
<msg timestamp="20190401 13:10:53.524" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:10:53.524" starttime="20190401 13:10:53.523"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:10:53.525" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:53.525" starttime="20190401 13:10:53.525"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:10:53.535" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:53.535" starttime="20190401 13:10:53.525"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:10:54.568" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:10:54.569" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:54.569" starttime="20190401 13:10:53.536"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:10:54.569" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:54.569" starttime="20190401 13:10:54.569"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:10:54.570" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:54.570" starttime="20190401 13:10:54.570"></status>
</kw>
<msg timestamp="20190401 13:10:54.570" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:10:54.570" starttime="20190401 13:10:54.569"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:10:54.571" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:10:54.571" starttime="20190401 13:10:54.570"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:10:54.572" level="INFO">0</msg>
<msg timestamp="20190401 13:10:54.572" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:54.572" starttime="20190401 13:10:54.571"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:10:54.572" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:10:54.572" starttime="20190401 13:10:54.572"></status>
</kw>
<msg timestamp="20190401 13:10:54.573" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:10:54.573" starttime="20190401 13:10:54.570"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:54.573" starttime="20190401 13:10:54.573"></status>
</kw>
<status status="PASS" endtime="20190401 13:10:54.573" starttime="20190401 13:10:54.573"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:54.574" starttime="20190401 13:10:54.573"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:10:54.574" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:10:54.574" starttime="20190401 13:10:54.574"></status>
</kw>
<msg timestamp="20190401 13:10:54.574" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:10:54.574" starttime="20190401 13:10:53.522"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:10:54.575" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:54.575" starttime="20190401 13:10:54.574"></status>
</kw>
<msg timestamp="20190401 13:10:54.575" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:10:54.575" starttime="20190401 13:10:53.521"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:10:54.575" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:10:54.575" starttime="20190401 13:10:54.575"></status>
</kw>
<status status="FAIL" endtime="20190401 13:10:54.575" starttime="20190401 13:10:53.521"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:10:59.577" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:59.577" starttime="20190401 13:10:59.577"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:59.578" starttime="20190401 13:10:59.578"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:10:59.579" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:10:59.579" starttime="20190401 13:10:59.578"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:59.579" starttime="20190401 13:10:59.579"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:10:59.579" starttime="20190401 13:10:59.579"></status>
</kw>
<msg timestamp="20190401 13:10:59.580" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:10:59.580" starttime="20190401 13:10:59.578"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:10:59.580" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:10:59.580" starttime="20190401 13:10:59.580"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:10:59.590" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:10:59.590" starttime="20190401 13:10:59.580"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:00.629" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:00.629" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:00.629" starttime="20190401 13:10:59.590"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:00.630" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:00.630" starttime="20190401 13:11:00.630"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:00.630" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:00.630" starttime="20190401 13:11:00.630"></status>
</kw>
<msg timestamp="20190401 13:11:00.630" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:00.630" starttime="20190401 13:11:00.629"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:00.632" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:00.632" starttime="20190401 13:11:00.631"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:00.633" level="INFO">0</msg>
<msg timestamp="20190401 13:11:00.633" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:00.633" starttime="20190401 13:11:00.632"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:00.633" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:00.633" starttime="20190401 13:11:00.633"></status>
</kw>
<msg timestamp="20190401 13:11:00.633" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:00.633" starttime="20190401 13:11:00.630"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:00.634" starttime="20190401 13:11:00.634"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:00.634" starttime="20190401 13:11:00.633"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:00.634" starttime="20190401 13:11:00.634"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:00.635" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:11:00.635" starttime="20190401 13:11:00.635"></status>
</kw>
<msg timestamp="20190401 13:11:00.635" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:11:00.635" starttime="20190401 13:10:59.577"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:11:00.635" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:00.635" starttime="20190401 13:11:00.635"></status>
</kw>
<msg timestamp="20190401 13:11:00.636" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:00.636" starttime="20190401 13:10:59.576"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:11:00.636" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:11:00.636" starttime="20190401 13:11:00.636"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:00.636" starttime="20190401 13:10:59.576"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:05.638" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:05.638" starttime="20190401 13:11:05.638"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:05.639" starttime="20190401 13:11:05.639"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:05.641" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:05.641" starttime="20190401 13:11:05.640"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:05.641" starttime="20190401 13:11:05.641"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:05.641" starttime="20190401 13:11:05.641"></status>
</kw>
<msg timestamp="20190401 13:11:05.642" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:05.642" starttime="20190401 13:11:05.640"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:05.642" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:05.642" starttime="20190401 13:11:05.642"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:05.651" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:05.651" starttime="20190401 13:11:05.642"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:06.703" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:06.703" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:06.703" starttime="20190401 13:11:05.651"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:06.704" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:06.704" starttime="20190401 13:11:06.704"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:06.705" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:06.705" starttime="20190401 13:11:06.704"></status>
</kw>
<msg timestamp="20190401 13:11:06.705" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:06.705" starttime="20190401 13:11:06.704"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:06.707" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:06.707" starttime="20190401 13:11:06.705"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:06.707" level="INFO">0</msg>
<msg timestamp="20190401 13:11:06.707" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:06.707" starttime="20190401 13:11:06.707"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:06.708" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:06.708" starttime="20190401 13:11:06.707"></status>
</kw>
<msg timestamp="20190401 13:11:06.708" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:06.708" starttime="20190401 13:11:06.705"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:06.708" starttime="20190401 13:11:06.708"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:06.709" starttime="20190401 13:11:06.708"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:06.709" starttime="20190401 13:11:06.709"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:06.709" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:11:06.709" starttime="20190401 13:11:06.709"></status>
</kw>
<msg timestamp="20190401 13:11:06.709" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:11:06.709" starttime="20190401 13:11:05.638"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:11:06.710" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:06.710" starttime="20190401 13:11:06.709"></status>
</kw>
<msg timestamp="20190401 13:11:06.710" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:06.710" starttime="20190401 13:11:05.637"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:11:06.710" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:11:06.710" starttime="20190401 13:11:06.710"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:06.711" starttime="20190401 13:11:05.637"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:11.712" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:11.712" starttime="20190401 13:11:11.712"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:11.713" starttime="20190401 13:11:11.712"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:11.714" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:11.714" starttime="20190401 13:11:11.713"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:11.714" starttime="20190401 13:11:11.714"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:11.715" starttime="20190401 13:11:11.714"></status>
</kw>
<msg timestamp="20190401 13:11:11.715" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:11.715" starttime="20190401 13:11:11.713"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:11.715" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:11.715" starttime="20190401 13:11:11.715"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:11.725" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:11.725" starttime="20190401 13:11:11.715"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:12.793" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:12.793" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:12.793" starttime="20190401 13:11:11.725"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:12.794" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:12.794" starttime="20190401 13:11:12.794"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:12.795" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:12.795" starttime="20190401 13:11:12.794"></status>
</kw>
<msg timestamp="20190401 13:11:12.795" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:12.795" starttime="20190401 13:11:12.794"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:12.797" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:12.797" starttime="20190401 13:11:12.795"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:12.797" level="INFO">0</msg>
<msg timestamp="20190401 13:11:12.797" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:12.797" starttime="20190401 13:11:12.797"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:12.798" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:12.798" starttime="20190401 13:11:12.797"></status>
</kw>
<msg timestamp="20190401 13:11:12.798" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:12.798" starttime="20190401 13:11:12.795"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:12.799" starttime="20190401 13:11:12.798"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:12.799" starttime="20190401 13:11:12.798"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:12.799" starttime="20190401 13:11:12.799"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:12.799" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:11:12.799" starttime="20190401 13:11:12.799"></status>
</kw>
<msg timestamp="20190401 13:11:12.799" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:11:12.799" starttime="20190401 13:11:11.712"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:11:12.800" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:12.800" starttime="20190401 13:11:12.799"></status>
</kw>
<msg timestamp="20190401 13:11:12.800" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:12.800" starttime="20190401 13:11:11.711"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:11:12.800" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:11:12.800" starttime="20190401 13:11:12.800"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:12.801" starttime="20190401 13:11:11.711"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:17.803" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:17.803" starttime="20190401 13:11:17.802"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:17.804" starttime="20190401 13:11:17.803"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:17.805" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:17.805" starttime="20190401 13:11:17.805"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:17.806" starttime="20190401 13:11:17.805"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:17.807" starttime="20190401 13:11:17.806"></status>
</kw>
<msg timestamp="20190401 13:11:17.808" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:17.808" starttime="20190401 13:11:17.804"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:17.808" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:17.808" starttime="20190401 13:11:17.808"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:17.826" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:17.827" starttime="20190401 13:11:17.808"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:18.912" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:18.912" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:18.912" starttime="20190401 13:11:17.827"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:18.913" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:18.913" starttime="20190401 13:11:18.913"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:18.913" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:18.913" starttime="20190401 13:11:18.913"></status>
</kw>
<msg timestamp="20190401 13:11:18.913" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:18.913" starttime="20190401 13:11:18.912"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:18.915" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:18.915" starttime="20190401 13:11:18.914"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:18.915" level="INFO">0</msg>
<msg timestamp="20190401 13:11:18.915" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:18.915" starttime="20190401 13:11:18.915"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:18.916" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:18.916" starttime="20190401 13:11:18.916"></status>
</kw>
<msg timestamp="20190401 13:11:18.916" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:18.916" starttime="20190401 13:11:18.913"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:18.917" starttime="20190401 13:11:18.916"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:18.917" starttime="20190401 13:11:18.916"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:18.917" starttime="20190401 13:11:18.917"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:18.917" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:11:18.917" starttime="20190401 13:11:18.917"></status>
</kw>
<msg timestamp="20190401 13:11:18.918" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:11:18.918" starttime="20190401 13:11:17.803"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:11:18.918" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:18.918" starttime="20190401 13:11:18.918"></status>
</kw>
<msg timestamp="20190401 13:11:18.918" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:18.918" starttime="20190401 13:11:17.802"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:11:18.919" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:11:18.919" starttime="20190401 13:11:18.918"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:18.919" starttime="20190401 13:11:17.801"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:23.920" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:23.920" starttime="20190401 13:11:23.920"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:23.921" starttime="20190401 13:11:23.921"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:23.922" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:23.922" starttime="20190401 13:11:23.921"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:23.922" starttime="20190401 13:11:23.922"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:23.922" starttime="20190401 13:11:23.922"></status>
</kw>
<msg timestamp="20190401 13:11:23.923" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:23.923" starttime="20190401 13:11:23.921"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:23.923" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:23.923" starttime="20190401 13:11:23.923"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:23.934" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:23.934" starttime="20190401 13:11:23.923"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:25.193" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:25.194" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:25.194" starttime="20190401 13:11:23.934"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:25.194" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:25.195" starttime="20190401 13:11:25.194"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:25.195" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:25.195" starttime="20190401 13:11:25.195"></status>
</kw>
<msg timestamp="20190401 13:11:25.195" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:25.195" starttime="20190401 13:11:25.194"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:25.197" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:25.197" starttime="20190401 13:11:25.195"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:25.198" level="INFO">0</msg>
<msg timestamp="20190401 13:11:25.198" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:25.198" starttime="20190401 13:11:25.197"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:25.198" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:25.198" starttime="20190401 13:11:25.198"></status>
</kw>
<msg timestamp="20190401 13:11:25.198" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:25.198" starttime="20190401 13:11:25.195"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:25.199" starttime="20190401 13:11:25.199"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:25.199" starttime="20190401 13:11:25.198"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:25.199" starttime="20190401 13:11:25.199"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:25.199" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:11:25.200" starttime="20190401 13:11:25.199"></status>
</kw>
<msg timestamp="20190401 13:11:25.200" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:11:25.200" starttime="20190401 13:11:23.920"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:11:25.200" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:25.200" starttime="20190401 13:11:25.200"></status>
</kw>
<msg timestamp="20190401 13:11:25.200" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:25.200" starttime="20190401 13:11:23.920"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:11:25.201" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:11:25.201" starttime="20190401 13:11:25.200"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:25.201" starttime="20190401 13:11:23.919"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:30.202" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:30.202" starttime="20190401 13:11:30.202"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:30.203" starttime="20190401 13:11:30.203"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:30.204" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:30.204" starttime="20190401 13:11:30.203"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:30.204" starttime="20190401 13:11:30.204"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:30.204" starttime="20190401 13:11:30.204"></status>
</kw>
<msg timestamp="20190401 13:11:30.205" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:30.205" starttime="20190401 13:11:30.203"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:30.205" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:30.205" starttime="20190401 13:11:30.205"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:30.214" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:30.214" starttime="20190401 13:11:30.205"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:31.349" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:31.349" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:31.349" starttime="20190401 13:11:30.214"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:31.350" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:31.350" starttime="20190401 13:11:31.350"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:31.351" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:31.351" starttime="20190401 13:11:31.351"></status>
</kw>
<msg timestamp="20190401 13:11:31.351" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:31.351" starttime="20190401 13:11:31.350"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:31.353" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:31.353" starttime="20190401 13:11:31.351"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:31.353" level="INFO">0</msg>
<msg timestamp="20190401 13:11:31.353" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:31.353" starttime="20190401 13:11:31.353"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:31.354" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:31.354" starttime="20190401 13:11:31.354"></status>
</kw>
<msg timestamp="20190401 13:11:31.354" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:31.354" starttime="20190401 13:11:31.351"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:31.355" starttime="20190401 13:11:31.354"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:31.355" starttime="20190401 13:11:31.354"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:31.355" starttime="20190401 13:11:31.355"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:31.355" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:11:31.355" starttime="20190401 13:11:31.355"></status>
</kw>
<msg timestamp="20190401 13:11:31.355" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:11:31.355" starttime="20190401 13:11:30.202"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:11:31.356" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:31.356" starttime="20190401 13:11:31.356"></status>
</kw>
<msg timestamp="20190401 13:11:31.356" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:31.356" starttime="20190401 13:11:30.202"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:11:31.356" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:11:31.357" starttime="20190401 13:11:31.356"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:31.357" starttime="20190401 13:11:30.201"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:36.358" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:36.358" starttime="20190401 13:11:36.358"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:36.359" starttime="20190401 13:11:36.359"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:36.359" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:36.359" starttime="20190401 13:11:36.359"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:36.360" starttime="20190401 13:11:36.360"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:36.360" starttime="20190401 13:11:36.360"></status>
</kw>
<msg timestamp="20190401 13:11:36.360" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:36.360" starttime="20190401 13:11:36.359"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:36.361" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:36.361" starttime="20190401 13:11:36.361"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:36.377" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:36.377" starttime="20190401 13:11:36.361"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:37.383" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:37.383" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:37.383" starttime="20190401 13:11:36.377"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:37.384" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:37.384" starttime="20190401 13:11:37.384"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:37.384" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:37.384" starttime="20190401 13:11:37.384"></status>
</kw>
<msg timestamp="20190401 13:11:37.384" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:37.384" starttime="20190401 13:11:37.383"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:37.387" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:37.387" starttime="20190401 13:11:37.385"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:37.388" level="INFO">0</msg>
<msg timestamp="20190401 13:11:37.388" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:37.388" starttime="20190401 13:11:37.387"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:37.388" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:37.388" starttime="20190401 13:11:37.388"></status>
</kw>
<msg timestamp="20190401 13:11:37.388" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:37.388" starttime="20190401 13:11:37.385"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:37.389" starttime="20190401 13:11:37.389"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:37.389" starttime="20190401 13:11:37.389"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:37.390" starttime="20190401 13:11:37.389"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:37.390" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:11:37.390" starttime="20190401 13:11:37.390"></status>
</kw>
<msg timestamp="20190401 13:11:37.390" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:11:37.390" starttime="20190401 13:11:36.358"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:11:37.390" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:37.390" starttime="20190401 13:11:37.390"></status>
</kw>
<msg timestamp="20190401 13:11:37.391" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:37.391" starttime="20190401 13:11:36.357"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:11:37.391" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:11:37.391" starttime="20190401 13:11:37.391"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:37.391" starttime="20190401 13:11:36.357"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:42.392" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:42.393" starttime="20190401 13:11:42.392"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:42.393" starttime="20190401 13:11:42.393"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:42.394" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:42.394" starttime="20190401 13:11:42.394"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:42.394" starttime="20190401 13:11:42.394"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:42.395" starttime="20190401 13:11:42.394"></status>
</kw>
<msg timestamp="20190401 13:11:42.395" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:42.395" starttime="20190401 13:11:42.393"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:42.395" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:42.395" starttime="20190401 13:11:42.395"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:42.410" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:42.410" starttime="20190401 13:11:42.395"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:43.397" level="INFO">degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:43.398" level="INFO">${output} = degraded
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:43.398" starttime="20190401 13:11:42.410"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:43.398" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:43.398" starttime="20190401 13:11:43.398"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:43.399" level="INFO">${clean_out} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:43.399" starttime="20190401 13:11:43.398"></status>
</kw>
<msg timestamp="20190401 13:11:43.399" level="INFO">${output} = degraded
</msg>
<status status="PASS" endtime="20190401 13:11:43.399" starttime="20190401 13:11:43.398"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:43.401" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:43.401" starttime="20190401 13:11:43.399"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:43.402" level="INFO">0</msg>
<msg timestamp="20190401 13:11:43.402" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:43.402" starttime="20190401 13:11:43.401"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:43.402" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:43.402" starttime="20190401 13:11:43.402"></status>
</kw>
<msg timestamp="20190401 13:11:43.402" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:43.402" starttime="20190401 13:11:43.399"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:43.403" starttime="20190401 13:11:43.403"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:43.403" starttime="20190401 13:11:43.402"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:43.403" starttime="20190401 13:11:43.403"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:43.404" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: degraded</msg>
<status status="PASS" endtime="20190401 13:11:43.404" starttime="20190401 13:11:43.404"></status>
</kw>
<msg timestamp="20190401 13:11:43.404" level="INFO">${result} = {u'stdout': u'degraded', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:11:43.404" starttime="20190401 13:11:42.393"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:11:43.404" level="INFO">${value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:43.404" starttime="20190401 13:11:43.404"></status>
</kw>
<msg timestamp="20190401 13:11:43.404" level="INFO">${current_value} = degraded</msg>
<status status="PASS" endtime="20190401 13:11:43.405" starttime="20190401 13:11:42.392"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<msg timestamp="20190401 13:11:43.405" level="FAIL">degraded != available</msg>
<status status="FAIL" endtime="20190401 13:11:43.405" starttime="20190401 13:11:43.405"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:43.405" starttime="20190401 13:11:42.391"></status>
</kw>
<kw name="Check Property Value" library="Utils">
<doc>Validates that property is set correctly to the expected
value</doc>
<arguments>
<arg>${host}</arg>
<arg>availability</arg>
<arg>available</arg>
</arguments>
<kw name="Retrieve Host Property" library="Utils">
<doc>Returns the spceified value of the property on the
system host.</doc>
<arguments>
<arg>${host}</arg>
<arg>${property}</arg>
</arguments>
<assign>
<var>${current_value}</var>
</assign>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system host-show ${hostname}</arg>
<arg>grep -w ${property}</arg>
<arg>awk '{print$4}'</arg>
</arguments>
<assign>
<var>${system_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:48.407" level="INFO">${system_cmd} = system host-show controller-1|grep -w availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:48.407" starttime="20190401 13:11:48.406"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${system_cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:48.407" starttime="20190401 13:11:48.407"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:48.408" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:48.408" starttime="20190401 13:11:48.408"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:48.408" starttime="20190401 13:11:48.408"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:48.409" starttime="20190401 13:11:48.409"></status>
</kw>
<msg timestamp="20190401 13:11:48.409" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:48.409" starttime="20190401 13:11:48.407"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:48.409" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:48.409" starttime="20190401 13:11:48.409"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:48.422" level="INFO">system host-show controller-1|grep -w  availability|awk '{print$4}'</msg>
<status status="PASS" endtime="20190401 13:11:48.422" starttime="20190401 13:11:48.410"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:49.432" level="INFO">available
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:49.432" level="INFO">${output} = available
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:49.432" starttime="20190401 13:11:48.422"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:49.433" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:49.433" starttime="20190401 13:11:49.433"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:49.433" level="INFO">${clean_out} = available
</msg>
<status status="PASS" endtime="20190401 13:11:49.433" starttime="20190401 13:11:49.433"></status>
</kw>
<msg timestamp="20190401 13:11:49.433" level="INFO">${output} = available
</msg>
<status status="PASS" endtime="20190401 13:11:49.434" starttime="20190401 13:11:49.432"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:49.435" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:49.435" starttime="20190401 13:11:49.434"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:49.436" level="INFO">0</msg>
<msg timestamp="20190401 13:11:49.436" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:49.436" starttime="20190401 13:11:49.436"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:49.436" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:49.436" starttime="20190401 13:11:49.436"></status>
</kw>
<msg timestamp="20190401 13:11:49.436" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:49.436" starttime="20190401 13:11:49.434"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:49.437" starttime="20190401 13:11:49.437"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:49.437" starttime="20190401 13:11:49.437"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:49.438" starttime="20190401 13:11:49.437"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:49.438" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: available</msg>
<status status="PASS" endtime="20190401 13:11:49.438" starttime="20190401 13:11:49.438"></status>
</kw>
<msg timestamp="20190401 13:11:49.438" level="INFO">${result} = {u'stdout': u'available', u'stderr': u'', u'rc': u'0'}</msg>
<status status="PASS" endtime="20190401 13:11:49.438" starttime="20190401 13:11:48.407"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:11:49.438" level="INFO">${value} = available</msg>
<status status="PASS" endtime="20190401 13:11:49.439" starttime="20190401 13:11:49.438"></status>
</kw>
<msg timestamp="20190401 13:11:49.439" level="INFO">${current_value} = available</msg>
<status status="PASS" endtime="20190401 13:11:49.439" starttime="20190401 13:11:48.406"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${current_value}</arg>
<arg>${expected_value}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:49.439" starttime="20190401 13:11:49.439"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:49.439" starttime="20190401 13:11:48.405"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:49.440" starttime="20190401 13:06:12.842"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:49.440" starttime="20190401 13:05:58.469"></status>
</kw>
<kw name="Generate Secondary Controller Connection" library="Utils">
<doc>Establish a SSH connection with the secondary controller
to have it alive.</doc>
<arguments>
<arg>${second_controller}</arg>
</arguments>
<kw name="Set Variable If" library="BuiltIn">
<doc>Sets variable based on the given condition.</doc>
<arguments>
<arg>'${controller}'=='controller-0'</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
<arg>${CONFIG.general.IP_UNIT_1_ADDRESS}</arg>
</arguments>
<assign>
<var>${controller_ip}</var>
</assign>
<msg timestamp="20190401 13:11:49.440" level="INFO">${controller_ip} = 192.168.200.77</msg>
<status status="PASS" endtime="20190401 13:11:49.440" starttime="20190401 13:11:49.440"></status>
</kw>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${controller_ip}</arg>
</arguments>
<assign>
<var>${secondary_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190401 13:11:49.441" level="INFO">${controller_connection} = 3</msg>
<status status="PASS" endtime="20190401 13:11:49.441" starttime="20190401 13:11:49.441"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190401 13:11:49.442" level="INFO">Length is 10</msg>
<msg timestamp="20190401 13:11:49.442" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190401 13:11:49.442" starttime="20190401 13:11:49.442"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190401 13:11:49.443" level="INFO">Logging into '192.168.200.77 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190401 13:11:50.527" level="INFO">Read output: Last login: Mon Apr  1 18:54:42 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-1:~$</msg>
<status status="PASS" endtime="20190401 13:11:50.527" starttime="20190401 13:11:49.442"></status>
</kw>
<msg timestamp="20190401 13:11:50.528" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 13:11:50.528" starttime="20190401 13:11:49.442"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:50.528" starttime="20190401 13:11:49.441"></status>
</kw>
<msg timestamp="20190401 13:11:50.528" level="INFO">${secondary_controller_connection} = 3</msg>
<status status="PASS" endtime="20190401 13:11:50.528" starttime="20190401 13:11:49.440"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.529" level="INFO">${secondary_controller_connection} = 3</msg>
<status status="PASS" endtime="20190401 13:11:50.529" starttime="20190401 13:11:50.529"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.529" level="INFO">3</msg>
<status status="PASS" endtime="20190401 13:11:50.530" starttime="20190401 13:11:50.529"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${secondary_controller_connection} is not None</arg>
<arg>Switch Controller Connection</arg>
<arg>${master_controller_connection}</arg>
<arg>${secondary_controller_connection}</arg>
</arguments>
<kw name="Switch Controller Connection" library="Utils">
<doc>Enable a SSH connection to the new active controller and
source proper variables.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
<arg>${secondary_controller_connection}</arg>
</arguments>
<kw name="Switch Connection" library="SSHLibrary">
<doc>Switches the active connection by index or alias.</doc>
<arguments>
<arg>${new_idx}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.531" starttime="20190401 13:11:50.531"></status>
</kw>
<kw name="Get Connection" library="SSHLibrary">
<doc>Returns information about the connection.</doc>
<arguments>
<arg>${new_idx}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.532" level="INFO">index=1
path_separator=/
prompt=$
width=80
newline=

height=24
encoding=UTF-8
alias=None
host=192.168.200.76 prompt=$
timeout=1 minute
term_type=vt100
port=22</msg>
<status status="PASS" endtime="20190401 13:11:50.532" starttime="20190401 13:11:50.531"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>whoami</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.533" starttime="20190401 13:11:50.532"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:50.534" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:50.534" starttime="20190401 13:11:50.534"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.535" starttime="20190401 13:11:50.534"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.535" starttime="20190401 13:11:50.535"></status>
</kw>
<msg timestamp="20190401 13:11:50.536" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:50.536" starttime="20190401 13:11:50.533"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:50.536" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:50.536" starttime="20190401 13:11:50.536"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.539" level="INFO">whoami</msg>
<status status="PASS" endtime="20190401 13:11:50.539" starttime="20190401 13:11:50.537"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:50.540" level="INFO">wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:50.540" level="INFO">${output} = wrsroot
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:50.540" starttime="20190401 13:11:50.539"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:50.541" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:50.541" starttime="20190401 13:11:50.541"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:50.542" level="INFO">${clean_out} = wrsroot
</msg>
<status status="PASS" endtime="20190401 13:11:50.542" starttime="20190401 13:11:50.541"></status>
</kw>
<msg timestamp="20190401 13:11:50.542" level="INFO">${output} = wrsroot
</msg>
<status status="PASS" endtime="20190401 13:11:50.542" starttime="20190401 13:11:50.540"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:50.544" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:50.544" starttime="20190401 13:11:50.543"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:50.544" level="INFO">0</msg>
<msg timestamp="20190401 13:11:50.544" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:50.545" starttime="20190401 13:11:50.544"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.545" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:50.545" starttime="20190401 13:11:50.545"></status>
</kw>
<msg timestamp="20190401 13:11:50.545" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:50.545" starttime="20190401 13:11:50.542"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.547" starttime="20190401 13:11:50.546"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:50.547" starttime="20190401 13:11:50.545"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.547" starttime="20190401 13:11:50.547"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.548" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: wrsroot</msg>
<status status="PASS" endtime="20190401 13:11:50.548" starttime="20190401 13:11:50.547"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:50.548" starttime="20190401 13:11:50.532"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Set Env Vars From Openrc</arg>
</arguments>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.550" starttime="20190401 13:11:50.549"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:50.551" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:50.551" starttime="20190401 13:11:50.550"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.551" starttime="20190401 13:11:50.551"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.552" starttime="20190401 13:11:50.552"></status>
</kw>
<msg timestamp="20190401 13:11:50.552" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:50.552" starttime="20190401 13:11:50.550"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:50.553" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:50.553" starttime="20190401 13:11:50.553"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.555" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 13:11:50.555" starttime="20190401 13:11:50.553"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:50.925" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:50.925" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:50.925" starttime="20190401 13:11:50.555"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:50.926" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:50.926" starttime="20190401 13:11:50.926"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:50.926" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 13:11:50.926" starttime="20190401 13:11:50.926"></status>
</kw>
<msg timestamp="20190401 13:11:50.926" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:11:50.926" starttime="20190401 13:11:50.925"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:50.928" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:50.928" starttime="20190401 13:11:50.927"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:50.929" level="INFO">0</msg>
<msg timestamp="20190401 13:11:50.929" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:50.929" starttime="20190401 13:11:50.929"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.929" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:50.929" starttime="20190401 13:11:50.929"></status>
</kw>
<msg timestamp="20190401 13:11:50.929" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:50.929" starttime="20190401 13:11:50.927"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.930" starttime="20190401 13:11:50.930"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:50.930" starttime="20190401 13:11:50.930"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.931" starttime="20190401 13:11:50.930"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.931" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 13:11:50.931" starttime="20190401 13:11:50.931"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:50.931" starttime="20190401 13:11:50.549"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:50.931" starttime="20190401 13:11:50.548"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:50.931" starttime="20190401 13:11:50.548"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${secondary_controller_connection}</arg>
<arg>${old_idx}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.931" level="INFO">${secondary_controller_connection} = 3</msg>
<status status="PASS" endtime="20190401 13:11:50.932" starttime="20190401 13:11:50.931"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
<arg>${new_idx}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.932" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:11:50.932" starttime="20190401 13:11:50.932"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:50.932" starttime="20190401 13:11:50.530"></status>
</kw>
<msg timestamp="20190401 13:11:50.932" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 13:11:50.932" starttime="20190401 13:11:50.530"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:50.932" starttime="20190401 13:11:49.440"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>5 min</arg>
<arg>5 sec</arg>
<arg>Check Ceph Status</arg>
<arg>HEALTH_OK</arg>
</arguments>
<kw name="Check Ceph Status" library="Utils">
<doc>Verifies the status of the CEPH feature.</doc>
<arguments>
<arg>HEALTH_OK</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph -s</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.933" starttime="20190401 13:11:50.933"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:50.934" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:50.934" starttime="20190401 13:11:50.934"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.935" starttime="20190401 13:11:50.934"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:50.935" starttime="20190401 13:11:50.935"></status>
</kw>
<msg timestamp="20190401 13:11:50.935" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:50.935" starttime="20190401 13:11:50.934"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:50.935" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:50.935" starttime="20190401 13:11:50.935"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:50.937" level="INFO">ceph -s</msg>
<status status="PASS" endtime="20190401 13:11:50.937" starttime="20190401 13:11:50.936"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:51.070" level="INFO">cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_OK
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e28: 2 osds: 2 up, 2 in
            flags sortbitwise,require_jewel_osds
      pgmap v66: 384 pgs, 6 pools, 1588 bytes data, 1116 objects
            87744 kB used, 891 GB / 891 GB avail
                 384 active+clean
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:51.070" level="INFO">${output} =     cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_OK
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e28: 2...</msg>
<status status="PASS" endtime="20190401 13:11:51.070" starttime="20190401 13:11:50.937"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:51.071" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:51.071" starttime="20190401 13:11:51.071"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:51.071" level="INFO">${clean_out} =     cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_OK
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e28: 2...</msg>
<status status="PASS" endtime="20190401 13:11:51.071" starttime="20190401 13:11:51.071"></status>
</kw>
<msg timestamp="20190401 13:11:51.071" level="INFO">${output} =     cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_OK
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e28: 2...</msg>
<status status="PASS" endtime="20190401 13:11:51.071" starttime="20190401 13:11:51.070"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:51.073" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:51.073" starttime="20190401 13:11:51.072"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:51.074" level="INFO">0</msg>
<msg timestamp="20190401 13:11:51.074" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:51.074" starttime="20190401 13:11:51.074"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:51.074" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:51.074" starttime="20190401 13:11:51.074"></status>
</kw>
<msg timestamp="20190401 13:11:51.075" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:51.075" starttime="20190401 13:11:51.072"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:51.075" starttime="20190401 13:11:51.075"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:51.075" starttime="20190401 13:11:51.075"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:51.076" starttime="20190401 13:11:51.075"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:51.076" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8
     health HEALTH_OK
     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}
            election epoch 4, quorum 0 controller
     osdmap e28: 2 osds: 2 up, 2 in
            flags sortbitwise,require_jewel_osds
      pgmap v66: 384 pgs, 6 pools, 1588 bytes data, 1116 objects
            87744 kB used, 891 GB / 891 GB avail
                 384 active+clean</msg>
<status status="PASS" endtime="20190401 13:11:51.076" starttime="20190401 13:11:51.076"></status>
</kw>
<msg timestamp="20190401 13:11:51.076" level="INFO">${result} = {u'stdout': u'cluster bb9ec81e-9de0-4764-96f3-91ee1f3ad1b8\r\n     health HEALTH_OK\r\n     monmap e1: 1 mons at {controller=10.10.53.2:6789/0}\r\n            election epoch 4, quorum 0 controller\r\n...</msg>
<status status="PASS" endtime="20190401 13:11:51.076" starttime="20190401 13:11:50.933"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${result.stdout}</arg>
<arg>${status}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:51.077" starttime="20190401 13:11:51.076"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>ceph osd tree</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:51.077" starttime="20190401 13:11:51.077"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:51.078" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:51.078" starttime="20190401 13:11:51.078"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:51.078" starttime="20190401 13:11:51.078"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:51.079" starttime="20190401 13:11:51.078"></status>
</kw>
<msg timestamp="20190401 13:11:51.079" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:51.079" starttime="20190401 13:11:51.077"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:11:51.079" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:51.079" starttime="20190401 13:11:51.079"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:51.080" level="INFO">ceph osd tree</msg>
<status status="PASS" endtime="20190401 13:11:51.080" starttime="20190401 13:11:51.079"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:51.216" level="INFO">ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.87097 root storage-tier                                           
-2 0.87097     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3 0.43549         host controller-1                                   
 1 0.43549             osd.1              up  1.00000          1.00000 
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:51.217" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.87097 root storage-tier                                           
-2 0.87097     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190401 13:11:51.217" starttime="20190401 13:11:51.080"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:51.217" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:51.217" starttime="20190401 13:11:51.217"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:51.218" level="INFO">${clean_out} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.87097 root storage-tier                                           
-2 0.87097     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190401 13:11:51.218" starttime="20190401 13:11:51.217"></status>
</kw>
<msg timestamp="20190401 13:11:51.218" level="INFO">${output} = ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.87097 root storage-tier                                           
-2 0.87097     chassis group-0                        ...</msg>
<status status="PASS" endtime="20190401 13:11:51.218" starttime="20190401 13:11:51.217"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:51.220" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:51.220" starttime="20190401 13:11:51.218"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:51.220" level="INFO">0</msg>
<msg timestamp="20190401 13:11:51.220" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:51.220" starttime="20190401 13:11:51.220"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:51.221" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:51.221" starttime="20190401 13:11:51.220"></status>
</kw>
<msg timestamp="20190401 13:11:51.221" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:51.221" starttime="20190401 13:11:51.218"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:51.222" starttime="20190401 13:11:51.221"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:51.222" starttime="20190401 13:11:51.221"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:51.222" starttime="20190401 13:11:51.222"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:51.222" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ID WEIGHT  TYPE NAME                 UP/DOWN REWEIGHT PRIMARY-AFFINITY 
-1 0.87097 root storage-tier                                           
-2 0.87097     chassis group-0                                         
-4 0.43549         host controller-0                                   
 0 0.43549             osd.0              up  1.00000          1.00000 
-3 0.43549         host controller-1                                   
 1 0.43549             osd.1              up  1.00000          1.00000</msg>
<status status="PASS" endtime="20190401 13:11:51.222" starttime="20190401 13:11:51.222"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:51.222" starttime="20190401 13:11:51.077"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:51.222" starttime="20190401 13:11:50.933"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:51.223" starttime="20190401 13:11:50.932"></status>
</kw>
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/${chart_manifest}</arg>
<arg>${host_image_path}/${chart_manifest}</arg>
</arguments>
<msg timestamp="20190401 13:11:51.230" level="INFO">[chan 1] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:11:51.236" level="INFO">[chan 2] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:11:51.237" level="FAIL">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/helm-charts-manifest.tgz'.</msg>
<status status="FAIL" endtime="20190401 13:11:51.237" starttime="20190401 13:11:51.223"></status>
</kw>
<doc>Validates provisioning of a duplex configuration
according to steps defined at
"https://wiki.openstack.org/wiki/StarlingX/Containers/
InstallationOnAIODX"</doc>
<tags>
<tag>Duplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:11:51.237" critical="yes" starttime="20190401 12:29:10.152">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/helm-charts-manifest.tgz'.</status>
</test>
<doc>Tests for provisioning and unlocking controllers, computes and
storage hosts.
Author(s):
- Jose Perez Carranza &lt;jose.perez.carranza@intel.com&gt;
- Juan Carlos Alonso &lt;juan.carlos.alonso@intel.com&gt;</doc>
<metadata>
<item name="ISO">bootimage.iso</item>
<item name="System">duplex</item>
</metadata>
<status status="FAIL" endtime="20190401 13:11:51.238" starttime="20190401 12:29:08.395"></status>
</suite>
<statistics>
<total>
<stat fail="1" pass="0">Critical Tests</stat>
<stat fail="1" pass="0">All Tests</stat>
</total>
<tag>
<stat fail="1" pass="0">Duplex</stat>
</tag>
<suite>
<stat fail="1" id="s1" name="Provision-Containers" pass="0">Provision-Containers</stat>
</suite>
</statistics>
<errors>
</errors>
</robot>
