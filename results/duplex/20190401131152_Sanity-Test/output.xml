<?xml version="1.0" encoding="UTF-8"?>
<robot rpa="false" generated="20190401 13:11:52.933" generator="Robot 3.1.1 (Python 2.7.15 on linux2)">
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Sanity-Test" id="s1" name="Sanity-Test">
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Sanity-Test/Sanity-OpenStack" id="s1-s1" name="Sanity-OpenStack">
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Sanity-Test/Sanity-OpenStack/01-Instance-From-Image.robot" id="s1-s1-s1" name="01-Instance-From-Image">
<kw type="setup" name="Stx Suite Setup" library="Utils">
<doc>Wrapper to setup the environment needed for exercise
StarlingX features</doc>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190401 13:11:53.065" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:11:53.065" starttime="20190401 13:11:53.065"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190401 13:11:53.066" level="INFO">Length is 10</msg>
<msg timestamp="20190401 13:11:53.066" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190401 13:11:53.066" starttime="20190401 13:11:53.066"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190401 13:11:53.067" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190401 13:11:54.176" level="INFO">Read output: Last login: Mon Apr  1 18:26:35 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<msg timestamp="20190401 13:11:54.177" level="INFO">/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:39: CryptographyDeprecationWarning: encode_point has been deprecated on EllipticCurvePublicNumbers and will be removed in a future version. Please use EllipticCurvePublicKey.public_bytes to obtain both compressed and uncompressed point encoding.
  m.add_string(self.Q_C.public_numbers().encode_point())
/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:96: CryptographyDeprecationWarning: Support for unsafe construction of public numbers from encoded data will be removed in a future version. Please use EllipticCurvePublicKey.from_encoded_point
  self.curve, Q_S_bytes
/home/mgperezi/duplex/stx-test-suite/Maria/lib/python2.7/site-packages/paramiko/kex_ecdh_nist.py:111: CryptographyDeprecationWarning: encode_point has been deprecated on EllipticCurvePublicNumbers and will be removed in a future version. Please use EllipticCurvePublicKey.public_bytes to obtain both compressed and uncompressed point encoding.
  hm.add_string(self.Q_C.public_numbers().encode_point())</msg>
<status status="PASS" endtime="20190401 13:11:54.177" starttime="20190401 13:11:53.067"></status>
</kw>
<msg timestamp="20190401 13:11:54.177" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 13:11:54.177" starttime="20190401 13:11:53.066"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:54.177" starttime="20190401 13:11:53.066"></status>
</kw>
<msg timestamp="20190401 13:11:54.177" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:11:54.177" starttime="20190401 13:11:53.065"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:11:54.178" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:11:54.178" starttime="20190401 13:11:54.178"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:11:54.178" level="INFO">1</msg>
<status status="PASS" endtime="20190401 13:11:54.178" starttime="20190401 13:11:54.178"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:54.178" starttime="20190401 13:11:53.064"></status>
</kw>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:54.179" starttime="20190401 13:11:54.179"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:11:54.180" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:11:54.180" starttime="20190401 13:11:54.180"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:54.180" starttime="20190401 13:11:54.180"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:54.181" starttime="20190401 13:11:54.181"></status>
</kw>
<msg timestamp="20190401 13:11:54.181" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:11:54.181" starttime="20190401 13:11:54.179"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190401 13:11:54.181" starttime="20190401 13:11:54.181"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:11:54.185" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 13:11:54.185" starttime="20190401 13:11:54.181"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:54.548" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:11:54.548" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:54.548" starttime="20190401 13:11:54.185"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:11:54.549" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:11:54.549" starttime="20190401 13:11:54.549"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:11:54.549" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 13:11:54.549" starttime="20190401 13:11:54.549"></status>
</kw>
<msg timestamp="20190401 13:11:54.549" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:11:54.549" starttime="20190401 13:11:54.548"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:11:54.551" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:11:54.551" starttime="20190401 13:11:54.550"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:54.552" level="INFO">0</msg>
<msg timestamp="20190401 13:11:54.552" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:54.552" starttime="20190401 13:11:54.552"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:11:54.552" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:11:54.552" starttime="20190401 13:11:54.552"></status>
</kw>
<msg timestamp="20190401 13:11:54.553" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:54.553" starttime="20190401 13:11:54.549"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:54.553" starttime="20190401 13:11:54.553"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:54.553" starttime="20190401 13:11:54.553"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:54.554" starttime="20190401 13:11:54.554"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:11:54.554" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 13:11:54.554" starttime="20190401 13:11:54.554"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:54.554" starttime="20190401 13:11:54.179"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:54.554" starttime="20190401 13:11:54.178"></status>
</kw>
<status status="PASS" endtime="20190401 13:11:54.554" starttime="20190401 13:11:53.064"></status>
</kw>
<test id="s1-s1-s1-t1" name="Create Flavors for Instances">
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${flavor_property_1}</arg>
<arg>${flavor_property_2}</arg>
</arguments>
<assign>
<var>${properties}</var>
</assign>
<msg timestamp="20190401 13:11:54.555" level="INFO">${properties} = --property sw:wrs:guest:heartbeat='false' --property hw:cpu_policy='shared'</msg>
<status status="PASS" endtime="20190401 13:11:54.555" starttime="20190401 13:11:54.555"></status>
</kw>
<kw name="Create Flavor" library="OpenStack">
<doc>Create a flavor with specified values.</doc>
<arguments>
<arg>${cirros_flavor_ram}</arg>
<arg>${cirros_flavor_vcpus}</arg>
<arg>${cirros_flavor_disk}</arg>
<arg>${cirros_flavor_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:54.556" level="INFO">${openstack_cmd} = openstack flavor create</msg>
<status status="PASS" endtime="20190401 13:11:54.556" starttime="20190401 13:11:54.556"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--ram ${ram}</arg>
<arg>--disk ${disk}</arg>
<arg>--vcpus ${vcpus}</arg>
<arg>--public</arg>
<arg>--id auto</arg>
<arg>${extra_args}</arg>
<arg>${name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:11:54.556" level="INFO">${cmd} = openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f1.small</msg>
<status status="PASS" endtime="20190401 13:11:54.557" starttime="20190401 13:11:54.556"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:11:54.557" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:11:54.557" starttime="20190401 13:11:54.557"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:54.558" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f1.small'.</msg>
<msg timestamp="20190401 13:11:55.236" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:11:55.237" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:11:55.237" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:11:55.237" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:11:55.237" starttime="20190401 13:11:54.557"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:11:55.237" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:11:55.237" starttime="20190401 13:11:55.237"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:11:55.238" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:11:55.238" starttime="20190401 13:11:55.238"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:55.238" starttime="20190401 13:11:55.238"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:55.238" starttime="20190401 13:11:54.557"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:55.239" starttime="20190401 13:11:54.555"></status>
</kw>
<doc>Create flavors with or without properties to be used
to launch Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:11:55.239" critical="yes" starttime="20190401 13:11:54.555">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t2" name="Create Images for Instances">
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/${cirros_image}</arg>
<arg>${host_image_path}/${cirros_image}</arg>
</arguments>
<msg timestamp="20190401 13:11:55.261" level="INFO">[chan 2] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:11:55.267" level="INFO">[chan 3] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:11:55.268" level="FAIL">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/cirros-0.4.0-x86_64-disk.qcow2'.</msg>
<status status="FAIL" endtime="20190401 13:11:55.268" starttime="20190401 13:11:55.239"></status>
</kw>
<doc>Create images with or without properties to be used
to launch Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:11:55.268" critical="yes" starttime="20190401 13:11:55.239">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/cirros-0.4.0-x86_64-disk.qcow2'.</status>
</test>
<test id="s1-s1-s1-t3" name="Create Networks for Instances">
<kw name="Create Network" library="OpenStack">
<doc>Create Network with openstack request.</doc>
<arguments>
<arg>${network_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:55.269" level="INFO">${openstack_cmd} = openstack network create</msg>
<status status="PASS" endtime="20190401 13:11:55.270" starttime="20190401 13:11:55.269"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>${network_name}</arg>
<arg>${additional_args}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:11:55.270" level="INFO">${cmd} = openstack network create network-1 </msg>
<status status="PASS" endtime="20190401 13:11:55.270" starttime="20190401 13:11:55.270"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:11:55.270" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:11:55.271" starttime="20190401 13:11:55.270"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:55.271" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network create network-1 '.</msg>
<msg timestamp="20190401 13:11:55.849" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:11:55.849" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:11:55.849" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:11:55.849" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:11:55.849" starttime="20190401 13:11:55.271"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:11:55.850" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:11:55.850" starttime="20190401 13:11:55.850"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:11:55.851" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:11:55.851" starttime="20190401 13:11:55.851"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:55.851" starttime="20190401 13:11:55.850"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:55.851" starttime="20190401 13:11:55.270"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:55.851" starttime="20190401 13:11:55.269"></status>
</kw>
<doc>Create networks to be used to launch Cirros and Centos
instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:11:55.851" critical="yes" starttime="20190401 13:11:55.269">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t4" name="Launch Instances">
<kw name="Create Instance" library="OpenStack">
<doc>Create a VM Instances with the net id of the Netowrk
flavor and image</doc>
<arguments>
<arg>${network_name}</arg>
<arg>${cirros_instance_name}</arg>
<arg>${cirros_image_name}</arg>
<arg>${cirros_flavor_name}</arg>
</arguments>
<kw name="Get Net Id" library="OpenStack">
<doc>Retrieve the net id for the given network name</doc>
<arguments>
<arg>${net_name}</arg>
</arguments>
<assign>
<var>${net_id}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:11:55.853" level="INFO">${openstack_cmd} = openstack network list</msg>
<status status="PASS" endtime="20190401 13:11:55.853" starttime="20190401 13:11:55.853"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>grep "${network_name}"</arg>
<arg>awk '{print$2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:11:55.853" level="INFO">${cmd} = openstack network list|grep "network-1"|awk '{print$2}'</msg>
<status status="PASS" endtime="20190401 13:11:55.853" starttime="20190401 13:11:55.853"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:11:55.854" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:11:55.854" starttime="20190401 13:11:55.854"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:55.855" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network list|grep "network-1"|awk '{print$2}''.</msg>
<msg timestamp="20190401 13:11:56.463" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190401 13:11:56.464" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:11:56.464" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:11:56.464" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:11:56.464" starttime="20190401 13:11:55.854"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:11:56.464" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 0}</msg>
<status status="PASS" endtime="20190401 13:11:56.464" starttime="20190401 13:11:56.464"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:11:56.465" starttime="20190401 13:11:56.465"></status>
</kw>
<msg timestamp="20190401 13:11:56.465" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:11:56.465" starttime="20190401 13:11:55.853"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:11:56.466" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:11:56.466" starttime="20190401 13:11:56.465"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${output}</arg>
<arg>${EMPTY}</arg>
</arguments>
<assign>
<var>${splitted_output}</var>
</assign>
<msg timestamp="20190401 13:11:56.466" level="INFO">${splitted_output} = []</msg>
<status status="PASS" endtime="20190401 13:11:56.466" starttime="20190401 13:11:56.466"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${splitted_output}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${net_id}</var>
</assign>
<msg timestamp="20190401 13:11:56.466" level="FAIL">IndexError: Given index 0 is out of the range 0--1.</msg>
<status status="FAIL" endtime="20190401 13:11:56.467" starttime="20190401 13:11:56.466"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:56.467" starttime="20190401 13:11:55.852"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:56.467" starttime="20190401 13:11:55.852"></status>
</kw>
<doc>Launch Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:11:56.467" critical="yes" starttime="20190401 13:11:55.852">IndexError: Given index 0 is out of the range 0--1.</status>
</test>
<test id="s1-s1-s1-t5" name="Suspend Resume Instances">
<kw name="Suspend Instance" library="OpenStack">
<doc>Suspend the corresponding VM</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server suspend ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:11:56.468" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:11:56.468" starttime="20190401 13:11:56.468"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:56.469" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server suspend vm-cirros-1'.</msg>
<msg timestamp="20190401 13:11:57.111" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:11:57.111" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:11:57.111" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:11:57.111" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:11:57.112" starttime="20190401 13:11:56.469"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:11:57.112" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:11:57.112" starttime="20190401 13:11:57.112"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:11:57.113" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:11:57.113" starttime="20190401 13:11:57.113"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:57.113" starttime="20190401 13:11:57.112"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:57.113" starttime="20190401 13:11:56.468"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:57.113" starttime="20190401 13:11:56.468"></status>
</kw>
<doc>Suspend and Resume Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:11:57.113" critical="yes" starttime="20190401 13:11:56.467">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t6" name="Set Error Active Flags Instances">
<kw name="Set Error State Instance" library="OpenStack">
<doc>Set 'Error' value to the corresponding VM</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
<arg>error</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server set --state ${value} ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:11:57.115" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:11:57.115" starttime="20190401 13:11:57.115"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:57.115" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server set --state error vm-cirros-1'.</msg>
<msg timestamp="20190401 13:11:57.693" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:11:57.693" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:11:57.693" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:11:57.693" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:11:57.693" starttime="20190401 13:11:57.115"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:11:57.694" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:11:57.694" starttime="20190401 13:11:57.694"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:11:57.695" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:11:57.695" starttime="20190401 13:11:57.695"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:57.695" starttime="20190401 13:11:57.694"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:57.696" starttime="20190401 13:11:57.114"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:57.696" starttime="20190401 13:11:57.114"></status>
</kw>
<doc>Set 'Error' and 'Active' flags to Cirros and Centos
instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:11:57.696" critical="yes" starttime="20190401 13:11:57.114">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t7" name="Pause Unpause Instances">
<kw name="Pause Instance" library="OpenStack">
<doc>Pause an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server pause ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:11:57.697" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:11:57.697" starttime="20190401 13:11:57.697"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:57.698" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server pause vm-cirros-1'.</msg>
<msg timestamp="20190401 13:11:58.356" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:11:58.357" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:11:58.357" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:11:58.357" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:11:58.357" starttime="20190401 13:11:57.697"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:11:58.357" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:11:58.357" starttime="20190401 13:11:58.357"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:11:58.358" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:11:58.358" starttime="20190401 13:11:58.358"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:58.359" starttime="20190401 13:11:58.358"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:58.359" starttime="20190401 13:11:57.697"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:58.359" starttime="20190401 13:11:57.696"></status>
</kw>
<doc>Pause and Unpause Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:11:58.359" critical="yes" starttime="20190401 13:11:57.696">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t8" name="Stop Start Instances">
<kw name="Stop Instance" library="OpenStack">
<doc>Stop an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server stop ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:11:58.360" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:11:58.360" starttime="20190401 13:11:58.360"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:58.361" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server stop vm-cirros-1'.</msg>
<msg timestamp="20190401 13:11:58.989" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:11:58.989" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:11:58.989" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:11:58.989" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:11:58.989" starttime="20190401 13:11:58.360"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:11:58.990" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:11:58.990" starttime="20190401 13:11:58.989"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:11:58.990" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:11:58.990" starttime="20190401 13:11:58.990"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:58.990" starttime="20190401 13:11:58.990"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:58.990" starttime="20190401 13:11:58.360"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:58.991" starttime="20190401 13:11:58.360"></status>
</kw>
<doc>Stop and Start Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:11:58.991" critical="yes" starttime="20190401 13:11:58.359">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t9" name="Lock Unlock Instances">
<kw name="Lock Instance" library="OpenStack">
<doc>Lock an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server lock ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:11:58.992" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:11:58.992" starttime="20190401 13:11:58.992"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:58.992" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server lock vm-cirros-1'.</msg>
<msg timestamp="20190401 13:11:59.570" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:11:59.571" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:11:59.571" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:11:59.571" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:11:59.571" starttime="20190401 13:11:58.992"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:11:59.571" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:11:59.571" starttime="20190401 13:11:59.571"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:11:59.572" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:11:59.572" starttime="20190401 13:11:59.572"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:59.572" starttime="20190401 13:11:59.571"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:59.572" starttime="20190401 13:11:58.992"></status>
</kw>
<status status="FAIL" endtime="20190401 13:11:59.572" starttime="20190401 13:11:58.991"></status>
</kw>
<doc>Lock and Unlock Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:11:59.573" critical="yes" starttime="20190401 13:11:58.991">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t10" name="Reboot Instances">
<kw name="Reboot Instance" library="OpenStack">
<doc>Reboot an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server reboot ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:11:59.574" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:11:59.574" starttime="20190401 13:11:59.574"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:11:59.574" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server reboot vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:00.233" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:00.233" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:00.233" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:00.233" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:00.233" starttime="20190401 13:11:59.574"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:00.234" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:00.234" starttime="20190401 13:12:00.233"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:00.235" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:00.235" starttime="20190401 13:12:00.234"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:00.236" starttime="20190401 13:12:00.234"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:00.236" starttime="20190401 13:11:59.573"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:00.236" starttime="20190401 13:11:59.573"></status>
</kw>
<doc>Reboot Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:00.236" critical="yes" starttime="20190401 13:11:59.573">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t11" name="Rebuild Instances">
<kw name="Rebuild Instance" library="OpenStack">
<doc>Rebuild an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server rebuild ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:00.237" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:00.237" starttime="20190401 13:12:00.237"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:00.238" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server rebuild vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:00.816" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:00.816" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:00.816" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:00.816" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:00.816" starttime="20190401 13:12:00.237"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:00.817" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:00.817" starttime="20190401 13:12:00.817"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:00.818" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:00.818" starttime="20190401 13:12:00.818"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:00.818" starttime="20190401 13:12:00.817"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:00.818" starttime="20190401 13:12:00.237"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:00.818" starttime="20190401 13:12:00.237"></status>
</kw>
<doc>Rebuild Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:00.818" critical="yes" starttime="20190401 13:12:00.236">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t12" name="Resize Instances">
<kw name="Create Flavor" library="OpenStack">
<doc>Create a flavor with specified values.</doc>
<arguments>
<arg>${cirros_flavor_ram}</arg>
<arg>${cirros_flavor_vcpus}</arg>
<arg>${cirros_flavor_disk}</arg>
<arg>${cirros_flavor_name_2}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:00.819" level="INFO">${openstack_cmd} = openstack flavor create</msg>
<status status="PASS" endtime="20190401 13:12:00.819" starttime="20190401 13:12:00.819"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--ram ${ram}</arg>
<arg>--disk ${disk}</arg>
<arg>--vcpus ${vcpus}</arg>
<arg>--public</arg>
<arg>--id auto</arg>
<arg>${extra_args}</arg>
<arg>${name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:00.820" level="INFO">${cmd} = openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f2.small</msg>
<status status="PASS" endtime="20190401 13:12:00.820" starttime="20190401 13:12:00.820"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:00.821" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:00.821" starttime="20190401 13:12:00.820"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:00.821" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f2.small'.</msg>
<msg timestamp="20190401 13:12:01.444" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:01.444" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:01.444" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:01.444" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:01.444" starttime="20190401 13:12:00.821"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:01.445" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:01.445" starttime="20190401 13:12:01.444"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:01.446" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:01.446" starttime="20190401 13:12:01.445"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:01.446" starttime="20190401 13:12:01.445"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:01.446" starttime="20190401 13:12:00.820"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:01.446" starttime="20190401 13:12:00.819"></status>
</kw>
<doc>Resize Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:01.446" critical="yes" starttime="20190401 13:12:00.818">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t13" name="Set Unset Properties Instances">
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${instance_property_1}='true'</arg>
<arg>${instance_property_2}='500'</arg>
<arg>${instance_property_3}='180'</arg>
</arguments>
<assign>
<var>${properties}</var>
</assign>
<msg timestamp="20190401 13:12:01.447" level="INFO">${properties} = --property sw:wrs:auto_recovery='true' --property hw:wrs:live_migration_max_downtime='500' --property hw:wrs:live_migration_timeout='180'</msg>
<status status="PASS" endtime="20190401 13:12:01.447" starttime="20190401 13:12:01.447"></status>
</kw>
<kw name="Set Instance Property" library="OpenStack">
<doc>Set properties of an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
<arg>${properties}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server set ${key} ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:01.449" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:01.449" starttime="20190401 13:12:01.448"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:01.449" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server set --property sw:wrs:auto_recovery='true' --property hw:wrs:live_migration_max_downtime='500' --property hw:wrs:live_migration_timeout='180' vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:02.091" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:02.092" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:02.092" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:02.092" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:02.092" starttime="20190401 13:12:01.449"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:02.092" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:02.092" starttime="20190401 13:12:02.092"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:02.093" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:02.093" starttime="20190401 13:12:02.093"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:02.093" starttime="20190401 13:12:02.093"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:02.093" starttime="20190401 13:12:01.448"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:02.093" starttime="20190401 13:12:01.448"></status>
</kw>
<doc>Set Unset properties of Cirros and Centos instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:02.094" critical="yes" starttime="20190401 13:12:01.447">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s1-t14" name="Evacuate Instances From Hosts">
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}' == 'Duplex'</arg>
<arg>Run Keywords</arg>
<arg>Evacuate Instances</arg>
<arg>controller-0</arg>
<arg>AND</arg>
<arg>Evacuate Instances</arg>
<arg>controller-1</arg>
<arg>ELSE IF</arg>
<arg>'${CONFIGURATION_TYPE}' == 'MN-Local' or '${CONFIGURATION_TYPE}' == 'MN-External'</arg>
<arg>Run Keywords</arg>
<arg>Evacuate Instances</arg>
<arg>compute-0</arg>
<arg>AND</arg>
<arg>Evacuate Instances</arg>
<arg>compute-1</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Evacuate Instances</arg>
<arg>controller-0</arg>
<arg>AND</arg>
<arg>Evacuate Instances</arg>
<arg>controller-1</arg>
</arguments>
<kw name="Evacuate Instances" library="OpenStack">
<doc>Evacuate all VMs from computes or from controllers.</doc>
<arguments>
<arg>controller-0</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack compute service set</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:02.095" level="INFO">${openstack_cmd} = openstack compute service set</msg>
<status status="PASS" endtime="20190401 13:12:02.095" starttime="20190401 13:12:02.095"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--disable</arg>
<arg>--disable-reason test-evacuate</arg>
<arg>${host}</arg>
<arg>nova-compute</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:02.096" level="INFO">${cmd} = openstack compute service set --disable --disable-reason test-evacuate controller-0 nova-compute</msg>
<status status="PASS" endtime="20190401 13:12:02.096" starttime="20190401 13:12:02.096"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:02.096" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:02.096" starttime="20190401 13:12:02.096"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:02.097" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack compute service set --disable --disable-reason test-evacuate controller-0 nova-compute'.</msg>
<msg timestamp="20190401 13:12:02.675" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:02.675" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:02.675" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:02.675" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:02.675" starttime="20190401 13:12:02.096"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:02.676" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:02.676" starttime="20190401 13:12:02.675"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:02.677" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:02.677" starttime="20190401 13:12:02.676"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:02.677" starttime="20190401 13:12:02.676"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:02.677" starttime="20190401 13:12:02.096"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:02.677" starttime="20190401 13:12:02.095"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:02.677" starttime="20190401 13:12:02.095"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:02.677" starttime="20190401 13:12:02.094"></status>
</kw>
<doc>Evacuate all Cirros and Centos instances from computes
or controllers.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:02.677" critical="yes" starttime="20190401 13:12:02.094">Cloud openstack_helm was not found.</status>
</test>
<kw type="teardown" name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>OpenStack.Openstack Cleanup All</arg>
<arg>Utils.Stx Suite TearDown</arg>
</arguments>
<kw name="Openstack Cleanup All" library="OpenStack">
<doc>Delete all instances, images, flavors, networks and
keypairs generated during tests.</doc>
<kw name="Delete All Instances" library="OpenStack">
<doc>Get a list of all existing instances to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack server list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:02.679" level="INFO">${openstack_cmd} = openstack server list</msg>
<status status="PASS" endtime="20190401 13:12:02.679" starttime="20190401 13:12:02.679"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:02.679" level="INFO">${cmd} = openstack server list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:02.679" starttime="20190401 13:12:02.679"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:02.680" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:02.680" starttime="20190401 13:12:02.680"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:02.680" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:03.289" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:03.289" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:03.289" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:03.289" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:03.289" starttime="20190401 13:12:02.680"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:03.290" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:03.290" starttime="20190401 13:12:03.289"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:03.290" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:03.291" starttime="20190401 13:12:03.290"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:03.291" starttime="20190401 13:12:03.290"></status>
</kw>
<msg timestamp="20190401 13:12:03.291" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:03.291" starttime="20190401 13:12:02.679"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{vm_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:03.291" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:03.292" starttime="20190401 13:12:03.291"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:03.292" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:03.292" starttime="20190401 13:12:03.292"></status>
</kw>
<msg timestamp="20190401 13:12:03.292" level="INFO">@{vm_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:03.292" starttime="20190401 13:12:03.291"></status>
</kw>
<kw type="for" name="${vm} IN [ @{vm_list} ]">
<status status="PASS" endtime="20190401 13:12:03.292" starttime="20190401 13:12:03.292"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:03.292" starttime="20190401 13:12:02.678"></status>
</kw>
<kw name="Delete All Images" library="OpenStack">
<doc>Get a list of all existing images to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack image list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:03.293" level="INFO">${openstack_cmd} = openstack image list</msg>
<status status="PASS" endtime="20190401 13:12:03.293" starttime="20190401 13:12:03.293"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "Cirros"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:03.293" level="INFO">${cmd} = openstack image list|awk '{print$4}'|grep -v "Name"|grep -v "Cirros"</msg>
<status status="PASS" endtime="20190401 13:12:03.293" starttime="20190401 13:12:03.293"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:03.294" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:03.294" starttime="20190401 13:12:03.294"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:03.294" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack image list|awk '{print$4}'|grep -v "Name"|grep -v "Cirros"'.</msg>
<msg timestamp="20190401 13:12:03.903" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:03.903" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:03.903" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:03.903" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:03.903" starttime="20190401 13:12:03.294"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:03.903" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:03.903" starttime="20190401 13:12:03.903"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:03.904" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:03.905" starttime="20190401 13:12:03.904"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:03.905" starttime="20190401 13:12:03.904"></status>
</kw>
<msg timestamp="20190401 13:12:03.905" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:03.905" starttime="20190401 13:12:03.293"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{image_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:03.906" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:03.906" starttime="20190401 13:12:03.906"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:03.906" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:03.906" starttime="20190401 13:12:03.906"></status>
</kw>
<msg timestamp="20190401 13:12:03.906" level="INFO">@{image_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:03.906" starttime="20190401 13:12:03.905"></status>
</kw>
<kw type="for" name="${image} IN [ @{image_list} ]">
<status status="PASS" endtime="20190401 13:12:03.906" starttime="20190401 13:12:03.906"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:03.907" starttime="20190401 13:12:03.292"></status>
</kw>
<kw name="Delete All Flavors" library="OpenStack">
<doc>Get a list of all existing flavors to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:03.907" level="INFO">${openstack_cmd} = openstack flavor list</msg>
<status status="PASS" endtime="20190401 13:12:03.907" starttime="20190401 13:12:03.907"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "m1"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:03.907" level="INFO">${cmd} = openstack flavor list|awk '{print$4}'|grep -v "Name"|grep -v "m1"</msg>
<status status="PASS" endtime="20190401 13:12:03.907" starttime="20190401 13:12:03.907"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:03.908" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:03.908" starttime="20190401 13:12:03.908"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:03.909" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor list|awk '{print$4}'|grep -v "Name"|grep -v "m1"'.</msg>
<msg timestamp="20190401 13:12:04.567" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:04.567" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:04.567" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:04.567" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:04.567" starttime="20190401 13:12:03.908"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:04.568" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:04.568" starttime="20190401 13:12:04.567"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:04.569" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:04.569" starttime="20190401 13:12:04.569"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:04.569" starttime="20190401 13:12:04.568"></status>
</kw>
<msg timestamp="20190401 13:12:04.569" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:04.569" starttime="20190401 13:12:03.908"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{flavor_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:04.570" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:04.570" starttime="20190401 13:12:04.570"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:04.570" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:04.570" starttime="20190401 13:12:04.570"></status>
</kw>
<msg timestamp="20190401 13:12:04.570" level="INFO">@{flavor_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:04.570" starttime="20190401 13:12:04.569"></status>
</kw>
<kw type="for" name="${flavor} IN [ @{flavor_list} ]">
<status status="PASS" endtime="20190401 13:12:04.571" starttime="20190401 13:12:04.570"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:04.571" starttime="20190401 13:12:03.907"></status>
</kw>
<kw name="Delete All Networks" library="OpenStack">
<doc>Get a list of all existing networks to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:04.571" level="INFO">${openstack_cmd} = openstack network list</msg>
<status status="PASS" endtime="20190401 13:12:04.571" starttime="20190401 13:12:04.571"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "private"</arg>
<arg>grep -v "public"</arg>
<arg>grep -v "external"</arg>
<arg>grep -v "internal"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:04.572" level="INFO">${cmd} = openstack network list|awk '{print$4}'|grep -v "Name"|grep -v "private"|grep -v "public"|grep -v "external"|grep -v "internal"</msg>
<status status="PASS" endtime="20190401 13:12:04.572" starttime="20190401 13:12:04.571"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:04.572" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:04.572" starttime="20190401 13:12:04.572"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:04.573" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network list|awk '{print$4}'|grep -v "Name"|grep -v "private"|grep -v "public"|grep -v "external"|grep -v "internal"'.</msg>
<msg timestamp="20190401 13:12:05.251" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:05.251" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:05.251" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:05.251" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:05.251" starttime="20190401 13:12:04.572"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:05.252" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:05.252" starttime="20190401 13:12:05.251"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:05.252" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:05.253" starttime="20190401 13:12:05.252"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:05.253" starttime="20190401 13:12:05.252"></status>
</kw>
<msg timestamp="20190401 13:12:05.253" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:05.253" starttime="20190401 13:12:04.572"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{network_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:05.253" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:05.254" starttime="20190401 13:12:05.253"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:05.254" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:05.254" starttime="20190401 13:12:05.254"></status>
</kw>
<msg timestamp="20190401 13:12:05.254" level="INFO">@{network_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:05.254" starttime="20190401 13:12:05.253"></status>
</kw>
<kw type="for" name="${network} IN [ @{network_list} ]">
<status status="PASS" endtime="20190401 13:12:05.254" starttime="20190401 13:12:05.254"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:05.254" starttime="20190401 13:12:04.571"></status>
</kw>
<kw name="Delete All KeyPairs" library="OpenStack">
<doc>Get a list of all existing keypais to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack keypair list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:05.255" level="INFO">${openstack_cmd} = openstack keypair list</msg>
<status status="PASS" endtime="20190401 13:12:05.255" starttime="20190401 13:12:05.255"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$2}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:05.255" level="INFO">${cmd} = openstack keypair list|awk '{print$2}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:05.255" starttime="20190401 13:12:05.255"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:05.256" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:05.256" starttime="20190401 13:12:05.256"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:05.256" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack keypair list|awk '{print$2}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:05.884" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:05.885" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:05.885" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:05.885" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:05.885" starttime="20190401 13:12:05.256"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:05.886" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:05.886" starttime="20190401 13:12:05.885"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:05.887" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:05.887" starttime="20190401 13:12:05.886"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:05.887" starttime="20190401 13:12:05.886"></status>
</kw>
<msg timestamp="20190401 13:12:05.887" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:05.887" starttime="20190401 13:12:05.255"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{key_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:05.888" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:05.888" starttime="20190401 13:12:05.887"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:05.888" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:05.888" starttime="20190401 13:12:05.888"></status>
</kw>
<msg timestamp="20190401 13:12:05.888" level="INFO">@{key_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:05.888" starttime="20190401 13:12:05.887"></status>
</kw>
<kw type="for" name="${key} IN [ @{key_list} ]">
<status status="PASS" endtime="20190401 13:12:05.888" starttime="20190401 13:12:05.888"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:05.888" starttime="20190401 13:12:05.254"></status>
</kw>
<kw name="Delete All Snapshots" library="OpenStack">
<doc>Get a list of all existing snapshots to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume snapshot list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:05.889" level="INFO">${openstack_cmd} = openstack volume snapshot list</msg>
<status status="PASS" endtime="20190401 13:12:05.889" starttime="20190401 13:12:05.889"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:05.889" level="INFO">${cmd} = openstack volume snapshot list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:05.889" starttime="20190401 13:12:05.889"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:05.890" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:05.890" starttime="20190401 13:12:05.890"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:05.890" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume snapshot list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:06.468" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:06.468" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:06.468" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:06.468" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:06.468" starttime="20190401 13:12:05.890"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:06.469" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:06.469" starttime="20190401 13:12:06.468"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:06.470" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:06.470" starttime="20190401 13:12:06.469"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:06.470" starttime="20190401 13:12:06.469"></status>
</kw>
<msg timestamp="20190401 13:12:06.470" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:06.470" starttime="20190401 13:12:05.889"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{snapshot_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:06.471" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:06.471" starttime="20190401 13:12:06.470"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:06.471" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:06.471" starttime="20190401 13:12:06.471"></status>
</kw>
<msg timestamp="20190401 13:12:06.471" level="INFO">@{snapshot_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:06.471" starttime="20190401 13:12:06.470"></status>
</kw>
<kw type="for" name="${snapshot} IN [ @{snapshot_list} ]">
<status status="PASS" endtime="20190401 13:12:06.471" starttime="20190401 13:12:06.471"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:06.471" starttime="20190401 13:12:05.888"></status>
</kw>
<kw name="Delete All Volumes" library="OpenStack">
<doc>Get a list of all existing volumes to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:06.472" level="INFO">${openstack_cmd} = openstack volume list</msg>
<status status="PASS" endtime="20190401 13:12:06.472" starttime="20190401 13:12:06.472"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$2}'</arg>
<arg>grep -v "ID"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:06.472" level="INFO">${cmd} = openstack volume list|awk '{print$2}'|grep -v "ID"</msg>
<status status="PASS" endtime="20190401 13:12:06.472" starttime="20190401 13:12:06.472"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:06.473" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:06.473" starttime="20190401 13:12:06.473"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:06.473" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume list|awk '{print$2}'|grep -v "ID"'.</msg>
<msg timestamp="20190401 13:12:07.132" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:07.132" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:07.132" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:07.132" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:07.132" starttime="20190401 13:12:06.473"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:07.133" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:07.133" starttime="20190401 13:12:07.132"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:07.134" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:07.134" starttime="20190401 13:12:07.134"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:07.134" starttime="20190401 13:12:07.133"></status>
</kw>
<msg timestamp="20190401 13:12:07.134" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:07.134" starttime="20190401 13:12:06.472"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{volume_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:07.135" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:07.135" starttime="20190401 13:12:07.135"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:07.135" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:07.135" starttime="20190401 13:12:07.135"></status>
</kw>
<msg timestamp="20190401 13:12:07.135" level="INFO">@{volume_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:07.135" starttime="20190401 13:12:07.134"></status>
</kw>
<kw type="for" name="${volume} IN [ @{volume_list} ]">
<status status="PASS" endtime="20190401 13:12:07.136" starttime="20190401 13:12:07.135"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:07.136" starttime="20190401 13:12:06.472"></status>
</kw>
<kw name="Delete All Stacks" library="OpenStack">
<doc>Get a list of all existing stacks to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack stack list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:07.136" level="INFO">${openstack_cmd} = openstack stack list</msg>
<status status="PASS" endtime="20190401 13:12:07.136" starttime="20190401 13:12:07.136"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:07.137" level="INFO">${cmd} = openstack stack list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:07.137" starttime="20190401 13:12:07.136"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:07.137" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:07.137" starttime="20190401 13:12:07.137"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:07.138" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack stack list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:07.716" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:07.716" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:07.716" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:07.717" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:07.717" starttime="20190401 13:12:07.137"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:07.717" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:07.717" starttime="20190401 13:12:07.717"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:07.718" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:07.718" starttime="20190401 13:12:07.718"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:07.718" starttime="20190401 13:12:07.717"></status>
</kw>
<msg timestamp="20190401 13:12:07.718" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:07.718" starttime="20190401 13:12:07.137"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{stack_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:07.719" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:07.719" starttime="20190401 13:12:07.719"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:07.719" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:07.719" starttime="20190401 13:12:07.719"></status>
</kw>
<msg timestamp="20190401 13:12:07.720" level="INFO">@{stack_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:07.720" starttime="20190401 13:12:07.719"></status>
</kw>
<kw type="for" name="${stack} IN [ @{stack_list} ]">
<status status="PASS" endtime="20190401 13:12:07.720" starttime="20190401 13:12:07.720"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:07.720" starttime="20190401 13:12:07.136"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:07.720" starttime="20190401 13:12:02.678"></status>
</kw>
<kw name="Stx Suite TearDown" library="Utils">
<doc>Wrapper to clean up activities on the suite.</doc>
<kw name="Close All Connections" library="SSHLibrary">
<doc>Closes all open connections.</doc>
<status status="PASS" endtime="20190401 13:12:07.752" starttime="20190401 13:12:07.720"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:07.752" starttime="20190401 13:12:07.720"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:07.752" starttime="20190401 13:12:02.678">Several failures occurred:

1) Cloud openstack_helm was not found.

2) Cloud openstack_helm was not found.

3) Cloud openstack_helm was not found.

4) Cloud openstack_helm was not found.

5) Cloud openstack_helm was not found.

6) Cloud openstack_helm was not found.

7) Cloud openstack_helm was not found.

8) Cloud openstack_helm was not found.</status>
</kw>
<doc>Tests to create instances from an image, perform different
power status and set properties, using Cirros and Centos OS.
Author(s):
- Juan Carlos Alonso juan.carlos.alonso@intel.com</doc>
<status status="FAIL" endtime="20190401 13:12:07.753" starttime="20190401 13:11:52.947">Suite teardown failed:
Several failures occurred:

1) Cloud openstack_helm was not found.

2) Cloud openstack_helm was not found.

3) Cloud openstack_helm was not found.

4) Cloud openstack_helm was not found.

5) Cloud openstack_helm was not found.

6) Cloud openstack_helm was not found.

7) Cloud openstack_helm was not found.

8) Cloud openstack_helm was not found.</status>
</suite>
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Sanity-Test/Sanity-OpenStack/02-Instance-From-Volume.robot" id="s1-s1-s2" name="02-Instance-From-Volume">
<kw type="setup" name="Stx Suite Setup" library="Utils">
<doc>Wrapper to setup the environment needed for exercise
StarlingX features</doc>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190401 13:12:07.768" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:07.768" starttime="20190401 13:12:07.768"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190401 13:12:07.769" level="INFO">Length is 10</msg>
<msg timestamp="20190401 13:12:07.769" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190401 13:12:07.769" starttime="20190401 13:12:07.769"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190401 13:12:07.770" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190401 13:12:08.856" level="INFO">Read output: Last login: Mon Apr  1 19:00:39 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<status status="PASS" endtime="20190401 13:12:08.856" starttime="20190401 13:12:07.770"></status>
</kw>
<msg timestamp="20190401 13:12:08.856" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 13:12:08.856" starttime="20190401 13:12:07.769"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:08.856" starttime="20190401 13:12:07.769"></status>
</kw>
<msg timestamp="20190401 13:12:08.856" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:08.856" starttime="20190401 13:12:07.768"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:12:08.857" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:08.857" starttime="20190401 13:12:08.857"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:12:08.857" level="INFO">1</msg>
<status status="PASS" endtime="20190401 13:12:08.857" starttime="20190401 13:12:08.857"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:08.857" starttime="20190401 13:12:07.767"></status>
</kw>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:08.858" starttime="20190401 13:12:08.858"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:12:08.859" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:12:08.859" starttime="20190401 13:12:08.859"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:08.859" starttime="20190401 13:12:08.859"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:08.860" starttime="20190401 13:12:08.860"></status>
</kw>
<msg timestamp="20190401 13:12:08.860" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:12:08.860" starttime="20190401 13:12:08.859"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190401 13:12:08.860" starttime="20190401 13:12:08.860"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:12:08.864" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 13:12:08.864" starttime="20190401 13:12:08.860"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:12:09.232" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:12:09.233" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:09.233" starttime="20190401 13:12:08.864"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:12:09.233" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:09.233" starttime="20190401 13:12:09.233"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:12:09.234" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 13:12:09.234" starttime="20190401 13:12:09.234"></status>
</kw>
<msg timestamp="20190401 13:12:09.234" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:12:09.234" starttime="20190401 13:12:09.233"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:12:09.236" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:12:09.236" starttime="20190401 13:12:09.234"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:09.236" level="INFO">0</msg>
<msg timestamp="20190401 13:12:09.236" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:09.236" starttime="20190401 13:12:09.236"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:12:09.237" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:12:09.237" starttime="20190401 13:12:09.237"></status>
</kw>
<msg timestamp="20190401 13:12:09.237" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:09.237" starttime="20190401 13:12:09.234"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:09.238" starttime="20190401 13:12:09.238"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:09.238" starttime="20190401 13:12:09.237"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:09.238" starttime="20190401 13:12:09.238"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:12:09.238" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 13:12:09.239" starttime="20190401 13:12:09.238"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:09.239" starttime="20190401 13:12:08.858"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:09.239" starttime="20190401 13:12:08.857"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:09.239" starttime="20190401 13:12:07.767"></status>
</kw>
<test id="s1-s1-s2-t1" name="Create Flavors for Instances">
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${flavor_property_1}</arg>
<arg>${flavor_property_2}</arg>
</arguments>
<assign>
<var>${properties}</var>
</assign>
<msg timestamp="20190401 13:12:09.240" level="INFO">${properties} = --property sw:wrs:guest:heartbeat='false' --property hw:cpu_policy='shared'</msg>
<status status="PASS" endtime="20190401 13:12:09.240" starttime="20190401 13:12:09.239"></status>
</kw>
<kw name="Create Flavor" library="OpenStack">
<doc>Create a flavor with specified values.</doc>
<arguments>
<arg>${cirros_flavor_ram}</arg>
<arg>${cirros_flavor_vcpus}</arg>
<arg>${cirros_flavor_disk}</arg>
<arg>${cirros_flavor_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:09.240" level="INFO">${openstack_cmd} = openstack flavor create</msg>
<status status="PASS" endtime="20190401 13:12:09.240" starttime="20190401 13:12:09.240"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--ram ${ram}</arg>
<arg>--disk ${disk}</arg>
<arg>--vcpus ${vcpus}</arg>
<arg>--public</arg>
<arg>--id auto</arg>
<arg>${extra_args}</arg>
<arg>${name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:09.241" level="INFO">${cmd} = openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f1.small</msg>
<status status="PASS" endtime="20190401 13:12:09.241" starttime="20190401 13:12:09.241"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:09.242" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:09.242" starttime="20190401 13:12:09.241"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:09.242" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f1.small'.</msg>
<msg timestamp="20190401 13:12:09.820" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:09.820" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:09.821" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:09.821" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:09.821" starttime="20190401 13:12:09.242"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:09.821" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:09.821" starttime="20190401 13:12:09.821"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:09.822" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:09.822" starttime="20190401 13:12:09.822"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:09.822" starttime="20190401 13:12:09.822"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:09.822" starttime="20190401 13:12:09.241"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:09.822" starttime="20190401 13:12:09.240"></status>
</kw>
<doc>Create flavors with or without properties to be used
to launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:09.823" critical="yes" starttime="20190401 13:12:09.239">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t2" name="Create Images for Instances">
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/${cirros_image}</arg>
<arg>${host_image_path}/${cirros_image}</arg>
</arguments>
<msg timestamp="20190401 13:12:09.860" level="INFO">[chan 2] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:12:09.866" level="INFO">[chan 3] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:12:09.867" level="FAIL">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/cirros-0.4.0-x86_64-disk.qcow2'.</msg>
<status status="FAIL" endtime="20190401 13:12:09.867" starttime="20190401 13:12:09.823"></status>
</kw>
<doc>Create images with or without properties to be used
to launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:09.867" critical="yes" starttime="20190401 13:12:09.823">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/cirros-0.4.0-x86_64-disk.qcow2'.</status>
</test>
<test id="s1-s1-s2-t3" name="Create Networks for Instance">
<kw name="Create Network" library="OpenStack">
<doc>Create Network with openstack request.</doc>
<arguments>
<arg>${network_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:09.868" level="INFO">${openstack_cmd} = openstack network create</msg>
<status status="PASS" endtime="20190401 13:12:09.868" starttime="20190401 13:12:09.868"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>${network_name}</arg>
<arg>${additional_args}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:09.869" level="INFO">${cmd} = openstack network create network-1 </msg>
<status status="PASS" endtime="20190401 13:12:09.869" starttime="20190401 13:12:09.868"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:09.869" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:09.869" starttime="20190401 13:12:09.869"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:09.870" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network create network-1 '.</msg>
<msg timestamp="20190401 13:12:10.498" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:10.498" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:10.498" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:10.498" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:10.498" starttime="20190401 13:12:09.870"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:10.499" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:10.499" starttime="20190401 13:12:10.498"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:10.499" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:10.499" starttime="20190401 13:12:10.499"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:10.499" starttime="20190401 13:12:10.499"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:10.500" starttime="20190401 13:12:09.869"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:10.500" starttime="20190401 13:12:09.868"></status>
</kw>
<doc>Create networks to be used to launch Cirros
instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:10.500" critical="yes" starttime="20190401 13:12:09.867">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t4" name="Create Volume for Instances">
<kw name="Create Volume" library="OpenStack">
<doc>Create Volume.</doc>
<arguments>
<arg>${cirros_volume_size}</arg>
<arg>${cirros_image_name}</arg>
<arg>--bootable</arg>
<arg>${cirros_volume_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:10.501" level="INFO">${openstack_cmd} = openstack volume create</msg>
<status status="PASS" endtime="20190401 13:12:10.501" starttime="20190401 13:12:10.501"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--size ${size}</arg>
<arg>--image ${image}</arg>
<arg>${bootable}</arg>
<arg>${name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:10.502" level="INFO">${cmd} = openstack volume create --size 20 --image cirros --bootable vol-cirros-1</msg>
<status status="PASS" endtime="20190401 13:12:10.502" starttime="20190401 13:12:10.501"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:10.502" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:10.502" starttime="20190401 13:12:10.502"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:10.503" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume create --size 20 --image cirros --bootable vol-cirros-1'.</msg>
<msg timestamp="20190401 13:12:11.131" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:11.131" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:11.131" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:11.131" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:11.132" starttime="20190401 13:12:10.502"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:11.132" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:11.132" starttime="20190401 13:12:11.132"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:11.133" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:11.133" starttime="20190401 13:12:11.133"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:11.133" starttime="20190401 13:12:11.132"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:11.133" starttime="20190401 13:12:10.502"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:11.133" starttime="20190401 13:12:10.501"></status>
</kw>
<doc>Create volumes with or without properties to be used to
to launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:11.133" critical="yes" starttime="20190401 13:12:10.500">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t5" name="Launch Instances">
<kw name="Create Instance From Volume" library="OpenStack">
<doc>Create a VM Instances with the net id of the Netowrk
flavor and volume</doc>
<arguments>
<arg>${network_name}</arg>
<arg>${cirros_instance_name}</arg>
<arg>${cirros_volume_name}</arg>
<arg>${cirros_flavor_name}</arg>
</arguments>
<kw name="Get Net Id" library="OpenStack">
<doc>Retrieve the net id for the given network name</doc>
<arguments>
<arg>${net_name}</arg>
</arguments>
<assign>
<var>${net_id}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:11.135" level="INFO">${openstack_cmd} = openstack network list</msg>
<status status="PASS" endtime="20190401 13:12:11.135" starttime="20190401 13:12:11.135"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>grep "${network_name}"</arg>
<arg>awk '{print$2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:11.135" level="INFO">${cmd} = openstack network list|grep "network-1"|awk '{print$2}'</msg>
<status status="PASS" endtime="20190401 13:12:11.135" starttime="20190401 13:12:11.135"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:11.136" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:11.136" starttime="20190401 13:12:11.136"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:11.136" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network list|grep "network-1"|awk '{print$2}''.</msg>
<msg timestamp="20190401 13:12:11.714" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190401 13:12:11.714" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:11.714" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:11.714" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:11.715" starttime="20190401 13:12:11.136"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:11.715" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 0}</msg>
<status status="PASS" endtime="20190401 13:12:11.715" starttime="20190401 13:12:11.715"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:11.716" starttime="20190401 13:12:11.715"></status>
</kw>
<msg timestamp="20190401 13:12:11.716" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:12:11.716" starttime="20190401 13:12:11.135"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:12:11.716" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:12:11.716" starttime="20190401 13:12:11.716"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${output}</arg>
<arg>${EMPTY}</arg>
</arguments>
<assign>
<var>${splitted_output}</var>
</assign>
<msg timestamp="20190401 13:12:11.716" level="INFO">${splitted_output} = []</msg>
<status status="PASS" endtime="20190401 13:12:11.717" starttime="20190401 13:12:11.716"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${splitted_output}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${net_id}</var>
</assign>
<msg timestamp="20190401 13:12:11.717" level="FAIL">IndexError: Given index 0 is out of the range 0--1.</msg>
<status status="FAIL" endtime="20190401 13:12:11.717" starttime="20190401 13:12:11.717"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:11.717" starttime="20190401 13:12:11.134"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:11.717" starttime="20190401 13:12:11.134"></status>
</kw>
<doc>Launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:11.717" critical="yes" starttime="20190401 13:12:11.134">IndexError: Given index 0 is out of the range 0--1.</status>
</test>
<test id="s1-s1-s2-t6" name="Suspend Resume Instance">
<kw name="Suspend Instance" library="OpenStack">
<doc>Suspend the corresponding VM</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server suspend ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:11.719" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:11.719" starttime="20190401 13:12:11.719"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:11.719" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server suspend vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:12.378" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:12.378" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:12.378" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:12.378" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:12.378" starttime="20190401 13:12:11.719"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:12.379" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:12.379" starttime="20190401 13:12:12.378"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:12.380" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:12.380" starttime="20190401 13:12:12.379"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:12.380" starttime="20190401 13:12:12.379"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:12.381" starttime="20190401 13:12:11.718"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:12.381" starttime="20190401 13:12:11.718"></status>
</kw>
<doc>Suspend and Resume Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:12.381" critical="yes" starttime="20190401 13:12:11.718">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t7" name="Set Error Active Flags Instance">
<kw name="Set Error State Instance" library="OpenStack">
<doc>Set 'Error' value to the corresponding VM</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
<arg>error</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server set --state ${value} ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:12.382" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:12.382" starttime="20190401 13:12:12.382"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:12.383" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server set --state error vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:12.976" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:12.976" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:12.976" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:12.976" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:12.976" starttime="20190401 13:12:12.383"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:12.977" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:12.977" starttime="20190401 13:12:12.976"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:12.977" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:12.977" starttime="20190401 13:12:12.977"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:12.977" starttime="20190401 13:12:12.977"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:12.978" starttime="20190401 13:12:12.382"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:12.978" starttime="20190401 13:12:12.382"></status>
</kw>
<doc>Set 'Error' and 'Active' flags to Cirros
instance.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:12.978" critical="yes" starttime="20190401 13:12:12.381">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t8" name="Pause Unpause Instances">
<kw name="Pause Instance" library="OpenStack">
<doc>Pause an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server pause ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:12.979" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:12.979" starttime="20190401 13:12:12.979"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:12.980" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server pause vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:13.622" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:13.623" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:13.623" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:13.623" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:13.623" starttime="20190401 13:12:12.979"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:13.623" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:13.624" starttime="20190401 13:12:13.623"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:13.624" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:13.624" starttime="20190401 13:12:13.624"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:13.624" starttime="20190401 13:12:13.624"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:13.624" starttime="20190401 13:12:12.979"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:13.625" starttime="20190401 13:12:12.979"></status>
</kw>
<doc>Pause and Unpause Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:13.625" critical="yes" starttime="20190401 13:12:12.978">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t9" name="Stop Start Instances">
<kw name="Stop Instance" library="OpenStack">
<doc>Stop an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server stop ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:13.626" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:13.626" starttime="20190401 13:12:13.626"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:13.627" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server stop vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:14.255" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:14.255" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:14.255" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:14.255" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:14.255" starttime="20190401 13:12:13.626"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:14.256" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:14.256" starttime="20190401 13:12:14.255"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:14.257" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:14.257" starttime="20190401 13:12:14.256"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:14.257" starttime="20190401 13:12:14.256"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:14.257" starttime="20190401 13:12:13.626"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:14.257" starttime="20190401 13:12:13.625"></status>
</kw>
<doc>Stop and Start Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:14.258" critical="yes" starttime="20190401 13:12:13.625">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t10" name="Lock Unlock Instances">
<kw name="Lock Instance" library="OpenStack">
<doc>Lock an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server lock ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:14.259" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:14.259" starttime="20190401 13:12:14.259"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:14.259" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server lock vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:14.838" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:14.838" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:14.838" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:14.838" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:14.838" starttime="20190401 13:12:14.259"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:14.839" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:14.839" starttime="20190401 13:12:14.838"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:14.839" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:14.840" starttime="20190401 13:12:14.839"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:14.840" starttime="20190401 13:12:14.839"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:14.840" starttime="20190401 13:12:14.258"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:14.840" starttime="20190401 13:12:14.258"></status>
</kw>
<doc>Lock and Unlock Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:14.840" critical="yes" starttime="20190401 13:12:14.258">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t11" name="Reboot Instances">
<kw name="Reboot Instance" library="OpenStack">
<doc>Reboot an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server reboot ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:14.841" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:14.841" starttime="20190401 13:12:14.841"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:14.842" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server reboot vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:15.500" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:15.500" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:15.501" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:15.501" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:15.501" starttime="20190401 13:12:14.842"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:15.501" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:15.501" starttime="20190401 13:12:15.501"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:15.502" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:15.502" starttime="20190401 13:12:15.502"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:15.502" starttime="20190401 13:12:15.501"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:15.502" starttime="20190401 13:12:14.841"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:15.502" starttime="20190401 13:12:14.841"></status>
</kw>
<doc>Reboot Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:15.502" critical="yes" starttime="20190401 13:12:14.840">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t12" name="Rebuild Instances">
<kw name="Rebuild Instance From Volume" library="OpenStack">
<doc>Rebuild an instance from volume</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
<arg>${cirros_image_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server rebuild --image ${image} ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:15.504" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:15.504" starttime="20190401 13:12:15.504"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:15.504" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server rebuild --image cirros vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:16.133" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:16.133" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:16.133" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:16.133" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:16.133" starttime="20190401 13:12:15.504"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:16.134" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:16.134" starttime="20190401 13:12:16.133"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:16.135" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:16.135" starttime="20190401 13:12:16.134"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:16.135" starttime="20190401 13:12:16.134"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:16.135" starttime="20190401 13:12:15.503"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:16.135" starttime="20190401 13:12:15.503"></status>
</kw>
<doc>Rebuild Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:16.135" critical="yes" starttime="20190401 13:12:15.503">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t13" name="Resize Instances">
<kw name="Create Flavor" library="OpenStack">
<doc>Create a flavor with specified values.</doc>
<arguments>
<arg>${cirros_flavor_ram}</arg>
<arg>${cirros_flavor_vcpus}</arg>
<arg>${cirros_flavor_disk}</arg>
<arg>${cirros_flavor_name_2}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:16.136" level="INFO">${openstack_cmd} = openstack flavor create</msg>
<status status="PASS" endtime="20190401 13:12:16.136" starttime="20190401 13:12:16.136"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--ram ${ram}</arg>
<arg>--disk ${disk}</arg>
<arg>--vcpus ${vcpus}</arg>
<arg>--public</arg>
<arg>--id auto</arg>
<arg>${extra_args}</arg>
<arg>${name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:16.137" level="INFO">${cmd} = openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f2.small</msg>
<status status="PASS" endtime="20190401 13:12:16.137" starttime="20190401 13:12:16.137"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:16.138" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:16.138" starttime="20190401 13:12:16.137"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:16.138" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f2.small'.</msg>
<msg timestamp="20190401 13:12:16.766" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:16.766" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:16.766" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:16.766" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:16.766" starttime="20190401 13:12:16.138"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:16.767" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:16.767" starttime="20190401 13:12:16.767"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:16.768" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:16.768" starttime="20190401 13:12:16.768"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:16.768" starttime="20190401 13:12:16.767"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:16.768" starttime="20190401 13:12:16.137"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:16.768" starttime="20190401 13:12:16.136"></status>
</kw>
<doc>Resize Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:16.768" critical="yes" starttime="20190401 13:12:16.135">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t14" name="Set Unset Properties Instances">
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${instance_property_1}='true'</arg>
<arg>${instance_property_2}='500'</arg>
<arg>${instance_property_3}='180'</arg>
</arguments>
<assign>
<var>${properties}</var>
</assign>
<msg timestamp="20190401 13:12:16.769" level="INFO">${properties} = --property sw:wrs:auto_recovery='true' --property hw:wrs:live_migration_max_downtime='500' --property hw:wrs:live_migration_timeout='180'</msg>
<status status="PASS" endtime="20190401 13:12:16.769" starttime="20190401 13:12:16.769"></status>
</kw>
<kw name="Set Instance Property" library="OpenStack">
<doc>Set properties of an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
<arg>${properties}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server set ${key} ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:16.770" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:16.770" starttime="20190401 13:12:16.770"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:16.771" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server set --property sw:wrs:auto_recovery='true' --property hw:wrs:live_migration_max_downtime='500' --property hw:wrs:live_migration_timeout='180' vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:17.399" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:17.399" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:17.399" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:17.399" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:17.399" starttime="20190401 13:12:16.771"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:17.400" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:17.400" starttime="20190401 13:12:17.399"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:17.401" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:17.401" starttime="20190401 13:12:17.400"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:17.401" starttime="20190401 13:12:17.400"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:17.401" starttime="20190401 13:12:16.770"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:17.401" starttime="20190401 13:12:16.770"></status>
</kw>
<doc>Set Unset properties of Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:17.401" critical="yes" starttime="20190401 13:12:16.769">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s2-t15" name="Evacuate Instances From Hosts">
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}' == 'Duplex'</arg>
<arg>Run Keywords</arg>
<arg>Evacuate Instances</arg>
<arg>controller-0</arg>
<arg>AND</arg>
<arg>Evacuate Instances</arg>
<arg>controller-1</arg>
<arg>ELSE IF</arg>
<arg>'${CONFIGURATION_TYPE}' == 'MN-Local' or '${CONFIGURATION_TYPE}' == 'MN-External'</arg>
<arg>Run Keywords</arg>
<arg>Evacuate Instances</arg>
<arg>compute-0</arg>
<arg>AND</arg>
<arg>Evacuate Instances</arg>
<arg>compute-1</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Evacuate Instances</arg>
<arg>controller-0</arg>
<arg>AND</arg>
<arg>Evacuate Instances</arg>
<arg>controller-1</arg>
</arguments>
<kw name="Evacuate Instances" library="OpenStack">
<doc>Evacuate all VMs from computes or from controllers.</doc>
<arguments>
<arg>controller-0</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack compute service set</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:17.403" level="INFO">${openstack_cmd} = openstack compute service set</msg>
<status status="PASS" endtime="20190401 13:12:17.403" starttime="20190401 13:12:17.403"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--disable</arg>
<arg>--disable-reason test-evacuate</arg>
<arg>${host}</arg>
<arg>nova-compute</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:17.404" level="INFO">${cmd} = openstack compute service set --disable --disable-reason test-evacuate controller-0 nova-compute</msg>
<status status="PASS" endtime="20190401 13:12:17.404" starttime="20190401 13:12:17.403"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:17.404" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:17.404" starttime="20190401 13:12:17.404"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:17.405" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack compute service set --disable --disable-reason test-evacuate controller-0 nova-compute'.</msg>
<msg timestamp="20190401 13:12:18.033" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:18.033" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:18.033" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:18.033" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:18.033" starttime="20190401 13:12:17.404"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:18.034" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:18.034" starttime="20190401 13:12:18.033"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:18.034" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:18.034" starttime="20190401 13:12:18.034"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:18.034" starttime="20190401 13:12:18.034"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:18.035" starttime="20190401 13:12:17.404"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:18.035" starttime="20190401 13:12:17.403"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:18.035" starttime="20190401 13:12:17.402"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:18.035" starttime="20190401 13:12:17.402"></status>
</kw>
<doc>Evacuate all Cirros instances from computes
or controllers.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:18.035" critical="yes" starttime="20190401 13:12:17.402">Cloud openstack_helm was not found.</status>
</test>
<kw type="teardown" name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>OpenStack.Openstack Cleanup All</arg>
<arg>Utils.Stx Suite TearDown</arg>
</arguments>
<kw name="Openstack Cleanup All" library="OpenStack">
<doc>Delete all instances, images, flavors, networks and
keypairs generated during tests.</doc>
<kw name="Delete All Instances" library="OpenStack">
<doc>Get a list of all existing instances to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack server list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:18.037" level="INFO">${openstack_cmd} = openstack server list</msg>
<status status="PASS" endtime="20190401 13:12:18.037" starttime="20190401 13:12:18.037"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:18.037" level="INFO">${cmd} = openstack server list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:18.037" starttime="20190401 13:12:18.037"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:18.038" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:18.038" starttime="20190401 13:12:18.038"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:18.038" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:18.666" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:18.666" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:18.667" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:18.667" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:18.667" starttime="20190401 13:12:18.038"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:18.667" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:18.667" starttime="20190401 13:12:18.667"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:18.668" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:18.668" starttime="20190401 13:12:18.668"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:18.668" starttime="20190401 13:12:18.667"></status>
</kw>
<msg timestamp="20190401 13:12:18.668" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:18.668" starttime="20190401 13:12:18.037"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{vm_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:18.669" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:18.669" starttime="20190401 13:12:18.669"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:18.669" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:18.669" starttime="20190401 13:12:18.669"></status>
</kw>
<msg timestamp="20190401 13:12:18.670" level="INFO">@{vm_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:18.670" starttime="20190401 13:12:18.669"></status>
</kw>
<kw type="for" name="${vm} IN [ @{vm_list} ]">
<status status="PASS" endtime="20190401 13:12:18.670" starttime="20190401 13:12:18.670"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:18.670" starttime="20190401 13:12:18.036"></status>
</kw>
<kw name="Delete All Images" library="OpenStack">
<doc>Get a list of all existing images to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack image list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:18.670" level="INFO">${openstack_cmd} = openstack image list</msg>
<status status="PASS" endtime="20190401 13:12:18.670" starttime="20190401 13:12:18.670"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "Cirros"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:18.671" level="INFO">${cmd} = openstack image list|awk '{print$4}'|grep -v "Name"|grep -v "Cirros"</msg>
<status status="PASS" endtime="20190401 13:12:18.671" starttime="20190401 13:12:18.670"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:18.671" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:18.671" starttime="20190401 13:12:18.671"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:18.672" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack image list|awk '{print$4}'|grep -v "Name"|grep -v "Cirros"'.</msg>
<msg timestamp="20190401 13:12:19.300" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:19.300" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:19.300" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:19.300" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:19.300" starttime="20190401 13:12:18.672"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:19.301" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:19.301" starttime="20190401 13:12:19.300"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:19.301" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:19.302" starttime="20190401 13:12:19.301"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:19.302" starttime="20190401 13:12:19.301"></status>
</kw>
<msg timestamp="20190401 13:12:19.302" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:19.302" starttime="20190401 13:12:18.671"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{image_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:19.303" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:19.303" starttime="20190401 13:12:19.302"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:19.303" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:19.303" starttime="20190401 13:12:19.303"></status>
</kw>
<msg timestamp="20190401 13:12:19.303" level="INFO">@{image_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:19.303" starttime="20190401 13:12:19.302"></status>
</kw>
<kw type="for" name="${image} IN [ @{image_list} ]">
<status status="PASS" endtime="20190401 13:12:19.303" starttime="20190401 13:12:19.303"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:19.303" starttime="20190401 13:12:18.670"></status>
</kw>
<kw name="Delete All Flavors" library="OpenStack">
<doc>Get a list of all existing flavors to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:19.304" level="INFO">${openstack_cmd} = openstack flavor list</msg>
<status status="PASS" endtime="20190401 13:12:19.304" starttime="20190401 13:12:19.304"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "m1"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:19.304" level="INFO">${cmd} = openstack flavor list|awk '{print$4}'|grep -v "Name"|grep -v "m1"</msg>
<status status="PASS" endtime="20190401 13:12:19.304" starttime="20190401 13:12:19.304"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:19.305" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:19.305" starttime="20190401 13:12:19.305"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:19.305" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor list|awk '{print$4}'|grep -v "Name"|grep -v "m1"'.</msg>
<msg timestamp="20190401 13:12:19.933" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:19.933" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:19.934" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:19.934" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:19.934" starttime="20190401 13:12:19.305"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:19.934" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:19.934" starttime="20190401 13:12:19.934"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:19.935" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:19.935" starttime="20190401 13:12:19.935"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:19.935" starttime="20190401 13:12:19.934"></status>
</kw>
<msg timestamp="20190401 13:12:19.935" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:19.935" starttime="20190401 13:12:19.304"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{flavor_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:19.936" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:19.936" starttime="20190401 13:12:19.936"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:19.936" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:19.936" starttime="20190401 13:12:19.936"></status>
</kw>
<msg timestamp="20190401 13:12:19.937" level="INFO">@{flavor_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:19.937" starttime="20190401 13:12:19.936"></status>
</kw>
<kw type="for" name="${flavor} IN [ @{flavor_list} ]">
<status status="PASS" endtime="20190401 13:12:19.937" starttime="20190401 13:12:19.937"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:19.937" starttime="20190401 13:12:19.303"></status>
</kw>
<kw name="Delete All Networks" library="OpenStack">
<doc>Get a list of all existing networks to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:19.937" level="INFO">${openstack_cmd} = openstack network list</msg>
<status status="PASS" endtime="20190401 13:12:19.937" starttime="20190401 13:12:19.937"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "private"</arg>
<arg>grep -v "public"</arg>
<arg>grep -v "external"</arg>
<arg>grep -v "internal"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:19.938" level="INFO">${cmd} = openstack network list|awk '{print$4}'|grep -v "Name"|grep -v "private"|grep -v "public"|grep -v "external"|grep -v "internal"</msg>
<status status="PASS" endtime="20190401 13:12:19.938" starttime="20190401 13:12:19.937"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:19.939" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:19.939" starttime="20190401 13:12:19.938"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:19.939" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network list|awk '{print$4}'|grep -v "Name"|grep -v "private"|grep -v "public"|grep -v "external"|grep -v "internal"'.</msg>
<msg timestamp="20190401 13:12:20.567" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:20.567" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:20.567" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:20.567" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:20.567" starttime="20190401 13:12:19.939"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:20.568" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:20.568" starttime="20190401 13:12:20.567"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:20.569" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:20.569" starttime="20190401 13:12:20.568"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:20.569" starttime="20190401 13:12:20.568"></status>
</kw>
<msg timestamp="20190401 13:12:20.569" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:20.569" starttime="20190401 13:12:19.938"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{network_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:20.570" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:20.570" starttime="20190401 13:12:20.569"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:20.570" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:20.570" starttime="20190401 13:12:20.570"></status>
</kw>
<msg timestamp="20190401 13:12:20.570" level="INFO">@{network_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:20.570" starttime="20190401 13:12:20.569"></status>
</kw>
<kw type="for" name="${network} IN [ @{network_list} ]">
<status status="PASS" endtime="20190401 13:12:20.570" starttime="20190401 13:12:20.570"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:20.570" starttime="20190401 13:12:19.937"></status>
</kw>
<kw name="Delete All KeyPairs" library="OpenStack">
<doc>Get a list of all existing keypais to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack keypair list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:20.571" level="INFO">${openstack_cmd} = openstack keypair list</msg>
<status status="PASS" endtime="20190401 13:12:20.571" starttime="20190401 13:12:20.571"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$2}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:20.571" level="INFO">${cmd} = openstack keypair list|awk '{print$2}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:20.571" starttime="20190401 13:12:20.571"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:20.572" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:20.572" starttime="20190401 13:12:20.572"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:20.572" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack keypair list|awk '{print$2}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:21.151" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:21.151" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:21.151" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:21.151" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:21.151" starttime="20190401 13:12:20.572"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:21.152" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:21.152" starttime="20190401 13:12:21.151"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:21.153" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:21.153" starttime="20190401 13:12:21.152"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:21.153" starttime="20190401 13:12:21.152"></status>
</kw>
<msg timestamp="20190401 13:12:21.153" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:21.153" starttime="20190401 13:12:20.571"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{key_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:21.154" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:21.154" starttime="20190401 13:12:21.153"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:21.154" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:21.154" starttime="20190401 13:12:21.154"></status>
</kw>
<msg timestamp="20190401 13:12:21.154" level="INFO">@{key_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:21.154" starttime="20190401 13:12:21.153"></status>
</kw>
<kw type="for" name="${key} IN [ @{key_list} ]">
<status status="PASS" endtime="20190401 13:12:21.154" starttime="20190401 13:12:21.154"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:21.154" starttime="20190401 13:12:20.571"></status>
</kw>
<kw name="Delete All Snapshots" library="OpenStack">
<doc>Get a list of all existing snapshots to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume snapshot list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:21.155" level="INFO">${openstack_cmd} = openstack volume snapshot list</msg>
<status status="PASS" endtime="20190401 13:12:21.155" starttime="20190401 13:12:21.155"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:21.155" level="INFO">${cmd} = openstack volume snapshot list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:21.155" starttime="20190401 13:12:21.155"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:21.156" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:21.156" starttime="20190401 13:12:21.156"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:21.156" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume snapshot list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:21.815" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:21.816" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:21.816" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:21.816" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:21.816" starttime="20190401 13:12:21.156"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:21.816" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:21.816" starttime="20190401 13:12:21.816"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:21.817" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:21.817" starttime="20190401 13:12:21.817"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:21.817" starttime="20190401 13:12:21.816"></status>
</kw>
<msg timestamp="20190401 13:12:21.817" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:21.817" starttime="20190401 13:12:21.155"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{snapshot_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:21.818" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:21.818" starttime="20190401 13:12:21.818"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:21.818" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:21.818" starttime="20190401 13:12:21.818"></status>
</kw>
<msg timestamp="20190401 13:12:21.819" level="INFO">@{snapshot_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:21.819" starttime="20190401 13:12:21.818"></status>
</kw>
<kw type="for" name="${snapshot} IN [ @{snapshot_list} ]">
<status status="PASS" endtime="20190401 13:12:21.819" starttime="20190401 13:12:21.819"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:21.819" starttime="20190401 13:12:21.155"></status>
</kw>
<kw name="Delete All Volumes" library="OpenStack">
<doc>Get a list of all existing volumes to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:21.819" level="INFO">${openstack_cmd} = openstack volume list</msg>
<status status="PASS" endtime="20190401 13:12:21.820" starttime="20190401 13:12:21.819"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$2}'</arg>
<arg>grep -v "ID"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:21.820" level="INFO">${cmd} = openstack volume list|awk '{print$2}'|grep -v "ID"</msg>
<status status="PASS" endtime="20190401 13:12:21.820" starttime="20190401 13:12:21.820"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:21.820" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:21.820" starttime="20190401 13:12:21.820"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:21.821" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume list|awk '{print$2}'|grep -v "ID"'.</msg>
<msg timestamp="20190401 13:12:22.449" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:22.449" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:22.449" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:22.449" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:22.449" starttime="20190401 13:12:21.821"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:22.450" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:22.450" starttime="20190401 13:12:22.450"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:22.451" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:22.451" starttime="20190401 13:12:22.450"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:22.451" starttime="20190401 13:12:22.450"></status>
</kw>
<msg timestamp="20190401 13:12:22.451" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:22.451" starttime="20190401 13:12:21.820"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{volume_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:22.452" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:22.452" starttime="20190401 13:12:22.452"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:22.452" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:22.452" starttime="20190401 13:12:22.452"></status>
</kw>
<msg timestamp="20190401 13:12:22.452" level="INFO">@{volume_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:22.452" starttime="20190401 13:12:22.451"></status>
</kw>
<kw type="for" name="${volume} IN [ @{volume_list} ]">
<status status="PASS" endtime="20190401 13:12:22.452" starttime="20190401 13:12:22.452"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:22.453" starttime="20190401 13:12:21.819"></status>
</kw>
<kw name="Delete All Stacks" library="OpenStack">
<doc>Get a list of all existing stacks to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack stack list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:22.453" level="INFO">${openstack_cmd} = openstack stack list</msg>
<status status="PASS" endtime="20190401 13:12:22.453" starttime="20190401 13:12:22.453"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:22.453" level="INFO">${cmd} = openstack stack list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:22.453" starttime="20190401 13:12:22.453"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:22.454" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:22.454" starttime="20190401 13:12:22.454"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:22.455" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack stack list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:23.033" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:23.033" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:23.033" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:23.033" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:23.033" starttime="20190401 13:12:22.454"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:23.034" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:23.034" starttime="20190401 13:12:23.033"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:23.034" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:23.034" starttime="20190401 13:12:23.034"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:23.034" starttime="20190401 13:12:23.034"></status>
</kw>
<msg timestamp="20190401 13:12:23.035" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:23.035" starttime="20190401 13:12:22.454"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{stack_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:23.035" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:23.035" starttime="20190401 13:12:23.035"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:23.036" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:23.036" starttime="20190401 13:12:23.036"></status>
</kw>
<msg timestamp="20190401 13:12:23.036" level="INFO">@{stack_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:23.036" starttime="20190401 13:12:23.035"></status>
</kw>
<kw type="for" name="${stack} IN [ @{stack_list} ]">
<status status="PASS" endtime="20190401 13:12:23.036" starttime="20190401 13:12:23.036"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:23.036" starttime="20190401 13:12:22.453"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:23.036" starttime="20190401 13:12:18.036"></status>
</kw>
<kw name="Stx Suite TearDown" library="Utils">
<doc>Wrapper to clean up activities on the suite.</doc>
<kw name="Close All Connections" library="SSHLibrary">
<doc>Closes all open connections.</doc>
<status status="PASS" endtime="20190401 13:12:23.069" starttime="20190401 13:12:23.037"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:23.069" starttime="20190401 13:12:23.037"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:23.069" starttime="20190401 13:12:18.036">Several failures occurred:

1) Cloud openstack_helm was not found.

2) Cloud openstack_helm was not found.

3) Cloud openstack_helm was not found.

4) Cloud openstack_helm was not found.

5) Cloud openstack_helm was not found.

6) Cloud openstack_helm was not found.

7) Cloud openstack_helm was not found.

8) Cloud openstack_helm was not found.</status>
</kw>
<doc>Tests to create instances from volume, perform different
power status and set properties, using Cirros OS.
Author(s):
- Juan Carlos Alonso juan.carlos.alonso@intel.com</doc>
<status status="FAIL" endtime="20190401 13:12:23.069" starttime="20190401 13:12:07.755">Suite teardown failed:
Several failures occurred:

1) Cloud openstack_helm was not found.

2) Cloud openstack_helm was not found.

3) Cloud openstack_helm was not found.

4) Cloud openstack_helm was not found.

5) Cloud openstack_helm was not found.

6) Cloud openstack_helm was not found.

7) Cloud openstack_helm was not found.

8) Cloud openstack_helm was not found.</status>
</suite>
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Sanity-Test/Sanity-OpenStack/03-Instance-From-Snapshot.robot" id="s1-s1-s3" name="03-Instance-From-Snapshot">
<kw type="setup" name="Stx Suite Setup" library="Utils">
<doc>Wrapper to setup the environment needed for exercise
StarlingX features</doc>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190401 13:12:23.085" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:23.085" starttime="20190401 13:12:23.084"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190401 13:12:23.085" level="INFO">Length is 10</msg>
<msg timestamp="20190401 13:12:23.085" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190401 13:12:23.085" starttime="20190401 13:12:23.085"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190401 13:12:23.086" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190401 13:12:24.176" level="INFO">Read output: Last login: Mon Apr  1 19:00:53 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<status status="PASS" endtime="20190401 13:12:24.176" starttime="20190401 13:12:23.086"></status>
</kw>
<msg timestamp="20190401 13:12:24.176" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 13:12:24.177" starttime="20190401 13:12:23.085"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:24.177" starttime="20190401 13:12:23.085"></status>
</kw>
<msg timestamp="20190401 13:12:24.177" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:24.177" starttime="20190401 13:12:23.084"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:12:24.177" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:24.177" starttime="20190401 13:12:24.177"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:12:24.178" level="INFO">1</msg>
<status status="PASS" endtime="20190401 13:12:24.178" starttime="20190401 13:12:24.177"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:24.178" starttime="20190401 13:12:23.084"></status>
</kw>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:24.179" starttime="20190401 13:12:24.178"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:12:24.179" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:12:24.179" starttime="20190401 13:12:24.179"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:24.180" starttime="20190401 13:12:24.180"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:24.180" starttime="20190401 13:12:24.180"></status>
</kw>
<msg timestamp="20190401 13:12:24.180" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:12:24.180" starttime="20190401 13:12:24.179"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190401 13:12:24.181" starttime="20190401 13:12:24.180"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:12:24.185" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 13:12:24.185" starttime="20190401 13:12:24.181"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:12:24.553" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:12:24.553" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:24.553" starttime="20190401 13:12:24.185"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:12:24.554" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:24.554" starttime="20190401 13:12:24.554"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:12:24.554" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 13:12:24.554" starttime="20190401 13:12:24.554"></status>
</kw>
<msg timestamp="20190401 13:12:24.554" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:12:24.554" starttime="20190401 13:12:24.553"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:12:24.556" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:12:24.556" starttime="20190401 13:12:24.555"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:24.557" level="INFO">0</msg>
<msg timestamp="20190401 13:12:24.557" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:24.557" starttime="20190401 13:12:24.557"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:12:24.557" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:12:24.557" starttime="20190401 13:12:24.557"></status>
</kw>
<msg timestamp="20190401 13:12:24.557" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:24.558" starttime="20190401 13:12:24.554"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:24.558" starttime="20190401 13:12:24.558"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:24.558" starttime="20190401 13:12:24.558"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:24.559" starttime="20190401 13:12:24.558"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:12:24.559" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 13:12:24.559" starttime="20190401 13:12:24.559"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:24.559" starttime="20190401 13:12:24.178"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:24.559" starttime="20190401 13:12:24.178"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:24.559" starttime="20190401 13:12:23.083"></status>
</kw>
<test id="s1-s1-s3-t1" name="Create Flavors for Instances">
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${flavor_property_1}</arg>
<arg>${flavor_property_2}</arg>
</arguments>
<assign>
<var>${properties}</var>
</assign>
<msg timestamp="20190401 13:12:24.560" level="INFO">${properties} = --property sw:wrs:guest:heartbeat='false' --property hw:cpu_policy='shared'</msg>
<status status="PASS" endtime="20190401 13:12:24.560" starttime="20190401 13:12:24.560"></status>
</kw>
<kw name="Create Flavor" library="OpenStack">
<doc>Create a flavor with specified values.</doc>
<arguments>
<arg>${cirros_flavor_ram}</arg>
<arg>${cirros_flavor_vcpus}</arg>
<arg>${cirros_flavor_disk}</arg>
<arg>${cirros_flavor_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:24.561" level="INFO">${openstack_cmd} = openstack flavor create</msg>
<status status="PASS" endtime="20190401 13:12:24.561" starttime="20190401 13:12:24.561"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--ram ${ram}</arg>
<arg>--disk ${disk}</arg>
<arg>--vcpus ${vcpus}</arg>
<arg>--public</arg>
<arg>--id auto</arg>
<arg>${extra_args}</arg>
<arg>${name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:24.561" level="INFO">${cmd} = openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f1.small</msg>
<status status="PASS" endtime="20190401 13:12:24.561" starttime="20190401 13:12:24.561"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:24.562" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:24.562" starttime="20190401 13:12:24.562"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:24.562" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f1.small'.</msg>
<msg timestamp="20190401 13:12:25.140" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:25.141" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:25.141" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:25.141" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:25.141" starttime="20190401 13:12:24.562"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:25.141" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:25.141" starttime="20190401 13:12:25.141"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:25.142" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:25.142" starttime="20190401 13:12:25.142"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:25.142" starttime="20190401 13:12:25.142"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:25.142" starttime="20190401 13:12:24.561"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:25.142" starttime="20190401 13:12:24.560"></status>
</kw>
<doc>Create flavors with or without properties to be used
to launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:25.143" critical="yes" starttime="20190401 13:12:24.559">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t2" name="Create Images for Instances">
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/${cirros_image}</arg>
<arg>${host_image_path}/${cirros_image}</arg>
</arguments>
<msg timestamp="20190401 13:12:25.181" level="INFO">[chan 2] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:12:25.187" level="INFO">[chan 3] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:12:25.189" level="FAIL">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/cirros-0.4.0-x86_64-disk.qcow2'.</msg>
<status status="FAIL" endtime="20190401 13:12:25.189" starttime="20190401 13:12:25.143"></status>
</kw>
<doc>Create images with or without properties to be used
to launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:25.189" critical="yes" starttime="20190401 13:12:25.143">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/cirros-0.4.0-x86_64-disk.qcow2'.</status>
</test>
<test id="s1-s1-s3-t3" name="Create Networks for Instance">
<kw name="Create Network" library="OpenStack">
<doc>Create Network with openstack request.</doc>
<arguments>
<arg>${network_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:25.190" level="INFO">${openstack_cmd} = openstack network create</msg>
<status status="PASS" endtime="20190401 13:12:25.190" starttime="20190401 13:12:25.190"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>${network_name}</arg>
<arg>${additional_args}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:25.190" level="INFO">${cmd} = openstack network create network-1 </msg>
<status status="PASS" endtime="20190401 13:12:25.190" starttime="20190401 13:12:25.190"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:25.191" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:25.191" starttime="20190401 13:12:25.191"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:25.192" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network create network-1 '.</msg>
<msg timestamp="20190401 13:12:25.770" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:25.770" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:25.770" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:25.770" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:25.770" starttime="20190401 13:12:25.191"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:25.771" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:25.771" starttime="20190401 13:12:25.770"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:25.772" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:25.772" starttime="20190401 13:12:25.771"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:25.772" starttime="20190401 13:12:25.771"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:25.772" starttime="20190401 13:12:25.191"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:25.772" starttime="20190401 13:12:25.190"></status>
</kw>
<doc>Create networks to be used to launch Cirros and Centos
instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:25.772" critical="yes" starttime="20190401 13:12:25.189">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t4" name="Create Volume for Instances">
<kw name="Create Volume" library="OpenStack">
<doc>Create Volume.</doc>
<arguments>
<arg>${cirros_volume_size}</arg>
<arg>${cirros_image_name}</arg>
<arg>--bootable</arg>
<arg>${cirros_volume_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:25.773" level="INFO">${openstack_cmd} = openstack volume create</msg>
<status status="PASS" endtime="20190401 13:12:25.773" starttime="20190401 13:12:25.773"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--size ${size}</arg>
<arg>--image ${image}</arg>
<arg>${bootable}</arg>
<arg>${name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:25.774" level="INFO">${cmd} = openstack volume create --size 20 --image cirros --bootable vol-cirros-1</msg>
<status status="PASS" endtime="20190401 13:12:25.774" starttime="20190401 13:12:25.773"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:25.774" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:25.774" starttime="20190401 13:12:25.774"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:25.775" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume create --size 20 --image cirros --bootable vol-cirros-1'.</msg>
<msg timestamp="20190401 13:12:26.433" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:26.433" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:26.433" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:26.433" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:26.433" starttime="20190401 13:12:25.774"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:26.434" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:26.434" starttime="20190401 13:12:26.434"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:26.435" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:26.435" starttime="20190401 13:12:26.435"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:26.435" starttime="20190401 13:12:26.434"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:26.435" starttime="20190401 13:12:25.774"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:26.435" starttime="20190401 13:12:25.773"></status>
</kw>
<doc>Create volumes with or without properties to be used
to launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:26.435" critical="yes" starttime="20190401 13:12:25.772">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t5" name="Create Snapshot for Instance">
<kw name="Create Snapshot" library="OpenStack">
<doc>Create Snapshot.</doc>
<arguments>
<arg>${cirros_volume_name}</arg>
<arg>${cirros_snapshot_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack volume snapshot create --volume ${volume} ${name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:26.437" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:26.437" starttime="20190401 13:12:26.437"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:26.438" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume snapshot create --volume vol-cirros-1 snap-cirros-1'.</msg>
<msg timestamp="20190401 13:12:27.066" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:27.066" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:27.066" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:27.066" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:27.066" starttime="20190401 13:12:26.437"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:27.067" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:27.067" starttime="20190401 13:12:27.066"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:27.067" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:27.067" starttime="20190401 13:12:27.067"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:27.067" starttime="20190401 13:12:27.067"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:27.067" starttime="20190401 13:12:26.436"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:27.068" starttime="20190401 13:12:26.436"></status>
</kw>
<doc>Create snapshots with or without properties to be used
to launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:27.068" critical="yes" starttime="20190401 13:12:26.436">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t6" name="Launch Instances">
<kw name="Create Instance From Snapshot" library="OpenStack">
<doc>Create a VM Instances with the net id of the Netowrk
flavor and snapshot</doc>
<arguments>
<arg>${network_name}</arg>
<arg>${cirros_image_name}</arg>
<arg>${cirros_instance_name}</arg>
<arg>${cirros_snapshot_name}</arg>
<arg>${cirros_snapshot_size}</arg>
<arg>${cirros_flavor_name}</arg>
</arguments>
<kw name="Get Net Id" library="OpenStack">
<doc>Retrieve the net id for the given network name</doc>
<arguments>
<arg>${net_name}</arg>
</arguments>
<assign>
<var>${net_id}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:27.069" level="INFO">${openstack_cmd} = openstack network list</msg>
<status status="PASS" endtime="20190401 13:12:27.069" starttime="20190401 13:12:27.069"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>grep "${network_name}"</arg>
<arg>awk '{print$2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:27.070" level="INFO">${cmd} = openstack network list|grep "network-1"|awk '{print$2}'</msg>
<status status="PASS" endtime="20190401 13:12:27.070" starttime="20190401 13:12:27.070"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:27.070" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:27.070" starttime="20190401 13:12:27.070"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:27.071" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network list|grep "network-1"|awk '{print$2}''.</msg>
<msg timestamp="20190401 13:12:27.663" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190401 13:12:27.663" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:27.663" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:27.663" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:27.663" starttime="20190401 13:12:27.071"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:27.664" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 0}</msg>
<status status="PASS" endtime="20190401 13:12:27.664" starttime="20190401 13:12:27.664"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:27.664" starttime="20190401 13:12:27.664"></status>
</kw>
<msg timestamp="20190401 13:12:27.665" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:12:27.665" starttime="20190401 13:12:27.070"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:12:27.665" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:12:27.665" starttime="20190401 13:12:27.665"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${output}</arg>
<arg>${EMPTY}</arg>
</arguments>
<assign>
<var>${splitted_output}</var>
</assign>
<msg timestamp="20190401 13:12:27.665" level="INFO">${splitted_output} = []</msg>
<status status="PASS" endtime="20190401 13:12:27.665" starttime="20190401 13:12:27.665"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${splitted_output}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${net_id}</var>
</assign>
<msg timestamp="20190401 13:12:27.666" level="FAIL">IndexError: Given index 0 is out of the range 0--1.</msg>
<status status="FAIL" endtime="20190401 13:12:27.666" starttime="20190401 13:12:27.666"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:27.666" starttime="20190401 13:12:27.069"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:27.666" starttime="20190401 13:12:27.069"></status>
</kw>
<doc>Launch Cirros instances from snapshot.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:27.666" critical="yes" starttime="20190401 13:12:27.068">IndexError: Given index 0 is out of the range 0--1.</status>
</test>
<test id="s1-s1-s3-t7" name="Suspend Resume Instances">
<kw name="Suspend Instance" library="OpenStack">
<doc>Suspend the corresponding VM</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server suspend ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:27.668" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:27.668" starttime="20190401 13:12:27.667"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:27.668" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server suspend vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:28.310" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:28.310" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:28.310" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:28.311" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:28.311" starttime="20190401 13:12:27.668"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:28.311" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:28.311" starttime="20190401 13:12:28.311"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:28.312" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:28.312" starttime="20190401 13:12:28.312"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:28.312" starttime="20190401 13:12:28.311"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:28.312" starttime="20190401 13:12:27.667"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:28.313" starttime="20190401 13:12:27.667"></status>
</kw>
<doc>Suspend and Resume Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:28.313" critical="yes" starttime="20190401 13:12:27.666">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t8" name="Set Error Active Flags Instances">
<kw name="Set Error State Instance" library="OpenStack">
<doc>Set 'Error' value to the corresponding VM</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
<arg>error</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server set --state ${value} ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:28.314" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:28.314" starttime="20190401 13:12:28.314"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:28.315" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server set --state error vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:28.993" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:28.993" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:28.993" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:28.993" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:28.993" starttime="20190401 13:12:28.314"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:28.994" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:28.994" starttime="20190401 13:12:28.993"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:28.995" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:28.995" starttime="20190401 13:12:28.994"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:28.995" starttime="20190401 13:12:28.994"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:28.995" starttime="20190401 13:12:28.314"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:28.995" starttime="20190401 13:12:28.313"></status>
</kw>
<doc>Set 'Error' and 'Active' flags to Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:28.995" critical="yes" starttime="20190401 13:12:28.313">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t9" name="Pause Unpause Instances">
<kw name="Pause Instance" library="OpenStack">
<doc>Pause an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server pause ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:28.996" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:28.996" starttime="20190401 13:12:28.996"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:28.997" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server pause vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:29.625" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:29.625" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:29.625" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:29.625" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:29.625" starttime="20190401 13:12:28.997"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:29.626" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:29.626" starttime="20190401 13:12:29.625"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:29.626" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:29.627" starttime="20190401 13:12:29.626"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:29.627" starttime="20190401 13:12:29.626"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:29.627" starttime="20190401 13:12:28.996"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:29.627" starttime="20190401 13:12:28.996"></status>
</kw>
<doc>Pause and Unpause Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:29.627" critical="yes" starttime="20190401 13:12:28.995">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t10" name="Stop Start Instances">
<kw name="Stop Instance" library="OpenStack">
<doc>Stop an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server stop ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:29.628" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:29.628" starttime="20190401 13:12:29.628"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:29.629" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server stop vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:30.263" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:30.263" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:30.263" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:30.263" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:30.263" starttime="20190401 13:12:29.629"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:30.264" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:30.264" starttime="20190401 13:12:30.264"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:30.265" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:30.265" starttime="20190401 13:12:30.264"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:30.265" starttime="20190401 13:12:30.264"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:30.265" starttime="20190401 13:12:29.628"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:30.265" starttime="20190401 13:12:29.628"></status>
</kw>
<doc>Stop and Start Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:30.265" critical="yes" starttime="20190401 13:12:29.627">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t11" name="Lock Unlock Instances">
<kw name="Lock Instance" library="OpenStack">
<doc>Lock an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server lock ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:30.267" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:30.267" starttime="20190401 13:12:30.267"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:30.267" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server lock vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:30.846" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:30.846" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:30.846" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:30.846" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:30.846" starttime="20190401 13:12:30.267"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:30.847" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:30.847" starttime="20190401 13:12:30.846"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:30.847" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:30.847" starttime="20190401 13:12:30.847"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:30.847" starttime="20190401 13:12:30.847"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:30.848" starttime="20190401 13:12:30.266"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:30.848" starttime="20190401 13:12:30.266"></status>
</kw>
<doc>Lock and Unlock Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:30.848" critical="yes" starttime="20190401 13:12:30.266">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t12" name="Reboot Instances">
<kw name="Reboot Instance" library="OpenStack">
<doc>Reboot an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server reboot ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:30.849" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:30.849" starttime="20190401 13:12:30.849"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:30.850" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server reboot vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:31.458" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:31.458" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:31.458" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:31.458" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:31.458" starttime="20190401 13:12:30.849"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:31.459" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:31.459" starttime="20190401 13:12:31.458"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:31.459" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:31.460" starttime="20190401 13:12:31.459"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:31.460" starttime="20190401 13:12:31.459"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:31.460" starttime="20190401 13:12:30.849"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:31.460" starttime="20190401 13:12:30.848"></status>
</kw>
<doc>Reboot Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:31.460" critical="yes" starttime="20190401 13:12:30.848">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t13" name="Rebuild Instances">
<kw name="Rebuild Instance From Volume" library="OpenStack">
<doc>Rebuild an instance from volume</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
<arg>${cirros_image_name}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server rebuild --image ${image} ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:31.461" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:31.462" starttime="20190401 13:12:31.461"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:31.462" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server rebuild --image cirros vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:32.121" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:32.121" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:32.121" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:32.121" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:32.121" starttime="20190401 13:12:31.462"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:32.122" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:32.122" starttime="20190401 13:12:32.121"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:32.123" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:32.123" starttime="20190401 13:12:32.122"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:32.123" starttime="20190401 13:12:32.122"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:32.123" starttime="20190401 13:12:31.461"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:32.123" starttime="20190401 13:12:31.461"></status>
</kw>
<doc>Rebuild Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:32.123" critical="yes" starttime="20190401 13:12:31.460">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t14" name="Resize Instances">
<kw name="Create Flavor" library="OpenStack">
<doc>Create a flavor with specified values.</doc>
<arguments>
<arg>${cirros_flavor_ram}</arg>
<arg>${cirros_flavor_vcpus}</arg>
<arg>${cirros_flavor_disk}</arg>
<arg>${cirros_flavor_name_2}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:32.124" level="INFO">${openstack_cmd} = openstack flavor create</msg>
<status status="PASS" endtime="20190401 13:12:32.124" starttime="20190401 13:12:32.124"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--ram ${ram}</arg>
<arg>--disk ${disk}</arg>
<arg>--vcpus ${vcpus}</arg>
<arg>--public</arg>
<arg>--id auto</arg>
<arg>${extra_args}</arg>
<arg>${name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:32.125" level="INFO">${cmd} = openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f2.small</msg>
<status status="PASS" endtime="20190401 13:12:32.125" starttime="20190401 13:12:32.125"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:32.126" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:32.126" starttime="20190401 13:12:32.125"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:32.126" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f2.small'.</msg>
<msg timestamp="20190401 13:12:32.704" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:32.704" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:32.704" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:32.704" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:32.705" starttime="20190401 13:12:32.126"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:32.705" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:32.705" starttime="20190401 13:12:32.705"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:32.706" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:32.706" starttime="20190401 13:12:32.706"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:32.706" starttime="20190401 13:12:32.705"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:32.706" starttime="20190401 13:12:32.125"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:32.706" starttime="20190401 13:12:32.124"></status>
</kw>
<doc>Resize Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:32.706" critical="yes" starttime="20190401 13:12:32.123">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t15" name="Set Unset Properties Instances">
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${instance_property_1}='true'</arg>
<arg>${instance_property_2}='500'</arg>
<arg>${instance_property_3}='180'</arg>
</arguments>
<assign>
<var>${properties}</var>
</assign>
<msg timestamp="20190401 13:12:32.707" level="INFO">${properties} = --property sw:wrs:auto_recovery='true' --property hw:wrs:live_migration_max_downtime='500' --property hw:wrs:live_migration_timeout='180'</msg>
<status status="PASS" endtime="20190401 13:12:32.707" starttime="20190401 13:12:32.707"></status>
</kw>
<kw name="Set Instance Property" library="OpenStack">
<doc>Set properties of an instance.</doc>
<arguments>
<arg>${cirros_instance_name}</arg>
<arg>${properties}</arg>
</arguments>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>openstack server set ${key} ${vm_name}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:32.708" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:32.708" starttime="20190401 13:12:32.708"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:32.709" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server set --property sw:wrs:auto_recovery='true' --property hw:wrs:live_migration_max_downtime='500' --property hw:wrs:live_migration_timeout='180' vm-cirros-1'.</msg>
<msg timestamp="20190401 13:12:33.368" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:33.368" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:33.368" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:33.368" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:33.368" starttime="20190401 13:12:32.708"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:33.369" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:33.369" starttime="20190401 13:12:33.368"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:33.369" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:33.369" starttime="20190401 13:12:33.369"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:33.369" starttime="20190401 13:12:33.369"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:33.370" starttime="20190401 13:12:32.708"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:33.370" starttime="20190401 13:12:32.707"></status>
</kw>
<doc>Set Unset properties of Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:33.370" critical="yes" starttime="20190401 13:12:32.707">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s3-t16" name="Evacuate Instances From Hosts">
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${CONFIGURATION_TYPE}' == 'Duplex'</arg>
<arg>Run Keywords</arg>
<arg>Evacuate Instances</arg>
<arg>controller-0</arg>
<arg>AND</arg>
<arg>Evacuate Instances</arg>
<arg>controller-1</arg>
<arg>ELSE IF</arg>
<arg>'${CONFIGURATION_TYPE}' == 'MN-Local' or '${CONFIGURATION_TYPE}' == 'MN-External'</arg>
<arg>Run Keywords</arg>
<arg>Evacuate Instances</arg>
<arg>compute-0</arg>
<arg>AND</arg>
<arg>Evacuate Instances</arg>
<arg>compute-1</arg>
</arguments>
<kw name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Evacuate Instances</arg>
<arg>controller-0</arg>
<arg>AND</arg>
<arg>Evacuate Instances</arg>
<arg>controller-1</arg>
</arguments>
<kw name="Evacuate Instances" library="OpenStack">
<doc>Evacuate all VMs from computes or from controllers.</doc>
<arguments>
<arg>controller-0</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack compute service set</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:33.372" level="INFO">${openstack_cmd} = openstack compute service set</msg>
<status status="PASS" endtime="20190401 13:12:33.372" starttime="20190401 13:12:33.372"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--disable</arg>
<arg>--disable-reason test-evacuate</arg>
<arg>${host}</arg>
<arg>nova-compute</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:33.372" level="INFO">${cmd} = openstack compute service set --disable --disable-reason test-evacuate controller-0 nova-compute</msg>
<status status="PASS" endtime="20190401 13:12:33.372" starttime="20190401 13:12:33.372"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
<arg>30 sec</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:33.373" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:33.373" starttime="20190401 13:12:33.373"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:33.373" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack compute service set --disable --disable-reason test-evacuate controller-0 nova-compute'.</msg>
<msg timestamp="20190401 13:12:33.951" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:33.952" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:33.952" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:33.952" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:33.952" starttime="20190401 13:12:33.373"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:33.952" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:33.952" starttime="20190401 13:12:33.952"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:33.953" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:33.953" starttime="20190401 13:12:33.953"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:33.953" starttime="20190401 13:12:33.953"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:33.953" starttime="20190401 13:12:33.372"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:33.953" starttime="20190401 13:12:33.371"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:33.953" starttime="20190401 13:12:33.371"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:33.953" starttime="20190401 13:12:33.371"></status>
</kw>
<doc>Evacuate all instances from computes or
controllers.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:33.954" critical="yes" starttime="20190401 13:12:33.370">Cloud openstack_helm was not found.</status>
</test>
<kw type="teardown" name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>OpenStack.Openstack Cleanup All</arg>
<arg>Utils.Stx Suite TearDown</arg>
</arguments>
<kw name="Openstack Cleanup All" library="OpenStack">
<doc>Delete all instances, images, flavors, networks and
keypairs generated during tests.</doc>
<kw name="Delete All Instances" library="OpenStack">
<doc>Get a list of all existing instances to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack server list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:33.955" level="INFO">${openstack_cmd} = openstack server list</msg>
<status status="PASS" endtime="20190401 13:12:33.955" starttime="20190401 13:12:33.955"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:33.956" level="INFO">${cmd} = openstack server list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:33.956" starttime="20190401 13:12:33.955"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:33.956" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:33.956" starttime="20190401 13:12:33.956"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:33.957" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:34.565" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:34.565" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:34.565" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:34.565" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:34.565" starttime="20190401 13:12:33.956"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:34.566" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:34.566" starttime="20190401 13:12:34.566"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:34.567" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:34.567" starttime="20190401 13:12:34.566"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:34.567" starttime="20190401 13:12:34.566"></status>
</kw>
<msg timestamp="20190401 13:12:34.567" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:34.567" starttime="20190401 13:12:33.956"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{vm_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:34.568" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:34.568" starttime="20190401 13:12:34.568"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:34.568" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:34.568" starttime="20190401 13:12:34.568"></status>
</kw>
<msg timestamp="20190401 13:12:34.568" level="INFO">@{vm_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:34.568" starttime="20190401 13:12:34.567"></status>
</kw>
<kw type="for" name="${vm} IN [ @{vm_list} ]">
<status status="PASS" endtime="20190401 13:12:34.568" starttime="20190401 13:12:34.568"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:34.569" starttime="20190401 13:12:33.955"></status>
</kw>
<kw name="Delete All Images" library="OpenStack">
<doc>Get a list of all existing images to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack image list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:34.569" level="INFO">${openstack_cmd} = openstack image list</msg>
<status status="PASS" endtime="20190401 13:12:34.569" starttime="20190401 13:12:34.569"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "Cirros"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:34.569" level="INFO">${cmd} = openstack image list|awk '{print$4}'|grep -v "Name"|grep -v "Cirros"</msg>
<status status="PASS" endtime="20190401 13:12:34.569" starttime="20190401 13:12:34.569"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:34.570" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:34.570" starttime="20190401 13:12:34.570"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:34.571" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack image list|awk '{print$4}'|grep -v "Name"|grep -v "Cirros"'.</msg>
<msg timestamp="20190401 13:12:35.229" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:35.230" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:35.230" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:35.230" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:35.230" starttime="20190401 13:12:34.570"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:35.230" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:35.230" starttime="20190401 13:12:35.230"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:35.231" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:35.231" starttime="20190401 13:12:35.231"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:35.231" starttime="20190401 13:12:35.231"></status>
</kw>
<msg timestamp="20190401 13:12:35.231" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:35.232" starttime="20190401 13:12:34.570"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{image_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:35.232" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:35.232" starttime="20190401 13:12:35.232"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:35.232" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:35.232" starttime="20190401 13:12:35.232"></status>
</kw>
<msg timestamp="20190401 13:12:35.233" level="INFO">@{image_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:35.233" starttime="20190401 13:12:35.232"></status>
</kw>
<kw type="for" name="${image} IN [ @{image_list} ]">
<status status="PASS" endtime="20190401 13:12:35.233" starttime="20190401 13:12:35.233"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:35.233" starttime="20190401 13:12:34.569"></status>
</kw>
<kw name="Delete All Flavors" library="OpenStack">
<doc>Get a list of all existing flavors to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:35.233" level="INFO">${openstack_cmd} = openstack flavor list</msg>
<status status="PASS" endtime="20190401 13:12:35.233" starttime="20190401 13:12:35.233"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "m1"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:35.234" level="INFO">${cmd} = openstack flavor list|awk '{print$4}'|grep -v "Name"|grep -v "m1"</msg>
<status status="PASS" endtime="20190401 13:12:35.234" starttime="20190401 13:12:35.234"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:35.234" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:35.234" starttime="20190401 13:12:35.234"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:35.235" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor list|awk '{print$4}'|grep -v "Name"|grep -v "m1"'.</msg>
<msg timestamp="20190401 13:12:35.813" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:35.813" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:35.813" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:35.813" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:35.813" starttime="20190401 13:12:35.235"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:35.814" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:35.814" starttime="20190401 13:12:35.813"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:35.814" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:35.815" starttime="20190401 13:12:35.814"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:35.815" starttime="20190401 13:12:35.814"></status>
</kw>
<msg timestamp="20190401 13:12:35.815" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:35.815" starttime="20190401 13:12:35.234"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{flavor_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:35.816" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:35.816" starttime="20190401 13:12:35.815"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:35.816" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:35.816" starttime="20190401 13:12:35.816"></status>
</kw>
<msg timestamp="20190401 13:12:35.816" level="INFO">@{flavor_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:35.816" starttime="20190401 13:12:35.815"></status>
</kw>
<kw type="for" name="${flavor} IN [ @{flavor_list} ]">
<status status="PASS" endtime="20190401 13:12:35.816" starttime="20190401 13:12:35.816"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:35.816" starttime="20190401 13:12:35.233"></status>
</kw>
<kw name="Delete All Networks" library="OpenStack">
<doc>Get a list of all existing networks to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:35.817" level="INFO">${openstack_cmd} = openstack network list</msg>
<status status="PASS" endtime="20190401 13:12:35.817" starttime="20190401 13:12:35.817"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "private"</arg>
<arg>grep -v "public"</arg>
<arg>grep -v "external"</arg>
<arg>grep -v "internal"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:35.817" level="INFO">${cmd} = openstack network list|awk '{print$4}'|grep -v "Name"|grep -v "private"|grep -v "public"|grep -v "external"|grep -v "internal"</msg>
<status status="PASS" endtime="20190401 13:12:35.817" starttime="20190401 13:12:35.817"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:35.818" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:35.818" starttime="20190401 13:12:35.818"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:35.819" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network list|awk '{print$4}'|grep -v "Name"|grep -v "private"|grep -v "public"|grep -v "external"|grep -v "internal"'.</msg>
<msg timestamp="20190401 13:12:36.427" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:36.427" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:36.427" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:36.427" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:36.427" starttime="20190401 13:12:35.818"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:36.428" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:36.428" starttime="20190401 13:12:36.427"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:36.428" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:36.428" starttime="20190401 13:12:36.428"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:36.428" starttime="20190401 13:12:36.428"></status>
</kw>
<msg timestamp="20190401 13:12:36.429" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:36.429" starttime="20190401 13:12:35.817"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{network_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:36.429" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:36.429" starttime="20190401 13:12:36.429"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:36.430" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:36.430" starttime="20190401 13:12:36.429"></status>
</kw>
<msg timestamp="20190401 13:12:36.430" level="INFO">@{network_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:36.430" starttime="20190401 13:12:36.429"></status>
</kw>
<kw type="for" name="${network} IN [ @{network_list} ]">
<status status="PASS" endtime="20190401 13:12:36.430" starttime="20190401 13:12:36.430"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:36.430" starttime="20190401 13:12:35.816"></status>
</kw>
<kw name="Delete All KeyPairs" library="OpenStack">
<doc>Get a list of all existing keypais to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack keypair list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:36.431" level="INFO">${openstack_cmd} = openstack keypair list</msg>
<status status="PASS" endtime="20190401 13:12:36.431" starttime="20190401 13:12:36.430"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$2}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:36.431" level="INFO">${cmd} = openstack keypair list|awk '{print$2}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:36.431" starttime="20190401 13:12:36.431"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:36.432" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:36.432" starttime="20190401 13:12:36.431"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:36.432" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack keypair list|awk '{print$2}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:37.091" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:37.091" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:37.091" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:37.091" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:37.091" starttime="20190401 13:12:36.432"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:37.092" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:37.092" starttime="20190401 13:12:37.091"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:37.093" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:37.093" starttime="20190401 13:12:37.092"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:37.093" starttime="20190401 13:12:37.092"></status>
</kw>
<msg timestamp="20190401 13:12:37.093" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:37.093" starttime="20190401 13:12:36.431"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{key_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:37.094" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:37.094" starttime="20190401 13:12:37.093"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:37.094" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:37.094" starttime="20190401 13:12:37.094"></status>
</kw>
<msg timestamp="20190401 13:12:37.094" level="INFO">@{key_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:37.094" starttime="20190401 13:12:37.093"></status>
</kw>
<kw type="for" name="${key} IN [ @{key_list} ]">
<status status="PASS" endtime="20190401 13:12:37.094" starttime="20190401 13:12:37.094"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:37.094" starttime="20190401 13:12:36.430"></status>
</kw>
<kw name="Delete All Snapshots" library="OpenStack">
<doc>Get a list of all existing snapshots to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume snapshot list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:37.095" level="INFO">${openstack_cmd} = openstack volume snapshot list</msg>
<status status="PASS" endtime="20190401 13:12:37.095" starttime="20190401 13:12:37.095"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:37.095" level="INFO">${cmd} = openstack volume snapshot list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:37.095" starttime="20190401 13:12:37.095"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:37.096" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:37.096" starttime="20190401 13:12:37.096"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:37.097" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume snapshot list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:37.674" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:37.674" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:37.674" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:37.675" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:37.675" starttime="20190401 13:12:37.096"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:37.675" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:37.675" starttime="20190401 13:12:37.675"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:37.676" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:37.676" starttime="20190401 13:12:37.676"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:37.676" starttime="20190401 13:12:37.675"></status>
</kw>
<msg timestamp="20190401 13:12:37.676" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:37.676" starttime="20190401 13:12:37.095"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{snapshot_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:37.677" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:37.677" starttime="20190401 13:12:37.677"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:37.677" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:37.677" starttime="20190401 13:12:37.677"></status>
</kw>
<msg timestamp="20190401 13:12:37.677" level="INFO">@{snapshot_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:37.677" starttime="20190401 13:12:37.676"></status>
</kw>
<kw type="for" name="${snapshot} IN [ @{snapshot_list} ]">
<status status="PASS" endtime="20190401 13:12:37.678" starttime="20190401 13:12:37.678"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:37.678" starttime="20190401 13:12:37.095"></status>
</kw>
<kw name="Delete All Volumes" library="OpenStack">
<doc>Get a list of all existing volumes to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:37.678" level="INFO">${openstack_cmd} = openstack volume list</msg>
<status status="PASS" endtime="20190401 13:12:37.678" starttime="20190401 13:12:37.678"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$2}'</arg>
<arg>grep -v "ID"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:37.679" level="INFO">${cmd} = openstack volume list|awk '{print$2}'|grep -v "ID"</msg>
<status status="PASS" endtime="20190401 13:12:37.679" starttime="20190401 13:12:37.678"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:37.679" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:37.679" starttime="20190401 13:12:37.679"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:37.680" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume list|awk '{print$2}'|grep -v "ID"'.</msg>
<msg timestamp="20190401 13:12:38.338" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:38.338" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:38.338" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:38.339" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:38.339" starttime="20190401 13:12:37.679"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:38.339" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:38.339" starttime="20190401 13:12:38.339"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:38.340" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:38.340" starttime="20190401 13:12:38.340"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:38.340" starttime="20190401 13:12:38.339"></status>
</kw>
<msg timestamp="20190401 13:12:38.340" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:38.340" starttime="20190401 13:12:37.679"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{volume_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:38.341" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:38.341" starttime="20190401 13:12:38.341"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:38.341" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:38.341" starttime="20190401 13:12:38.341"></status>
</kw>
<msg timestamp="20190401 13:12:38.342" level="INFO">@{volume_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:38.342" starttime="20190401 13:12:38.340"></status>
</kw>
<kw type="for" name="${volume} IN [ @{volume_list} ]">
<status status="PASS" endtime="20190401 13:12:38.342" starttime="20190401 13:12:38.342"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:38.342" starttime="20190401 13:12:37.678"></status>
</kw>
<kw name="Delete All Stacks" library="OpenStack">
<doc>Get a list of all existing stacks to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack stack list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:38.342" level="INFO">${openstack_cmd} = openstack stack list</msg>
<status status="PASS" endtime="20190401 13:12:38.342" starttime="20190401 13:12:38.342"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:38.343" level="INFO">${cmd} = openstack stack list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:38.343" starttime="20190401 13:12:38.342"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:38.343" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:38.343" starttime="20190401 13:12:38.343"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:38.344" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack stack list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:38.972" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:38.972" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:38.972" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:38.972" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:38.972" starttime="20190401 13:12:38.343"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:38.973" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:38.973" starttime="20190401 13:12:38.972"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:38.974" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:38.974" starttime="20190401 13:12:38.973"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:38.974" starttime="20190401 13:12:38.973"></status>
</kw>
<msg timestamp="20190401 13:12:38.974" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:38.974" starttime="20190401 13:12:38.343"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{stack_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:38.975" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:38.975" starttime="20190401 13:12:38.974"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:38.975" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:38.975" starttime="20190401 13:12:38.975"></status>
</kw>
<msg timestamp="20190401 13:12:38.975" level="INFO">@{stack_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:38.975" starttime="20190401 13:12:38.974"></status>
</kw>
<kw type="for" name="${stack} IN [ @{stack_list} ]">
<status status="PASS" endtime="20190401 13:12:38.975" starttime="20190401 13:12:38.975"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:38.975" starttime="20190401 13:12:38.342"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:38.976" starttime="20190401 13:12:33.955"></status>
</kw>
<kw name="Stx Suite TearDown" library="Utils">
<doc>Wrapper to clean up activities on the suite.</doc>
<kw name="Close All Connections" library="SSHLibrary">
<doc>Closes all open connections.</doc>
<status status="PASS" endtime="20190401 13:12:38.977" starttime="20190401 13:12:38.976"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:38.978" starttime="20190401 13:12:38.976"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:38.978" starttime="20190401 13:12:33.955">Several failures occurred:

1) Cloud openstack_helm was not found.

2) Cloud openstack_helm was not found.

3) Cloud openstack_helm was not found.

4) Cloud openstack_helm was not found.

5) Cloud openstack_helm was not found.

6) Cloud openstack_helm was not found.

7) Cloud openstack_helm was not found.

8) Cloud openstack_helm was not found.</status>
</kw>
<doc>Tests to create instances from a volume, perform different
power status and set properties, using Cirros OS.
Author(s):
- Juan Carlos Alonso &lt;juan.carlos.alonso@intel.com&gt;</doc>
<status status="FAIL" endtime="20190401 13:12:38.978" starttime="20190401 13:12:23.072">Suite teardown failed:
Several failures occurred:

1) Cloud openstack_helm was not found.

2) Cloud openstack_helm was not found.

3) Cloud openstack_helm was not found.

4) Cloud openstack_helm was not found.

5) Cloud openstack_helm was not found.

6) Cloud openstack_helm was not found.

7) Cloud openstack_helm was not found.

8) Cloud openstack_helm was not found.</status>
</suite>
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Sanity-Test/Sanity-OpenStack/04-Instance-From-Heat-Template.robot" id="s1-s1-s4" name="04-Instance-From-Heat-Template">
<kw type="setup" name="Stx Suite Setup" library="Utils">
<doc>Wrapper to setup the environment needed for exercise
StarlingX features</doc>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190401 13:12:38.994" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:38.994" starttime="20190401 13:12:38.993"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190401 13:12:38.994" level="INFO">Length is 10</msg>
<msg timestamp="20190401 13:12:38.994" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190401 13:12:38.994" starttime="20190401 13:12:38.994"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190401 13:12:38.995" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190401 13:12:40.080" level="INFO">Read output: Last login: Mon Apr  1 19:01:09 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<status status="PASS" endtime="20190401 13:12:40.080" starttime="20190401 13:12:38.995"></status>
</kw>
<msg timestamp="20190401 13:12:40.080" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 13:12:40.080" starttime="20190401 13:12:38.994"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:40.081" starttime="20190401 13:12:38.994"></status>
</kw>
<msg timestamp="20190401 13:12:40.081" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:40.081" starttime="20190401 13:12:38.992"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:12:40.081" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:40.081" starttime="20190401 13:12:40.081"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:12:40.082" level="INFO">1</msg>
<status status="PASS" endtime="20190401 13:12:40.082" starttime="20190401 13:12:40.081"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:40.082" starttime="20190401 13:12:38.992"></status>
</kw>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:40.083" starttime="20190401 13:12:40.082"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:12:40.083" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:12:40.083" starttime="20190401 13:12:40.083"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:40.084" starttime="20190401 13:12:40.083"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:40.084" starttime="20190401 13:12:40.084"></status>
</kw>
<msg timestamp="20190401 13:12:40.084" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:12:40.084" starttime="20190401 13:12:40.083"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190401 13:12:40.084" starttime="20190401 13:12:40.084"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:12:40.088" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 13:12:40.088" starttime="20190401 13:12:40.085"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:12:40.452" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:12:40.453" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:40.453" starttime="20190401 13:12:40.089"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:12:40.454" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:40.454" starttime="20190401 13:12:40.453"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:12:40.454" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 13:12:40.454" starttime="20190401 13:12:40.454"></status>
</kw>
<msg timestamp="20190401 13:12:40.454" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:12:40.454" starttime="20190401 13:12:40.453"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:12:40.456" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:12:40.456" starttime="20190401 13:12:40.455"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:40.457" level="INFO">0</msg>
<msg timestamp="20190401 13:12:40.457" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:40.457" starttime="20190401 13:12:40.456"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:12:40.457" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:12:40.457" starttime="20190401 13:12:40.457"></status>
</kw>
<msg timestamp="20190401 13:12:40.457" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:40.457" starttime="20190401 13:12:40.454"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:40.458" starttime="20190401 13:12:40.458"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:40.458" starttime="20190401 13:12:40.457"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:40.458" starttime="20190401 13:12:40.458"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:12:40.459" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 13:12:40.459" starttime="20190401 13:12:40.459"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:40.459" starttime="20190401 13:12:40.082"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:40.459" starttime="20190401 13:12:40.082"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:40.459" starttime="20190401 13:12:38.992"></status>
</kw>
<test id="s1-s1-s4-t1" name="Create Flavors for Instance">
<kw name="Create Flavor" library="OpenStack">
<doc>Create a flavor with specified values.</doc>
<arguments>
<arg>${cirros_flavor_ram}</arg>
<arg>${cirros_flavor_vcpus}</arg>
<arg>${cirros_flavor_disk}</arg>
<arg>${cirros_flavor_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:40.460" level="INFO">${openstack_cmd} = openstack flavor create</msg>
<status status="PASS" endtime="20190401 13:12:40.460" starttime="20190401 13:12:40.460"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--ram ${ram}</arg>
<arg>--disk ${disk}</arg>
<arg>--vcpus ${vcpus}</arg>
<arg>--public</arg>
<arg>--id auto</arg>
<arg>${extra_args}</arg>
<arg>${name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:40.461" level="INFO">${cmd} = openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f1.small</msg>
<status status="PASS" endtime="20190401 13:12:40.461" starttime="20190401 13:12:40.460"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:40.461" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:40.461" starttime="20190401 13:12:40.461"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:40.462" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor create --ram 2048 --disk 20 --vcpus 1 --public --id auto  f1.small'.</msg>
<msg timestamp="20190401 13:12:41.039" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:41.040" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:41.040" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:41.040" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:41.040" starttime="20190401 13:12:40.461"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:41.041" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:41.041" starttime="20190401 13:12:41.040"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:41.041" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:41.041" starttime="20190401 13:12:41.041"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:41.041" starttime="20190401 13:12:41.041"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:41.042" starttime="20190401 13:12:40.461"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:41.042" starttime="20190401 13:12:40.460"></status>
</kw>
<doc>Create flavors with or without properties to be used
to launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:41.042" critical="yes" starttime="20190401 13:12:40.459">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s4-t2" name="Create Images for Instances">
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/${cirros_image}</arg>
<arg>${host_image_path}/${cirros_image}</arg>
</arguments>
<msg timestamp="20190401 13:12:41.080" level="INFO">[chan 2] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:12:41.086" level="INFO">[chan 3] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:12:41.086" level="FAIL">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/cirros-0.4.0-x86_64-disk.qcow2'.</msg>
<status status="FAIL" endtime="20190401 13:12:41.086" starttime="20190401 13:12:41.043"></status>
</kw>
<doc>Create images with or without properties to be used
to launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:41.087" critical="yes" starttime="20190401 13:12:41.042">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/cirros-0.4.0-x86_64-disk.qcow2'.</status>
</test>
<test id="s1-s1-s4-t3" name="Create Networks for Instance">
<kw name="Create Network" library="OpenStack">
<doc>Create Network with openstack request.</doc>
<arguments>
<arg>${network_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network create</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:41.088" level="INFO">${openstack_cmd} = openstack network create</msg>
<status status="PASS" endtime="20190401 13:12:41.088" starttime="20190401 13:12:41.088"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>${network_name}</arg>
<arg>${additional_args}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:41.088" level="INFO">${cmd} = openstack network create network-1 </msg>
<status status="PASS" endtime="20190401 13:12:41.088" starttime="20190401 13:12:41.088"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:41.089" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:41.089" starttime="20190401 13:12:41.089"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:41.089" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network create network-1 '.</msg>
<msg timestamp="20190401 13:12:41.667" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:41.667" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:41.667" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:41.667" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:41.667" starttime="20190401 13:12:41.089"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:41.668" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:41.668" starttime="20190401 13:12:41.668"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:41.669" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:41.669" starttime="20190401 13:12:41.669"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:41.669" starttime="20190401 13:12:41.668"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:41.669" starttime="20190401 13:12:41.088"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:41.669" starttime="20190401 13:12:41.087"></status>
</kw>
<doc>Create networks to be used to launch Cirros
instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:41.669" critical="yes" starttime="20190401 13:12:41.087">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s4-t4" name="Create Instance Trough Stack">
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/${stack_template}</arg>
<arg>${host_image_path}/${stack_template}</arg>
</arguments>
<msg timestamp="20190401 13:12:41.697" level="INFO">'/home/mgperezi/duplex/stx-test-suite/Utils/stack_template.yml' -&gt; '/home/wrsroot//Utils/stack_template.yml'</msg>
<status status="PASS" endtime="20190401 13:12:41.697" starttime="20190401 13:12:41.670"></status>
</kw>
<kw name="Get Net Id" library="OpenStack">
<doc>Retrieve the net id for the given network name</doc>
<arguments>
<arg>${network_name}</arg>
</arguments>
<assign>
<var>${net_id}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:41.698" level="INFO">${openstack_cmd} = openstack network list</msg>
<status status="PASS" endtime="20190401 13:12:41.698" starttime="20190401 13:12:41.698"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>grep "${network_name}"</arg>
<arg>awk '{print$2}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:41.698" level="INFO">${cmd} = openstack network list|grep "network-1"|awk '{print$2}'</msg>
<status status="PASS" endtime="20190401 13:12:41.698" starttime="20190401 13:12:41.698"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:41.699" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:41.699" starttime="20190401 13:12:41.699"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:41.700" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network list|grep "network-1"|awk '{print$2}''.</msg>
<msg timestamp="20190401 13:12:42.328" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190401 13:12:42.328" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:42.328" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:42.328" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:42.328" starttime="20190401 13:12:41.699"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:42.329" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 0}</msg>
<status status="PASS" endtime="20190401 13:12:42.329" starttime="20190401 13:12:42.328"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:42.329" starttime="20190401 13:12:42.329"></status>
</kw>
<msg timestamp="20190401 13:12:42.329" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:12:42.329" starttime="20190401 13:12:41.699"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:12:42.330" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:12:42.330" starttime="20190401 13:12:42.330"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${output}</arg>
<arg>${EMPTY}</arg>
</arguments>
<assign>
<var>${splitted_output}</var>
</assign>
<msg timestamp="20190401 13:12:42.330" level="INFO">${splitted_output} = []</msg>
<status status="PASS" endtime="20190401 13:12:42.330" starttime="20190401 13:12:42.330"></status>
</kw>
<kw name="Get From List" library="Collections">
<doc>Returns the value specified with an ``index`` from ``list``.</doc>
<arguments>
<arg>${splitted_output}</arg>
<arg>0</arg>
</arguments>
<assign>
<var>${net_id}</var>
</assign>
<msg timestamp="20190401 13:12:42.331" level="FAIL">IndexError: Given index 0 is out of the range 0--1.</msg>
<status status="FAIL" endtime="20190401 13:12:42.331" starttime="20190401 13:12:42.330"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:42.331" starttime="20190401 13:12:41.697"></status>
</kw>
<doc>Create a Cirros instance using a heat template</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:42.331" critical="yes" starttime="20190401 13:12:41.670">IndexError: Given index 0 is out of the range 0--1.</status>
</test>
<kw type="teardown" name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>OpenStack.Openstack Cleanup All</arg>
<arg>Utils.Stx Suite TearDown</arg>
</arguments>
<kw name="Openstack Cleanup All" library="OpenStack">
<doc>Delete all instances, images, flavors, networks and
keypairs generated during tests.</doc>
<kw name="Delete All Instances" library="OpenStack">
<doc>Get a list of all existing instances to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack server list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:42.332" level="INFO">${openstack_cmd} = openstack server list</msg>
<status status="PASS" endtime="20190401 13:12:42.332" starttime="20190401 13:12:42.332"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:42.333" level="INFO">${cmd} = openstack server list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:42.333" starttime="20190401 13:12:42.332"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:42.333" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:42.333" starttime="20190401 13:12:42.333"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:42.334" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:42.912" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:42.912" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:42.912" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:42.912" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:42.912" starttime="20190401 13:12:42.334"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:42.913" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:42.913" starttime="20190401 13:12:42.913"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:42.914" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:42.914" starttime="20190401 13:12:42.913"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:42.914" starttime="20190401 13:12:42.913"></status>
</kw>
<msg timestamp="20190401 13:12:42.914" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:42.914" starttime="20190401 13:12:42.333"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{vm_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:42.915" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:42.915" starttime="20190401 13:12:42.915"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:42.915" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:42.915" starttime="20190401 13:12:42.915"></status>
</kw>
<msg timestamp="20190401 13:12:42.915" level="INFO">@{vm_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:42.915" starttime="20190401 13:12:42.914"></status>
</kw>
<kw type="for" name="${vm} IN [ @{vm_list} ]">
<status status="PASS" endtime="20190401 13:12:42.915" starttime="20190401 13:12:42.915"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:42.916" starttime="20190401 13:12:42.332"></status>
</kw>
<kw name="Delete All Images" library="OpenStack">
<doc>Get a list of all existing images to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack image list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:42.916" level="INFO">${openstack_cmd} = openstack image list</msg>
<status status="PASS" endtime="20190401 13:12:42.916" starttime="20190401 13:12:42.916"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "Cirros"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:42.916" level="INFO">${cmd} = openstack image list|awk '{print$4}'|grep -v "Name"|grep -v "Cirros"</msg>
<status status="PASS" endtime="20190401 13:12:42.916" starttime="20190401 13:12:42.916"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:42.917" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:42.917" starttime="20190401 13:12:42.917"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:42.917" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack image list|awk '{print$4}'|grep -v "Name"|grep -v "Cirros"'.</msg>
<msg timestamp="20190401 13:12:43.526" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:43.526" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:43.526" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:43.527" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:43.527" starttime="20190401 13:12:42.917"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:43.527" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:43.527" starttime="20190401 13:12:43.527"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:43.528" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:43.528" starttime="20190401 13:12:43.528"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:43.528" starttime="20190401 13:12:43.527"></status>
</kw>
<msg timestamp="20190401 13:12:43.528" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:43.528" starttime="20190401 13:12:42.917"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{image_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:43.529" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:43.529" starttime="20190401 13:12:43.529"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:43.529" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:43.529" starttime="20190401 13:12:43.529"></status>
</kw>
<msg timestamp="20190401 13:12:43.529" level="INFO">@{image_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:43.529" starttime="20190401 13:12:43.528"></status>
</kw>
<kw type="for" name="${image} IN [ @{image_list} ]">
<status status="PASS" endtime="20190401 13:12:43.530" starttime="20190401 13:12:43.530"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:43.530" starttime="20190401 13:12:42.916"></status>
</kw>
<kw name="Delete All Flavors" library="OpenStack">
<doc>Get a list of all existing flavors to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:43.530" level="INFO">${openstack_cmd} = openstack flavor list</msg>
<status status="PASS" endtime="20190401 13:12:43.530" starttime="20190401 13:12:43.530"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "m1"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:43.531" level="INFO">${cmd} = openstack flavor list|awk '{print$4}'|grep -v "Name"|grep -v "m1"</msg>
<status status="PASS" endtime="20190401 13:12:43.531" starttime="20190401 13:12:43.530"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:43.531" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:43.531" starttime="20190401 13:12:43.531"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:43.532" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor list|awk '{print$4}'|grep -v "Name"|grep -v "m1"'.</msg>
<msg timestamp="20190401 13:12:44.174" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:44.175" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:44.175" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:44.175" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:44.175" starttime="20190401 13:12:43.532"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:44.175" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:44.175" starttime="20190401 13:12:44.175"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:44.176" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:44.176" starttime="20190401 13:12:44.176"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:44.176" starttime="20190401 13:12:44.175"></status>
</kw>
<msg timestamp="20190401 13:12:44.176" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:44.176" starttime="20190401 13:12:43.531"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{flavor_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:44.177" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:44.177" starttime="20190401 13:12:44.177"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:44.177" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:44.177" starttime="20190401 13:12:44.177"></status>
</kw>
<msg timestamp="20190401 13:12:44.178" level="INFO">@{flavor_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:44.178" starttime="20190401 13:12:44.177"></status>
</kw>
<kw type="for" name="${flavor} IN [ @{flavor_list} ]">
<status status="PASS" endtime="20190401 13:12:44.178" starttime="20190401 13:12:44.178"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:44.178" starttime="20190401 13:12:43.530"></status>
</kw>
<kw name="Delete All Networks" library="OpenStack">
<doc>Get a list of all existing networks to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:44.178" level="INFO">${openstack_cmd} = openstack network list</msg>
<status status="PASS" endtime="20190401 13:12:44.178" starttime="20190401 13:12:44.178"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "private"</arg>
<arg>grep -v "public"</arg>
<arg>grep -v "external"</arg>
<arg>grep -v "internal"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:44.179" level="INFO">${cmd} = openstack network list|awk '{print$4}'|grep -v "Name"|grep -v "private"|grep -v "public"|grep -v "external"|grep -v "internal"</msg>
<status status="PASS" endtime="20190401 13:12:44.179" starttime="20190401 13:12:44.178"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:44.179" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:44.179" starttime="20190401 13:12:44.179"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:44.180" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network list|awk '{print$4}'|grep -v "Name"|grep -v "private"|grep -v "public"|grep -v "external"|grep -v "internal"'.</msg>
<msg timestamp="20190401 13:12:44.808" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:44.808" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:44.808" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:44.808" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:44.808" starttime="20190401 13:12:44.179"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:44.809" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:44.809" starttime="20190401 13:12:44.808"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:44.810" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:44.810" starttime="20190401 13:12:44.809"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:44.810" starttime="20190401 13:12:44.809"></status>
</kw>
<msg timestamp="20190401 13:12:44.810" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:44.810" starttime="20190401 13:12:44.179"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{network_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:44.811" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:44.811" starttime="20190401 13:12:44.810"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:44.811" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:44.811" starttime="20190401 13:12:44.811"></status>
</kw>
<msg timestamp="20190401 13:12:44.811" level="INFO">@{network_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:44.811" starttime="20190401 13:12:44.810"></status>
</kw>
<kw type="for" name="${network} IN [ @{network_list} ]">
<status status="PASS" endtime="20190401 13:12:44.811" starttime="20190401 13:12:44.811"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:44.811" starttime="20190401 13:12:44.178"></status>
</kw>
<kw name="Delete All KeyPairs" library="OpenStack">
<doc>Get a list of all existing keypais to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack keypair list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:44.812" level="INFO">${openstack_cmd} = openstack keypair list</msg>
<status status="PASS" endtime="20190401 13:12:44.812" starttime="20190401 13:12:44.812"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$2}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:44.812" level="INFO">${cmd} = openstack keypair list|awk '{print$2}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:44.812" starttime="20190401 13:12:44.812"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:44.813" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:44.813" starttime="20190401 13:12:44.813"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:44.813" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack keypair list|awk '{print$2}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:45.456" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:45.456" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:45.456" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:45.456" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:45.456" starttime="20190401 13:12:44.813"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:45.457" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:45.457" starttime="20190401 13:12:45.456"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:45.458" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:45.458" starttime="20190401 13:12:45.457"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:45.458" starttime="20190401 13:12:45.457"></status>
</kw>
<msg timestamp="20190401 13:12:45.458" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:45.458" starttime="20190401 13:12:44.812"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{key_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:45.459" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:45.459" starttime="20190401 13:12:45.459"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:45.459" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:45.459" starttime="20190401 13:12:45.459"></status>
</kw>
<msg timestamp="20190401 13:12:45.459" level="INFO">@{key_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:45.459" starttime="20190401 13:12:45.458"></status>
</kw>
<kw type="for" name="${key} IN [ @{key_list} ]">
<status status="PASS" endtime="20190401 13:12:45.459" starttime="20190401 13:12:45.459"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:45.460" starttime="20190401 13:12:44.811"></status>
</kw>
<kw name="Delete All Snapshots" library="OpenStack">
<doc>Get a list of all existing snapshots to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume snapshot list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:45.460" level="INFO">${openstack_cmd} = openstack volume snapshot list</msg>
<status status="PASS" endtime="20190401 13:12:45.460" starttime="20190401 13:12:45.460"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:45.460" level="INFO">${cmd} = openstack volume snapshot list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:45.460" starttime="20190401 13:12:45.460"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:45.461" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:45.461" starttime="20190401 13:12:45.461"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:45.461" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume snapshot list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:46.089" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:46.090" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:46.090" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:46.090" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:46.090" starttime="20190401 13:12:45.461"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:46.090" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:46.090" starttime="20190401 13:12:46.090"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:46.091" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:46.091" starttime="20190401 13:12:46.091"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:46.091" starttime="20190401 13:12:46.090"></status>
</kw>
<msg timestamp="20190401 13:12:46.091" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:46.091" starttime="20190401 13:12:45.460"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{snapshot_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:46.092" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:46.092" starttime="20190401 13:12:46.092"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:46.092" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:46.092" starttime="20190401 13:12:46.092"></status>
</kw>
<msg timestamp="20190401 13:12:46.093" level="INFO">@{snapshot_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:46.093" starttime="20190401 13:12:46.092"></status>
</kw>
<kw type="for" name="${snapshot} IN [ @{snapshot_list} ]">
<status status="PASS" endtime="20190401 13:12:46.093" starttime="20190401 13:12:46.093"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:46.093" starttime="20190401 13:12:45.460"></status>
</kw>
<kw name="Delete All Volumes" library="OpenStack">
<doc>Get a list of all existing volumes to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:46.093" level="INFO">${openstack_cmd} = openstack volume list</msg>
<status status="PASS" endtime="20190401 13:12:46.093" starttime="20190401 13:12:46.093"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$2}'</arg>
<arg>grep -v "ID"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:46.094" level="INFO">${cmd} = openstack volume list|awk '{print$2}'|grep -v "ID"</msg>
<status status="PASS" endtime="20190401 13:12:46.094" starttime="20190401 13:12:46.093"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:46.094" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:46.094" starttime="20190401 13:12:46.094"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:46.095" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume list|awk '{print$2}'|grep -v "ID"'.</msg>
<msg timestamp="20190401 13:12:46.679" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:46.679" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:46.679" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:46.679" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:46.679" starttime="20190401 13:12:46.094"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:46.680" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:46.680" starttime="20190401 13:12:46.679"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:46.680" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:46.681" starttime="20190401 13:12:46.680"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:46.681" starttime="20190401 13:12:46.680"></status>
</kw>
<msg timestamp="20190401 13:12:46.681" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:46.681" starttime="20190401 13:12:46.094"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{volume_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:46.681" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:46.681" starttime="20190401 13:12:46.681"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:46.682" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:46.682" starttime="20190401 13:12:46.682"></status>
</kw>
<msg timestamp="20190401 13:12:46.682" level="INFO">@{volume_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:46.682" starttime="20190401 13:12:46.681"></status>
</kw>
<kw type="for" name="${volume} IN [ @{volume_list} ]">
<status status="PASS" endtime="20190401 13:12:46.682" starttime="20190401 13:12:46.682"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:46.682" starttime="20190401 13:12:46.093"></status>
</kw>
<kw name="Delete All Stacks" library="OpenStack">
<doc>Get a list of all existing stacks to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack stack list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:46.683" level="INFO">${openstack_cmd} = openstack stack list</msg>
<status status="PASS" endtime="20190401 13:12:46.683" starttime="20190401 13:12:46.683"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:46.683" level="INFO">${cmd} = openstack stack list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:46.683" starttime="20190401 13:12:46.683"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:46.684" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:46.684" starttime="20190401 13:12:46.684"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:46.684" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack stack list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:47.342" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:47.343" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:47.343" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:47.343" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:47.343" starttime="20190401 13:12:46.684"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:47.343" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:47.343" starttime="20190401 13:12:47.343"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:47.344" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:47.344" starttime="20190401 13:12:47.344"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:47.344" starttime="20190401 13:12:47.343"></status>
</kw>
<msg timestamp="20190401 13:12:47.344" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:47.344" starttime="20190401 13:12:46.683"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{stack_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:47.345" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:47.345" starttime="20190401 13:12:47.345"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:47.345" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:47.345" starttime="20190401 13:12:47.345"></status>
</kw>
<msg timestamp="20190401 13:12:47.346" level="INFO">@{stack_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:47.346" starttime="20190401 13:12:47.345"></status>
</kw>
<kw type="for" name="${stack} IN [ @{stack_list} ]">
<status status="PASS" endtime="20190401 13:12:47.346" starttime="20190401 13:12:47.346"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:47.346" starttime="20190401 13:12:46.682"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:47.346" starttime="20190401 13:12:42.332"></status>
</kw>
<kw name="Stx Suite TearDown" library="Utils">
<doc>Wrapper to clean up activities on the suite.</doc>
<kw name="Close All Connections" library="SSHLibrary">
<doc>Closes all open connections.</doc>
<status status="PASS" endtime="20190401 13:12:47.348" starttime="20190401 13:12:47.346"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:47.348" starttime="20190401 13:12:47.346"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:47.348" starttime="20190401 13:12:42.331">Several failures occurred:

1) Cloud openstack_helm was not found.

2) Cloud openstack_helm was not found.

3) Cloud openstack_helm was not found.

4) Cloud openstack_helm was not found.

5) Cloud openstack_helm was not found.

6) Cloud openstack_helm was not found.

7) Cloud openstack_helm was not found.

8) Cloud openstack_helm was not found.</status>
</kw>
<doc>Test to launch instance through a heat template.
Author(s):
- Hector Ivan Ramos Escobar &lt;ramos.escobarx.hector.ivan@intel.com&gt;
- Juan Carlos Alonso Sanchez &lt;juan.carlos.alonso@intel.com&gt;</doc>
<status status="FAIL" endtime="20190401 13:12:47.348" starttime="20190401 13:12:38.981">Suite teardown failed:
Several failures occurred:

1) Cloud openstack_helm was not found.

2) Cloud openstack_helm was not found.

3) Cloud openstack_helm was not found.

4) Cloud openstack_helm was not found.

5) Cloud openstack_helm was not found.

6) Cloud openstack_helm was not found.

7) Cloud openstack_helm was not found.

8) Cloud openstack_helm was not found.</status>
</suite>
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Sanity-Test/Sanity-OpenStack/05-Measurements-For-Metric.robot" id="s1-s1-s5" name="05-Measurements-For-Metric">
<kw type="setup" name="Stx Suite Setup" library="Utils">
<doc>Wrapper to setup the environment needed for exercise
StarlingX features</doc>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190401 13:12:47.362" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:47.362" starttime="20190401 13:12:47.362"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190401 13:12:47.363" level="INFO">Length is 10</msg>
<msg timestamp="20190401 13:12:47.363" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190401 13:12:47.363" starttime="20190401 13:12:47.363"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190401 13:12:47.364" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190401 13:12:48.448" level="INFO">Read output: Last login: Mon Apr  1 19:01:25 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<status status="PASS" endtime="20190401 13:12:48.448" starttime="20190401 13:12:47.363"></status>
</kw>
<msg timestamp="20190401 13:12:48.449" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 13:12:48.449" starttime="20190401 13:12:47.363"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:48.449" starttime="20190401 13:12:47.363"></status>
</kw>
<msg timestamp="20190401 13:12:48.449" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:48.449" starttime="20190401 13:12:47.362"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:12:48.450" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:48.450" starttime="20190401 13:12:48.449"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:12:48.450" level="INFO">1</msg>
<status status="PASS" endtime="20190401 13:12:48.450" starttime="20190401 13:12:48.450"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:48.450" starttime="20190401 13:12:47.361"></status>
</kw>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:48.452" starttime="20190401 13:12:48.451"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:12:48.452" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:12:48.453" starttime="20190401 13:12:48.452"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:48.453" starttime="20190401 13:12:48.453"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:48.453" starttime="20190401 13:12:48.453"></status>
</kw>
<msg timestamp="20190401 13:12:48.454" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:12:48.454" starttime="20190401 13:12:48.452"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190401 13:12:48.454" starttime="20190401 13:12:48.454"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:12:48.456" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 13:12:48.457" starttime="20190401 13:12:48.454"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:12:48.827" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:12:48.827" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:48.828" starttime="20190401 13:12:48.457"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:12:48.828" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:48.828" starttime="20190401 13:12:48.828"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:12:48.829" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 13:12:48.829" starttime="20190401 13:12:48.829"></status>
</kw>
<msg timestamp="20190401 13:12:48.829" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:12:48.829" starttime="20190401 13:12:48.828"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:12:48.831" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:12:48.831" starttime="20190401 13:12:48.829"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:48.831" level="INFO">0</msg>
<msg timestamp="20190401 13:12:48.831" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:48.831" starttime="20190401 13:12:48.831"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:12:48.831" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:12:48.831" starttime="20190401 13:12:48.831"></status>
</kw>
<msg timestamp="20190401 13:12:48.832" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:48.832" starttime="20190401 13:12:48.829"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:48.832" starttime="20190401 13:12:48.832"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:48.832" starttime="20190401 13:12:48.832"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:48.833" starttime="20190401 13:12:48.833"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:12:48.833" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 13:12:48.833" starttime="20190401 13:12:48.833"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:48.833" starttime="20190401 13:12:48.451"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:48.833" starttime="20190401 13:12:48.451"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:48.833" starttime="20190401 13:12:47.361"></status>
</kw>
<test id="s1-s1-s5-t1" name="Create Image For Metrics">
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/${cirros_image}</arg>
<arg>${host_image_path}/${cirros_image}</arg>
</arguments>
<msg timestamp="20190401 13:12:48.841" level="INFO">[chan 1] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:12:48.847" level="INFO">[chan 2] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:12:48.848" level="FAIL">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/cirros-0.4.0-x86_64-disk.qcow2'.</msg>
<status status="FAIL" endtime="20190401 13:12:48.848" starttime="20190401 13:12:48.834"></status>
</kw>
<doc>Create images with or without properties to be used
to launch Cirros instances.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:48.848" critical="yes" starttime="20190401 13:12:48.833">There are no source files matching '/home/mgperezi/duplex/stx-test-suite/cirros-0.4.0-x86_64-disk.qcow2'.</status>
</test>
<test id="s1-s1-s5-t2" name="Update Image Name">
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>openstack image show</arg>
<arg>${cirros_image_name}</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:48.849" level="INFO">${openstack_cmd} = openstack image show cirros</msg>
<status status="PASS" endtime="20190401 13:12:48.849" starttime="20190401 13:12:48.849"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>grep "created_at"</arg>
<arg>awk '{print $4}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:48.849" level="INFO">${cmd} = openstack image show cirros|grep "created_at"|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 13:12:48.849" starttime="20190401 13:12:48.849"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:48.850" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:48.850" starttime="20190401 13:12:48.850"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:48.850" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack image show cirros|grep "created_at"|awk '{print $4}''.</msg>
<msg timestamp="20190401 13:12:49.479" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190401 13:12:49.479" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:49.479" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:49.479" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:49.479" starttime="20190401 13:12:48.850"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:49.480" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 0}</msg>
<status status="PASS" endtime="20190401 13:12:49.480" starttime="20190401 13:12:49.479"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:49.480" starttime="20190401 13:12:49.480"></status>
</kw>
<msg timestamp="20190401 13:12:49.480" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:12:49.480" starttime="20190401 13:12:48.849"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${created_at}</var>
</assign>
<msg timestamp="20190401 13:12:49.481" level="INFO">${created_at} = </msg>
<status status="PASS" endtime="20190401 13:12:49.481" starttime="20190401 13:12:49.481"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack image set</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:49.481" level="INFO">${openstack_cmd} = openstack image set</msg>
<status status="PASS" endtime="20190401 13:12:49.481" starttime="20190401 13:12:49.481"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--name ${cirros_image_name_tmp}</arg>
<arg>${cirros_image_name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:49.482" level="INFO">${cmd} = openstack image set --name cirros-tmp cirros</msg>
<status status="PASS" endtime="20190401 13:12:49.482" starttime="20190401 13:12:49.481"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:49.482" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:49.482" starttime="20190401 13:12:49.482"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:49.483" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack image set --name cirros-tmp cirros'.</msg>
<msg timestamp="20190401 13:12:50.111" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:50.112" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:50.112" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:50.112" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:50.112" starttime="20190401 13:12:49.482"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:50.112" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:50.112" starttime="20190401 13:12:50.112"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:50.113" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:50.113" starttime="20190401 13:12:50.113"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:50.113" starttime="20190401 13:12:50.113"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:50.113" starttime="20190401 13:12:49.482"></status>
</kw>
<doc>Update image name.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:50.114" critical="yes" starttime="20190401 13:12:48.848">Cloud openstack_helm was not found.</status>
</test>
<test id="s1-s1-s5-t3" name="Update Image Disk Ram Size">
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>openstack image show</arg>
<arg>${cirros_image_name}</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:50.114" level="INFO">${openstack_cmd} = openstack image show cirros</msg>
<status status="PASS" endtime="20190401 13:12:50.114" starttime="20190401 13:12:50.114"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>grep "updated_at"</arg>
<arg>awk '{print $4}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:50.115" level="INFO">${cmd} = openstack image show cirros|grep "updated_at"|awk '{print $4}'</msg>
<status status="PASS" endtime="20190401 13:12:50.115" starttime="20190401 13:12:50.115"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:50.116" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:50.116" starttime="20190401 13:12:50.115"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:50.116" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack image show cirros|grep "updated_at"|awk '{print $4}''.</msg>
<msg timestamp="20190401 13:12:50.744" level="INFO">Command exited with return code 0.</msg>
<msg timestamp="20190401 13:12:50.745" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:50.745" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:50.745" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:50.745" starttime="20190401 13:12:50.116"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:50.745" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 0}</msg>
<status status="PASS" endtime="20190401 13:12:50.745" starttime="20190401 13:12:50.745"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:50.746" starttime="20190401 13:12:50.745"></status>
</kw>
<msg timestamp="20190401 13:12:50.746" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:12:50.746" starttime="20190401 13:12:50.115"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${updated_at}</var>
</assign>
<msg timestamp="20190401 13:12:50.746" level="INFO">${updated_at} = </msg>
<status status="PASS" endtime="20190401 13:12:50.746" starttime="20190401 13:12:50.746"></status>
</kw>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack image set</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:50.747" level="INFO">${openstack_cmd} = openstack image set</msg>
<status status="PASS" endtime="20190401 13:12:50.747" starttime="20190401 13:12:50.747"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${openstack_cmd}</arg>
<arg>--min-disk ${image_disk_size}</arg>
<arg>${cirros_image_name}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:50.747" level="INFO">${cmd} = openstack image set --min-disk 10 cirros</msg>
<status status="PASS" endtime="20190401 13:12:50.747" starttime="20190401 13:12:50.747"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:50.748" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:50.748" starttime="20190401 13:12:50.748"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:50.748" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack image set --min-disk 10 cirros'.</msg>
<msg timestamp="20190401 13:12:51.327" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:51.327" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:51.327" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:51.327" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:51.327" starttime="20190401 13:12:50.748"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:51.328" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:51.328" starttime="20190401 13:12:51.328"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:51.329" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:51.330" starttime="20190401 13:12:51.329"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:51.330" starttime="20190401 13:12:51.329"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:51.330" starttime="20190401 13:12:50.747"></status>
</kw>
<doc>Update image disk size and ram size.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:51.330" critical="yes" starttime="20190401 13:12:50.114">Cloud openstack_helm was not found.</status>
</test>
<kw type="teardown" name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>OpenStack.Openstack Cleanup All</arg>
<arg>Utils.Stx Suite TearDown</arg>
</arguments>
<kw name="Openstack Cleanup All" library="OpenStack">
<doc>Delete all instances, images, flavors, networks and
keypairs generated during tests.</doc>
<kw name="Delete All Instances" library="OpenStack">
<doc>Get a list of all existing instances to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack server list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:51.332" level="INFO">${openstack_cmd} = openstack server list</msg>
<status status="PASS" endtime="20190401 13:12:51.332" starttime="20190401 13:12:51.332"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:51.333" level="INFO">${cmd} = openstack server list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:51.333" starttime="20190401 13:12:51.333"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:51.335" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:51.335" starttime="20190401 13:12:51.335"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:51.336" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack server list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:51.944" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:51.944" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:51.944" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:51.944" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:51.944" starttime="20190401 13:12:51.335"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:51.945" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:51.945" starttime="20190401 13:12:51.944"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:51.946" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:51.946" starttime="20190401 13:12:51.946"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:51.947" starttime="20190401 13:12:51.945"></status>
</kw>
<msg timestamp="20190401 13:12:51.947" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:51.947" starttime="20190401 13:12:51.333"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{vm_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:51.948" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:51.948" starttime="20190401 13:12:51.948"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:51.949" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:51.949" starttime="20190401 13:12:51.948"></status>
</kw>
<msg timestamp="20190401 13:12:51.949" level="INFO">@{vm_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:51.949" starttime="20190401 13:12:51.947"></status>
</kw>
<kw type="for" name="${vm} IN [ @{vm_list} ]">
<status status="PASS" endtime="20190401 13:12:51.949" starttime="20190401 13:12:51.949"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:51.949" starttime="20190401 13:12:51.332"></status>
</kw>
<kw name="Delete All Images" library="OpenStack">
<doc>Get a list of all existing images to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack image list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:51.950" level="INFO">${openstack_cmd} = openstack image list</msg>
<status status="PASS" endtime="20190401 13:12:51.950" starttime="20190401 13:12:51.950"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "Cirros"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:51.951" level="INFO">${cmd} = openstack image list|awk '{print$4}'|grep -v "Name"|grep -v "Cirros"</msg>
<status status="PASS" endtime="20190401 13:12:51.951" starttime="20190401 13:12:51.950"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:51.952" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:51.952" starttime="20190401 13:12:51.951"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:51.953" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack image list|awk '{print$4}'|grep -v "Name"|grep -v "Cirros"'.</msg>
<msg timestamp="20190401 13:12:52.595" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:52.595" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:52.595" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:52.595" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:52.595" starttime="20190401 13:12:51.952"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:52.596" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:52.596" starttime="20190401 13:12:52.595"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:52.597" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:52.597" starttime="20190401 13:12:52.597"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:52.597" starttime="20190401 13:12:52.596"></status>
</kw>
<msg timestamp="20190401 13:12:52.598" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:52.598" starttime="20190401 13:12:51.951"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{image_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:52.599" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:52.599" starttime="20190401 13:12:52.599"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:52.599" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:52.600" starttime="20190401 13:12:52.599"></status>
</kw>
<msg timestamp="20190401 13:12:52.600" level="INFO">@{image_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:52.600" starttime="20190401 13:12:52.598"></status>
</kw>
<kw type="for" name="${image} IN [ @{image_list} ]">
<status status="PASS" endtime="20190401 13:12:52.600" starttime="20190401 13:12:52.600"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:52.600" starttime="20190401 13:12:51.950"></status>
</kw>
<kw name="Delete All Flavors" library="OpenStack">
<doc>Get a list of all existing flavors to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack flavor list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:52.601" level="INFO">${openstack_cmd} = openstack flavor list</msg>
<status status="PASS" endtime="20190401 13:12:52.601" starttime="20190401 13:12:52.601"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "m1"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:52.602" level="INFO">${cmd} = openstack flavor list|awk '{print$4}'|grep -v "Name"|grep -v "m1"</msg>
<status status="PASS" endtime="20190401 13:12:52.602" starttime="20190401 13:12:52.601"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:52.603" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:52.603" starttime="20190401 13:12:52.603"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:52.604" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack flavor list|awk '{print$4}'|grep -v "Name"|grep -v "m1"'.</msg>
<msg timestamp="20190401 13:12:53.232" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:53.232" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:53.232" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:53.232" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:53.232" starttime="20190401 13:12:52.603"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:53.233" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:53.233" starttime="20190401 13:12:53.233"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:53.234" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:53.235" starttime="20190401 13:12:53.234"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:53.235" starttime="20190401 13:12:53.234"></status>
</kw>
<msg timestamp="20190401 13:12:53.235" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:53.235" starttime="20190401 13:12:52.602"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{flavor_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:53.236" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:53.236" starttime="20190401 13:12:53.236"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:53.237" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:53.237" starttime="20190401 13:12:53.236"></status>
</kw>
<msg timestamp="20190401 13:12:53.237" level="INFO">@{flavor_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:53.237" starttime="20190401 13:12:53.235"></status>
</kw>
<kw type="for" name="${flavor} IN [ @{flavor_list} ]">
<status status="PASS" endtime="20190401 13:12:53.237" starttime="20190401 13:12:53.237"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:53.238" starttime="20190401 13:12:52.600"></status>
</kw>
<kw name="Delete All Networks" library="OpenStack">
<doc>Get a list of all existing networks to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack network list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:53.238" level="INFO">${openstack_cmd} = openstack network list</msg>
<status status="PASS" endtime="20190401 13:12:53.238" starttime="20190401 13:12:53.238"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
<arg>grep -v "private"</arg>
<arg>grep -v "public"</arg>
<arg>grep -v "external"</arg>
<arg>grep -v "internal"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:53.239" level="INFO">${cmd} = openstack network list|awk '{print$4}'|grep -v "Name"|grep -v "private"|grep -v "public"|grep -v "external"|grep -v "internal"</msg>
<status status="PASS" endtime="20190401 13:12:53.239" starttime="20190401 13:12:53.239"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:53.240" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:53.240" starttime="20190401 13:12:53.240"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:53.241" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack network list|awk '{print$4}'|grep -v "Name"|grep -v "private"|grep -v "public"|grep -v "external"|grep -v "internal"'.</msg>
<msg timestamp="20190401 13:12:53.869" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:53.869" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:53.869" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:53.869" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:53.870" starttime="20190401 13:12:53.240"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:53.870" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:53.871" starttime="20190401 13:12:53.870"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:53.872" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:53.872" starttime="20190401 13:12:53.871"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:53.872" starttime="20190401 13:12:53.871"></status>
</kw>
<msg timestamp="20190401 13:12:53.872" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:53.872" starttime="20190401 13:12:53.239"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{network_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:53.873" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:53.873" starttime="20190401 13:12:53.873"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:53.874" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:53.874" starttime="20190401 13:12:53.874"></status>
</kw>
<msg timestamp="20190401 13:12:53.874" level="INFO">@{network_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:53.874" starttime="20190401 13:12:53.873"></status>
</kw>
<kw type="for" name="${network} IN [ @{network_list} ]">
<status status="PASS" endtime="20190401 13:12:53.874" starttime="20190401 13:12:53.874"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:53.875" starttime="20190401 13:12:53.238"></status>
</kw>
<kw name="Delete All KeyPairs" library="OpenStack">
<doc>Get a list of all existing keypais to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack keypair list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:53.875" level="INFO">${openstack_cmd} = openstack keypair list</msg>
<status status="PASS" endtime="20190401 13:12:53.875" starttime="20190401 13:12:53.875"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$2}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:53.876" level="INFO">${cmd} = openstack keypair list|awk '{print$2}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:53.876" starttime="20190401 13:12:53.876"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:53.877" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:53.877" starttime="20190401 13:12:53.877"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:53.878" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack keypair list|awk '{print$2}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:54.507" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:54.507" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:54.507" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:54.507" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:54.507" starttime="20190401 13:12:53.878"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:54.508" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:54.508" starttime="20190401 13:12:54.508"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:54.509" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:54.509" starttime="20190401 13:12:54.508"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:54.509" starttime="20190401 13:12:54.508"></status>
</kw>
<msg timestamp="20190401 13:12:54.509" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:54.509" starttime="20190401 13:12:53.876"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{key_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:54.510" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:54.510" starttime="20190401 13:12:54.510"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:54.510" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:54.510" starttime="20190401 13:12:54.510"></status>
</kw>
<msg timestamp="20190401 13:12:54.510" level="INFO">@{key_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:54.510" starttime="20190401 13:12:54.509"></status>
</kw>
<kw type="for" name="${key} IN [ @{key_list} ]">
<status status="PASS" endtime="20190401 13:12:54.510" starttime="20190401 13:12:54.510"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:54.511" starttime="20190401 13:12:53.875"></status>
</kw>
<kw name="Delete All Snapshots" library="OpenStack">
<doc>Get a list of all existing snapshots to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume snapshot list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:54.511" level="INFO">${openstack_cmd} = openstack volume snapshot list</msg>
<status status="PASS" endtime="20190401 13:12:54.511" starttime="20190401 13:12:54.511"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:54.511" level="INFO">${cmd} = openstack volume snapshot list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:54.511" starttime="20190401 13:12:54.511"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:54.512" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:54.512" starttime="20190401 13:12:54.512"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:54.512" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume snapshot list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:55.141" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:55.141" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:55.141" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:55.141" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:55.141" starttime="20190401 13:12:54.512"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:55.142" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:55.142" starttime="20190401 13:12:55.141"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:55.142" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:55.143" starttime="20190401 13:12:55.142"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:55.143" starttime="20190401 13:12:55.142"></status>
</kw>
<msg timestamp="20190401 13:12:55.143" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:55.143" starttime="20190401 13:12:54.511"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{snapshot_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:55.143" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:55.144" starttime="20190401 13:12:55.143"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:55.144" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:55.144" starttime="20190401 13:12:55.144"></status>
</kw>
<msg timestamp="20190401 13:12:55.144" level="INFO">@{snapshot_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:55.144" starttime="20190401 13:12:55.143"></status>
</kw>
<kw type="for" name="${snapshot} IN [ @{snapshot_list} ]">
<status status="PASS" endtime="20190401 13:12:55.144" starttime="20190401 13:12:55.144"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:55.144" starttime="20190401 13:12:54.511"></status>
</kw>
<kw name="Delete All Volumes" library="OpenStack">
<doc>Get a list of all existing volumes to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack volume list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:55.145" level="INFO">${openstack_cmd} = openstack volume list</msg>
<status status="PASS" endtime="20190401 13:12:55.145" starttime="20190401 13:12:55.145"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$2}'</arg>
<arg>grep -v "ID"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:55.145" level="INFO">${cmd} = openstack volume list|awk '{print$2}'|grep -v "ID"</msg>
<status status="PASS" endtime="20190401 13:12:55.145" starttime="20190401 13:12:55.145"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:55.146" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:55.146" starttime="20190401 13:12:55.146"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:55.146" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack volume list|awk '{print$2}'|grep -v "ID"'.</msg>
<msg timestamp="20190401 13:12:55.725" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:55.725" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:55.725" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:55.725" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:55.725" starttime="20190401 13:12:55.146"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:55.725" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:55.725" starttime="20190401 13:12:55.725"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:55.726" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:55.726" starttime="20190401 13:12:55.726"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:55.726" starttime="20190401 13:12:55.726"></status>
</kw>
<msg timestamp="20190401 13:12:55.727" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:55.727" starttime="20190401 13:12:55.145"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{volume_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:55.727" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:55.727" starttime="20190401 13:12:55.727"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:55.728" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:55.728" starttime="20190401 13:12:55.727"></status>
</kw>
<msg timestamp="20190401 13:12:55.728" level="INFO">@{volume_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:55.728" starttime="20190401 13:12:55.727"></status>
</kw>
<kw type="for" name="${volume} IN [ @{volume_list} ]">
<status status="PASS" endtime="20190401 13:12:55.728" starttime="20190401 13:12:55.728"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:55.728" starttime="20190401 13:12:55.144"></status>
</kw>
<kw name="Delete All Stacks" library="OpenStack">
<doc>Get a list of all existing stacks to delete them one
by one.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>openstack stack list</arg>
</arguments>
<assign>
<var>${openstack_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:55.728" level="INFO">${openstack_cmd} = openstack stack list</msg>
<status status="PASS" endtime="20190401 13:12:55.729" starttime="20190401 13:12:55.728"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${openstack_cmd}</arg>
<arg>awk '{print$4}'</arg>
<arg>grep -v "Name"</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:55.729" level="INFO">${cmd} = openstack stack list|awk '{print$4}'|grep -v "Name"</msg>
<status status="PASS" endtime="20190401 13:12:55.729" starttime="20190401 13:12:55.729"></status>
</kw>
<kw name="Run OS Command" library="OpenStack">
<doc>Keyword to execute exclusively commands for OpenStack as
it uses the proper token for OS authentication.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>export OS_CLOUD=openstack_helm</arg>
</arguments>
<assign>
<var>${load_os_token}</var>
</assign>
<msg timestamp="20190401 13:12:55.729" level="INFO">${load_os_token} = export OS_CLOUD=openstack_helm</msg>
<status status="PASS" endtime="20190401 13:12:55.729" starttime="20190401 13:12:55.729"></status>
</kw>
<kw name="Execute Command" library="SSHLibrary">
<doc>Executes ``command`` on the remote machine and returns its outputs.</doc>
<arguments>
<arg>${load_os_token} &amp;&amp; ${cmd}</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=True</arg>
<arg>return_rc=True</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${stdout}</var>
<var>${stderr}</var>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:55.730" level="INFO">Executing command 'export OS_CLOUD=openstack_helm &amp;&amp; openstack stack list|awk '{print$4}'|grep -v "Name"'.</msg>
<msg timestamp="20190401 13:12:56.339" level="INFO">Command exited with return code 1.</msg>
<msg timestamp="20190401 13:12:56.339" level="INFO">${stdout} = </msg>
<msg timestamp="20190401 13:12:56.339" level="INFO">${stderr} = Cloud openstack_helm was not found.</msg>
<msg timestamp="20190401 13:12:56.339" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:56.339" starttime="20190401 13:12:55.730"></status>
</kw>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${stdout}</arg>
<arg>stderr=${stderr}</arg>
<arg>rc=${rc}</arg>
</arguments>
<assign>
<var>${res}</var>
</assign>
<msg timestamp="20190401 13:12:56.340" level="INFO">${res} = {u'stdout': u'', u'stderr': u'Cloud openstack_helm was not found.', u'rc': 1}</msg>
<status status="PASS" endtime="20190401 13:12:56.340" starttime="20190401 13:12:56.339"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} != 0 and ${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${stderr}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${stderr}</arg>
</arguments>
<msg timestamp="20190401 13:12:56.341" level="FAIL">Cloud openstack_helm was not found.</msg>
<status status="FAIL" endtime="20190401 13:12:56.341" starttime="20190401 13:12:56.340"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:56.341" starttime="20190401 13:12:56.340"></status>
</kw>
<msg timestamp="20190401 13:12:56.341" level="INFO">&amp;{result} = { stdout= | stderr=Cloud openstack_helm was not found. | rc=1 }</msg>
<status status="FAIL" endtime="20190401 13:12:56.341" starttime="20190401 13:12:55.729"></status>
</kw>
<kw name="Convert Response To List" library="Utils">
<doc>Given a response dictionary, gets the stdout and split
it by spaces and return it as a list.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<assign>
<var>@{stack_list}</var>
</assign>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${response}</var>
</assign>
<msg timestamp="20190401 13:12:56.342" level="INFO">${response} = </msg>
<status status="PASS" endtime="20190401 13:12:56.342" starttime="20190401 13:12:56.341"></status>
</kw>
<kw name="Split String" library="String">
<doc>Splits the ``string`` using ``separator`` as a delimiter string.</doc>
<arguments>
<arg>${response}</arg>
</arguments>
<assign>
<var>@{res_in_list}</var>
</assign>
<msg timestamp="20190401 13:12:56.342" level="INFO">@{res_in_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:56.342" starttime="20190401 13:12:56.342"></status>
</kw>
<msg timestamp="20190401 13:12:56.342" level="INFO">@{stack_list} = [ ]</msg>
<status status="PASS" endtime="20190401 13:12:56.342" starttime="20190401 13:12:56.341"></status>
</kw>
<kw type="for" name="${stack} IN [ @{stack_list} ]">
<status status="PASS" endtime="20190401 13:12:56.342" starttime="20190401 13:12:56.342"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:56.342" starttime="20190401 13:12:55.728"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:56.343" starttime="20190401 13:12:51.331"></status>
</kw>
<kw name="Stx Suite TearDown" library="Utils">
<doc>Wrapper to clean up activities on the suite.</doc>
<kw name="Close All Connections" library="SSHLibrary">
<doc>Closes all open connections.</doc>
<status status="PASS" endtime="20190401 13:12:56.375" starttime="20190401 13:12:56.343"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:56.375" starttime="20190401 13:12:56.343"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:56.375" starttime="20190401 13:12:51.331">Several failures occurred:

1) Cloud openstack_helm was not found.

2) Cloud openstack_helm was not found.

3) Cloud openstack_helm was not found.

4) Cloud openstack_helm was not found.

5) Cloud openstack_helm was not found.

6) Cloud openstack_helm was not found.

7) Cloud openstack_helm was not found.

8) Cloud openstack_helm was not found.</status>
</kw>
<doc>Test to create an instance with Cirros.
Author(s):
- Hector Ivan Ramos Escobar &lt;ramos.escobarx.hector.ivan@intel.com&gt;
- Juan Carlos Alonso &lt;juan.carlos.alonso@intel.com&gt;</doc>
<status status="FAIL" endtime="20190401 13:12:56.375" starttime="20190401 13:12:47.350">Suite teardown failed:
Several failures occurred:

1) Cloud openstack_helm was not found.

2) Cloud openstack_helm was not found.

3) Cloud openstack_helm was not found.

4) Cloud openstack_helm was not found.

5) Cloud openstack_helm was not found.

6) Cloud openstack_helm was not found.

7) Cloud openstack_helm was not found.

8) Cloud openstack_helm was not found.</status>
</suite>
<status status="FAIL" endtime="20190401 13:12:56.378" starttime="20190401 13:11:52.946"></status>
</suite>
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Sanity-Test/Sanity-Platform" id="s1-s2" name="Sanity-Platform">
<suite source="/home/mgperezi/duplex/stx-test-suite/Tests/Sanity-Test/Sanity-Platform/02-OpenStack-Pod-Healthy.robot" id="s1-s2-s1" name="02-OpenStack-Pod-Healthy">
<kw type="setup" name="Stx Suite Setup" library="Utils">
<doc>Wrapper to setup the environment needed for exercise
StarlingX features</doc>
<kw name="Open Master Controller Connection" library="Utils">
<doc>Establish a SSH connection with the master controller
to start executing the the suite.</doc>
<kw name="Connect to Controller Node" library="Utils">
<doc>Stablish a SSH connection to the controller and return
the connection id</doc>
<arguments>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_NAME}</arg>
<arg>${CONFIG.credentials.STX_DEPLOY_USER_PSWD}</arg>
<arg>${CONFIG.general.IP_UNIT_0_ADDRESS}</arg>
</arguments>
<assign>
<var>${master_controller_connection}</var>
</assign>
<kw name="Open Connection" library="SSHLibrary">
<doc>Opens a new SSH connection to the given ``host`` and ``port``.</doc>
<arguments>
<arg>${ip_address} prompt=${prompt}</arg>
<arg>timeout=${timeout}</arg>
</arguments>
<assign>
<var>${controller_connection}</var>
</assign>
<msg timestamp="20190401 13:12:56.398" level="INFO">${controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:56.398" starttime="20190401 13:12:56.397"></status>
</kw>
<kw name="Flexible_SSH_Login" library="Utils">
<doc>On active SSH session: if given non-empty password,
do Login, else do Login With Public Key.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
</arguments>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${password}</arg>
</arguments>
<assign>
<var>${pwd_length}</var>
</assign>
<msg timestamp="20190401 13:12:56.398" level="INFO">Length is 10</msg>
<msg timestamp="20190401 13:12:56.398" level="INFO">${pwd_length} = 10</msg>
<status status="PASS" endtime="20190401 13:12:56.398" starttime="20190401 13:12:56.398"></status>
</kw>
<kw name="Run Keyword And Return If" library="BuiltIn">
<doc>Runs the specified keyword and returns from the enclosing user keyword.</doc>
<arguments>
<arg>${pwd_length} &gt; 0</arg>
<arg>SSHLibrary.Login</arg>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<kw name="Login" library="SSHLibrary">
<doc>Logs into the SSH server with the given ``username`` and ``password``.</doc>
<arguments>
<arg>${user}</arg>
<arg>${password}</arg>
<arg>delay=${delay}</arg>
</arguments>
<msg timestamp="20190401 13:12:56.399" level="INFO">Logging into '192.168.200.76 prompt=$:22' as 'wrsroot'.</msg>
<msg timestamp="20190401 13:12:57.484" level="INFO">Read output: Last login: Mon Apr  1 19:01:33 2019 from 192.168.200.60
/etc/motd.d/00-header:

[H[2J
WARNING: Unauthorized access to this system is forbidden and will be
prosecuted by law. By accessing this system, you agree that your
actions may be monitored if unauthorized usage is suspected.

controller-0:~$</msg>
<status status="PASS" endtime="20190401 13:12:57.484" starttime="20190401 13:12:56.399"></status>
</kw>
<msg timestamp="20190401 13:12:57.484" level="INFO">Returning from the enclosing user keyword.</msg>
<status status="PASS" endtime="20190401 13:12:57.484" starttime="20190401 13:12:56.398"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:57.484" starttime="20190401 13:12:56.398"></status>
</kw>
<msg timestamp="20190401 13:12:57.484" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:57.484" starttime="20190401 13:12:56.397"></status>
</kw>
<kw name="Set Suite Variable" library="BuiltIn">
<doc>Makes a variable available everywhere within the scope of the current suite.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:12:57.485" level="INFO">${master_controller_connection} = 1</msg>
<status status="PASS" endtime="20190401 13:12:57.485" starttime="20190401 13:12:57.485"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${master_controller_connection}</arg>
</arguments>
<msg timestamp="20190401 13:12:57.485" level="INFO">1</msg>
<status status="PASS" endtime="20190401 13:12:57.485" starttime="20190401 13:12:57.485"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:57.485" starttime="20190401 13:12:56.397"></status>
</kw>
<kw name="Set Env Vars From Openrc" library="Utils">
<doc>Sources the openrc form /etc/nova/ to have the admin
variables exported on the controller.</doc>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>source /etc/platform/openrc</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:57.486" starttime="20190401 13:12:57.486"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:12:57.487" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:12:57.487" starttime="20190401 13:12:57.487"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:57.487" starttime="20190401 13:12:57.487"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:57.488" starttime="20190401 13:12:57.488"></status>
</kw>
<msg timestamp="20190401 13:12:57.488" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:12:57.488" starttime="20190401 13:12:57.487"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<status status="PASS" endtime="20190401 13:12:57.488" starttime="20190401 13:12:57.488"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:12:57.492" level="INFO">source /etc/platform/openrc</msg>
<status status="PASS" endtime="20190401 13:12:57.492" starttime="20190401 13:12:57.488"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:12:57.884" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:12:57.884" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:57.884" starttime="20190401 13:12:57.492"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:12:57.885" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:57.885" starttime="20190401 13:12:57.885"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:12:57.885" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 13:12:57.885" starttime="20190401 13:12:57.885"></status>
</kw>
<msg timestamp="20190401 13:12:57.886" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:12:57.886" starttime="20190401 13:12:57.884"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:12:57.888" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:12:57.888" starttime="20190401 13:12:57.886"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:57.888" level="INFO">0</msg>
<msg timestamp="20190401 13:12:57.888" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:57.888" starttime="20190401 13:12:57.888"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:12:57.888" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:12:57.888" starttime="20190401 13:12:57.888"></status>
</kw>
<msg timestamp="20190401 13:12:57.888" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:57.889" starttime="20190401 13:12:57.886"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:57.889" starttime="20190401 13:12:57.889"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:57.889" starttime="20190401 13:12:57.889"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:57.890" starttime="20190401 13:12:57.889"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:12:57.890" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 13:12:57.890" starttime="20190401 13:12:57.890"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:57.890" starttime="20190401 13:12:57.486"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:57.890" starttime="20190401 13:12:57.485"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:57.890" starttime="20190401 13:12:56.396"></status>
</kw>
<test id="s1-s2-s1-t1" name="OpenStack PODs Healthy">
<kw name="Check System Application Status" library="Utils">
<doc>Check if openstack applications were applied.</doc>
<arguments>
<arg>stx-openstack</arg>
<arg>applied</arg>
</arguments>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>system application-list</arg>
<arg>grep ${application}</arg>
<arg>awk '{print $8}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:57.891" level="INFO">${cmd} = system application-list|grep stx-openstack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190401 13:12:57.891" starttime="20190401 13:12:57.891"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:57.892" starttime="20190401 13:12:57.892"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:12:57.893" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:12:57.893" starttime="20190401 13:12:57.892"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:57.893" starttime="20190401 13:12:57.893"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:57.893" starttime="20190401 13:12:57.893"></status>
</kw>
<msg timestamp="20190401 13:12:57.894" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:12:57.894" starttime="20190401 13:12:57.892"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:12:57.894" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:57.894" starttime="20190401 13:12:57.894"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:12:57.904" level="INFO">system application-list|grep stx-opens tack|awk '{print $8}'</msg>
<status status="PASS" endtime="20190401 13:12:57.904" starttime="20190401 13:12:57.894"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:12:58.906" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:12:58.907" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:58.907" starttime="20190401 13:12:57.904"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:12:58.907" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:58.907" starttime="20190401 13:12:58.907"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:12:58.908" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 13:12:58.908" starttime="20190401 13:12:58.908"></status>
</kw>
<msg timestamp="20190401 13:12:58.908" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:12:58.908" starttime="20190401 13:12:58.907"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:12:58.910" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:12:58.910" starttime="20190401 13:12:58.908"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:58.910" level="INFO">0</msg>
<msg timestamp="20190401 13:12:58.910" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:58.910" starttime="20190401 13:12:58.910"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:12:58.911" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:12:58.911" starttime="20190401 13:12:58.911"></status>
</kw>
<msg timestamp="20190401 13:12:58.911" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:12:58.911" starttime="20190401 13:12:58.908"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:58.912" starttime="20190401 13:12:58.911"></status>
</kw>
<status status="PASS" endtime="20190401 13:12:58.912" starttime="20190401 13:12:58.911"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:58.912" starttime="20190401 13:12:58.912"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:12:58.912" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 13:12:58.912" starttime="20190401 13:12:58.912"></status>
</kw>
<msg timestamp="20190401 13:12:58.913" level="INFO">&amp;{result} = { stdout= | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:12:58.913" starttime="20190401 13:12:57.891"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:12:58.913" level="INFO">${value} = </msg>
<status status="PASS" endtime="20190401 13:12:58.913" starttime="20190401 13:12:58.913"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${value}' == 'apply-failed'</arg>
<arg>System Application Apply</arg>
<arg>${application}</arg>
<arg>ELSE</arg>
<arg>Should Be Equal As Strings</arg>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>${status}</arg>
</arguments>
<msg timestamp="20190401 13:12:58.914" level="FAIL"> != applied</msg>
<status status="FAIL" endtime="20190401 13:12:58.914" starttime="20190401 13:12:58.913"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:58.914" starttime="20190401 13:12:58.913"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:58.914" starttime="20190401 13:12:57.891"></status>
</kw>
<doc>Check all OpenStack pods are healthy, in Running or
Completed state.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:58.914" critical="yes" starttime="20190401 13:12:57.890"> != applied</status>
</test>
<test id="s1-s2-s1-t2" name="Reapply STX OpenStack">
<kw name="System Application Apply" library="Utils">
<doc>Run the system aplication apply</doc>
<arguments>
<arg>stx-openstack</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system application-apply ${application}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:58.916" starttime="20190401 13:12:58.915"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:12:58.916" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:12:58.916" starttime="20190401 13:12:58.916"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:58.917" starttime="20190401 13:12:58.917"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:58.917" starttime="20190401 13:12:58.917"></status>
</kw>
<msg timestamp="20190401 13:12:58.917" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:12:58.917" starttime="20190401 13:12:58.916"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:12:58.918" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:58.918" starttime="20190401 13:12:58.917"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:12:58.924" level="INFO">system application-apply stx-openstack [A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Kk</msg>
<status status="PASS" endtime="20190401 13:12:58.924" starttime="20190401 13:12:58.918"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:12:59.913" level="INFO">Application-apply rejected: application not found.
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:12:59.913" level="INFO">${output} = Application-apply rejected: application not found.
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:59.913" starttime="20190401 13:12:58.925"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:12:59.914" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:59.914" starttime="20190401 13:12:59.914"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:12:59.915" level="INFO">${clean_out} = Application-apply rejected: application not found.
</msg>
<status status="PASS" endtime="20190401 13:12:59.915" starttime="20190401 13:12:59.914"></status>
</kw>
<msg timestamp="20190401 13:12:59.915" level="INFO">${output} = Application-apply rejected: application not found.
</msg>
<status status="PASS" endtime="20190401 13:12:59.915" starttime="20190401 13:12:59.913"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:12:59.917" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:12:59.917" starttime="20190401 13:12:59.915"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:12:59.917" level="INFO">1</msg>
<msg timestamp="20190401 13:12:59.917" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:59.917" starttime="20190401 13:12:59.917"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:12:59.918" level="INFO">1</msg>
<status status="PASS" endtime="20190401 13:12:59.918" starttime="20190401 13:12:59.917"></status>
</kw>
<msg timestamp="20190401 13:12:59.918" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:12:59.918" starttime="20190401 13:12:59.915"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<msg timestamp="20190401 13:12:59.919" level="FAIL">Application-apply rejected: application not found.
</msg>
<status status="FAIL" endtime="20190401 13:12:59.919" starttime="20190401 13:12:59.918"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:59.919" starttime="20190401 13:12:59.918"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:59.919" starttime="20190401 13:12:58.915"></status>
</kw>
<status status="FAIL" endtime="20190401 13:12:59.919" starttime="20190401 13:12:58.915"></status>
</kw>
<doc>Re apply stx openstack application without any
modification to helm charts.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:12:59.919" critical="yes" starttime="20190401 13:12:58.914">Application-apply rejected: application not found.
</status>
</test>
<test id="s1-s2-s1-t3" name="STX OpenStack Override Update Reset">
<kw name="Helm Override OpenStack" library="Utils">
<doc>Helm override for OpenStack nova chart and reset.</doc>
<arguments>
<arg>nova</arg>
<arg>openstack</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>system helm-override-update</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:12:59.920" level="INFO">${kubectl_cmd} = system helm-override-update</msg>
<status status="PASS" endtime="20190401 13:12:59.920" starttime="20190401 13:12:59.920"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>${kubectl_cmd}</arg>
<arg>--set conf.nova.DEFAULT.foo=bar</arg>
<arg>${char_name}</arg>
<arg>${namespace}</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:12:59.921" level="INFO">${cmd} = system helm-override-update --set conf.nova.DEFAULT.foo=bar nova openstack</msg>
<status status="PASS" endtime="20190401 13:12:59.921" starttime="20190401 13:12:59.920"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:59.921" starttime="20190401 13:12:59.921"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:12:59.922" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:12:59.922" starttime="20190401 13:12:59.922"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:59.922" starttime="20190401 13:12:59.922"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:12:59.923" starttime="20190401 13:12:59.923"></status>
</kw>
<msg timestamp="20190401 13:12:59.923" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:12:59.923" starttime="20190401 13:12:59.922"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:12:59.923" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:12:59.923" starttime="20190401 13:12:59.923"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:12:59.934" level="INFO">system helm-override-update --set conf .nova.DEFAULT.foo=bar nova openstack</msg>
<status status="PASS" endtime="20190401 13:12:59.934" starttime="20190401 13:12:59.923"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:01.258" level="INFO">+----------------+----------------+
| Property       | Value          |
+----------------+----------------+
| name           | nova           |
| namespace      | openstack      |
| user_overrides | conf:          |
|                |   nova:        |
|                |     DEFAULT:   |
|                |       foo: bar |
|                |                |
+----------------+----------------+
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:01.258" level="INFO">${output} = +----------------+----------------+
| Property       | Value          |
+----------------+----------------+
| name           | nova           |
| namespace      | openstack      |
| user_override...</msg>
<status status="PASS" endtime="20190401 13:13:01.258" starttime="20190401 13:12:59.934"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:01.259" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:01.259" starttime="20190401 13:13:01.259"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:01.259" level="INFO">${clean_out} = +----------------+----------------+
| Property       | Value          |
+----------------+----------------+
| name           | nova           |
| namespace      | openstack      |
| user_override...</msg>
<status status="PASS" endtime="20190401 13:13:01.259" starttime="20190401 13:13:01.259"></status>
</kw>
<msg timestamp="20190401 13:13:01.259" level="INFO">${output} = +----------------+----------------+
| Property       | Value          |
+----------------+----------------+
| name           | nova           |
| namespace      | openstack      |
| user_override...</msg>
<status status="PASS" endtime="20190401 13:13:01.259" starttime="20190401 13:13:01.258"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:01.261" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:01.261" starttime="20190401 13:13:01.260"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:01.262" level="INFO">0</msg>
<msg timestamp="20190401 13:13:01.262" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:01.262" starttime="20190401 13:13:01.262"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:01.262" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:01.262" starttime="20190401 13:13:01.262"></status>
</kw>
<msg timestamp="20190401 13:13:01.263" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:01.263" starttime="20190401 13:13:01.259"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:01.264" starttime="20190401 13:13:01.263"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:01.264" starttime="20190401 13:13:01.263"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:01.264" starttime="20190401 13:13:01.264"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:01.264" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: +----------------+----------------+
| Property       | Value          |
+----------------+----------------+
| name           | nova           |
| namespace      | openstack      |
| user_overrides | conf:          |
|                |   nova:        |
|                |     DEFAULT:   |
|                |       foo: bar |
|                |                |
+----------------+----------------+</msg>
<status status="PASS" endtime="20190401 13:13:01.264" starttime="20190401 13:13:01.264"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:01.264" starttime="20190401 13:12:59.921"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:01.265" starttime="20190401 13:12:59.920"></status>
</kw>
<kw name="System Application Apply" library="Utils">
<doc>Run the system aplication apply</doc>
<arguments>
<arg>stx-openstack</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>system application-apply ${application}</arg>
<arg>True</arg>
</arguments>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:01.266" starttime="20190401 13:13:01.265"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:01.266" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:01.266" starttime="20190401 13:13:01.266"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:01.267" starttime="20190401 13:13:01.266"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:01.267" starttime="20190401 13:13:01.267"></status>
</kw>
<msg timestamp="20190401 13:13:01.267" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:01.267" starttime="20190401 13:13:01.266"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:01.267" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:01.268" starttime="20190401 13:13:01.267"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:01.275" level="INFO">system application-apply stx-openstack [A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Kk</msg>
<status status="PASS" endtime="20190401 13:13:01.275" starttime="20190401 13:13:01.268"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:02.272" level="INFO">Application-apply rejected: application not found.
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:02.272" level="INFO">${output} = Application-apply rejected: application not found.
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.272" starttime="20190401 13:13:01.275"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:02.273" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.273" starttime="20190401 13:13:02.272"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:02.273" level="INFO">${clean_out} = Application-apply rejected: application not found.
</msg>
<status status="PASS" endtime="20190401 13:13:02.273" starttime="20190401 13:13:02.273"></status>
</kw>
<msg timestamp="20190401 13:13:02.273" level="INFO">${output} = Application-apply rejected: application not found.
</msg>
<status status="PASS" endtime="20190401 13:13:02.273" starttime="20190401 13:13:02.272"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:02.275" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:02.275" starttime="20190401 13:13:02.274"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:02.276" level="INFO">1</msg>
<msg timestamp="20190401 13:13:02.276" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:13:02.276" starttime="20190401 13:13:02.275"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.276" level="INFO">1</msg>
<status status="PASS" endtime="20190401 13:13:02.276" starttime="20190401 13:13:02.276"></status>
</kw>
<msg timestamp="20190401 13:13:02.276" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:13:02.276" starttime="20190401 13:13:02.273"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Fail" library="BuiltIn">
<doc>Fails the test with the given message and optionally alters its tags.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.277" level="FAIL">Application-apply rejected: application not found.
</msg>
<status status="FAIL" endtime="20190401 13:13:02.277" starttime="20190401 13:13:02.277"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:02.277" starttime="20190401 13:13:02.276"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:02.277" starttime="20190401 13:13:01.265"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:02.277" starttime="20190401 13:13:01.265"></status>
</kw>
<doc>Helm override for OpenStack nova chart and reset.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:13:02.278" critical="yes" starttime="20190401 13:12:59.919">Application-apply rejected: application not found.
</status>
</test>
<test id="s1-s2-s1-t4" name="Kube System Services">
<kw name="Check PODs Health" library="Utils">
<doc>Check all OpenStack pods are healthy</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods --all-namespaces -o wide</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:02.279" level="INFO">${kubectl_cmd} = kubectl get pods --all-namespaces -o wide</msg>
<status status="PASS" endtime="20190401 13:13:02.279" starttime="20190401 13:13:02.279"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep -v NAMESPACE</arg>
<arg>grep -v Running</arg>
<arg>grep -v Completed</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:02.279" level="INFO">${cmd} = kubectl get pods --all-namespaces -o wide|grep -v NAMESPACE|grep -v Running|grep -v Completed</msg>
<status status="PASS" endtime="20190401 13:13:02.279" starttime="20190401 13:13:02.279"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.280" starttime="20190401 13:13:02.280"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:02.281" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:02.281" starttime="20190401 13:13:02.280"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.281" starttime="20190401 13:13:02.281"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.281" starttime="20190401 13:13:02.281"></status>
</kw>
<msg timestamp="20190401 13:13:02.282" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:02.282" starttime="20190401 13:13:02.280"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:02.282" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.282" starttime="20190401 13:13:02.282"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.294" level="INFO">kubectl get pods --all-namespaces -o w ide|grep -v NAMESPACE|grep -v Running|grep -v Completed</msg>
<status status="PASS" endtime="20190401 13:13:02.295" starttime="20190401 13:13:02.282"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:02.431" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:02.431" level="INFO">${output} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.431" starttime="20190401 13:13:02.295"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:02.431" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.431" starttime="20190401 13:13:02.431"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:02.432" level="INFO">${clean_out} = </msg>
<status status="PASS" endtime="20190401 13:13:02.432" starttime="20190401 13:13:02.432"></status>
</kw>
<msg timestamp="20190401 13:13:02.432" level="INFO">${output} = </msg>
<status status="PASS" endtime="20190401 13:13:02.432" starttime="20190401 13:13:02.431"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:02.434" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:02.434" starttime="20190401 13:13:02.432"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:02.434" level="INFO">1</msg>
<msg timestamp="20190401 13:13:02.434" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:13:02.434" starttime="20190401 13:13:02.434"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.435" level="INFO">1</msg>
<status status="PASS" endtime="20190401 13:13:02.435" starttime="20190401 13:13:02.435"></status>
</kw>
<msg timestamp="20190401 13:13:02.435" level="INFO">${rc} = 1</msg>
<status status="PASS" endtime="20190401 13:13:02.435" starttime="20190401 13:13:02.432"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.436" starttime="20190401 13:13:02.436"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:02.436" starttime="20190401 13:13:02.435"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.436" starttime="20190401 13:13:02.436"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.436" level="INFO">Dictionary size is 3 and it contains following items:
rc: 1
stderr: 
stdout: </msg>
<status status="PASS" endtime="20190401 13:13:02.436" starttime="20190401 13:13:02.436"></status>
</kw>
<msg timestamp="20190401 13:13:02.437" level="INFO">&amp;{result} = { stdout= | stderr= | rc=1 }</msg>
<status status="PASS" endtime="20190401 13:13:02.437" starttime="20190401 13:13:02.279"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:13:02.437" level="INFO">${value} = </msg>
<status status="PASS" endtime="20190401 13:13:02.437" starttime="20190401 13:13:02.437"></status>
</kw>
<kw name="Should Be Empty" library="BuiltIn">
<doc>Verifies that the given item is empty.</doc>
<arguments>
<arg>${value}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.437" level="INFO">Length is 0</msg>
<status status="PASS" endtime="20190401 13:13:02.437" starttime="20190401 13:13:02.437"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:02.437" starttime="20190401 13:13:02.278"></status>
</kw>
<kw name="Check Kube System Services" library="Utils">
<doc>Check pods status and kube-system services are
displayed.</doc>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get services -n kube-system</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:02.438" level="INFO">${kubectl_cmd} = kubectl get services -n kube-system</msg>
<status status="PASS" endtime="20190401 13:13:02.438" starttime="20190401 13:13:02.438"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep -v NAME</arg>
<arg>awk '{print $1}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:02.438" level="INFO">${cmd} = kubectl get services -n kube-system|grep -v NAME|awk '{print $1}'</msg>
<status status="PASS" endtime="20190401 13:13:02.438" starttime="20190401 13:13:02.438"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.439" starttime="20190401 13:13:02.439"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:02.440" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:02.440" starttime="20190401 13:13:02.439"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.441" starttime="20190401 13:13:02.440"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.441" starttime="20190401 13:13:02.441"></status>
</kw>
<msg timestamp="20190401 13:13:02.441" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:02.441" starttime="20190401 13:13:02.439"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:02.442" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.442" starttime="20190401 13:13:02.442"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.451" level="INFO">kubectl get services -n kube-system|gr ep -v NAME|awk '{print $1}'</msg>
<status status="PASS" endtime="20190401 13:13:02.451" starttime="20190401 13:13:02.442"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:02.593" level="INFO">calico-typha
kube-dns
tiller-deploy
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:02.593" level="INFO">${output} = calico-typha
kube-dns
tiller-deploy
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.593" starttime="20190401 13:13:02.452"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:02.594" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.594" starttime="20190401 13:13:02.594"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:02.594" level="INFO">${clean_out} = calico-typha
kube-dns
tiller-deploy
</msg>
<status status="PASS" endtime="20190401 13:13:02.594" starttime="20190401 13:13:02.594"></status>
</kw>
<msg timestamp="20190401 13:13:02.594" level="INFO">${output} = calico-typha
kube-dns
tiller-deploy
</msg>
<status status="PASS" endtime="20190401 13:13:02.595" starttime="20190401 13:13:02.593"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:02.596" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:02.596" starttime="20190401 13:13:02.595"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:02.597" level="INFO">0</msg>
<msg timestamp="20190401 13:13:02.597" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:02.597" starttime="20190401 13:13:02.596"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.597" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:02.597" starttime="20190401 13:13:02.597"></status>
</kw>
<msg timestamp="20190401 13:13:02.597" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:02.597" starttime="20190401 13:13:02.595"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.598" starttime="20190401 13:13:02.598"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:02.598" starttime="20190401 13:13:02.597"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.598" starttime="20190401 13:13:02.598"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.599" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: calico-typha
kube-dns
tiller-deploy</msg>
<status status="PASS" endtime="20190401 13:13:02.599" starttime="20190401 13:13:02.599"></status>
</kw>
<msg timestamp="20190401 13:13:02.599" level="INFO">&amp;{result} = { stdout=calico-typha
kube-dns
tiller-deploy | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:02.599" starttime="20190401 13:13:02.438"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${kubeb_systems}</var>
</assign>
<msg timestamp="20190401 13:13:02.599" level="INFO">${kubeb_systems} = calico-typha
kube-dns
tiller-deploy</msg>
<status status="PASS" endtime="20190401 13:13:02.599" starttime="20190401 13:13:02.599"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${kubeb_systems}</arg>
<arg>calico-typha</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.600" starttime="20190401 13:13:02.599"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${kubeb_systems}</arg>
<arg>kube-dns</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.600" starttime="20190401 13:13:02.600"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${kubeb_systems}</arg>
<arg>tiller-deploy</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.600" starttime="20190401 13:13:02.600"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>kubectl get deployments.apps -n kube-system</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.601" starttime="20190401 13:13:02.601"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:02.602" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:02.602" starttime="20190401 13:13:02.601"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.602" starttime="20190401 13:13:02.602"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.602" starttime="20190401 13:13:02.602"></status>
</kw>
<msg timestamp="20190401 13:13:02.602" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:02.602" starttime="20190401 13:13:02.601"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:02.603" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.603" starttime="20190401 13:13:02.603"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.604" level="INFO">kubectl get deployments.apps -n kube-s ystem</msg>
<status status="PASS" endtime="20190401 13:13:02.604" starttime="20190401 13:13:02.603"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:02.747" level="INFO">NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
calico-typha    0         0         0            0           6h17m
coredns         2         2         2            2           6h17m
tiller-deploy   1         1         1            1           6h17m
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:02.747" level="INFO">${output} = NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
calico-typha    0         0         0            0           6h17m
coredns         2         2         2            2           6h17m...</msg>
<status status="PASS" endtime="20190401 13:13:02.747" starttime="20190401 13:13:02.604"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:02.748" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.748" starttime="20190401 13:13:02.748"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:02.748" level="INFO">${clean_out} = NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
calico-typha    0         0         0            0           6h17m
coredns         2         2         2            2           6h17m...</msg>
<status status="PASS" endtime="20190401 13:13:02.748" starttime="20190401 13:13:02.748"></status>
</kw>
<msg timestamp="20190401 13:13:02.749" level="INFO">${output} = NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
calico-typha    0         0         0            0           6h17m
coredns         2         2         2            2           6h17m...</msg>
<status status="PASS" endtime="20190401 13:13:02.749" starttime="20190401 13:13:02.747"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:02.751" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:02.751" starttime="20190401 13:13:02.749"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:02.751" level="INFO">0</msg>
<msg timestamp="20190401 13:13:02.751" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:02.751" starttime="20190401 13:13:02.751"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.752" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:02.752" starttime="20190401 13:13:02.751"></status>
</kw>
<msg timestamp="20190401 13:13:02.752" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:02.752" starttime="20190401 13:13:02.749"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.753" starttime="20190401 13:13:02.752"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:02.753" starttime="20190401 13:13:02.752"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.753" starttime="20190401 13:13:02.753"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.753" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
calico-typha    0         0         0            0           6h17m
coredns         2         2         2            2           6h17m
tiller-deploy   1         1         1            1           6h17m</msg>
<status status="PASS" endtime="20190401 13:13:02.753" starttime="20190401 13:13:02.753"></status>
</kw>
<msg timestamp="20190401 13:13:02.754" level="INFO">&amp;{result} = { stdout=NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
calico-typha    0         0         0            0           6h17m
coredns         2         2         2            2       ...</msg>
<status status="PASS" endtime="20190401 13:13:02.754" starttime="20190401 13:13:02.600"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${kubeb_systems}</var>
</assign>
<msg timestamp="20190401 13:13:02.754" level="INFO">${kubeb_systems} = NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
calico-typha    0         0         0            0           6h17m
coredns         2         2         2            2           6h17m...</msg>
<status status="PASS" endtime="20190401 13:13:02.754" starttime="20190401 13:13:02.754"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${kubeb_systems}</arg>
<arg>calico-typha</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.754" starttime="20190401 13:13:02.754"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${kubeb_systems}</arg>
<arg>coredns</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.755" starttime="20190401 13:13:02.754"></status>
</kw>
<kw name="Should Contain" library="BuiltIn">
<doc>Fails if ``container`` does not contain ``item`` one or more times.</doc>
<arguments>
<arg>${kubeb_systems}</arg>
<arg>tiller-deploy</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.755" starttime="20190401 13:13:02.755"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:02.755" starttime="20190401 13:13:02.438"></status>
</kw>
<doc>Check pods status and kube-system services are
displayed.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="PASS" endtime="20190401 13:13:02.755" critical="yes" starttime="20190401 13:13:02.278"></status>
</test>
<test id="s1-s2-s1-t5" name="Create Check Delete POD">
<kw name="Put File" library="SSHLibrary">
<doc>Uploads file(s) from the local machine to the remote machine.</doc>
<arguments>
<arg>%{PYTHONPATH}/Utils/${pod_yml}</arg>
<arg>${host_image_path}/${pod_yml}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.763" level="INFO">[chan 1] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:13:02.769" level="INFO">[chan 2] Opened sftp connection (server version 3)</msg>
<msg timestamp="20190401 13:13:02.774" level="INFO">'/home/mgperezi/duplex/stx-test-suite/Utils/testpod.yaml' -&gt; '/home/wrsroot//testpod.yaml'</msg>
<status status="PASS" endtime="20190401 13:13:02.774" starttime="20190401 13:13:02.756"></status>
</kw>
<kw name="Create POD" library="Utils">
<doc>Create a POD.</doc>
<arguments>
<arg>${pod_yml}</arg>
<arg>${pod_name}</arg>
</arguments>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>kubectl create -f ${pod_yml}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.775" starttime="20190401 13:13:02.774"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:02.776" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:02.776" starttime="20190401 13:13:02.775"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.776" starttime="20190401 13:13:02.776"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.776" starttime="20190401 13:13:02.776"></status>
</kw>
<msg timestamp="20190401 13:13:02.777" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:02.777" starttime="20190401 13:13:02.775"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:02.777" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.777" starttime="20190401 13:13:02.777"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.782" level="INFO">kubectl create -f testpod.yaml</msg>
<status status="PASS" endtime="20190401 13:13:02.782" starttime="20190401 13:13:02.777"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:02.969" level="INFO">pod/testpod created
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:02.970" level="INFO">${output} = pod/testpod created
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.970" starttime="20190401 13:13:02.782"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:02.970" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.970" starttime="20190401 13:13:02.970"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:02.971" level="INFO">${clean_out} = pod/testpod created
</msg>
<status status="PASS" endtime="20190401 13:13:02.971" starttime="20190401 13:13:02.971"></status>
</kw>
<msg timestamp="20190401 13:13:02.971" level="INFO">${output} = pod/testpod created
</msg>
<status status="PASS" endtime="20190401 13:13:02.971" starttime="20190401 13:13:02.970"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:02.973" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:02.973" starttime="20190401 13:13:02.971"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:02.973" level="INFO">0</msg>
<msg timestamp="20190401 13:13:02.973" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:02.973" starttime="20190401 13:13:02.973"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.974" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:02.974" starttime="20190401 13:13:02.974"></status>
</kw>
<msg timestamp="20190401 13:13:02.974" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:02.974" starttime="20190401 13:13:02.971"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.975" starttime="20190401 13:13:02.974"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:02.975" starttime="20190401 13:13:02.974"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.975" starttime="20190401 13:13:02.975"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.975" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: pod/testpod created</msg>
<status status="PASS" endtime="20190401 13:13:02.975" starttime="20190401 13:13:02.975"></status>
</kw>
<msg timestamp="20190401 13:13:02.976" level="INFO">&amp;{result} = { stdout=pod/testpod created | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:02.976" starttime="20190401 13:13:02.774"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${value}</var>
</assign>
<msg timestamp="20190401 13:13:02.976" level="INFO">${value} = pod/testpod created</msg>
<status status="PASS" endtime="20190401 13:13:02.976" starttime="20190401 13:13:02.976"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${value}</arg>
<arg>pod/${pod_name} created</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.976" starttime="20190401 13:13:02.976"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:02.976" starttime="20190401 13:13:02.774"></status>
</kw>
<kw name="Wait Until Keyword Succeeds" library="BuiltIn">
<doc>Runs the specified keyword and retries if it fails.</doc>
<arguments>
<arg>1 min</arg>
<arg>5 sec</arg>
<arg>Check POD</arg>
<arg>${pod_name}</arg>
</arguments>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:02.977" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:02.977" starttime="20190401 13:13:02.977"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:02.978" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:02.978" starttime="20190401 13:13:02.977"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.978" starttime="20190401 13:13:02.978"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:02.979" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:02.979" starttime="20190401 13:13:02.979"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.979" starttime="20190401 13:13:02.979"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:02.980" starttime="20190401 13:13:02.980"></status>
</kw>
<msg timestamp="20190401 13:13:02.980" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:02.980" starttime="20190401 13:13:02.978"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:02.980" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:02.980" starttime="20190401 13:13:02.980"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:02.989" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:02.989" starttime="20190401 13:13:02.980"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:03.126" level="INFO">ContainerCreating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:03.127" level="INFO">${output} = ContainerCreating
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:03.127" starttime="20190401 13:13:02.989"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:03.128" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:03.128" starttime="20190401 13:13:03.127"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:03.128" level="INFO">${clean_out} = ContainerCreating
</msg>
<status status="PASS" endtime="20190401 13:13:03.128" starttime="20190401 13:13:03.128"></status>
</kw>
<msg timestamp="20190401 13:13:03.128" level="INFO">${output} = ContainerCreating
</msg>
<status status="PASS" endtime="20190401 13:13:03.128" starttime="20190401 13:13:03.127"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:03.130" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:03.130" starttime="20190401 13:13:03.128"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:03.130" level="INFO">0</msg>
<msg timestamp="20190401 13:13:03.130" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:03.130" starttime="20190401 13:13:03.130"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:03.131" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:03.131" starttime="20190401 13:13:03.130"></status>
</kw>
<msg timestamp="20190401 13:13:03.131" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:03.131" starttime="20190401 13:13:03.128"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:03.132" starttime="20190401 13:13:03.131"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:03.132" starttime="20190401 13:13:03.131"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:03.132" starttime="20190401 13:13:03.132"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:03.132" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ContainerCreating</msg>
<status status="PASS" endtime="20190401 13:13:03.132" starttime="20190401 13:13:03.132"></status>
</kw>
<msg timestamp="20190401 13:13:03.132" level="INFO">&amp;{result} = { stdout=ContainerCreating | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:03.132" starttime="20190401 13:13:02.978"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:03.133" level="INFO">${status} = ContainerCreating</msg>
<status status="PASS" endtime="20190401 13:13:03.133" starttime="20190401 13:13:03.133"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:03.133" level="FAIL">ContainerCreating != Running</msg>
<status status="FAIL" endtime="20190401 13:13:03.133" starttime="20190401 13:13:03.133"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:03.133" starttime="20190401 13:13:02.977"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:08.134" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:08.134" starttime="20190401 13:13:08.134"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:08.135" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:08.135" starttime="20190401 13:13:08.134"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:08.135" starttime="20190401 13:13:08.135"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:08.136" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:08.136" starttime="20190401 13:13:08.136"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:08.137" starttime="20190401 13:13:08.136"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:08.137" starttime="20190401 13:13:08.137"></status>
</kw>
<msg timestamp="20190401 13:13:08.137" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:08.137" starttime="20190401 13:13:08.136"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:08.137" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:08.137" starttime="20190401 13:13:08.137"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:08.145" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:08.145" starttime="20190401 13:13:08.138"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:08.273" level="INFO">ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:08.273" level="INFO">${output} = ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:08.273" starttime="20190401 13:13:08.145"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:08.275" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:08.275" starttime="20190401 13:13:08.274"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:08.275" level="INFO">${clean_out} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:08.275" starttime="20190401 13:13:08.275"></status>
</kw>
<msg timestamp="20190401 13:13:08.275" level="INFO">${output} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:08.275" starttime="20190401 13:13:08.273"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:08.277" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:08.277" starttime="20190401 13:13:08.276"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:08.278" level="INFO">0</msg>
<msg timestamp="20190401 13:13:08.278" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:08.278" starttime="20190401 13:13:08.277"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:08.278" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:08.278" starttime="20190401 13:13:08.278"></status>
</kw>
<msg timestamp="20190401 13:13:08.278" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:08.278" starttime="20190401 13:13:08.275"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:08.279" starttime="20190401 13:13:08.279"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:08.279" starttime="20190401 13:13:08.278"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:08.279" starttime="20190401 13:13:08.279"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:08.280" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:08.280" starttime="20190401 13:13:08.279"></status>
</kw>
<msg timestamp="20190401 13:13:08.280" level="INFO">&amp;{result} = { stdout=ImagePullBackOff | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:08.280" starttime="20190401 13:13:08.135"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:08.280" level="INFO">${status} = ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:08.280" starttime="20190401 13:13:08.280"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:08.281" level="FAIL">ImagePullBackOff != Running</msg>
<status status="FAIL" endtime="20190401 13:13:08.281" starttime="20190401 13:13:08.280"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:08.281" starttime="20190401 13:13:08.134"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:13.282" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:13.282" starttime="20190401 13:13:13.282"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:13.282" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:13.282" starttime="20190401 13:13:13.282"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:13.283" starttime="20190401 13:13:13.283"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:13.284" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:13.284" starttime="20190401 13:13:13.283"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:13.284" starttime="20190401 13:13:13.284"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:13.284" starttime="20190401 13:13:13.284"></status>
</kw>
<msg timestamp="20190401 13:13:13.285" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:13.285" starttime="20190401 13:13:13.283"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:13.285" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:13.285" starttime="20190401 13:13:13.285"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:13.293" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:13.294" starttime="20190401 13:13:13.285"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:13.420" level="INFO">ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:13.420" level="INFO">${output} = ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:13.420" starttime="20190401 13:13:13.294"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:13.421" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:13.421" starttime="20190401 13:13:13.420"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:13.421" level="INFO">${clean_out} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:13.421" starttime="20190401 13:13:13.421"></status>
</kw>
<msg timestamp="20190401 13:13:13.421" level="INFO">${output} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:13.421" starttime="20190401 13:13:13.420"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:13.423" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:13.423" starttime="20190401 13:13:13.421"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:13.424" level="INFO">0</msg>
<msg timestamp="20190401 13:13:13.424" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:13.424" starttime="20190401 13:13:13.423"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:13.424" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:13.424" starttime="20190401 13:13:13.424"></status>
</kw>
<msg timestamp="20190401 13:13:13.424" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:13.424" starttime="20190401 13:13:13.421"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:13.425" starttime="20190401 13:13:13.425"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:13.425" starttime="20190401 13:13:13.424"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:13.425" starttime="20190401 13:13:13.425"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:13.426" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:13.426" starttime="20190401 13:13:13.425"></status>
</kw>
<msg timestamp="20190401 13:13:13.426" level="INFO">&amp;{result} = { stdout=ImagePullBackOff | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:13.426" starttime="20190401 13:13:13.282"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:13.426" level="INFO">${status} = ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:13.426" starttime="20190401 13:13:13.426"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:13.427" level="FAIL">ImagePullBackOff != Running</msg>
<status status="FAIL" endtime="20190401 13:13:13.427" starttime="20190401 13:13:13.426"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:13.427" starttime="20190401 13:13:13.281"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:18.428" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:18.428" starttime="20190401 13:13:18.428"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:18.428" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:18.428" starttime="20190401 13:13:18.428"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:18.429" starttime="20190401 13:13:18.429"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:18.430" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:18.430" starttime="20190401 13:13:18.429"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:18.430" starttime="20190401 13:13:18.430"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:18.430" starttime="20190401 13:13:18.430"></status>
</kw>
<msg timestamp="20190401 13:13:18.431" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:18.431" starttime="20190401 13:13:18.429"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:18.431" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:18.431" starttime="20190401 13:13:18.431"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:18.439" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:18.439" starttime="20190401 13:13:18.431"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:18.574" level="INFO">ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:18.575" level="INFO">${output} = ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:18.575" starttime="20190401 13:13:18.439"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:18.575" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:18.575" starttime="20190401 13:13:18.575"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:18.576" level="INFO">${clean_out} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:18.576" starttime="20190401 13:13:18.575"></status>
</kw>
<msg timestamp="20190401 13:13:18.576" level="INFO">${output} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:18.576" starttime="20190401 13:13:18.575"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:18.578" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:18.578" starttime="20190401 13:13:18.576"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:18.578" level="INFO">0</msg>
<msg timestamp="20190401 13:13:18.578" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:18.578" starttime="20190401 13:13:18.578"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:18.578" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:18.579" starttime="20190401 13:13:18.578"></status>
</kw>
<msg timestamp="20190401 13:13:18.579" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:18.579" starttime="20190401 13:13:18.576"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:18.580" starttime="20190401 13:13:18.579"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:18.580" starttime="20190401 13:13:18.579"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:18.580" starttime="20190401 13:13:18.580"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:18.580" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:18.580" starttime="20190401 13:13:18.580"></status>
</kw>
<msg timestamp="20190401 13:13:18.581" level="INFO">&amp;{result} = { stdout=ImagePullBackOff | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:18.581" starttime="20190401 13:13:18.428"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:18.581" level="INFO">${status} = ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:18.581" starttime="20190401 13:13:18.581"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:18.581" level="FAIL">ImagePullBackOff != Running</msg>
<status status="FAIL" endtime="20190401 13:13:18.581" starttime="20190401 13:13:18.581"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:18.581" starttime="20190401 13:13:18.427"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:23.583" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:23.583" starttime="20190401 13:13:23.583"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:23.584" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:23.584" starttime="20190401 13:13:23.583"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:23.585" starttime="20190401 13:13:23.584"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:23.586" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:23.586" starttime="20190401 13:13:23.585"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:23.587" starttime="20190401 13:13:23.586"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:23.587" starttime="20190401 13:13:23.587"></status>
</kw>
<msg timestamp="20190401 13:13:23.588" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:23.588" starttime="20190401 13:13:23.585"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:23.588" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:23.588" starttime="20190401 13:13:23.588"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:23.603" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:23.603" starttime="20190401 13:13:23.588"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:23.733" level="INFO">ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:23.733" level="INFO">${output} = ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:23.733" starttime="20190401 13:13:23.603"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:23.734" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:23.734" starttime="20190401 13:13:23.733"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:23.734" level="INFO">${clean_out} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:23.734" starttime="20190401 13:13:23.734"></status>
</kw>
<msg timestamp="20190401 13:13:23.734" level="INFO">${output} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:23.734" starttime="20190401 13:13:23.733"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:23.736" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:23.736" starttime="20190401 13:13:23.734"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:23.736" level="INFO">0</msg>
<msg timestamp="20190401 13:13:23.736" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:23.737" starttime="20190401 13:13:23.736"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:23.737" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:23.737" starttime="20190401 13:13:23.737"></status>
</kw>
<msg timestamp="20190401 13:13:23.737" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:23.737" starttime="20190401 13:13:23.734"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:23.738" starttime="20190401 13:13:23.737"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:23.738" starttime="20190401 13:13:23.737"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:23.738" starttime="20190401 13:13:23.738"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:23.738" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:23.738" starttime="20190401 13:13:23.738"></status>
</kw>
<msg timestamp="20190401 13:13:23.739" level="INFO">&amp;{result} = { stdout=ImagePullBackOff | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:23.739" starttime="20190401 13:13:23.584"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:23.739" level="INFO">${status} = ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:23.739" starttime="20190401 13:13:23.739"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:23.740" level="FAIL">ImagePullBackOff != Running</msg>
<status status="FAIL" endtime="20190401 13:13:23.740" starttime="20190401 13:13:23.739"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:23.740" starttime="20190401 13:13:23.582"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:28.741" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:28.741" starttime="20190401 13:13:28.741"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:28.741" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:28.741" starttime="20190401 13:13:28.741"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:28.742" starttime="20190401 13:13:28.742"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:28.743" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:28.743" starttime="20190401 13:13:28.742"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:28.743" starttime="20190401 13:13:28.743"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:28.743" starttime="20190401 13:13:28.743"></status>
</kw>
<msg timestamp="20190401 13:13:28.744" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:28.744" starttime="20190401 13:13:28.742"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:28.744" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:28.744" starttime="20190401 13:13:28.744"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:28.754" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:28.755" starttime="20190401 13:13:28.744"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:28.931" level="INFO">ErrImagePull
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:28.932" level="INFO">${output} = ErrImagePull
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:28.932" starttime="20190401 13:13:28.755"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:28.932" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:28.932" starttime="20190401 13:13:28.932"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:28.933" level="INFO">${clean_out} = ErrImagePull
</msg>
<status status="PASS" endtime="20190401 13:13:28.933" starttime="20190401 13:13:28.932"></status>
</kw>
<msg timestamp="20190401 13:13:28.933" level="INFO">${output} = ErrImagePull
</msg>
<status status="PASS" endtime="20190401 13:13:28.933" starttime="20190401 13:13:28.932"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:28.934" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:28.934" starttime="20190401 13:13:28.933"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:28.935" level="INFO">0</msg>
<msg timestamp="20190401 13:13:28.935" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:28.935" starttime="20190401 13:13:28.934"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:28.935" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:28.936" starttime="20190401 13:13:28.935"></status>
</kw>
<msg timestamp="20190401 13:13:28.936" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:28.936" starttime="20190401 13:13:28.933"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:28.936" starttime="20190401 13:13:28.936"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:28.937" starttime="20190401 13:13:28.936"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:28.937" starttime="20190401 13:13:28.937"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:28.937" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ErrImagePull</msg>
<status status="PASS" endtime="20190401 13:13:28.937" starttime="20190401 13:13:28.937"></status>
</kw>
<msg timestamp="20190401 13:13:28.937" level="INFO">&amp;{result} = { stdout=ErrImagePull | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:28.937" starttime="20190401 13:13:28.741"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:28.938" level="INFO">${status} = ErrImagePull</msg>
<status status="PASS" endtime="20190401 13:13:28.938" starttime="20190401 13:13:28.937"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:28.938" level="FAIL">ErrImagePull != Running</msg>
<status status="FAIL" endtime="20190401 13:13:28.938" starttime="20190401 13:13:28.938"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:28.938" starttime="20190401 13:13:28.740"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:33.940" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:33.940" starttime="20190401 13:13:33.939"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:33.940" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:33.940" starttime="20190401 13:13:33.940"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:33.941" starttime="20190401 13:13:33.941"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:33.941" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:33.941" starttime="20190401 13:13:33.941"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:33.942" starttime="20190401 13:13:33.942"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:33.942" starttime="20190401 13:13:33.942"></status>
</kw>
<msg timestamp="20190401 13:13:33.942" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:33.943" starttime="20190401 13:13:33.941"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:33.943" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:33.943" starttime="20190401 13:13:33.943"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:33.952" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:33.952" starttime="20190401 13:13:33.943"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:34.074" level="INFO">ErrImagePull
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:34.074" level="INFO">${output} = ErrImagePull
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:34.074" starttime="20190401 13:13:33.952"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:34.075" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:34.075" starttime="20190401 13:13:34.075"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:34.075" level="INFO">${clean_out} = ErrImagePull
</msg>
<status status="PASS" endtime="20190401 13:13:34.076" starttime="20190401 13:13:34.075"></status>
</kw>
<msg timestamp="20190401 13:13:34.076" level="INFO">${output} = ErrImagePull
</msg>
<status status="PASS" endtime="20190401 13:13:34.076" starttime="20190401 13:13:34.075"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:34.078" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:34.078" starttime="20190401 13:13:34.076"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:34.078" level="INFO">0</msg>
<msg timestamp="20190401 13:13:34.078" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:34.078" starttime="20190401 13:13:34.078"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:34.078" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:34.079" starttime="20190401 13:13:34.078"></status>
</kw>
<msg timestamp="20190401 13:13:34.079" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:34.079" starttime="20190401 13:13:34.076"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:34.079" starttime="20190401 13:13:34.079"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:34.080" starttime="20190401 13:13:34.079"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:34.080" starttime="20190401 13:13:34.080"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:34.080" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ErrImagePull</msg>
<status status="PASS" endtime="20190401 13:13:34.080" starttime="20190401 13:13:34.080"></status>
</kw>
<msg timestamp="20190401 13:13:34.080" level="INFO">&amp;{result} = { stdout=ErrImagePull | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:34.080" starttime="20190401 13:13:33.940"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:34.081" level="INFO">${status} = ErrImagePull</msg>
<status status="PASS" endtime="20190401 13:13:34.081" starttime="20190401 13:13:34.081"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:34.081" level="FAIL">ErrImagePull != Running</msg>
<status status="FAIL" endtime="20190401 13:13:34.081" starttime="20190401 13:13:34.081"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:34.081" starttime="20190401 13:13:33.939"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:39.082" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:39.082" starttime="20190401 13:13:39.082"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:39.083" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:39.083" starttime="20190401 13:13:39.083"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:39.084" starttime="20190401 13:13:39.084"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:39.084" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:39.085" starttime="20190401 13:13:39.084"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:39.085" starttime="20190401 13:13:39.085"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:39.085" starttime="20190401 13:13:39.085"></status>
</kw>
<msg timestamp="20190401 13:13:39.085" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:39.086" starttime="20190401 13:13:39.084"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:39.086" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:39.086" starttime="20190401 13:13:39.086"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:39.107" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:39.107" starttime="20190401 13:13:39.086"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:39.229" level="INFO">ErrImagePull
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:39.230" level="INFO">${output} = ErrImagePull
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:39.230" starttime="20190401 13:13:39.107"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:39.230" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:39.230" starttime="20190401 13:13:39.230"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:39.231" level="INFO">${clean_out} = ErrImagePull
</msg>
<status status="PASS" endtime="20190401 13:13:39.231" starttime="20190401 13:13:39.230"></status>
</kw>
<msg timestamp="20190401 13:13:39.231" level="INFO">${output} = ErrImagePull
</msg>
<status status="PASS" endtime="20190401 13:13:39.231" starttime="20190401 13:13:39.230"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:39.233" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:39.233" starttime="20190401 13:13:39.231"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:39.233" level="INFO">0</msg>
<msg timestamp="20190401 13:13:39.233" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:39.233" starttime="20190401 13:13:39.233"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:39.234" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:39.234" starttime="20190401 13:13:39.234"></status>
</kw>
<msg timestamp="20190401 13:13:39.234" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:39.234" starttime="20190401 13:13:39.231"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:39.235" starttime="20190401 13:13:39.234"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:39.235" starttime="20190401 13:13:39.234"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:39.235" starttime="20190401 13:13:39.235"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:39.235" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ErrImagePull</msg>
<status status="PASS" endtime="20190401 13:13:39.235" starttime="20190401 13:13:39.235"></status>
</kw>
<msg timestamp="20190401 13:13:39.236" level="INFO">&amp;{result} = { stdout=ErrImagePull | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:39.236" starttime="20190401 13:13:39.083"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:39.236" level="INFO">${status} = ErrImagePull</msg>
<status status="PASS" endtime="20190401 13:13:39.236" starttime="20190401 13:13:39.236"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:39.236" level="FAIL">ErrImagePull != Running</msg>
<status status="FAIL" endtime="20190401 13:13:39.236" starttime="20190401 13:13:39.236"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:39.237" starttime="20190401 13:13:39.082"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:44.238" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:44.238" starttime="20190401 13:13:44.237"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:44.238" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:44.238" starttime="20190401 13:13:44.238"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:44.239" starttime="20190401 13:13:44.239"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:44.240" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:44.240" starttime="20190401 13:13:44.239"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:44.240" starttime="20190401 13:13:44.240"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:44.241" starttime="20190401 13:13:44.240"></status>
</kw>
<msg timestamp="20190401 13:13:44.241" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:44.241" starttime="20190401 13:13:44.239"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:44.241" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:44.241" starttime="20190401 13:13:44.241"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:44.243" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:44.243" starttime="20190401 13:13:44.241"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:44.383" level="INFO">ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:44.383" level="INFO">${output} = ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:44.383" starttime="20190401 13:13:44.243"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:44.383" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:44.383" starttime="20190401 13:13:44.383"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:44.384" level="INFO">${clean_out} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:44.384" starttime="20190401 13:13:44.383"></status>
</kw>
<msg timestamp="20190401 13:13:44.384" level="INFO">${output} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:44.384" starttime="20190401 13:13:44.383"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:44.386" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:44.386" starttime="20190401 13:13:44.384"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:44.386" level="INFO">0</msg>
<msg timestamp="20190401 13:13:44.386" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:44.386" starttime="20190401 13:13:44.386"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:44.387" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:44.387" starttime="20190401 13:13:44.386"></status>
</kw>
<msg timestamp="20190401 13:13:44.387" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:44.387" starttime="20190401 13:13:44.384"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:44.388" starttime="20190401 13:13:44.387"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:44.388" starttime="20190401 13:13:44.387"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:44.388" starttime="20190401 13:13:44.388"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:44.388" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:44.388" starttime="20190401 13:13:44.388"></status>
</kw>
<msg timestamp="20190401 13:13:44.388" level="INFO">&amp;{result} = { stdout=ImagePullBackOff | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:44.388" starttime="20190401 13:13:44.238"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:44.389" level="INFO">${status} = ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:44.389" starttime="20190401 13:13:44.389"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:44.389" level="FAIL">ImagePullBackOff != Running</msg>
<status status="FAIL" endtime="20190401 13:13:44.389" starttime="20190401 13:13:44.389"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:44.389" starttime="20190401 13:13:44.237"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:49.390" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:49.390" starttime="20190401 13:13:49.390"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:49.391" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:49.391" starttime="20190401 13:13:49.390"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:49.391" starttime="20190401 13:13:49.391"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:49.392" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:49.392" starttime="20190401 13:13:49.392"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:49.393" starttime="20190401 13:13:49.392"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:49.393" starttime="20190401 13:13:49.393"></status>
</kw>
<msg timestamp="20190401 13:13:49.393" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:49.393" starttime="20190401 13:13:49.392"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:49.394" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:49.394" starttime="20190401 13:13:49.394"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:49.402" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:49.402" starttime="20190401 13:13:49.394"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:49.527" level="INFO">ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:49.528" level="INFO">${output} = ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:49.528" starttime="20190401 13:13:49.402"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:49.528" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:49.528" starttime="20190401 13:13:49.528"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:49.529" level="INFO">${clean_out} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:49.529" starttime="20190401 13:13:49.528"></status>
</kw>
<msg timestamp="20190401 13:13:49.529" level="INFO">${output} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:49.529" starttime="20190401 13:13:49.528"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:49.530" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:49.530" starttime="20190401 13:13:49.529"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:49.531" level="INFO">0</msg>
<msg timestamp="20190401 13:13:49.531" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:49.531" starttime="20190401 13:13:49.531"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:49.531" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:49.531" starttime="20190401 13:13:49.531"></status>
</kw>
<msg timestamp="20190401 13:13:49.531" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:49.531" starttime="20190401 13:13:49.529"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:49.532" starttime="20190401 13:13:49.532"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:49.532" starttime="20190401 13:13:49.532"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:49.533" starttime="20190401 13:13:49.532"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:49.533" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:49.533" starttime="20190401 13:13:49.533"></status>
</kw>
<msg timestamp="20190401 13:13:49.533" level="INFO">&amp;{result} = { stdout=ImagePullBackOff | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:49.533" starttime="20190401 13:13:49.391"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:49.533" level="INFO">${status} = ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:49.533" starttime="20190401 13:13:49.533"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:49.534" level="FAIL">ImagePullBackOff != Running</msg>
<status status="FAIL" endtime="20190401 13:13:49.534" starttime="20190401 13:13:49.534"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:49.534" starttime="20190401 13:13:49.390"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:54.535" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:54.535" starttime="20190401 13:13:54.535"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:54.535" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:54.535" starttime="20190401 13:13:54.535"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:54.536" starttime="20190401 13:13:54.536"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:54.537" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:54.537" starttime="20190401 13:13:54.537"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:54.537" starttime="20190401 13:13:54.537"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:54.538" starttime="20190401 13:13:54.537"></status>
</kw>
<msg timestamp="20190401 13:13:54.538" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:54.538" starttime="20190401 13:13:54.536"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:54.538" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:54.538" starttime="20190401 13:13:54.538"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:54.547" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:54.547" starttime="20190401 13:13:54.538"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:54.671" level="INFO">ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:54.671" level="INFO">${output} = ImagePullBackOff
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:54.671" starttime="20190401 13:13:54.547"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:54.672" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:54.672" starttime="20190401 13:13:54.672"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:54.672" level="INFO">${clean_out} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:54.673" starttime="20190401 13:13:54.672"></status>
</kw>
<msg timestamp="20190401 13:13:54.673" level="INFO">${output} = ImagePullBackOff
</msg>
<status status="PASS" endtime="20190401 13:13:54.673" starttime="20190401 13:13:54.672"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:54.674" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:54.674" starttime="20190401 13:13:54.673"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:54.675" level="INFO">0</msg>
<msg timestamp="20190401 13:13:54.675" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:54.675" starttime="20190401 13:13:54.674"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:54.675" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:54.675" starttime="20190401 13:13:54.675"></status>
</kw>
<msg timestamp="20190401 13:13:54.675" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:54.675" starttime="20190401 13:13:54.673"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:54.676" starttime="20190401 13:13:54.676"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:54.676" starttime="20190401 13:13:54.675"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:54.676" starttime="20190401 13:13:54.676"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:54.677" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:54.677" starttime="20190401 13:13:54.677"></status>
</kw>
<msg timestamp="20190401 13:13:54.677" level="INFO">&amp;{result} = { stdout=ImagePullBackOff | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:54.677" starttime="20190401 13:13:54.536"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:54.677" level="INFO">${status} = ImagePullBackOff</msg>
<status status="PASS" endtime="20190401 13:13:54.677" starttime="20190401 13:13:54.677"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:54.678" level="FAIL">ImagePullBackOff != Running</msg>
<status status="FAIL" endtime="20190401 13:13:54.678" starttime="20190401 13:13:54.677"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:54.678" starttime="20190401 13:13:54.534"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:13:59.679" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:13:59.679" starttime="20190401 13:13:59.679"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:13:59.679" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:59.679" starttime="20190401 13:13:59.679"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:59.680" starttime="20190401 13:13:59.680"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:13:59.681" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:13:59.681" starttime="20190401 13:13:59.680"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:59.681" starttime="20190401 13:13:59.681"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:59.681" starttime="20190401 13:13:59.681"></status>
</kw>
<msg timestamp="20190401 13:13:59.682" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:13:59.682" starttime="20190401 13:13:59.680"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:13:59.682" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:59.682" starttime="20190401 13:13:59.682"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:13:59.690" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:13:59.691" starttime="20190401 13:13:59.682"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:13:59.813" level="INFO">ErrImagePull
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:13:59.813" level="INFO">${output} = ErrImagePull
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:59.813" starttime="20190401 13:13:59.691"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:13:59.814" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:13:59.814" starttime="20190401 13:13:59.814"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:13:59.814" level="INFO">${clean_out} = ErrImagePull
</msg>
<status status="PASS" endtime="20190401 13:13:59.814" starttime="20190401 13:13:59.814"></status>
</kw>
<msg timestamp="20190401 13:13:59.815" level="INFO">${output} = ErrImagePull
</msg>
<status status="PASS" endtime="20190401 13:13:59.815" starttime="20190401 13:13:59.813"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:13:59.816" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:13:59.816" starttime="20190401 13:13:59.815"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:13:59.817" level="INFO">0</msg>
<msg timestamp="20190401 13:13:59.817" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:59.817" starttime="20190401 13:13:59.816"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:13:59.817" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:13:59.817" starttime="20190401 13:13:59.817"></status>
</kw>
<msg timestamp="20190401 13:13:59.817" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:13:59.817" starttime="20190401 13:13:59.815"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:59.818" starttime="20190401 13:13:59.818"></status>
</kw>
<status status="PASS" endtime="20190401 13:13:59.818" starttime="20190401 13:13:59.818"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:13:59.819" starttime="20190401 13:13:59.818"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:13:59.819" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ErrImagePull</msg>
<status status="PASS" endtime="20190401 13:13:59.819" starttime="20190401 13:13:59.819"></status>
</kw>
<msg timestamp="20190401 13:13:59.819" level="INFO">&amp;{result} = { stdout=ErrImagePull | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:13:59.819" starttime="20190401 13:13:59.679"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:13:59.819" level="INFO">${status} = ErrImagePull</msg>
<status status="PASS" endtime="20190401 13:13:59.819" starttime="20190401 13:13:59.819"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:13:59.820" level="FAIL">ErrImagePull != Running</msg>
<status status="FAIL" endtime="20190401 13:13:59.820" starttime="20190401 13:13:59.820"></status>
</kw>
<status status="FAIL" endtime="20190401 13:13:59.820" starttime="20190401 13:13:59.678"></status>
</kw>
<kw name="Check POD" library="Utils">
<doc>Check if a POD is running.</doc>
<arguments>
<arg>${pod_name}</arg>
</arguments>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>kubectl get pods -n default</arg>
</arguments>
<assign>
<var>${kubectl_cmd}</var>
</assign>
<msg timestamp="20190401 13:14:04.821" level="INFO">${kubectl_cmd} = kubectl get pods -n default</msg>
<status status="PASS" endtime="20190401 13:14:04.821" starttime="20190401 13:14:04.821"></status>
</kw>
<kw name="Catenate" library="BuiltIn">
<doc>Catenates the given items together and returns the resulted string.</doc>
<arguments>
<arg>SEPARATOR=|</arg>
<arg>${kubectl_cmd}</arg>
<arg>grep ${pod_name}</arg>
<arg>awk '{print $3}'</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20190401 13:14:04.821" level="INFO">${cmd} = kubectl get pods -n default|grep testpod|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:14:04.821" starttime="20190401 13:14:04.821"></status>
</kw>
<kw name="Run Command" library="Utils">
<doc>Execute a command on controller over ssh connection
keeping environment visible to the subsequent keywords.Also allows
the keyword to fail if there is an error, by default this keyword
will not fail and will return the stderr.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Set Client Configuration" library="SSHLibrary">
<doc>Update the `configuration` of the current connection.</doc>
<arguments>
<arg>timeout=${timeout}</arg>
<arg>prompt=$</arg>
</arguments>
<status status="PASS" endtime="20190401 13:14:04.822" starttime="20190401 13:14:04.822"></status>
</kw>
<kw name="Create Empy Result Dictionary" library="Utils">
<doc>Creates an Empty Dictionary with the required structure
for a response of executed command.</doc>
<assign>
<var>&amp;{result}</var>
</assign>
<kw name="Create Dictionary" library="BuiltIn">
<doc>Creates and returns a dictionary based on the given ``items``.</doc>
<arguments>
<arg>stdout=${EMPTY}</arg>
</arguments>
<assign>
<var>&amp;{result_dict}</var>
</assign>
<msg timestamp="20190401 13:14:04.823" level="INFO">&amp;{result_dict} = { stdout= }</msg>
<status status="PASS" endtime="20190401 13:14:04.823" starttime="20190401 13:14:04.822"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>stderr=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:14:04.823" starttime="20190401 13:14:04.823"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result_dict}</arg>
<arg>rc=${EMPTY}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:14:04.823" starttime="20190401 13:14:04.823"></status>
</kw>
<msg timestamp="20190401 13:14:04.824" level="INFO">&amp;{result} = { stdout= | stderr= | rc= }</msg>
<status status="PASS" endtime="20190401 13:14:04.824" starttime="20190401 13:14:04.822"></status>
</kw>
<kw name="Read" library="SSHLibrary">
<doc>Consumes and returns everything available on the server output.</doc>
<msg timestamp="20190401 13:14:04.824" level="INFO">[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:14:04.824" starttime="20190401 13:14:04.824"></status>
</kw>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20190401 13:14:04.833" level="INFO">kubectl get pods -n default|grep testp od|awk '{print $3}'</msg>
<status status="PASS" endtime="20190401 13:14:04.833" starttime="20190401 13:14:04.824"></status>
</kw>
<kw name="Read Until Prompt" library="SSHLibrary">
<doc>Consumes and returns the server output until the prompt is found.</doc>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20190401 13:14:04.963" level="INFO">ErrImagePull
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<msg timestamp="20190401 13:14:04.963" level="INFO">${output} = ErrImagePull
[wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:14:04.963" starttime="20190401 13:14:04.833"></status>
</kw>
<kw name="Remove Prompt Line" library="Utils">
<doc>On the response of the command execution is also
retrieved the prompt line (because the use of Read until prompt)
this keyword delete that last line and returns a clean output.</doc>
<arguments>
<arg>${output}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<kw name="Get Line" library="String">
<doc>Returns the specified line from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>-1</arg>
</arguments>
<assign>
<var>${line_to_remove}</var>
</assign>
<msg timestamp="20190401 13:14:04.964" level="INFO">${line_to_remove} = [wrsroot@controller-0 ~(keystone_admin)]$</msg>
<status status="PASS" endtime="20190401 13:14:04.964" starttime="20190401 13:14:04.964"></status>
</kw>
<kw name="Remove String" library="String">
<doc>Removes all ``removables`` from the given ``string``.</doc>
<arguments>
<arg>${output}</arg>
<arg>${line_to_remove}</arg>
</arguments>
<assign>
<var>${clean_out}</var>
</assign>
<msg timestamp="20190401 13:14:04.964" level="INFO">${clean_out} = ErrImagePull
</msg>
<status status="PASS" endtime="20190401 13:14:04.964" starttime="20190401 13:14:04.964"></status>
</kw>
<msg timestamp="20190401 13:14:04.964" level="INFO">${output} = ErrImagePull
</msg>
<status status="PASS" endtime="20190401 13:14:04.964" starttime="20190401 13:14:04.963"></status>
</kw>
<kw name="Get Return Code" library="Utils">
<doc>Wrapper to return the code number of last executed
command</doc>
<assign>
<var>${rc}</var>
</assign>
<kw name="Write" library="SSHLibrary">
<doc>Writes the given ``text`` on the remote machine and appends a newline.</doc>
<arguments>
<arg>echo $?</arg>
</arguments>
<msg timestamp="20190401 13:14:04.967" level="INFO">echo $?</msg>
<status status="PASS" endtime="20190401 13:14:04.967" starttime="20190401 13:14:04.965"></status>
</kw>
<kw name="Read Until Regexp" library="SSHLibrary">
<doc>Consumes and returns the server output until a match to ``regexp`` is found.</doc>
<arguments>
<arg>[0-9]+</arg>
</arguments>
<assign>
<var>${rc}</var>
</assign>
<msg timestamp="20190401 13:14:04.967" level="INFO">0</msg>
<msg timestamp="20190401 13:14:04.967" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:14:04.967" starttime="20190401 13:14:04.967"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${rc}</arg>
</arguments>
<msg timestamp="20190401 13:14:04.967" level="INFO">0</msg>
<status status="PASS" endtime="20190401 13:14:04.968" starttime="20190401 13:14:04.967"></status>
</kw>
<msg timestamp="20190401 13:14:04.968" level="INFO">${rc} = 0</msg>
<status status="PASS" endtime="20190401 13:14:04.968" starttime="20190401 13:14:04.964"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${rc} == 0</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
<arg>ELSE IF</arg>
<arg>${fail_if_error} == True</arg>
<arg>FAIL</arg>
<arg>${output}</arg>
<arg>ELSE</arg>
<arg>Set To Dictionary</arg>
<arg>${result}</arg>
<arg>stderr=${output}</arg>
</arguments>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout=${output.strip()}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:14:04.968" starttime="20190401 13:14:04.968"></status>
</kw>
<status status="PASS" endtime="20190401 13:14:04.969" starttime="20190401 13:14:04.968"></status>
</kw>
<kw name="Set To Dictionary" library="Collections">
<doc>Adds the given ``key_value_pairs`` and ``items`` to the ``dictionary``.</doc>
<arguments>
<arg>${result}</arg>
<arg>rc=${rc}</arg>
</arguments>
<status status="PASS" endtime="20190401 13:14:04.969" starttime="20190401 13:14:04.969"></status>
</kw>
<kw name="Log Dictionary" library="Collections">
<doc>Logs the size and contents of the ``dictionary`` using given ``level``.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20190401 13:14:04.969" level="INFO">Dictionary size is 3 and it contains following items:
rc: 0
stderr: 
stdout: ErrImagePull</msg>
<status status="PASS" endtime="20190401 13:14:04.969" starttime="20190401 13:14:04.969"></status>
</kw>
<msg timestamp="20190401 13:14:04.969" level="INFO">&amp;{result} = { stdout=ErrImagePull | stderr= | rc=0 }</msg>
<status status="PASS" endtime="20190401 13:14:04.969" starttime="20190401 13:14:04.821"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result}</arg>
<arg>stdout</arg>
</arguments>
<assign>
<var>${status}</var>
</assign>
<msg timestamp="20190401 13:14:04.970" level="INFO">${status} = ErrImagePull</msg>
<status status="PASS" endtime="20190401 13:14:04.970" starttime="20190401 13:14:04.970"></status>
</kw>
<kw name="Should Be Equal As Strings" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to strings.</doc>
<arguments>
<arg>${status}</arg>
<arg>Running</arg>
</arguments>
<msg timestamp="20190401 13:14:04.970" level="FAIL">ErrImagePull != Running</msg>
<status status="FAIL" endtime="20190401 13:14:04.970" starttime="20190401 13:14:04.970"></status>
</kw>
<status status="FAIL" endtime="20190401 13:14:04.970" starttime="20190401 13:14:04.820"></status>
</kw>
<msg timestamp="20190401 13:14:04.970" level="FAIL">Keyword 'Check POD' failed after retrying for 1 minute. The last error was: ErrImagePull != Running</msg>
<status status="FAIL" endtime="20190401 13:14:04.970" starttime="20190401 13:13:02.977"></status>
</kw>
<doc>Launch a POD via kubectl.</doc>
<tags>
<tag>Duplex</tag>
<tag>MN-External</tag>
<tag>MN-Local</tag>
<tag>Simplex</tag>
</tags>
<status status="FAIL" endtime="20190401 13:14:04.971" critical="yes" starttime="20190401 13:13:02.755">Keyword 'Check POD' failed after retrying for 1 minute. The last error was: ErrImagePull != Running</status>
</test>
<kw type="teardown" name="Run Keywords" library="BuiltIn">
<doc>Executes all the given keywords in a sequence.</doc>
<arguments>
<arg>Utils.Stx Suite TearDown</arg>
</arguments>
<kw name="Stx Suite TearDown" library="Utils">
<doc>Wrapper to clean up activities on the suite.</doc>
<kw name="Close All Connections" library="SSHLibrary">
<doc>Closes all open connections.</doc>
<status status="PASS" endtime="20190401 13:14:04.973" starttime="20190401 13:14:04.972"></status>
</kw>
<status status="PASS" endtime="20190401 13:14:04.973" starttime="20190401 13:14:04.972"></status>
</kw>
<status status="PASS" endtime="20190401 13:14:04.973" starttime="20190401 13:14:04.971"></status>
</kw>
<doc>Check the health of PODs services; update and apply the
helm chart via system application-apply.
Author(s):
- Hector Ivan Ramos Escobar &lt;ramos.escobarx.hector.ivan@intel.com&gt;
- Juan Carlos Alonso &lt;juan.carlos.alonso@intel.com&gt;</doc>
<status status="FAIL" endtime="20190401 13:14:04.973" starttime="20190401 13:12:56.385"></status>
</suite>
<status status="FAIL" endtime="20190401 13:14:04.975" starttime="20190401 13:12:56.384"></status>
</suite>
<metadata>
<item name="ISO">bootimage.iso</item>
<item name="System">duplex</item>
</metadata>
<status status="FAIL" endtime="20190401 13:14:04.979" starttime="20190401 13:11:52.934"></status>
</suite>
<statistics>
<total>
<stat fail="56" pass="1">Critical Tests</stat>
<stat fail="56" pass="1">All Tests</stat>
</total>
<tag>
<stat fail="56" pass="1">Duplex</stat>
</tag>
<suite>
<stat fail="56" id="s1" name="Sanity-Test" pass="1">Sanity-Test</stat>
<stat fail="52" id="s1-s1" name="Sanity-OpenStack" pass="0">Sanity-Test.Sanity-OpenStack</stat>
<stat fail="14" id="s1-s1-s1" name="01-Instance-From-Image" pass="0">Sanity-Test.Sanity-OpenStack.01-Instance-From-Image</stat>
<stat fail="15" id="s1-s1-s2" name="02-Instance-From-Volume" pass="0">Sanity-Test.Sanity-OpenStack.02-Instance-From-Volume</stat>
<stat fail="16" id="s1-s1-s3" name="03-Instance-From-Snapshot" pass="0">Sanity-Test.Sanity-OpenStack.03-Instance-From-Snapshot</stat>
<stat fail="4" id="s1-s1-s4" name="04-Instance-From-Heat-Template" pass="0">Sanity-Test.Sanity-OpenStack.04-Instance-From-Heat-Template</stat>
<stat fail="3" id="s1-s1-s5" name="05-Measurements-For-Metric" pass="0">Sanity-Test.Sanity-OpenStack.05-Measurements-For-Metric</stat>
<stat fail="4" id="s1-s2" name="Sanity-Platform" pass="1">Sanity-Test.Sanity-Platform</stat>
<stat fail="4" id="s1-s2-s1" name="02-OpenStack-Pod-Healthy" pass="1">Sanity-Test.Sanity-Platform.02-OpenStack-Pod-Healthy</stat>
</suite>
</statistics>
<errors>
</errors>
</robot>
